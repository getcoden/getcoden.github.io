<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pandas groupby 保存到 dataFrame</title>
    <url>/2021/02/01/00-Pandas%20groupby%20%E4%BF%9D%E5%AD%98%E5%88%B0%20dataFrame/</url>
    <content><![CDATA[<h3 id="直接使用-reset-index-方法删除原来索引"><a href="#直接使用-reset-index-方法删除原来索引" class="headerlink" title="直接使用 reset_index 方法删除原来索引"></a>直接使用 reset_index 方法删除原来索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test_df &#x3D; pd.DataFrame(&#123;&#39;a&#39;:[1,1,3,2],&#39;b&#39;:[1,4,6,9],&#39;c&#39;:[1,4,8,12]&#125;)</span><br><span class="line">g_df &#x3D;test_df[&#39;c&#39;].groupby([test_df[&#39;a&#39;], test_df[&#39;b&#39;]]).sum()</span><br><span class="line">c_df &#x3D; pd.DataFrame(g_df)</span><br><span class="line">c_df.reset_index(inplace&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>输入出结果：<br><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201105347.png" alt="20210201105347"></p>
<p>分组后的原生结果：<br><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201110100.png" alt="20210201110100"></p>
<p>分组后转换为DataFrame的结果：<br><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201110222.png" alt="20210201110222"></p>
<p>使用 reset_index 方法删除原来索引后的结果:<br><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201110629.png" alt="20210201110629"></p>
<h3 id="将由-DataFrame-组成的字典存储至-Excel-的不同-Sheet-中（不覆盖）—-以及将数据读取回原形式"><a href="#将由-DataFrame-组成的字典存储至-Excel-的不同-Sheet-中（不覆盖）—-以及将数据读取回原形式" class="headerlink" title="将由 DataFrame 组成的字典存储至 Excel 的不同 Sheet 中（不覆盖）— 以及将数据读取回原形式"></a>将由 DataFrame 组成的字典存储至 Excel 的不同 Sheet 中（不覆盖）— 以及将数据读取回原形式</h3><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>&emsp;&emsp;当在 Excel 中存储多个 Sheet 时，不可以直接遍历字典，循环 df.to_excel ()，这样做的话前一个 Sheet 会不断被后一个 Sheet 覆盖，最后只存下来最后一个 Sheet。</p>
<p>想要不被覆盖可以通过 pd.ExcelWriter () 进行如下操作，其中 dic 为存储 DataFrame 的字典，dic_key 对应每个 Sheet 名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with pd.ExcelWriter(&quot;excel_name.xlsx&quot;) as writer:</span><br><span class="line">    for dic_key in dic.keys():</span><br><span class="line">        print(&#39;Saving data of &#39; + str(detector))</span><br><span class="line">        dic[dic_key].to_excel(writer, sheet_name &#x3D; str(detector))</span><br><span class="line">        print(&#39;Done!&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>&emsp;&emsp;上一问题的对偶过程是将 Excel 各 Sheet 的数据读取成一个字典包含多个 DataFrame 的形式。可以先建立空字典（dic），读取 Excel 的 Sheet 名字（sheet_name）作为字典的键，再循环读取每个 Sheet 的数据。过程如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#125;</span><br><span class="line"># 读取excel的Sheet名</span><br><span class="line">sheet_names &#x3D; pd.ExcelFile(&#39;excel_name.xlsx&#39;).sheet_names</span><br><span class="line">for sheet_name in sheet_names:</span><br><span class="line">    print(&#39;Loading data of Sheet &#39; + sheet_name + &#39;...&#39;)</span><br><span class="line">    dds[sheet_name] &#x3D; pd.read_excel(&#39;excel_name.xlsx&#39;, sheet_name&#x3D;sheet_name, index_col&#x3D;0)</span><br><span class="line">    print(&#39;Done!&#39;)</span><br></pre></td></tr></table></figure>
<p>当然跟 open 文件一样，上面的 5 行代码也可以简写如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with pd.ExcelWriter(r&#39;C:\Users\数据\Desktop\data\test2.xls&#39;) as writer:</span><br><span class="line">    df1.to_excel(writer, sheet_name&#x3D;&#39;df1&#39;)</span><br><span class="line">    df2.to_excel(writer, sheet_name&#x3D;&#39;df2&#39;)</span><br></pre></td></tr></table></figure>
<p>简单高效，不需要再单独写 save 和 close，自动完成。</p>
<h2 id="将-groupby-之后的数据以及标签保存-excel"><a href="#将-groupby-之后的数据以及标签保存-excel" class="headerlink" title="将 groupby 之后的数据以及标签保存 excel"></a>将 groupby 之后的数据以及标签保存 excel</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 欢迎使用Markdown编辑器</span><br><span class="line">  packsort&#x3D;newpack.groupby([&#39;Stock&#39;, &#39;ReportPeriod&#39;])[&#39;EndShare&#39;].sum()</span><br><span class="line"></span><br><span class="line">  data &#x3D; pd.DataFrame()</span><br><span class="line"></span><br><span class="line">  data&#x3D;packsort.reset_index() ###记住reset</span><br><span class="line">  #print(data)</span><br><span class="line">  </span><br><span class="line">  data.to_csv(&quot;MPayHold.csv&quot;, index&#x3D;False, encoding&#x3D;&quot;utf_8_sig&quot;)</span><br></pre></td></tr></table></figure>
<p>需要用到 packsort.reset_index () 重置索引，再转化为 dataframe 写入 excel</p>
<h2 id="Dataframeg-groupby-分组统计结果转换成-Dataframe，再修改其索引"><a href="#Dataframeg-groupby-分组统计结果转换成-Dataframe，再修改其索引" class="headerlink" title="Dataframeg groupby 分组统计结果转换成 Dataframe，再修改其索引"></a>Dataframeg groupby 分组统计结果转换成 Dataframe，再修改其索引</h2><p>pandas 提供了 groupby 函数可以对数据集按一个键或多个键进行分组统计。</p>
<p>groupby 分组函数：返回一个重构的 dataframe，数据的原索引会保留，但数据的相对位置会发生变化。</p>
<p>下面以一组数据为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"># 创建dataframe</span><br><span class="line">data &#x3D; pd.DataFrame(&#123;&quot;key&quot;: list(&quot;abbcaabac&quot;),</span><br><span class="line">                     &quot;value&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;)</span><br><span class="line"></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206081228.png" alt="20210206081228"></p>
</div>

<p>下面按 key 进行分组:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 按key分组</span><br><span class="line">data_group &#x3D; data.groupby(data[&quot;key&quot;])</span><br><span class="line"># 分组后的结果不能直接输出</span><br><span class="line">print(data_group)    # 输出的是data_group的类型</span><br></pre></td></tr></table></figure>
<p>可以使用循环对分组后的结果进行遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for key, value in data_group:</span><br><span class="line">    print(key)</span><br><span class="line">    print(value)</span><br><span class="line">    print(type(value))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206081413.png" alt="20210206081413"></p>
</div>

<ul>
<li>分组后的组名分别是 a, b, c；直接用类型转换 data_group 转变成 dataframe 不太容易。每一个 value 都是 dataframe 类型，可以把每个 value 进行拼接形成新的 dataframe，列名与原数据相同。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_data &#x3D; pd.DataFrame(columns&#x3D;[&quot;key&quot;, &quot;value&quot;])</span><br><span class="line">print(new_data)</span><br></pre></td></tr></table></figure>
<p>通过循环，对 value 进行拼接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 循环拼接</span><br><span class="line">for key, value in data_group:</span><br><span class="line">    new_data &#x3D; pd.concat([new_data, value])</span><br><span class="line">print(new_data)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206081542.png" alt="20210206081542"></p>
</div>

<p>在原始数据上实现了分组，但是原索引得到了保留，可以通过以下代码改变索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_data.index &#x3D; np.arange(len(new_data.index))</span><br><span class="line">print(new_data)</span><br></pre></td></tr></table></figure>
<p>结果可以看到数据变为有序：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206081629.png" alt="20210206081629"></p>
</div>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>00.小白Python学习路线</title>
    <url>/2021/01/29/00-%E5%B0%8F%E7%99%BDPython%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>学前须知：Python 是一种解释型、面向对象、动态数据类型</p>
<ul>
<li>Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。</li>
</ul>
<ul>
<li><p>像 Perl 语言一样，Python 源代码同样遵循 GPL (GNU General Public License) 协议。</p>
</li>
<li><p>Python 是一种解释型语言： 这就说明开发过程中没有了编译这个环节。类似于 PHP 和 Perl 语言。</p>
</li>
<li><p>Python 是面向对象语言: 这就说明 Python 支持面向对象的风格或代码封装在对象的编程技术。</p>
</li>
<li><p>Python 是交互式语言： 这就说明你可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。</p>
</li>
<li><p>Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到浏览器再到游戏。</p>
</li>
</ul>
<p>准备：在学习之前，我们首先要思考一个问题，怎么写代码，用什么写？所以，初学者我推荐 Python3.6 版本，这是最成熟的版本之一，一些功能库基本上都会兼容。编译软件使用 Pycharm。</p>
<pre><code>0 基础小白怎么学 Python 呢？
</code></pre>
<h3 id="一、确定学习目标"><a href="#一、确定学习目标" class="headerlink" title="一、确定学习目标"></a>一、确定学习目标</h3><p>&emsp;&emsp;任何人，无论是学习一个新东西的时候，都首先要确定一个方向，不然就像无头苍蝇样，胡乱碰撞。只有确定了学习方向，才能一直朝着这个方向走，才能在学习中进步，才能体会 Python 给你带来的快乐。</p>
<div align =center>


</div>

<h3 id="二、Python-基础知识学习"><a href="#二、Python-基础知识学习" class="headerlink" title="二、Python 基础知识学习"></a>二、Python 基础知识学习</h3><ul>
<li><p>a. 首先了解 Python 是什么，它都能做些什么？</p>
</li>
<li><p>b. 需要知道什么是变量、算法、解释器</p>
</li>
<li><p>c Python 的基本数据类型</p>
</li>
<li><p>d 列表和元组的操作方法</p>
</li>
<li><p>e 字符串操作方法</p>
</li>
<li><p>f 基本的字典操作方法</p>
</li>
</ul>
<div align =center>


</div>


<h3 id="三、掌握-Python-的条件语句，判断、循环的相关执行语句"><a href="#三、掌握-Python-的条件语句，判断、循环的相关执行语句" class="headerlink" title="三、掌握 Python 的条件语句，判断、循环的相关执行语句"></a>三、掌握 Python 的条件语句，判断、循环的相关执行语句</h3><ul>
<li><p>条件、判断语句：if、else、elif</p>
</li>
<li><p>循环语句：while、for</p>
</li>
<li><p>判断结束语句：continue、break</p>
</li>
</ul>
<h3 id="四、面对对象知识"><a href="#四、面对对象知识" class="headerlink" title="四、面对对象知识"></a>四、面对对象知识</h3><ul>
<li><p>类 (Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>
</li>
<li><p>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p>
</li>
<li><p>数据成员：类变量或者实例变量，用于处理类及其实例对象的相关的数据。</p>
</li>
<li><p>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p>
</li>
<li><p>局部变量：定义在方法中的变量，只作用于当前实例的类。</p>
</li>
<li><p>实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。</p>
</li>
<li><p>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个 Dog 类型的对象派生自 Animal 类，这是模拟 “是一个（is-a）” 关系（例图，Dog 是一个 Animal）。</p>
</li>
<li><p>实例化：创建一个类的实例，类的具体对象。</p>
</li>
<li><p>方法：类中定义的函数。</p>
</li>
<li><p>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p>
</li>
</ul>
<div align =center>


</div>


<h3 id="五、实践"><a href="#五、实践" class="headerlink" title="五、实践"></a>五、实践</h3><p>&emsp;&emsp;学习到了这个阶段了，一定要多动手实践，学了不去用，不去实操，时间过去一个月、两个月或许还记得，但时间长了，也就慢慢的忘了。在项目实践过程中出现问题，查找和处理过程中遇到的错误和异常，遇到问题多上网搜索，也可以参考公众号内的一些文章，在成功的解决了这些问题之后，你就得到一种特别的满足，特别的开心，这也是你学习 Python 给你带来的动力。</p>
<div align =center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/%E4%BD%A0%E6%87%82%E6%88%91%E7%9A%84%E6%84%8F%E6%80%9D%E5%90%A7.png" alt="你懂我的意思吧"></p>
</div>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>000按条件批量从不同文件中提取数据项</title>
    <url>/2021/07/08/000%E6%8C%89%E6%9D%A1%E4%BB%B6%E6%89%B9%E9%87%8F%E4%BB%8E%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8F%90%E5%8F%96%E6%95%B0%E6%8D%AE%E9%A1%B9/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_one_excel</span>(<span class="params"><span class="built_in">dir</span></span>):</span></span><br><span class="line">    os.chdir(<span class="string">r&quot;D:\test1&quot;</span>)</span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> root_dir, sub_dir, files <span class="keyword">in</span> os.walk(<span class="built_in">dir</span>): <span class="comment"># 第一个为起始路径，第二个为起始路径下的文件夹，第三个是起始路径下的文件。</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.xlsx&#x27;</span>):</span><br><span class="line">                <span class="comment"># 构造绝对路径</span></span><br><span class="line">                file_name = os.path.join(root_dir, file)</span><br><span class="line">                file_list.append(file_name)</span><br><span class="line">    dfs=[]</span><br><span class="line">    dfs2=[]</span><br><span class="line">    <span class="keyword">for</span> file1 <span class="keyword">in</span> file_list:</span><br><span class="line">        data = pd.read_excel(file1)</span><br><span class="line">        dataframe_1 =  data.loc[data[<span class="string">&#x27;部门&#x27;</span>] == <span class="string">&#x27;A&#x27;</span>, [<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;工资&#x27;</span>]]</span><br><span class="line">        dataframe_1[<span class="string">&#x27;文件&#x27;</span>]=file1</span><br><span class="line">        dataframe_2 =  data.loc[data[<span class="string">&#x27;工资&#x27;</span>] &lt; <span class="number">3000</span>, [<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;工资&#x27;</span>]]</span><br><span class="line">        dataframe_2[<span class="string">&#x27;文件&#x27;</span>]=file1</span><br><span class="line">        </span><br><span class="line">        dfs.append(dataframe_1)</span><br><span class="line">        dfs2.append(dataframe_2)</span><br><span class="line">        allexcel=pd.concat(dfs)</span><br><span class="line">        allexcel2=pd.concat(dfs2)</span><br><span class="line">        </span><br><span class="line">    allexcel.to_excel(<span class="string">&#x27;./0123.xlsx&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line">    allexcel2.to_excel(<span class="string">&#x27;./01233.xlsx&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line">        </span><br><span class="line">to_one_excel(<span class="string">r&quot;D:\test1&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_one_excel</span>(<span class="params"><span class="built_in">dir</span></span>):</span></span><br><span class="line">    os.chdir(<span class="string">r&quot;D:\test1&quot;</span>)</span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> root_dir, sub_dir, files <span class="keyword">in</span> os.walk(<span class="built_in">dir</span>): <span class="comment"># 第一个为起始路径，第二个为起始路径下的文件夹，第三个是起始路径下的文件。</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.xlsx&#x27;</span>):</span><br><span class="line">                <span class="comment"># 构造绝对路径</span></span><br><span class="line">                file_name = os.path.join(root_dir, file)</span><br><span class="line">                file_list.append(file_name)</span><br><span class="line">    dfs=[]</span><br><span class="line">    dfs2=[]</span><br><span class="line">    <span class="keyword">for</span> file1 <span class="keyword">in</span> file_list:</span><br><span class="line">        data = pd.read_excel(file1)</span><br><span class="line">        dataframe_1 =  data.loc[data[<span class="string">&#x27;部门&#x27;</span>] == <span class="string">&#x27;A&#x27;</span>, [<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;工资&#x27;</span>]]</span><br><span class="line">        dataframe_1[<span class="string">&#x27;文件&#x27;</span>]=file1</span><br><span class="line">        dataframe_2 =  data.loc[data[<span class="string">&#x27;工资&#x27;</span>] &lt; <span class="number">3000</span>, [<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;工资&#x27;</span>]]</span><br><span class="line">        dataframe_2[<span class="string">&#x27;文件&#x27;</span>]=file1</span><br><span class="line">        </span><br><span class="line">        dfs.append(dataframe_1)</span><br><span class="line">        dfs2.append(dataframe_2)</span><br><span class="line">        </span><br><span class="line">        allexcel=pd.concat( dfs)</span><br><span class="line">        allexcel2=pd.concat(dfs2)</span><br><span class="line">        </span><br><span class="line">    allexcel.to_excel(<span class="string">&#x27;./finall部门.xlsx&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line">    allexcel2.to_excel(<span class="string">&#x27;./finallname.xlsx&#x27;</span>,index=<span class="literal">False</span>)</span><br><span class="line">        </span><br><span class="line">to_one_excel(<span class="string">r&quot;D:\test1&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>01-pandas中利用groupby分组导入数据到excel中</title>
    <url>/2021/02/01/01-Pandas%E4%B8%AD%E5%88%A9%E7%94%A8groupby%E5%88%86%E7%BB%84%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%88%B0excel%E4%B8%AD/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.read_table(read_file, header&#x3D;0, dtype&#x3D;str, sep&#x3D;&#39;\t&#39;)</span><br><span class="line">res_file &#x3D; fileDir + r&#39;\filename.xlsx&#39;</span><br><span class="line">writer &#x3D; pd.ExcelWriter(res_file)</span><br><span class="line">groupby_df &#x3D; df.groupby([&#39;colname&#39;])</span><br><span class="line"></span><br><span class="line">for i in groupby_df:</span><br><span class="line">    i[1].to_excel(writer, index&#x3D;False, sheet_name&#x3D;i[0])</span><br><span class="line"></span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>
<h3 id="使用-pandas-dataframe-toexcel-groupby-ExcelWriter-拆分-Excel-总表到分表，按某列的值分类到分表的-Python-方法"><a href="#使用-pandas-dataframe-toexcel-groupby-ExcelWriter-拆分-Excel-总表到分表，按某列的值分类到分表的-Python-方法" class="headerlink" title="使用 pandas.dataframe.toexcel, groupby, ExcelWriter 拆分 Excel 总表到分表，按某列的值分类到分表的 Python 方法"></a>使用 pandas.dataframe.toexcel, groupby, ExcelWriter 拆分 Excel 总表到分表，按某列的值分类到分表的 Python 方法</h3><p>首先，我们先读取总表， 其中 dtype 可以指定某列读取的格式.</p>
<p>读取 2020-07-27 的格式日期时，输出到 Excel 文件日期会变为 2020-07-27  00:00:00 格式</p>
<p>我们可以使用 date_parse 参数指定处理函数， 如果格式复杂且有错误，这是一个好办法.</p>
<p>也可以使用 datetime 中的 strftime 和 strptime 来处理，</p>
<p>上诉两种办法都需要指定一个函数，也可以使用 lambda</p>
<p>我这里不想处理日期格式，选择用字符串类型来读取。想要了解的可以参考别的文章，或者我可能勤奋以后会写 (大概率不会)</p>
<p>dtype 参数可以指定某列使用你想要的类型来读取</p>
<p><code>data = pandas.read_excel(&quot;总表.xls&quot;, dtype=&#123;&quot;日期&quot;: str&#125;)</code></p>
<p>如果我们想要按照部门来分类,写入分表, 下面这种写法会覆盖原来的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_departments &#x3D; data.groupby(&quot;部门&quot;)</span><br><span class="line">for department, data_department in data_departments:</span><br><span class="line">    data_department.to_excel(&quot;分类后的表.xls&quot;, department)</span><br></pre></td></tr></table></figure>
<p>要想达到分表的效果且不会覆盖， 我们可以使用 pandas.ExcelWriter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_departments&#x3D; data.groupby(&quot;部门&quot;)</span><br><span class="line"> </span><br><span class="line">writer1 &#x3D; pandas.ExcelWriter(&quot;分类后的表.xls&quot;)</span><br><span class="line"> </span><br><span class="line">for department, data_department in data_departments:</span><br><span class="line">    data_department.to_excel(writer1, department)</span><br><span class="line"> </span><br><span class="line">writer1.save()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201115903.png" alt="20210201115903"></p>
<p>如果我们想要按字段内容生成多个 Excel 表， 可以直接这样做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_departments&#x3D; data.groupby(&quot;地区&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">for department, data_department in data_departments:</span><br><span class="line">    data_department.to_excel(f&quot;&#123;department&#125;.xls&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201115943.png" alt="20210201115943"></p>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>01.初识Python</title>
    <url>/2021/01/26/01.%E5%88%9D%E8%AF%86Python/</url>
    <content><![CDATA[<h4 id="Python的历史"><a href="#Python的历史" class="headerlink" title="Python的历史"></a>Python的历史</h4><ol>
<li>1989年圣诞节：Guido von Rossum开始写Python语言的编译器。</li>
<li>1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，还有对列表、字典等核心数据类型，同时支持以模块为基础来构造应用程序。</li>
<li>1994年1月：Python 1.0正式发布。</li>
<li>2000年10月16日：Python 2.0发布，增加了完整的<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">垃圾回收</a>，提供了对<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。</li>
<li>2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6/2.7版本中。</li>
</ol>
<p>目前我们使用的Python 3.7.x的版本是在2018年发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以阅读名为<a href="http://www.cnblogs.com/vamei/archive/2013/02/06/2892628.html">《Python简史》</a>的网络文章。</p>
<h4 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h4><p>Python的优点很多，简单的可以总结为以下几点。</p>
<ol>
<li>简单明了，学习曲线低，比很多编程语言都容易上手。</li>
<li>开放源代码，拥有强大的社区和生态圈，尤其是在数据分析和机器学习领域。</li>
<li>解释型语言，天生具有平台可移植性，代码可以工作于不同的操作系统。</li>
<li>对两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。</li>
<li>代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。</li>
</ol>
<p>Python的缺点主要集中在以下几点。</p>
<ol>
<li>执行效率稍低，对执行效率要求高的部分可以由其他语言（如：C、C++）编写。</li>
<li>代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被弱化。</li>
<li>在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。</li>
</ol>
<h4 id="Python的应用领域"><a href="#Python的应用领域" class="headerlink" title="Python的应用领域"></a>Python的应用领域</h4><p>目前Python在Web应用后端开发、云基础设施建设、DevOps、网络数据采集（爬虫）、自动化测试、数据分析、机器学习等领域都有着广泛的应用。</p>
<h3 id="安装Python解释器"><a href="#安装Python解释器" class="headerlink" title="安装Python解释器"></a>安装Python解释器</h3><p>想要开始Python编程之旅，首先得在自己使用的计算机上安装Python解释器环境，下面将以安装官方的Python解释器为例，讲解如何在不同的操作系统上安装Python环境。官方的Python解释器是用C语言实现的，也是使用最为广泛的Python解释器，通常称之为CPython。除此之外，Python解释器还有Java语言实现的Jython、C#语言实现的IronPython以及PyPy、Brython、Pyston等版本，有兴趣的读者可以自行了解。</p>
<h3 id="Python开发工具"><a href="#Python开发工具" class="headerlink" title="Python开发工具"></a>Python开发工具</h3><h4 id="IDLE-自带的集成开发工具"><a href="#IDLE-自带的集成开发工具" class="headerlink" title="IDLE - 自带的集成开发工具"></a>IDLE - 自带的集成开发工具</h4><p>IDLE是安装Python环境时自带的集成开发工具，如下图所示。但是由于IDLE的用户体验并不是那么好所以很少在实际开发中被采用。</p>
<p><img src="./res/python-idle.png"></p>
<h4 id="Visual-Studio-Code-更好的交互式编程工具"><a href="#Visual-Studio-Code-更好的交互式编程工具" class="headerlink" title="Visual Studio Code - 更好的交互式编程工具"></a>Visual Studio Code - 更好的交互式编程工具</h4><p>Visual Studio Code（简称 VS Code ）是一个由微软开发，同时支持 Windows 、 Linux 和 macOS 等操作系统的 免费代码编辑器，它支持 测试，并内置了 Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和 代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。</p>
<p>在 2019 年的 Stack Overflow 组织的开发者调研中，VS Code 被认为是最受开发者欢迎的开发环境，据调查 87317 名受访者中有 50.7% 的受访者声称正在使用 VS Code。</p>
<p>Visual Studio Code 具备了现代文本编辑器所具有的功能，例如更改字符编码、更换换行符、语法高亮、支持正则表达式、安装扩展、创建 snippet 等。</p>
<p>此外 Visual Studio Code 还支持扩展程序。通过安装扩展程序，Code 可以支持更多新的语言、界面主题、测试器，以及更多的增值服务。Visual Studio Code 的扩展程序运行于独立的进程中，以保证编辑器的运行速度不受干扰。</p>
<p>Visual Studio Code 支持多种编程语言，集成终端，可以在编辑器中运行脚本、编译软件、调试脚本、设置断点、做版本管理。</p>
<p>可以在命令面板中（快捷键 Ctrl+Shift+P）搜索和输入命令，从而实现指定功能，例如安装扩展、设置属性等、调用扩展的命令。</p>
<p>在控制面板做的设置都会自动保存到 json，也可以直接修改 json 文件，方便备份或部署。</p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>02.1数值和字符串</title>
    <url>/2021/01/29/02-1%E6%95%B0%E5%80%BC%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>1、数值</p>
<ul>
<li>数值数据类型</li>
</ul>
<p>python 支持如下数值型数据：</p>
<table>
<thead>
<tr>
<th align="center">数值类型</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数（int）</td>
<td align="center">0, -3</td>
</tr>
<tr>
<td align="center">浮点数（float）</td>
<td align="center">3.1415926, 0.3E+1, 3E-1</td>
</tr>
<tr>
<td align="center">十六进制（hexadecimal）</td>
<td align="center">0xAF（以0x开头，其后都是数字或者大小写字母）</td>
</tr>
<tr>
<td align="center">八进制（octal）</td>
<td align="center">0o10（以0o或0O开头，其后其后都是0-7之间的整数）</td>
</tr>
<tr>
<td align="center">二进制（binary）</td>
<td align="center">0b1011010010（以0b或0B开头,其后都是0、1）</td>
</tr>
</tbody></table>
<ul>
<li>数值运算<br>常见数字运算类型及内置函数如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运算符  含义</span><br><span class="line">+      （加）    </span><br><span class="line">-      （减）</span><br><span class="line">*      （乘）</span><br><span class="line">&#x2F;      （除）</span><br><span class="line">&#x2F;&#x2F;     （整除运算）</span><br><span class="line">%      （求余数）</span><br><span class="line">**     （幂）</span><br><span class="line">int(x)   (取x整数部分)</span><br><span class="line">float(x) （将x转化为浮点数）</span><br><span class="line">pow(x,y)  （求x的y次幂）</span><br><span class="line">abs(x)   （求x的绝对值）</span><br><span class="line">round(x)  (x四舍五入)</span><br><span class="line">bin(x)   (将x转化为二进制)</span><br><span class="line">oct(x)  （将x转化为八进制）</span><br><span class="line">hex(x) （将x转化为十六进制）</span><br><span class="line">math.floor(x) (math模块中向下取整，floor中文有地板的意思)</span><br><span class="line">math.ceil(x) （math模块中向上取整，ceil中文天花板的意思）</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数值运算举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  In [1]: #加</span><br><span class="line">   ...: print(2 + 3)</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">In [2]: #减</span><br><span class="line">   ...: print(2 - 3)</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">In [3]: #乘</span><br><span class="line">   ...: print(2 * 3)</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">In [4]: #除</span><br><span class="line">   ...: print(2 &#x2F; 3)</span><br><span class="line">0.6666666666666666</span><br><span class="line"></span><br><span class="line">In [5]: #整除运算，向下取整</span><br><span class="line">   ...: print(1 &#x2F;&#x2F; 3)</span><br><span class="line">   ...: print(5.0 &#x2F;&#x2F; 2.0)#输出结果类型与除数和被除数一致</span><br><span class="line">   ...: print(5.0 &#x2F;&#x2F; 2)</span><br><span class="line">   ...: print(5 &#x2F;&#x2F; 2.0)</span><br><span class="line">   ...: print(-5 &#x2F;&#x2F; 2)#向下（向负3）取整</span><br><span class="line">0</span><br><span class="line">2.0</span><br><span class="line">2.0</span><br><span class="line">2.0</span><br><span class="line">-3</span><br><span class="line"></span><br><span class="line">In [6]: #求余运算</span><br><span class="line">    ...: print(5 % 2)</span><br><span class="line">    ...: print(5.0 % 2.0)</span><br><span class="line">    ...: print(5.0 % 2)</span><br><span class="line">    ...: print(5 % 2.0)</span><br><span class="line">1</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line"></span><br><span class="line">In [7]: #求幂</span><br><span class="line">    ...: print(2 ** 3)</span><br><span class="line">    ...: print(-2 ** 2)#注意比较区别</span><br><span class="line">    ...: print((-2) ** 2)</span><br><span class="line">8</span><br><span class="line">-4</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">In [8]: #取浮点数</span><br><span class="line">    ...: print(float(2))</span><br><span class="line">    ...:</span><br><span class="line">    ...:</span><br><span class="line">2.0</span><br><span class="line"></span><br><span class="line">In [9]: #取整数</span><br><span class="line">    ...: print(int(2.3))</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">In [10]: #取浮点数</span><br><span class="line">    ...: print(float(2))</span><br><span class="line">2.0</span><br><span class="line"></span><br><span class="line">In [11]: #pow函数求幂</span><br><span class="line">    ...: print(pow(2,3))</span><br><span class="line">    ...: print(2 ** 3)#与上行等价</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">In [12]: #取绝对值</span><br><span class="line">    ...: print(abs(-2))</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">In [13]: #四舍五入</span><br><span class="line">    ...: print(round(2.3))</span><br><span class="line">    ...: print(round(2.6))</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">In [14]: #转二进制</span><br><span class="line">    ...: print(bin(2))</span><br><span class="line">    ...:</span><br><span class="line">    ...: #转八进制</span><br><span class="line">    ...: print(oct(2))</span><br><span class="line">    ...:</span><br><span class="line">    ...: #转十六进制</span><br><span class="line">    ...: print(hex(2))</span><br><span class="line">0b10</span><br><span class="line">0o2</span><br><span class="line">0x2</span><br><span class="line"></span><br><span class="line">In [15]: #向下取整和向上取整</span><br><span class="line">   ...: import math</span><br><span class="line">   ...: print(math.floor(3.5))#向下取整</span><br><span class="line">   ...: print(math.ceil(3.5))#向上取整</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>2、字符串<br>字符串使用单引号，双引号或者三引号包围起来，例如，”hello, boy!”，’hello, boy!’，’’’hello,boy!’’’。</p>
</li>
<li><p>单引号双引号区别</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [16]: #该场景单引号和双引号作用一致</span><br><span class="line">   ...: print(&quot;hello boy!&quot;)</span><br><span class="line">   ...: print(&#39;hello girl!&#39;)</span><br><span class="line">hello boy!</span><br><span class="line">hello girl!</span><br><span class="line"></span><br><span class="line">#以下场景双引号和单引号作用不一致</span><br><span class="line">In [13]: print(&#39;hello,boy! Let&#39;s do it&#39;)</span><br><span class="line">  File &quot;&lt;ipython-input-13-be7bb4cf818c&gt;&quot;, line 1</span><br><span class="line">    print(&#39;hello,boy! Let&#39;s do it&#39;)</span><br><span class="line">                                  ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>反斜杠 \ 转义符<br>
  可添加转义字符使以上场景发挥相同作用。

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [15]: print(&#39;hello,boy! Let\&#39;s do it&#39;)</span><br><span class="line">hello,boy! Let&#39;s do it</span><br></pre></td></tr></table></figure>
<ul>
<li>输出原始字符串<br> 
输出字符串例如，换行符（\n），tab 分隔符（\t）等的原始字符串，而不是换行或者 tab 分割

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [16]: #方法一，反斜线转义</span><br><span class="line">    ...: #分别在特殊字符钱加反斜线转义</span><br><span class="line">    ...: print(&quot;Hi\\tHello\\nboy!&quot;)</span><br><span class="line">    ...:</span><br><span class="line">    ...: #方法二，使用r</span><br><span class="line">    ...: print(repr(&quot;Hi\tHello\nboy!&quot;))</span><br><span class="line">    ...: print(r&quot;Hi\tHello\nboy!&quot;)</span><br><span class="line"></span><br><span class="line">        Hi\tHello\nboy!</span><br><span class="line">        Hi\tHello\nboy!</span><br></pre></td></tr></table></figure>
<ul>
<li>三引号<br>
三引号内的字符可自由换行。

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [26]: print(&quot;&quot;&quot;Hello</span><br><span class="line">    ...: ,</span><br><span class="line">    ...: boy!&quot;&quot;&quot;)</span><br><span class="line">Hello</span><br><span class="line">,</span><br><span class="line">boy!</span><br></pre></td></tr></table></figure>
<p>三引号内可以随意使用双引号和单引号而不需要转义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [22]: print(&quot;&quot;&quot;hello,boy! Let&#39;s d&quot;o it&quot;&quot;&quot;)</span><br><span class="line">hello,boy! Let&#39;s d&quot;o it</span><br></pre></td></tr></table></figure>
<ul>
<li>操作字符串</li>
</ul>
<p>索引、切片、乘法、成员资格检查、长度、最小值和最大值都适用于字符串。</p>
<ul>
<li>字符串修改</li>
</ul>
<p>字符串是不可变的，所有的元素赋值和切片赋值都是非法的；<br>强行修改字符串的值会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [128]: &quot;Hello&quot;[1:]&#x3D;&quot;o&quot;</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-128-0a82fa2a7175&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 &quot;Hello&quot;[1:]&#x3D;&quot;o&quot;</span><br><span class="line"></span><br><span class="line">TypeError: &#39;str&#39; object does not support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>索引</li>
</ul>
<p>索引每次取一个元素，python 索引从 0 开始，可以为负数，最后一位索引为 - 1, 倒数第二位索引为 - 2，依次类推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [6]: &quot;Keepstudying&quot;[0:3]#取出索引位为0到2的元素</span><br><span class="line">Out[6]: &#39;Kee&#39;</span><br><span class="line"></span><br><span class="line">In [7]: &quot;Keepstudying&quot;[0:-2]#取出索引位为0到倒数第三个元素</span><br><span class="line">Out[7]: &#39;Keepstudyi&#39;</span><br><span class="line"></span><br><span class="line">In [8]: &quot;Keepstudying&quot;[-4:-2]#取出索引位为-4到-3的元素</span><br><span class="line">Out[8]: &#39;yi&#39;</span><br><span class="line"></span><br><span class="line">In [9]: &quot;Keepstudying&quot;[:3]#第一个参数可以省略</span><br><span class="line">Out[9]: &#39;Kee&#39;</span><br><span class="line"></span><br><span class="line">In [10]: &quot;Keepstudying&quot;[:]#取出所有元素</span><br><span class="line">Out[10]: &#39;Keepstudying&#39;</span><br><span class="line"></span><br><span class="line">In [11]: &quot;Keepstudying&quot;[1:]#第二个参数也可以省略</span><br><span class="line">Out[11]: &#39;eepstudying&#39;</span><br><span class="line"></span><br><span class="line">In [13]: &quot;Keepstudying&quot;[1:5:2]#步长为2</span><br><span class="line">Out[13]: &#39;ep&#39;</span><br><span class="line"></span><br><span class="line">In [14]: &quot;Keepstudying&quot;[::-1]#将字符颠倒</span><br><span class="line">Out[14]: &#39;gniydutspeeK&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>乘法<br>str*n，重复 str n 次。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [27]: print(&quot;Keepstudying\t&quot; * 10)#重复10次</span><br><span class="line">Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>拼接</p>
<bf>
使用加号拼接。

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [27]: print(&quot;Hello,&quot;+&quot;world!&quot;)</span><br><span class="line">Hello,world!</span><br></pre></td></tr></table></figure>
<ul>
<li>in 成员资格检查</li>
</ul>
<p>使用 in 判断字符串是否包含某个子字符串，包含返回 True，不包含返回 False。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [15]: &quot;stu&quot; in &quot;Keepstudying&quot;</span><br><span class="line">Out[15]: True</span><br><span class="line"></span><br><span class="line">In [16]: &quot;stv&quot; in &quot;Keepstudying&quot;</span><br><span class="line">Out[16]: False</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历</li>
</ul>
<p>依次输出字符串中每个元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [18]: for i in &quot;Keepstudying&quot;:</span><br><span class="line">    ...:     print(i)</span><br><span class="line">K</span><br><span class="line">e</span><br><span class="line">e</span><br><span class="line">p</span><br><span class="line">s</span><br><span class="line">t</span><br><span class="line">u</span><br><span class="line">d</span><br><span class="line">y</span><br><span class="line">i</span><br><span class="line">n</span><br><span class="line">g</span><br></pre></td></tr></table></figure>
<ul>
<li><p>求长度</p>
<p>使用 len 函数，计算字符串个数，\t，\n 算一个字符。</p>
<pre><code>In [23]: len(&quot;Keepstudyin  \t\ng&quot;)
Out[23]: 16
```
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>02.2数值和字符串</title>
    <url>/2021/01/29/02-2%E6%95%B0%E5%80%BC%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<ul>
<li>字符串方法</li>
</ul>
<p>字符串处理方法很多（下面斜体为所有内置方法），本文介绍常用的几种方法，详细可见链接：<a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html">https://docs.python.org/zh-cn/3.7/library/stdtypes.html</a> 。</p>
<p><code>In [23]: print(dir(str))#dir列出字符串所用方法</code></p>
<p>[‘<strong>add</strong>‘, ‘<strong>class</strong>‘, ‘<strong>contains</strong>‘, ‘<strong>delattr</strong>‘, ‘<strong>dir</strong>‘, ‘<strong>doc</strong>‘, ‘<strong>eq</strong>‘, ‘<strong>format</strong>‘, ‘<strong>ge</strong>‘, ‘<strong>getattribute</strong>‘, ‘<strong>getitem</strong>‘, ‘<strong>getnewargs</strong>‘, ‘<strong>gt</strong>‘, ‘<strong>hash</strong>‘, ‘<strong>init</strong>‘, ‘<strong>init_subclass__’, ‘<strong>iter</strong>‘, ‘<strong>le</strong>‘, ‘<strong>len</strong>‘, ‘<strong>lt</strong>‘, ‘<strong>mod</strong>‘, ‘<strong>mul</strong>‘, ‘<strong>ne</strong>‘, ‘<strong>new</strong>‘, ‘<strong>reduce</strong>‘, ‘__reduce_ex</strong>‘, ‘<strong>repr</strong>‘, ‘<strong>rmod</strong>‘, ‘<strong>rmul</strong>‘, ‘<strong>setattr</strong>‘, ‘<strong>sizeof</strong>‘, ‘<strong>str</strong>‘, ‘<strong>subclasshook</strong>‘, <strong><em>‘capitalize’, ‘casefold’, ‘center’, ‘count’, ‘encode’, ‘endswith’, ‘expandtabs’, ‘find’, ‘format’, ‘format_map’, ‘index’, ‘isalnum’, ‘isalpha’, ‘isascii’, ‘isdecimal’, ‘isdigit’, ‘isidentifier’, ‘islower’, ‘isnumeric’, ‘isprintable’, ‘isspace’, ‘istitle’, ‘isupper’, ‘join’, ‘ljust’, ‘lower’, ‘lstrip’, ‘maketrans’, ‘partition’, ‘replace’, ‘rfind’, ‘rindex’, ‘rjust’, ‘rpartition’, ‘rsplit’, ‘rstrip’, ‘split’, ‘splitlines’, ‘startswith’, ‘strip’, ‘swapcase’, ‘title’, ‘translate’, ‘upper’, ‘zfill’]</em></strong></p>
<ul>
<li><p>find 方法</p>
<p>语法，str.find (sub_str,a,b)</p>
</li>
</ul>
<p>字符串 str 中查找子字符串 sub_str 所在位置时使用，a，b 分别制定从 str 中开始搜索的位置，默认从第一个字符开始，a，b 均可忽略；如果找到 sub_str，就返回 sub_str 的第一个字符的索引，没找到返回 - 1。可用来判断 str 中是否包 sub_str 以及位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [32]: print(&quot;xiyangyang lanyangyang&quot;.find(&quot;huitanglang&quot;))</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">In [33]: print(&quot;xiyangyang lanyangyang&quot;.find(&quot;yang&quot;))</span><br><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>join 方法</li>
</ul>
<p>语法：sep.join (str)，以 sep 为分隔符拼接字符串 str。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [36]: print(&quot;+&quot;.join(&quot;xiyangyang&quot;))</span><br><span class="line">x+i+y+a+n+g+y+a+n+g</span><br></pre></td></tr></table></figure>
<ul>
<li>split 方法</li>
</ul>
<p>语法：str.split (sep)，以 sep 为分隔符，拆分字符串 str 为一个 list。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [37]: print(&quot;x+i+y+a+n+g+y+a+n+g&quot;.split(&quot;+&quot;))</span><br><span class="line">[&#39;x&#39;, &#39;i&#39;, &#39;y&#39;, &#39;a&#39;, &#39;n&#39;, &#39;g&#39;, &#39;y&#39;, &#39;a&#39;, &#39;n&#39;, &#39;g&#39;]</span><br></pre></td></tr></table></figure>
<ul>
<li>lower 方法</li>
</ul>
<p>语法：str.lower ()，将字符串 str 转化为小写版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [39]: print(&quot;Hello! Hi!&quot;.lower())</span><br><span class="line">hello! hi!</span><br></pre></td></tr></table></figure>
<ul>
<li>upper 方法</li>
</ul>
<p>语法：str.upper ()，将字符串 str 转化为大写版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [41]: print(&quot;Hello! Hi!&quot;.upper())</span><br><span class="line">HELLO! HI!</span><br></pre></td></tr></table></figure>
<ul>
<li>replace 方法</li>
</ul>
<p>语法：str.replace (“sub_str1”, “sub_str2”, max)。将字符串 str 中的子字符串 sub_str1 替换为 sub_str2，max 为允许替换的最大次数，可忽略，默认替换所有。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [48]: print(&quot;xiyangyang lanyangyang&quot;.replace(&quot;an&quot;,&quot;XX&quot;,2))</span><br><span class="line">xiyXXgyXXg lanyangyang</span><br></pre></td></tr></table></figure>
<ul>
<li><p>strip，lstrip 和 rstrip 方法</p>
<p>语法：三个方法类似，str.strip (sub_str)。strip 方法去掉 str 开头和结尾的子字符串 sub_str，sub_str 可忽略，默认为空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [49]: print(&quot; Hello &quot;.strip())</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">In [50]: print(&quot; Hello &quot;.lstrip())</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">In [51]: print(&quot; Hello &quot;.rstrip())</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">In [52: print(&quot; Hello &quot;.rstrip(&quot;o &quot;))</span><br><span class="line">Hell</span><br></pre></td></tr></table></figure></li>
<li><p>translate 方法</p>
</li>
</ul>
<p>语法：str.translate (table)，该方法同时替换 str 中多个字符，replace 一次只能替换一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [56]: old &#x3D; &quot;axy&quot;</span><br><span class="line">    ...: new &#x3D; &quot;123&quot;</span><br><span class="line">    ...: #调用字符串str的maketrans方法制作转换表</span><br><span class="line">    ...: table &#x3D; str.maketrans(old, new)</span><br><span class="line">    ...:</span><br><span class="line">    ...: str1 &#x3D; &quot;xiyangyang lanyangyang&quot;</span><br><span class="line">    ...: print (str1.translate(table))</span><br><span class="line">2i31ng31ng l1n31ng31ng</span><br></pre></td></tr></table></figure>
<ul>
<li>startswith 方法</li>
</ul>
<p>语法：str.startswith (sub_str, a, b)。判断 str 是否以 sub_str 开头，是则返回 True，否则返回 False，a，b 指定检索开始和结束（ 默认是字符串的长度，表示结束搜索的位置）为止，默认从第一个字符开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [64]: print(&quot;Hello&quot;.startswith(&quot;H&quot;))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<ul>
<li>endswith 方法</li>
</ul>
<p>使用类似 startswith，判断 str 是否以 sub_str 结尾。</p>
<ul>
<li><p>is 开头的诸多方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isascii&#39;, &#39;isdecimal&#39;,</span><br><span class="line">&#39;isdigit&#39;, &#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;,</span><br><span class="line">&#39;istitle&#39;, &#39;isupper&#39;</span><br></pre></td></tr></table></figure>
<p>以上分别为判断字符时否是字母或数字、字母、ASCII 等，详细参考 <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html%EF%BC%8C%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E">https://docs.python.org/zh-cn/3.7/library/stdtypes.html，结果返回</a> True 或者 False。</p>
</li>
<li><p>字符串格式化输出：format 方法</p>
</li>
<li><ul>
<li>调用参数</li>
</ul>
</li>
</ul>
<p>按顺序将字段和参数配对输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#按顺序将字段和参数配对输出</span><br><span class="line">In [79]: &quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(1, 2, 4, 3)</span><br><span class="line">Out[79]: &#39;1 2 4 3&#39;</span><br><span class="line"> </span><br><span class="line">#给参数指定名称，通过参数名称调用输出</span><br><span class="line">In [80]: &quot;&#123;a&#125; &#123;a&#125; &#123;b&#125; &#123;b&#125;&quot;.format(a&#x3D;1, b&#x3D;2)</span><br><span class="line">Out[80]: &#39;1 1 2 2&#39;</span><br><span class="line"> </span><br><span class="line">#以上两种方法混用</span><br><span class="line">In [81]: &quot;&#123;&#125; &#123;a&#125; &#123;&#125; &#123;b&#125;&quot;.format(0, 3, a&#x3D;1, b&#x3D;2)</span><br><span class="line">Out[81]: &#39;0 1 3 2&#39;</span><br><span class="line"> </span><br><span class="line">#未命名参数通过索引调用输出</span><br><span class="line">In [82]: &quot;&#123;1&#125; &#123;a&#125; &#123;0&#125; &#123;b&#125;&quot;.format(0, 3, a&#x3D;1, b&#x3D;2)</span><br><span class="line">Out[82]: &#39;3 1 0 2&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>参数格式转换</li>
</ul>
</li>
</ul>
<p>指定要转换的值是哪种类型，如下例中的 f b。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [85]: &quot;The number is &#123;:f&#125;&quot;.format(42)#f将小数表示为定点数</span><br><span class="line">Out[85]: &#39;The number is 42.000000&#39;</span><br><span class="line"> </span><br><span class="line">In [86]: &quot;The number is &#123;:b&#125;&quot;.format(42)#b将整数表示为二进制数</span><br><span class="line">Out[86]: &#39;The number is 101010&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>python 指定字符宽度，精度</li>
</ul>
</li>
</ul>
<p>常用转化类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b             将整数表示为二进制数</span><br><span class="line">c             将整数解读为Unicode码点</span><br><span class="line">d             将整数视为十进制数进行处理，这是整数默认使用的说明符</span><br><span class="line">e             使用科学表示法来表示小数（用e来表示指数）</span><br><span class="line">E             与e相同，但使用E来表示指数</span><br><span class="line">f              将小数表示为定点数</span><br><span class="line">F            与f相同，但对于特殊值（nan和inf），使用大写表示</span><br><span class="line">g            自动在定点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少有1位小数</span><br><span class="line">G            与g相同，但使用大写来表示指数和特殊值</span><br><span class="line">n            与g相同，但插入随区域而异的数字分隔符</span><br><span class="line">o            将整数表示为八进制数</span><br><span class="line">s            保持字符串的格式不变，这是默认用于字符串的说明符</span><br><span class="line">x            将整数表示为十六进制数并使用小写字母</span><br><span class="line">X            与x相同，但使用大写字母</span><br><span class="line">%            将数表示为百分比值（乘以100，按说明符f设置格式，再在后面加上%）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [96]: &quot;Pi is &#123;pi:10.2f&#125;&quot;.format(pi&#x3D;math.pi)#指定字符快读为10，精度为2个小数位</span><br><span class="line">Out[96]: &#39;Pi is       3.14&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>指定字符千分位分隔符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [101]: &#39;Oh gold banknote is &#123;:,&#125; yuan&#39;.format(100000000000)</span><br><span class="line">Out[101]: &#39;Oh gold banknote is 100,000,000,000 yuan&#39;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li>对齐</li>
</ul>
</li>
</ul>
<p>分别使用 &lt;、&gt; 和 ^ 指定左对齐，右对齐和居中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [107]: print(&#39;&#123;0:&lt;10.2f&#125;\n&#123;0:^10.2f&#125;\n&#123;0:&gt;10.2f&#125;&#39;.format(math.pi))</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210128181624.png" alt="20210128181624"></p>
<ul>
<li><ul>
<li>指定填充字符</li>
</ul>
</li>
</ul>
<p>默认为空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [113]: print(&#39;&#123;0:$&lt;10.2f&#125;\n&#123;0:@^10.2f&#125;\n&#123;0:&amp;&gt;10.2f&#125;&#39;.format(math.pi))</span><br><span class="line">3.14$$$$$$</span><br><span class="line">@@@3.14@@@</span><br><span class="line">&amp;&amp;&amp;&amp;&amp;&amp;3.14</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>等号（=），指定将填充字符放在符号和数字之间。</li>
</ul>
</li>
</ul>
<p>此处 = 类似于 &lt;、&gt; 和 ^</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [127]: print(&#39;&#123;0:$&gt;10.2f&#125;\n&#123;1:$&#x3D;10.2f&#125;&#39;.format(math.pi, -math.pi))</span><br><span class="line">$$$$$$3.14</span><br><span class="line">-$$$$$3.14</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>02.语言元素</title>
    <url>/2021/01/26/02.%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h4 id="指令和程序"><a href="#指令和程序" class="headerlink" title="指令和程序"></a>指令和程序</h4><p>计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器放在一起就是我们通常所说的中央处理器，它的功能是执行各种运算和控制指令以及处理计算机软件中的数据。我们通常所说的程序实际上就是指令的集合，我们程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。今天我们大多数时候使用的计算机，虽然它们的元器件做工越来越精密，处理能力越来越强大，但究其本质来说仍然属于<a href="https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84">“冯·诺依曼结构”</a>的计算机。“冯·诺依曼结构”有两个关键点，一是指出要将存储设备与中央处理器分开，二是提出了将数据以二进制方式编码。二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法没有实质性的区别，人类因为有十根手指所以使用了十进制（因为在数数时十根手指用完之后就只能进位了，当然凡事都有例外，玛雅人可能是因为长年光着脚的原因把脚趾头也算上了，于是他们使用了二十进制的计数法，在这种计数法的指导下玛雅人的历法就与我们平常使用的历法不一样，而按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为”2012年是玛雅人预言的世界末日“这种荒诞的说法，今天我们可以大胆的猜测，玛雅文明之所以发展缓慢估计也与使用了二十进制有关）。对于计算机来说，二进制在物理器件上来说是最容易实现的（高电压表示1，低电压表示0），于是在“冯·诺依曼结构”的计算机都使用了二进制。虽然我们并不需要每个程序员都能够使用二进制的思维方式来工作，但是了解二进制以及它与我们生活中的十进制之间的转换关系，以及二进制与八进制和十六进制的转换关系还是有必要的。如果你对这一点不熟悉，可以自行使用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">维基百科</a>或者<a href="https://baike.baidu.com/">百度百科</a>科普一下。</p>
<blockquote>
<p><strong>说明</strong>：近期关于<strong>量子计算机</strong>的研究已经被推倒了风口浪尖，量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息。2018年6月，Intel宣布开发出新款量子芯片并通过了在接近绝对零度环境下的测试；2019年，IBM和Google都推出了自己的量子计算机。</p>
</blockquote>
<h3 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h3><p>在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多种类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），我们先介绍几种常用的数据类型。</p>
<ul>
<li>整型：Python中可以处理任意大小的整数（Python 2.x中有<code>int</code>和<code>long</code>两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如<code>0b100</code>，换算成十进制是4）、八进制（如<code>0o100</code>，换算成十进制是64）、十进制（<code>100</code>）和十六进制（<code>0x100</code>，换算成十进制是256）的表示法。</li>
<li>浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如<code>123.456</code>）之外还支持科学计数法（如<code>1.23456e2</code>）。</li>
<li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如<code>&#39;hello&#39;</code>和<code>&quot;hello&quot;</code>,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。</li>
<li>布尔型：布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如<code>3 &lt; 5</code>会产生布尔值<code>True</code>，而<code>2 == 1</code>会产生布尔值<code>False</code>）。</li>
<li>复数型：形如<code>3+5j</code>，跟数学上的复数表示一样，唯一不同的是虚部的<code>i</code>换成了<code>j</code>。实际上，这个类型并不常用，大家了解一下就可以了。</li>
</ul>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。</p>
<ul>
<li>硬性规则：<ul>
<li>变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。</li>
<li>大小写敏感（大写的<code>a</code>和小写的<code>A</code>是两个不同的变量）。</li>
<li>不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。</li>
</ul>
</li>
<li>PEP 8要求：<ul>
<li>用小写字母拼写，多个单词用下划线连接。</li>
<li>受保护的实例属性用单个下划线开头（后面会讲到）。</li>
<li>私有的实例属性用两个下划线开头（后面会讲到）。</li>
</ul>
</li>
</ul>
<p>当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名时做到见名知意也是非常重要的。</p>
<h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><p>下面通过几个例子来说明变量的类型和变量使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用变量保存数据并进行加减乘除运算</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">a = <span class="number">321</span></span><br><span class="line">b = <span class="number">12</span></span><br><span class="line">print(a + b)    <span class="comment"># 333</span></span><br><span class="line">print(a - b)    <span class="comment"># 309</span></span><br><span class="line">print(a * b)    <span class="comment"># 3852</span></span><br><span class="line">print(a / b)    <span class="comment"># 26.75</span></span><br></pre></td></tr></table></figure>
<p>在Python中可以使用<code>type</code>函数对变量的类型进行检查。程序设计中函数的概念跟数学上函数的概念是一致的，数学上的函数相信大家并不陌生，它包括了函数名、自变量和因变量。如果暂时不理解这个概念也不要紧，我们会在后续的章节中专门讲解函数的定义和使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用type()检查变量的类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line">b = <span class="number">12.345</span></span><br><span class="line">c = <span class="number">1</span> + <span class="number">5j</span></span><br><span class="line">d = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">e = <span class="literal">True</span></span><br><span class="line">print(<span class="built_in">type</span>(a))    <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(b))    <span class="comment"># &lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(c))    <span class="comment"># &lt;class &#x27;complex&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(d))    <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(e))    <span class="comment"># &lt;class &#x27;bool&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以使用Python中内置的函数对变量类型进行转换。</p>
<ul>
<li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li>
<li><code>float()</code>：将一个字符串转换成浮点数。</li>
<li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li>
<li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li>
<li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。</li>
</ul>
<p>下面的代码通过键盘输入两个整数来实现对两个整数的算术运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用input()函数获取键盘输入(字符串)</span></span><br><span class="line"><span class="string">使用int()函数将输入的字符串转换成整数</span></span><br><span class="line"><span class="string">使用print()函数输出带占位符的字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;a = &#x27;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;b = &#x27;</span>))</span><br><span class="line">print(<span class="string">&#x27;%d + %d = %d&#x27;</span> % (a, b, a + b))</span><br><span class="line">print(<span class="string">&#x27;%d - %d = %d&#x27;</span> % (a, b, a - b))</span><br><span class="line">print(<span class="string">&#x27;%d * %d = %d&#x27;</span> % (a, b, a * b))</span><br><span class="line">print(<span class="string">&#x27;%d / %d = %f&#x27;</span> % (a, b, a / b))</span><br><span class="line">print(<span class="string">&#x27;%d // %d = %d&#x27;</span> % (a, b, a // b))</span><br><span class="line">print(<span class="string">&#x27;%d %% %d = %d&#x27;</span> % (a, b, a % b))</span><br><span class="line">print(<span class="string">&#x27;%d ** %d = %d&#x27;</span> % (a, b, a ** b))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面的print函数中输出的字符串使用了占位符语法，其中<code>%d</code>是整数的占位符，<code>%f</code>是小数的占位符，<code>%%</code>表示百分号（因为百分号代表了占位符，所以带占位符的字符串中要表示百分号必须写成<code>%%</code>），字符串之后的<code>%</code>后面跟的变量值会替换掉占位符然后输出到终端中，运行上面的程序，看看程序执行结果就明白啦。</p>
</blockquote>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，运算符的优先级指的是多个运算符同时出现时，先做什么运算然后再做什么运算。除了我们之前已经用过的赋值运算符和算术运算符，我们稍后会陆续讲到其他运算符的使用。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code> <code>[:]</code></td>
<td>下标，切片</td>
</tr>
<tr>
<td><code>**</code></td>
<td>指数</td>
</tr>
<tr>
<td><code>~</code> <code>+</code> <code>-</code></td>
<td>按位取反, 正负号</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td>
<td>乘，除，模，整除</td>
</tr>
<tr>
<td><code>+</code> <code>-</code></td>
<td>加，减</td>
</tr>
<tr>
<td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td>右移，左移</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>^</code> <code>|</code></td>
<td>按位异或，按位或</td>
</tr>
<tr>
<td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>小于等于，小于，大于，大于等于</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code></td>
<td>等于，不等于</td>
</tr>
<tr>
<td><code>is</code>  <code>is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in</code> <code>not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not</code> <code>or</code> <code>and</code></td>
<td>逻辑运算符</td>
</tr>
<tr>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> `</td>
<td>=<code> </code>^=<code> </code>&gt;&gt;=<code> </code>&lt;&lt;=`</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong> 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。</p>
</blockquote>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。下面的例子演示了赋值运算符和复合赋值运算符的使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">赋值运算符和复合赋值运算符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">a += b        <span class="comment"># 相当于：a = a + b</span></span><br><span class="line">a *= a + <span class="number">2</span>    <span class="comment"># 相当于：a = a * (a + 2)</span></span><br><span class="line">print(a)      <span class="comment"># 算一下这里会输出什么</span></span><br></pre></td></tr></table></figure>
<h3 id="比较运算符和逻辑运算符"><a href="#比较运算符和逻辑运算符" class="headerlink" title="比较运算符和逻辑运算符"></a>比较运算符和逻辑运算符</h3><p>比较运算符有的地方也称为关系运算符，包括<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>，我相信没有什么好解释的，大家一看就能懂，唯一需要提醒的是比较相等用的是<code>==</code>，请注意这个地方是两个等号，因为<code>=</code>是赋值运算符，我们在上面刚刚讲到过，<code>==</code>才是比较相等的比较运算符。比较运算符会产生布尔值，要么是<code>True</code>要么是<code>False</code>。</p>
<p>逻辑运算符有三个，分别是<code>and</code>、<code>or</code>和<code>not</code>。<code>and</code>字面意思是“而且”，所以<code>and</code>运算符会连接两个布尔值，如果两个布尔值都是<code>True</code>，那么运算的结果就是<code>True</code>；左右两边的布尔值有一个是<code>False</code>，最终的运算结果就是<code>False</code>。相信大家已经想到了，如果<code>and</code>左边的布尔值是<code>False</code>，不管右边的布尔值是什么，最终的结果都是<code>False</code>，所以在做运算的时候右边的值会被跳过（短路处理），这也就意味着在<code>and</code>运算符左边为<code>False</code>的情况下，右边的表达式根本不会执行。<code>or</code>字面意思是“或者”，所以<code>or</code>运算符也会连接两个布尔值，如果两个布尔值有任意一个是<code>True</code>，那么最终的结果就是<code>True</code>。当然，<code>or</code>运算符也是有短路功能的，在它左边的布尔值为<code>True</code>的情况下，右边的表达式根本不会执行。<code>not</code>运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值，也就是说，后面的布尔值如果是<code>True</code>运算结果就是<code>False</code>，而后面的布尔值如果是<code>False</code>则运算结果就是<code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">比较运算符和逻辑运算符的使用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">flag0 = <span class="number">1</span> == <span class="number">1</span></span><br><span class="line">flag1 = <span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line">flag2 = <span class="number">2</span> &lt; <span class="number">1</span></span><br><span class="line">flag3 = flag1 <span class="keyword">and</span> flag2</span><br><span class="line">flag4 = flag1 <span class="keyword">or</span> flag2</span><br><span class="line">flag5 = <span class="keyword">not</span> (<span class="number">1</span> != <span class="number">2</span>)</span><br><span class="line">print(<span class="string">&#x27;flag0 =&#x27;</span>, flag0)    <span class="comment"># flag0 = True</span></span><br><span class="line">print(<span class="string">&#x27;flag1 =&#x27;</span>, flag1)    <span class="comment"># flag1 = True</span></span><br><span class="line">print(<span class="string">&#x27;flag2 =&#x27;</span>, flag2)    <span class="comment"># flag2 = False</span></span><br><span class="line">print(<span class="string">&#x27;flag3 =&#x27;</span>, flag3)    <span class="comment"># flag3 = False</span></span><br><span class="line">print(<span class="string">&#x27;flag4 =&#x27;</span>, flag4)    <span class="comment"># flag4 = True</span></span><br><span class="line">print(<span class="string">&#x27;flag5 =&#x27;</span>, flag5)    <span class="comment"># flag5 = False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：比较运算符的优先级高于赋值运算符，所以<code>flag0 = 1 == 1</code>先做<code>1 == 1</code>产生布尔值<code>True</code>，再将这个值赋值给变量<code>flag0</code>。<code>print</code>函数可以输出多个值，多个值之间可以用<code>,</code>进行分隔，输出的内容之间默认以空格分开。</p>
</blockquote>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：华氏温度转换为摄氏温度。"><a href="#练习1：华氏温度转换为摄氏温度。" class="headerlink" title="练习1：华氏温度转换为摄氏温度。"></a>练习1：华氏温度转换为摄氏温度。</h4><blockquote>
<p>提示：华氏温度到摄氏温度的转换公式为：$C=(F - 32) \div 1.8$。</p>
</blockquote>
<p>参考答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">将华氏温度转换为摄氏温度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">f = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入华氏温度: &#x27;</span>))</span><br><span class="line">c = (f - <span class="number">32</span>) / <span class="number">1.8</span></span><br><span class="line">print(<span class="string">&#x27;%.1f华氏度 = %.1f摄氏度&#x27;</span> % (f, c))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：在使用<code>print</code>函数输出时，也可以对字符串内容进行格式化处理，上面<code>print</code>函数中的字符串<code>%1.f</code>是一个占位符，稍后会由一个<code>float</code>类型的变量值替换掉它。同理，如果字符串中有<code>%d</code>，后面可以用一个<code>int</code>类型的变量值替换掉它，而<code>%s</code>会被字符串的值替换掉。除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中<code>&#123;f:.1f&#125;</code>和<code>&#123;c:.1f&#125;</code>可以先看成是<code>&#123;f&#125;</code>和<code>&#123;c&#125;</code>，表示输出时会用变量<code>f</code>和变量<code>c</code>的值替换掉这两个占位符，后面的<code>:.1f</code>表示这是一个浮点数，小数点后保留1位有效数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;f:<span class="number">.1</span>f&#125;</span>华氏度 = <span class="subst">&#123;c:<span class="number">.1</span>f&#125;</span>摄氏度&#x27;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="练习2：输入圆的半径计算计算周长和面积。"><a href="#练习2：输入圆的半径计算计算周长和面积。" class="headerlink" title="练习2：输入圆的半径计算计算周长和面积。"></a>练习2：输入圆的半径计算计算周长和面积。</h4><p>参考答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输入半径计算圆的周长和面积</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">radius = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入圆的半径: &#x27;</span>))</span><br><span class="line">perimeter = <span class="number">2</span> * <span class="number">3.1416</span> * radius</span><br><span class="line">area = <span class="number">3.1416</span> * radius * radius</span><br><span class="line">print(<span class="string">&#x27;周长: %.2f&#x27;</span> % perimeter)</span><br><span class="line">print(<span class="string">&#x27;面积: %.2f&#x27;</span> % area)</span><br></pre></td></tr></table></figure>
<h4 id="练习3：输入年份判断是不是闰年。"><a href="#练习3：输入年份判断是不是闰年。" class="headerlink" title="练习3：输入年份判断是不是闰年。"></a>练习3：输入年份判断是不是闰年。</h4><p>参考答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输入年份 如果是闰年输出True 否则输出False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">year = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入年份: &#x27;</span>))</span><br><span class="line"><span class="comment"># 如果代码太长写成一行不便于阅读 可以使用\对代码进行折行</span></span><br><span class="line">is_leap = year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">or</span> \</span><br><span class="line">          year % <span class="number">400</span> == <span class="number">0</span></span><br><span class="line">print(is_leap)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：比较运算符会产生布尔值，而逻辑运算符<code>and</code>和<code>or</code>会对这些布尔值进行组合，最终也是得到一个布尔值，闰年输出<code>True</code>，平年输出<code>False</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>DataFrame读写及路径问题总结</title>
    <url>/2021/02/04/DataFrame%E8%AF%BB%E5%86%99%E5%8F%8A%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="一、路径问题"><a href="#一、路径问题" class="headerlink" title="一、路径问题"></a>一、路径问题</h2><h3 id="在写代码前一定要先导入相关的库"><a href="#在写代码前一定要先导入相关的库" class="headerlink" title="在写代码前一定要先导入相关的库"></a>在写代码前一定要先导入相关的库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import os </span><br></pre></td></tr></table></figure>
<h4 id="1、导入文件"><a href="#1、导入文件" class="headerlink" title="1、导入文件"></a>1、导入文件</h4><p><code>data = pd.read_excel(&quot;D:\\PycharmProjects\\hellow\\excel\\招生信息.xlsx&quot;)     # 打开原始工作表</code></p>
<a id="more"></a>

<p>&emsp;&emsp;文件目录采用双斜线替换了反斜线，避免了因为误识别文件目录为转义符导致的错误，类似解决错误转义符出错的方法如下。<br><br><br>（1）路径前加‘r’<br><br><br>（2）替换为双斜线<br><br><br>（3）替换为正斜线</p>
<p>注意：在 read_excel 时一定是读取原文件路径，大部分程序出错都是因为读取路径的问题</p>
<h4 id="2、获取工作表行数列数"><a href="#2、获取工作表行数列数" class="headerlink" title="2、获取工作表行数列数"></a>2、获取工作表行数列数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lens &#x3D; data.shape[1]  # 获取行数 shape[1]获取列数</span><br><span class="line">rows &#x3D; data.shape[0]  # 获取行数 shape[0]获取行数</span><br></pre></td></tr></table></figure>
<h4 id="3、获取指定工作表"><a href="#3、获取指定工作表" class="headerlink" title="3、获取指定工作表"></a>3、获取指定工作表</h4><p><code>data = pd.read_excel(r&quot;D:\excel\招生信息.xlsx&quot;,sheetname=&#39;sheet名&#39;) </code></p>
<h4 id="4、获取指定工作薄中所有工作表"><a href="#4、获取指定工作薄中所有工作表" class="headerlink" title="4、获取指定工作薄中所有工作表"></a>4、获取指定工作薄中所有工作表</h4><p><code>data = pd.read_excel(r&quot;D:\excel\招生信息.xlsx&quot;,sheetname=None) </code></p>
<h4 id="5、获取所有工作表中指定列"><a href="#5、获取所有工作表中指定列" class="headerlink" title="5、获取所有工作表中指定列"></a>5、获取所有工作表中指定列</h4><p><code>data = pd.read_excel(r&quot;D:\excel\招生信息.xlsx&quot;,sheetname=None，usecols=[&#39;A1&#39;,&#39;A2&#39;,....]) </code></p>
<h2 id="二、批量读取-Excel-文件"><a href="#二、批量读取-Excel-文件" class="headerlink" title="二、批量读取 Excel 文件"></a>二、批量读取 Excel 文件</h2><h3 id="1、读取同一个文件夹下的多个-Excel-文件"><a href="#1、读取同一个文件夹下的多个-Excel-文件" class="headerlink" title="1、读取同一个文件夹下的多个 Excel 文件"></a>1、读取同一个文件夹下的多个 Excel 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x3D; r&#39;D:\jupyter notebook\test&#39; </span><br><span class="line">filenames &#x3D; os.listdir(dir)</span><br><span class="line">dfs &#x3D; []</span><br><span class="line">for filename in filenames:</span><br><span class="line">   print(&#39;正在处理第&#39;) + str(index+1) + &#39;个表格&#39;）</span><br><span class="line">   # print(&#39;需要合并的文件为:&#39;,dir + filename)    # 为第二种写法</span><br><span class="line">   dfs.append(pd.read_excel(dir + &#39;\\&#39; + filename))</span><br><span class="line">   # dfs.append(pd.read_excel(os.path.join(dir,filename)))  # 为第二种写法</span><br><span class="line">   index +&#x3D;1</span><br><span class="line">df &#x3D; pd.concat(dfs)</span><br><span class="line">df.to_excel(&#39;&#39;dir + &#39;\\&#39; + total.xlsx&#39;&#39;,index &#x3D; False)</span><br><span class="line">print(&#39;合并后的数据大小为:&#39;,df.shape)</span><br><span class="line">print(&#39;合并完成&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="2、读取同一个文件夹下的多个不同文件内的-Excel-文件"><a href="#2、读取同一个文件夹下的多个不同文件内的-Excel-文件" class="headerlink" title="2、读取同一个文件夹下的多个不同文件内的 Excel 文件"></a>2、读取同一个文件夹下的多个不同文件内的 Excel 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_paths &#x3D; r&#39;D:\jupyter notebook\test&#39; </span><br><span class="line">file_list &#x3D; []</span><br><span class="line">dfs &#x3D; []</span><br><span class="line">for root,dirs,files in os.walk(file_paths):</span><br><span class="line">   print(root,dirs,files)   # 输出看看就会明白都是些什么信息了</span><br><span class="line">   for file in files:</span><br><span class="line">      file_path &#x3D; os.path.join(root,file)  # 使用os.path.join(dirpath, name)得到全路径</span><br><span class="line">      file_list.append(file_path)</span><br><span class="line">      df &#x3D; pd.read_excel(file_path)  # 将excel转换成DataFrame</span><br><span class="line">      dfs.append(df)</span><br><span class="line">df &#x3D; pd.concat(dfs,axis &#x3D; 1)  # 将多个DataFrame合并为一个</span><br></pre></td></tr></table></figure>
<h2 id="python-对-excel-操作获取某一列，某一行的值，对某一列信息筛选"><a href="#python-对-excel-操作获取某一列，某一行的值，对某一列信息筛选" class="headerlink" title="python 对 excel 操作获取某一列，某一行的值，对某一列信息筛选"></a>python 对 excel 操作获取某一列，某一行的值，对某一列信息筛选</h2><p>以下为<a href="https://blog.csdn.net/weixin_43245453/article/details/90747259">转载文章</a><br>向大神学习</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">path &#x3D; &#39;G:\动力系\新建文件夹\什么.xls&#39;</span><br><span class="line">data &#x3D; pd.read_excel(path,None)#读取数据,设置None可以生成一个字典，字典中的key值即为sheet名字，此时不用使用DataFram，会报错</span><br><span class="line">print(data.keys())#查看sheet的名字</span><br><span class="line">for sh_name in data.keys():</span><br><span class="line">    print(&#39;sheet_name的名字是：&#39;,sh_name)</span><br><span class="line">    sh_data &#x3D; pd.DataFrame(pd.read_excel(path,sh_name))#获得每一个sheet中的内容</span><br><span class="line">    print(sh_data)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210203225541.png" alt="20210203225541"></p>
</div>

<h4 id="获得某一行，某一列的值"><a href="#获得某一行，某一列的值" class="headerlink" title="获得某一行，某一列的值"></a>获得某一行，某一列的值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">path &#x3D; &#39;G:\动力系\新建文件夹\什么.xls&#39;</span><br><span class="line">data &#x3D; pd.DataFrame(pd.read_excel(path))#读取数据,设置None可以生成一个字典，字典中的key值即为sheet名字，此时不用使用DataFram，会报错</span><br><span class="line">print(data.index)#获取行的索引名称</span><br><span class="line">print(data.columns)#获取列的索引名称</span><br><span class="line">print(data[&#39;姓名&#39;])#获取列名为姓名这一列的内容</span><br><span class="line">print(data.loc[0])#获取行名为0这一行的内容</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210203225808.png" alt="20210203225808"></p>
</div>

<h4 id="对某一列的信息进行筛选"><a href="#对某一列的信息进行筛选" class="headerlink" title="对某一列的信息进行筛选"></a>对某一列的信息进行筛选</h4><p>筛选使用的是 data.loc [列名称 = 提取的信息]</p>
<p>假如我要提取院系下面的动力，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">path &#x3D; &#39;G:\动力系\新建文件夹\什么.xls&#39;</span><br><span class="line">data &#x3D; pd.DataFrame(pd.read_excel(path))#读取数据,设置None可以生成一个字典，字典中的key值即为sheet名字，此时不用使用DataFram，会报错</span><br><span class="line">result &#x3D; data.loc[data[&#39;院系&#39;] &#x3D;&#x3D; &#39;动力&#39;]#获取列明为院系，内容为动力的内容</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210203225916.png" alt="20210203225916"></p>
</div>

<h2 id="python-下-pandas-库中读取指定行或列数据"><a href="#python-下-pandas-库中读取指定行或列数据" class="headerlink" title="python 下 pandas 库中读取指定行或列数据"></a>python 下 pandas 库中读取指定行或列数据</h2><p>关键！！！！使用 loc 函数来查找。<br>话不多说，直接演示：<br>有以下名为 try.xlsx 表：[此文为转载，出处在CSDN上，具体忘记了，表示感谢]</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210203230209.png" alt="20210203230209"></p>
</div>

<h4 id="1-根据-index-查询"><a href="#1-根据-index-查询" class="headerlink" title="1. 根据 index 查询"></a>1. 根据 index 查询</h4><p>条件：首先导入的数据必须的有 index<br>或者自己添加吧，方法简单，读取 excel 文件时直接加 index_col<br>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd                      #导入pandas库</span><br><span class="line"></span><br><span class="line">excel_file &#x3D; &#39;.&#x2F;try.xlsx&#39;               #导入excel数据</span><br><span class="line">data &#x3D; pd.read_excel(excel_file, index_col&#x3D;&#39;姓名&#39;)        </span><br><span class="line">#这个的index_col就是index，可以选择任意字段作为索引index，读入数据</span><br><span class="line">print(data.loc[&#39;李四&#39;])</span><br></pre></td></tr></table></figure>
<p>打印结果就是:<br><br><br>部门 B<br><br><br>工资 6600<br><br><br>Name: 李四，dtype: object<br><br><br>（注意点：索引）</p>
<h4 id="2-已知数据在第几行找到想要的数据"><a href="#2-已知数据在第几行找到想要的数据" class="headerlink" title="2. 已知数据在第几行找到想要的数据"></a>2. 已知数据在第几行找到想要的数据</h4><p>假如我们的表中，有某个员工的工资数据为空了，那我们怎么找到自己想要的数据呢。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in data.columns:</span><br><span class="line">    for j in range(len(data)):</span><br><span class="line">        if (data[i].isnull())[j]:</span><br><span class="line">            bumen &#x3D; data.iloc[j, [0]]                             #找出缺失值所在的部门</span><br><span class="line">            data[i][j] &#x3D; charuzhi(bumen)</span><br></pre></td></tr></table></figure>
<p>原理很简单，首先检索全部的数据，然后我们可以用 pandas 中的 iloc 函数。上面的 iloc [j, [2]] 中 j 是具体的位置，【0】是你要得到的数据所在的 column</p>
<h4 id="3-根据条件查询找到指定行数据"><a href="#3-根据条件查询找到指定行数据" class="headerlink" title="3. 根据条件查询找到指定行数据"></a>3. 根据条件查询找到指定行数据</h4><p>例如查找 A 部门所有成员的的姓名和工资或者工资低于 3000 的人：<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;根据条件查询某行数据&quot;&quot;&quot;</span><br><span class="line">import pandas as pd            #导入pandas库</span><br><span class="line"></span><br><span class="line">excel_file &#x3D; &#39;.&#x2F;try.xlsx&#39;        #导入文件</span><br><span class="line">data &#x3D; pd.read_excel(excel_file)      #读入数据</span><br><span class="line"></span><br><span class="line">print(data.loc[data[&#39;部门&#39;] &#x3D;&#x3D; &#39;A&#39;, [&#39;姓名&#39;, &#39;工资&#39;]])     #部门为A，打印姓名和工资</span><br><span class="line">print(data.loc[data[&#39;工资&#39;] &lt; 3000, [&#39;姓名&#39;,&#39;工资&#39;]])    #查找工资小于3000的人</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210203230509.png" alt="20210203230509"></p>
</div>
若要把这些数据独立生成 excel 文件或者 csv 文件：
添加以下代码:

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;导出为excel或csv文件&quot;&quot;&quot;</span><br><span class="line">dataframe_1 &#x3D; data.loc[data[&#39;部门&#39;] &#x3D;&#x3D; &#39;A&#39;, [&#39;姓名&#39;, &#39;工资&#39;]]</span><br><span class="line">dataframe_2 &#x3D; data.loc[data[&#39;工资&#39;] &lt; 3000, [&#39;姓名&#39;, &#39;工资&#39;]]</span><br><span class="line">dataframe_1.to_excel(&#39;dataframe_1.xlsx&#39;)</span><br><span class="line">dataframe_2.to_excel(&#39;dataframe_2.xlsx&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="4-找出指定列"><a href="#4-找出指定列" class="headerlink" title="4. 找出指定列"></a>4. 找出指定列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data[&#39;columns&#39;]  #columns即你需要的字段名称即可</span><br><span class="line">#注意这列的columns不能是index的名称</span><br><span class="line">#如果要打印index的话就data.index</span><br><span class="line">data.columns  #与上面的一样</span><br></pre></td></tr></table></figure>
<p>以上全过程用到的库：<br>pandas，xlrd , openpyxl</p>
<h4 id="5-找出指定的行和指定的列"><a href="#5-找出指定的行和指定的列" class="headerlink" title="5. 找出指定的行和指定的列"></a>5. 找出指定的行和指定的列</h4><p>主要使用的就是函数 iloc</p>
<p><code>data.iloc[:,:2]  #即全部行，前两列的数据</code></p>
<p>逗号前是行，逗号后是列的范围，很容易理解</p>
<h4 id="6-在规定范围内找出符合条件的数据"><a href="#6-在规定范围内找出符合条件的数据" class="headerlink" title="6. 在规定范围内找出符合条件的数据"></a>6. 在规定范围内找出符合条件的数据</h4><p><code>data.iloc[:10,:][data.工资&gt;6000]</code></p>
<p>这样即可找出前 11 行里工资大于 6000 的所有人的信息了</p>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>JupyterNotebook介绍安装及使用教程</title>
    <url>/2021/06/26/JupyterNotebook%E4%BB%8B%E7%BB%8D%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>由于最近开始学pandas数据处理的课程，看了很多教程都有介绍说使用Jupyter Notebook是最合适的选择。于是乎从网上找了教程来学习使用，但找了很久才完美的安装及初步的学会简单使用。由于其过程中踩了很多坑，做了太久的工具选择的痛苦决定，故今天写下这篇个人认为是正确且完善的安装使用教程，以便于广大想要学习使用此工具的同学，同时也是为方便以后自己观看学习。如有不恰当之处，请指出，本人会及时改正。过程中有引用网上各大神的教程说明及图片，在此向他们致敬，如有不适请及时联系，定会删除。</p>
<h2 id="一、什么是Jupyter-Notebook？"><a href="#一、什么是Jupyter-Notebook？" class="headerlink" title="一、什么是Jupyter Notebook？"></a>一、什么是Jupyter Notebook？</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Jupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。简而言之，Jupyter Notebook是以网页的形式打开，可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。</p>
<h3 id="2-组成部分"><a href="#2-组成部分" class="headerlink" title="2. 组成部分"></a>2. 组成部分</h3><p>① 网页应用</p>
<p>网页应用即基于网页形式的、结合了编写说明文档、数学公式、交互计算和其他富媒体形式的工具。简言之，网页应用是可以实现各种功能的工具。</p>
<p>② 文档</p>
<p>即Jupyter Notebook中所有交互计算、编写说明文档、数学公式、图片以及其他富媒体形式的输入和输出，都是以文档的形式体现的。这些文档是保存为后缀名为.ipynb的JSON格式文件，不仅便于版本控制，也方便与他人共享。此外，文档还可以导出为：HTML、LaTeX、PDF等格式。</p>
<h3 id="3-Jupyter-Notebook的主要特点"><a href="#3-Jupyter-Notebook的主要特点" class="headerlink" title="3. Jupyter Notebook的主要特点"></a>3. Jupyter Notebook的主要特点</h3><blockquote>
<p>1、编程时具有语法高亮、缩进、tab补全的功能。</p>
<p>2、可直接通过浏览器运行代码，同时在代码块下方展示运行结果。</p>
<p>3、以富媒体格式展示计算结果。富媒体格式包括：HTML，LaTeX，PNG，SVG等。</p>
<p>4、对代码编写说明文档或语句时，支持Markdown语法。</p>
<p>5、支持使用LaTeX编写数学性说明。</p>
</blockquote>
<h2 id="二、安装Jupyter-Notebook"><a href="#二、安装Jupyter-Notebook" class="headerlink" title="二、安装Jupyter Notebook"></a>二、安装Jupyter Notebook</h2><ol>
<li>安装</li>
</ol>
<p>安装Jupyter Notebook的前提是需要安装了Python3 版本及以上</p>
<p>2、使用pip命令安装</p>
<p>①把pip升级到最新版本   python -m pip install –upgrade pip</p>
<p>②安装Jupyter Notebook  pip install jupyter notbook -i 国内源</p>
<p>注：在安装Python时默认都安装了pip，安装pip后，在cmd.exe下可以运行pip。安装库：pip install 库的名字  换源：因为PyPi地址在国外，国内访问速度慢有些地方甚至访问不了,把镜像源换为国内地址速度简直飞起。</p>
<p>国内一些常用的软件源如下：</p>
<blockquote>
<p>阿里云：<a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学：<a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>豆瓣：<a href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a></p>
<p>清华大学：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></p>
<p>中国科学技术大学：<a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
</blockquote>
<p>以阿里云镜像源为例</p>
<p><code>pip install 库的名字 -i https://mirrors.aliyun.com/pypi/simple/</code></p>
<p>3、常用pip安装常用命令</p>
<p>0、把pip升级到最新版本   python -m pip install –upgrade pip</p>
<p>①查看已安装的库 pip list</p>
<p>②更新库 pip install –upgrade 库的名字</p>
<p>③卸载库pip uninstall 库的名字 -y   # 加上-y表示直接卸载，没有提示选择是否要卸载，直到最后完成卸载提示。</p>
<p>④迁移库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip freeze&gt;requirements.txt--&gt;将本机库列表输出到指定的requirements.txt文件 </span><br><span class="line"></span><br><span class="line">示例：pip freeze&gt;C:\Users\自己的\Desktop\requirements.txt--&gt;输出到桌面 </span><br><span class="line"></span><br><span class="line">找到导出的文件，即看文件的路径，使用文件完整路径安装</span><br><span class="line"></span><br><span class="line">pip install -r C:\Users\自己的\Desktop\requirements.txt 使用pip安装requirements.txt文件中所含的库 </span><br></pre></td></tr></table></figure>

<p>查看库的版本     pip  version</p>
<p>查看需要更新的库     pip list  --outdated</p>
<h2 id="三、使用Jupyter-Notebook"><a href="#三、使用Jupyter-Notebook" class="headerlink" title="三、使用Jupyter Notebook"></a>三、使用Jupyter Notebook</h2><p>1、在cmd中输入jupyter notebook 即可打开，看到如下界面，表示安装成功。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626121556.png" alt="20210626121556"></p>
</div>

<p>注意2:</p>
<p>Jupyter notebook使用过程成中 对应的 cmd 不要关闭。</p>
<h2 id="四、配置-Jupyter-notebook"><a href="#四、配置-Jupyter-notebook" class="headerlink" title="四、配置 Jupyter notebook"></a>四、配置 Jupyter notebook</h2><h3 id="如何更改默认目录？"><a href="#如何更改默认目录？" class="headerlink" title="如何更改默认目录？"></a>如何更改默认目录？</h3><p>默认情况下，Jupyter notebook 将 c: / users / username 设置为默认目录。 我们可以更改默认目录，以便更容易地管理项目。</p>
<p><code>CMD 中输入 jupyter notebook --generate-config</code></p>
<p>•    首先生成配置文件</p>
<p><code>Jupyter notebook --generate-config</code></p>
<p>这会生成一个配置文件，路径终端会给出。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626121841.png" alt="20210626121841"></p>
</div>

<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626121850.png" alt="20210626121850"></p>
</div>

<p><code>用记事本打开 jupyter_notebook_config.py</code></p>
<p>做如下修改，记得要把句首【#】去掉，参数才能生效</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626121922.png" alt="20210626121922"></p>
</div>

<h2 id="五、运行Jupyter-Notebook"><a href="#五、运行Jupyter-Notebook" class="headerlink" title="五、运行Jupyter Notebook"></a>五、运行Jupyter Notebook</h2><ol start="0">
<li>帮助</li>
</ol>
<p>如果你有任何jupyter notebook命令的疑问，可以考虑查看官方帮助文档，命令如下：</p>
<p><code>jupyter notebook --help  或  jupyter notebook -h</code></p>
<ol>
<li><p>启动</p>
<p>① 默认端口启动</p>
</li>
</ol>
<p><code>在终端中输入以下命令：jupyter notebook</code></p>
<p>执行命令之后，在终端中将会显示一系列notebook的服务器信息，同时浏览器将会自动启动Jupyter Notebook。</p>
<p>启动过程中终端显示内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jupyter notebook</span><br><span class="line">[I 08:58:24.417 NotebookApp] Serving notebooks from local directory: &#x2F;Users&#x2F;catherine</span><br><span class="line">[I 08:58:24.417 NotebookApp] 0 active kernels</span><br><span class="line">[I 08:58:24.417 NotebookApp] The Jupyter Notebook is running at: http:&#x2F;&#x2F;localhost:8888&#x2F;</span><br><span class="line">[I 08:58:24.417 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</span><br></pre></td></tr></table></figure>
<p>•    注意：之后在Jupyter Notebook的所有操作，都请保持终端不要关闭，因为一旦关闭终端，就会断开与本地服务器的链接，你将无法在Jupyter Notebook中进行其他操作啦。</p>
<p>浏览器地址栏中默认地将会显示：<a href="http://localhost:8888。其中，“localhost”指的是本机，“8888”则是端口号。">http://localhost:8888。其中，“localhost”指的是本机，“8888”则是端口号。</a></p>
<p>如果你同时启动了多个Jupyter Notebook，由于默认端口“8888”被占用，因此地址栏中的数字将从“8888”起，每多启动一个Jupyter Notebook数字就加1，如“8889”、“8890”……</p>
<p>② 指定端口启动</p>
<p>如果你想自定义端口号来启动Jupyter Notebook，可以在终端中输入以下命令：</p>
<p><code>jupyter notebook --port &lt;port_number&gt;</code></p>
<p>其中，“<port_number>”是自定义端口号，直接以数字的形式写在命令当中，数字两边不加尖括号“&lt;&gt;”。如：jupyter notebook –port 9999，即在端口号为“9999”的服务器启动Jupyter Notebook。</p>
<p>③ 启动服务器但不打开浏览器</p>
<p>如果你只是想启动Jupyter Notebook的服务器但不打算立刻进入到主页面，那么就无需立刻启动浏览器。在终端中输入：</p>
<p><code>jupyter notebook --no-browser</code></p>
<p>此时，将会在终端显示启动的服务器信息，并在服务器启动之后，显示出打开浏览器页面的链接。当你需要启动浏览器页面时，只需要复制链接，并粘贴在浏览器的地址栏中，轻按回车变转到了你的Jupyter Notebook页面。</p>
<p><code>no_browser</code></p>
<p>例图中由于在完成上面内容时我同时启动了多个Jupyter Notebook，因此显示我的“8888”端口号被占用，最终分配给我的是“8889”。</p>
<ol>
<li><p>主页面</p>
<p>① 主页面内容</p>
</li>
</ol>
<p>当执行完启动命令之后，浏览器将会进入到Notebook的主页面，如下图所示。<br>如果你的主页面里边的文件夹跟我的不同，或者你在疑惑为什么首次启动里边就已经有这么多文件夹，不要担心，这里边的文件夹全都是你的家目录里的目录文件。你可以在终端中执行以下2步来查看：</p>
<h2 id="六、安装jupyter-contrib-nbextensions库"><a href="#六、安装jupyter-contrib-nbextensions库" class="headerlink" title="六、安装jupyter_contrib_nbextensions库"></a>六、安装jupyter_contrib_nbextensions库</h2><p>安装步骤：<br>如果你已经安装了，先执行卸载命令：</p>
<p><code>pip uninstall jupyter_contrib_nbextensions</code></p>
<p><code>pip uninstall jupyter_nbextensions_configurator</code></p>
<p>在cmd中运行：</p>
<p><code>pip install jupyter_contrib_nbextensions</code></p>
<p><code>jupyter-contrib-nbextension install --user</code></p>
<p>记住jupyter, contrib和nbextension中间要加上-，这个很重要…否则就会报以下错误：</p>
<p><code>Exception: Jupyter command </code>jupyter-contrib<code> not found.</code></p>
<p>在其中勾选需要的功能即可</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626122606.png" alt="20210626122606"></p>
</div>

<p><strong>较为常见的部分功能</strong></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626122649.png" alt="20210626122649"></p>
</div>

<p>注意：勾选 autopep8 后可能会提示找不到该模块，此时:</p>
<p><code>pip install autopep8 -i 国内源</code></p>
<p>即可</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626122746.png" alt="20210626122746"></p>
</div>

<h2 id="七、创建快捷方式"><a href="#七、创建快捷方式" class="headerlink" title="七、创建快捷方式"></a>七、创建快捷方式</h2><p>每次都通过命令行来打开 Jupyter Lab 确实麻烦。</p>
<p>写个.bat文件就好啦。</p>
<p>方法：先创建一个文本文件，在里面写入jupyter notebook，之后把扩展名改为.bat，双击运行即可。</p>
<h2 id="八、Jupyter的各种快捷键"><a href="#八、Jupyter的各种快捷键" class="headerlink" title="八、Jupyter的各种快捷键"></a>八、Jupyter的各种快捷键</h2><blockquote>
<p>执行当前cell，并自动跳到下一个cell：Shift Enter</p>
<p>执行当前cell，执行后不自动调转到下一个cell：Ctrl-Enter</p>
<p>是当前的cell进入编辑模式：Enter</p>
<p>退出当前cell的编辑模式：Esc</p>
<p>删除当前的cell：双D</p>
<p>为当前的cell加入line number：单L</p>
<p>将当前的cell转化为具有一级标题的maskdown：单1</p>
<p>将当前的cell转化为具有二级标题的maskdown：单2</p>
<p>将当前的cell转化为具有三级标题的maskdown：单3</p>
<p>为一行或者多行添加/取消注释：Crtl /</p>
<p>撤销对某个cell的删除：z</p>
<p>浏览器的各个Tab之间切换：Crtl PgUp和Crtl PgDn</p>
<p>快速跳转到首个cell：Crtl Home</p>
<p>快速跳转到最后一个cell：Crtl End</p>
</blockquote>
<h2 id="九、Jupyter-Notebook如何导入代码"><a href="#九、Jupyter-Notebook如何导入代码" class="headerlink" title="九、Jupyter Notebook如何导入代码"></a>九、Jupyter Notebook如何导入代码</h2><p>即导入代码到jupyter notebook的cell中</p>
<p>1 将本地的.py文件load到jupyter的一个cell中</p>
<p>问题背景：有一个test.py文件，需要将其载入到jupyter的一个cell中</p>
<p>test.py内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import caffe</span><br><span class="line"></span><br><span class="line">SolverName &#x3D; &quot;&#x2F;root&#x2F;workspace&quot;</span><br><span class="line">sovler &#x3D; caffe.AdamSolver(SolverName)</span><br></pre></td></tr></table></figure>
<p>方法步骤：</p>
<p>（1）在需要导入该段代码的cell中输入</p>
<p><code>%load test.py      # test.py 是当前路径下的一个python文件</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626123324.png" alt="20210626123324"></p>
</div>

<p>（2）运行该cell</p>
<p>利用快捷键“Shift+Enter”，可以看到如下结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626123346.png" alt="20210626123346"></p>
</div>

<p>（3）可以看到，运行后，%load test.py被自动加入了注释符号#，test.py中的所有代码都被load到了当前的cell中</p>
<p>2 从网络load代码到jupyter</p>
<p>在cell中输入%load http://…..，然后运行该cell，就会将load后面所对应地址的代码load到当前的cell中；</p>
<p>下面给出一个例子，导入matplotlib中的一个小例子color example code</p>
<p>首先，在想要导入该段代码的cell中输入</p>
<p><code>%load test.py</code>   #test.py是当前路径下的一个python文件,然后，Shift+Enter运行，可以看到如下结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626123506.png" alt="20210626123506"></p>
</div>

<p>可以看到，运行后，%load test.py被自动加入了注释符号#，test.py中的所有代码都被load到了当前的cell中</p>
<h2 id="十、Jupyter运行python文件"><a href="#十、Jupyter运行python文件" class="headerlink" title="十、Jupyter运行python文件"></a>十、Jupyter运行python文件</h2><p>利用jupyter的cell是可以运行python文件的，即在cell中运行如下代码：</p>
<p><code>%run file.py</code></p>
<p>file.py为要运行的python程序，结果会显示在该cell中</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626123619.png" alt="20210626123619"></p>
</div>


<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626123629.png" alt="20210626123629"></p>
</div>

<h2 id="十一、Jupyter一些其他琐碎用法"><a href="#十一、Jupyter一些其他琐碎用法" class="headerlink" title="十一、Jupyter一些其他琐碎用法"></a>十一、Jupyter一些其他琐碎用法</h2><p>1 jupyter的cell可以作为unix command使用</p>
<p>具体方法为：在unitx command前面加入一个感叹号“！”</p>
<p>例子：</p>
<p>查看python版本：!python –version</p>
<p>运行python文件：!python myfile.py</p>
<p>2 Magic functions</p>
<p>3 获取current working directory</p>
<p>即当前运行的代码所在的路径具体方法：current_path = %pwd   这样得到的current_path就是当前工作路径的字符转</p>
<p>4 使用Matplotlib绘图</p>
<p>在Jupyter Notebook中，如果使用Matplotlib绘图，有时是弹不出图像框的，此时，可以在开头加入:</p>
<p><code>%matplotlib inline</code></p>
<h2 id="十二、Jupyter中的Markdown"><a href="#十二、Jupyter中的Markdown" class="headerlink" title="十二、Jupyter中的Markdown"></a>十二、Jupyter中的Markdown</h2><p>1 在jupyter中设置link，需要设置两部分：</p>
<p>要跳到的位置(the destination)</p>
<p>需要在要跳转到的位置添加下面语句:</p>
<p><code>&lt;a id=&#39;the_destination&#39;&gt;&lt;/a&gt;</code></p>
<p>这里的id取值任意赋值，下面在添加链接时要用需要添加链接的文字（an internal hyperlink to the destination），即点击该处可以跳转到the destination，在需要添加链接的文字后面加入：下面是一个例子：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626123914.png" alt="20210626123914"></p>
</div>

<p>效果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210626123944.png" alt="20210626123944"></p>
</div>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法查看</title>
    <url>/2021/01/29/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%9F%A5%E7%9C%8B/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/191d1e21f7ed/">1. Markdown 基本语法含流程图的创建</a></p>
<p><a href="http://markdown.p2hp.com/basic-syntax/index.html">2. 基本语法 官网</a></p>
<p><a href="https://www.jianshu.com/p/ebe52d2d468f">3. Markdown语法大全(超级版)</a></p>
<pre><code>表头|表头|表头
:--|:--:|:--:
内容|内容|内容
内容|内容|内容

第二行分割表头和内容。
- 有一个就行，为了对齐，多加了几个
文字默认居左
-两边加：表示文字居中
-右边加：表示文字居右
</code></pre>
<p>效果如下：</p>
<table>
<thead>
<tr>
<th align="center">姓名</th>
<th align="center">技能</th>
<th align="center">排行</th>
</tr>
</thead>
<tbody><tr>
<td align="center">刘备</td>
<td align="center">哭</td>
<td align="center">大哥</td>
</tr>
<tr>
<td align="center">关羽</td>
<td align="center">打</td>
<td align="center">二哥</td>
</tr>
<tr>
<td align="center">张飞</td>
<td align="center">骂</td>
<td align="center">三弟</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas之拆分工作表_输入到文件夹</title>
    <url>/2021/03/06/Pandas%E4%B9%8B%E6%8B%86%E5%88%86%E5%B7%A5%E4%BD%9C%E8%A1%A8-%E8%BE%93%E5%85%A5%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<h3 id="拆分总表为单个-excel-文件至一个文件夹内"><a href="#拆分总表为单个-excel-文件至一个文件夹内" class="headerlink" title="拆分总表为单个 excel 文件至一个文件夹内"></a>拆分总表为单个 excel 文件至一个文件夹内</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import os</span><br><span class="line">data &#x3D; pd.read_excel(&#39;.&#x2F;五年级账号和密码.xls&#39;)		#读取数据</span><br><span class="line">data_list &#x3D; list(data[&#39;班级&#39;].drop_duplicates())        #去重处理</span><br><span class="line">longth &#x3D; len(data_list)		#计算共有多少数量</span><br><span class="line">path &#x3D; &#39;.&#x2F;SplitExcel&#39;</span><br><span class="line">if not os.path.exists(path):					#当前文件夹下是否有此文件夹</span><br><span class="line">    os.mkdir(path)					#创建此文件夹</span><br><span class="line">count &#x3D; 0</span><br><span class="line">for item in data_list:</span><br><span class="line">    data_select &#x3D; data[data[&#39;班级&#39;]&#x3D;&#x3D;item]		       #选出item对应的行</span><br><span class="line">    Bigzone &#x3D; data_select.iat[0,0]				#需要参与文件命名的值</span><br><span class="line">    Smallzone &#x3D; data_select.iat[0,1]</span><br><span class="line">    service_code &#x3D; data_select.iat[0,2]</span><br><span class="line">    data_select.to_excel(&#39;.&#x2F;SplitExcel&#x2F;&#123;0:&#125;-&#123;1:&#125;.xlsx&#39;.format(Bigzone,Smallzone),index&#x3D;False)	#按照对应的值生成EXCEL文件</span><br><span class="line">    count +&#x3D; 1</span><br><span class="line">    print(&#39;\rEXCEL表中共有 &#123;&#125; 个班级，正在拆分第 &#123;&#125; 个的数据，拆分进度：&#123;:.2%&#125;&#39;.format(longth, count, count &#x2F; longth),end&#x3D;&quot;&quot;)</span><br><span class="line">print(&#39;\n&#123;&#125;个名称已经全部拆分完毕，请前往SplitExcel文件夹下查看拆分后的各文件数据.&#39;.format(longth))</span><br></pre></td></tr></table></figure>
<h3 id="拆分总表至一个新工作薄内的每个工作表"><a href="#拆分总表至一个新工作薄内的每个工作表" class="headerlink" title="拆分总表至一个新工作薄内的每个工作表"></a>拆分总表至一个新工作薄内的每个工作表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd			#调用pandas包</span><br><span class="line">import xlsxwriter  			#调用xlswriter包，用来生成表</span><br><span class="line"></span><br><span class="line">data&#x3D;pd.read_excel(&#39;.&#x2F;五年级账号和密码.xls&#39;) 	#读取存储路径在桌面的工作簿chaifengzb,编码格式为gbk</span><br><span class="line">area_list&#x3D;list(set(data[&quot;班级&quot;])) 	#按分公司字段分成列表</span><br><span class="line"></span><br><span class="line">writer&#x3D;pd.ExcelWriter(&#39;.&#x2F;chaifengzb1.xls&#39;) 	    #生成一个新 工作簿</span><br><span class="line"></span><br><span class="line">data.to_excel(writer,sheet_name&#x3D;&quot;班级&quot;,index&#x3D;False)      #将总表存到新工作簿中</span><br><span class="line"></span><br><span class="line">for j in area_list:</span><br><span class="line">    df&#x3D;data[data[&quot;班级&quot;]&#x3D;&#x3D;j]</span><br><span class="line">    df.to_excel(writer,sheet_name&#x3D;&#39;五&#39;+j,index&#x3D;False)   #按分成的列表中的分公司字段进行命名</span><br><span class="line">writer.save()  				                            #文件保存</span><br></pre></td></tr></table></figure>
<h3 id="一种简洁高效的办法"><a href="#一种简洁高效的办法" class="headerlink" title="一种简洁高效的办法"></a>一种简洁高效的办法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df &#x3D;pd.read_excel(&#39;F:\\fxwnj五年级(2).xls&#39;,dtype&#x3D;str)</span><br><span class="line">class_list &#x3D; list(df[&#39;班级&#39;].drop_duplicates())</span><br><span class="line">for i in class_list:</span><br><span class="line">    banji &#x3D; df[df[&#39;班级&#39;]&#x3D;&#x3D;i]</span><br><span class="line">    banji.to_excel(&#39;%s.xlsx&#39;%(i),index &#x3D; False)</span><br><span class="line"></span><br><span class="line">print(&#39;拆分表格已完成，请到工作目录下查看！&#39;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas在github上获取原始数据集</title>
    <url>/2021/02/16/Pandas%E5%9C%A8github%E4%B8%8A%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>GitHub repository 的文件地址后面直接加？raw=true</code></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1、文本类文件，小文件 (txt,xml,gif) 可以直接展示；</p>
<p>2、压缩文件会提示下载，这就可以通过 github 升级程序。</p>
<p>Sample：</p>
<p>在github的文件地址后面直接加上(？raw=true)</p>
<p>zip 提示 save</p>
<p><a href="https://github.com/Song2017/PersonalLab/blob/master/0_testRaw/raw.zip?raw=true">https://github.com/Song2017/PersonalLab/blob/master/0_testRaw/raw.zip?raw=true</a></p>
<p>txt</p>
<p><a href="https://github.com/Song2017/PersonalLab/blob/master/0_testRaw/rawTxt.txt?raw=true">https://github.com/Song2017/PersonalLab/blob/master/0_testRaw/rawTxt.txt?raw=true</a></p>
<p>Pandas读取github上的数据集:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210216122500.png" alt="20210216122500"></p>
</div>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在数据分析的过程里，你已经体会到 Python 生态系统的强大了吧？</p>
<p>数据采集、整理、可视化、统计分析…… 一直到深度学习，都有相应的 Python 包支持。</p>
<p>但是你会发现，没有任何一个 Python 软件包，是全能的。</p>
<p>这是一种非常好的设计思维 —— 用优秀的工具，做专业的事儿；用许多优秀工具组成的系统，来有条不紊地处理复杂问题。</p>
<p>所以，在这个过程中，你大概率会经常遇到数据的交换问题。</p>
<p>有时候，是把分析结果存起来，下次读取回来继续使用。</p>
<p>更重要的时候，是把一个工具的分析结果导出，导入到另一个工具包中。</p>
<p>这些数据存取的功能，几乎分布在每一个 Python 数据科学软件包之内。</p>
<p>但是，其中有一个最重要的枢纽，那就是 Pandas 。</p>
<p>不止一次跟你提起过，学好 Pandas 的重要性。</p>
<p>很多情况下，看似复杂的数据整理与可视化，Pandas 只需要一行语句就能搞定。</p>
<p>回顾我们的教程里，也曾使用过各种不同的格式读取数据到 Pandas 进行处理。</p>
<p>然而，当你需要自己独立面对软件包的格式要求时，也许仅仅是因为不了解如何正确生成或读取某种格式，结果导致出错，甚至会使你丧失探索的信心与兴趣。</p>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas排序简单排复杂排</title>
    <url>/2021/02/05/Pandas%E6%8E%92%E5%BA%8F%E7%AE%80%E5%8D%95%E6%8E%92%E5%A4%8D%E6%9D%82%E6%8E%92/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">lists &#x3D; pd.read_excel(&quot;..&#x2F;007&#x2F;List.xlsx&quot;)</span><br><span class="line"></span><br><span class="line"># 按指定的一列排序</span><br><span class="line">lists.sort_values(by&#x3D;&quot;Price&quot;,inplace&#x3D;True,ascending&#x3D;False)</span><br><span class="line"></span><br><span class="line"># 指定多列排序(注意：对Worthy列升序，再对Price列降序)，ascending不指定的话，默认是True升序</span><br><span class="line">lists.sort_values(by&#x3D;[&quot;Worthy&quot;,&quot;Price&quot;],inplace&#x3D;True,ascending&#x3D;[True,False])</span><br><span class="line"></span><br><span class="line">print(lists)</span><br></pre></td></tr></table></figure>
<p>结果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205123136.png" alt="20210205123136"></p>
</div>

<h3 id="Pandas-函数填充、计算列"><a href="#Pandas-函数填充、计算列" class="headerlink" title="Pandas_函数填充、计算列"></a>Pandas_函数填充、计算列</h3><h4 id="函数填充、计算列"><a href="#函数填充、计算列" class="headerlink" title="函数填充、计算列"></a>函数填充、计算列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">books &#x3D; pd.read_excel(&quot;..&#x2F;006&#x2F;Books.xlsx&quot;,index_col&#x3D;&quot;ID&quot;)</span><br><span class="line">print(books.dtypes)</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure>
<p>结果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205123512.png" alt="20210205123512"></p>
</div>

<h4 id="一、将-“ListPrice”-列-和-“Discount”-列-相乘的值赋给-Price"><a href="#一、将-“ListPrice”-列-和-“Discount”-列-相乘的值赋给-Price" class="headerlink" title="一、将 “ListPrice” 列 和 “Discount” 列 相乘的值赋给 Price"></a>一、将 “ListPrice” 列 和 “Discount” 列 相乘的值赋给 Price</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方法1：按列来运算</span><br><span class="line">books[&quot;Price&quot;] &#x3D; books[&quot;ListPrice&quot;]*books[&quot;Discount&quot;]</span><br><span class="line">books[&quot;Price&quot;]&#x3D;books[&quot;ListPrice&quot;]*8   </span><br><span class="line"></span><br><span class="line"># 方法2：按单元格来运算（类似excel里的操作）</span><br><span class="line">print(books.index)</span><br><span class="line">for i in books.index:</span><br><span class="line">    books[&quot;Price&quot;].at[i]&#x3D;books[&quot;ListPrice&quot;].at[i]*books[&quot;Discount&quot;].at[i] #一旦其中一个是指定到单元格的，其他列也要指定到单元格</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 一般我们需要对某几行操作运算时才会用方法2,比如，我们只对第5行到第15行之间的价格运算</span><br><span class="line">for i in range(5,15):</span><br><span class="line">    books[&quot;Price&quot;].at[i]&#x3D;books[&quot;ListPrice&quot;].at[i]*books[&quot;Discount&quot;].at[i]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205123821.png" alt="20210205123821"></p>
</div>

<h4 id="二、将-“ListPrice”-列-2-元-后-赋给-Price"><a href="#二、将-“ListPrice”-列-2-元-后-赋给-Price" class="headerlink" title="二、将 “ListPrice” 列 +2 元 后 赋给 Price"></a>二、将 “ListPrice” 列 +2 元 后 赋给 Price</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方法1：直接加</span><br><span class="line">books[&quot;Price&quot;] &#x3D; books[&quot;ListPrice&quot;]+2</span><br><span class="line"></span><br><span class="line"># 方法2：用函数</span><br><span class="line">def add_2(x):</span><br><span class="line">    return x+2</span><br><span class="line"></span><br><span class="line">books[&quot;Price&quot;]&#x3D;books[&quot;ListPrice&quot;].apply(add_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方法3：用lambda</span><br><span class="line">books[&quot;Price&quot;]&#x3D;books[&quot;ListPrice&quot;].apply(lambda x:x+2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205123940.png" alt="20210205123940"></p>
</div>

]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas操作Excel的四种类型</title>
    <url>/2021/02/04/Pandas%E6%93%8D%E4%BD%9CExcel%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_41278904/article/details/100167702">转载</a>表示感谢，只是在此记录一下，以便以后自己使用</p>
<h3 id="使用-python-一分钟完成-Excel-数据由多个文件合并为一个文件（pandas）"><a href="#使用-python-一分钟完成-Excel-数据由多个文件合并为一个文件（pandas）" class="headerlink" title="使用 python 一分钟完成 Excel 数据由多个文件合并为一个文件（pandas）"></a>使用 python 一分钟完成 Excel 数据由多个文件合并为一个文件（pandas）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一步：调用pandas包</span><br><span class="line">import pandas as pd</span><br><span class="line">import os</span><br><span class="line">iris_concat &#x3D; pd.DataFrame()</span><br><span class="line"># 第二步：读取数据并合并</span><br><span class="line">for name in os.listdir(&#39;.&#x2F;data&#x2F;&#39;):</span><br><span class="line">    iris &#x3D; pd.read_excel(&#39;.&#x2F;data&#x2F;%s&#39;%(name))</span><br><span class="line">    iris_concat &#x3D; pd.concat([iris_concat,iris])</span><br><span class="line">iris_concat.to_excel(&#39;.&#x2F;iris_concat.xlsx&#39;)#数据保存路径   </span><br></pre></td></tr></table></figure>
<h3 id="使用-Python-一分钟完成-Excel-数据由多个-sheet-合并为一个-sheet（pandas）"><a href="#使用-Python-一分钟完成-Excel-数据由多个-sheet-合并为一个-sheet（pandas）" class="headerlink" title="使用 Python 一分钟完成 Excel 数据由多个 sheet 合并为一个 sheet（pandas）"></a>使用 Python 一分钟完成 Excel 数据由多个 sheet 合并为一个 sheet（pandas）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一步：调用pandas包</span><br><span class="line">import pandas as pd</span><br><span class="line">#第二步：读取数据</span><br><span class="line">iris &#x3D; pd.read_excel(&#39;.&#x2F;iris_sheets.xlsx&#39;,None)#读入数据文件</span><br><span class="line">keys &#x3D; list(iris.keys())</span><br><span class="line">#第三步：数据合并</span><br><span class="line">iris_concat &#x3D; pd.DataFrame()</span><br><span class="line">for i in keys:</span><br><span class="line">    iris1 &#x3D; iris[i]</span><br><span class="line">    iris_concat &#x3D; pd.concat([iris_concat,iris1])</span><br><span class="line">iris_concat.to_excel(&#39;.&#x2F;iris_concat.xlsx&#39;)#数据保存路径   </span><br></pre></td></tr></table></figure>
<h3 id="使用-Python-中-pandas-按照某一列把一个-Excel-文件拆分为多个-Excel-文件"><a href="#使用-Python-中-pandas-按照某一列把一个-Excel-文件拆分为多个-Excel-文件" class="headerlink" title="使用 Python 中 pandas 按照某一列把一个 Excel 文件拆分为多个 Excel 文件"></a>使用 Python 中 pandas 按照某一列把一个 Excel 文件拆分为多个 Excel 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一步：调用pandas包</span><br><span class="line">import pandas as pd</span><br><span class="line">#第二步：读入文件</span><br><span class="line">iris &#x3D; pd.read_excel(&#39;.&#x2F;iris.xlsx&#39;)</span><br><span class="line"># 第三步：获取class列表并去重</span><br><span class="line">class_list &#x3D; list(iris[&#39;class&#39;].drop_duplicates())</span><br><span class="line">#第四步：按照类别分文件存放数据</span><br><span class="line">for i in class_list:</span><br><span class="line">    iris1 &#x3D; iris[iris[&#39;class&#39;]&#x3D;&#x3D;i]</span><br><span class="line">    iris1.to_excel(&#39;.&#x2F;%s.xlsx&#39;%(i))</span><br></pre></td></tr></table></figure>
<h3 id="使用-Python-一分钟完成按照某一列将-Excel-数据由一个-sheet-拆分为多个-sheet（使用-pandas-超简单）"><a href="#使用-Python-一分钟完成按照某一列将-Excel-数据由一个-sheet-拆分为多个-sheet（使用-pandas-超简单）" class="headerlink" title="使用 Python 一分钟完成按照某一列将 Excel 数据由一个 sheet 拆分为多个 sheet（使用 pandas 超简单）"></a>使用 Python 一分钟完成按照某一列将 Excel 数据由一个 sheet 拆分为多个 sheet（使用 pandas 超简单）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一步：调用pandas包</span><br><span class="line">import pandas as pd</span><br><span class="line">#第二步：读取数据</span><br><span class="line">iris &#x3D; pd.read_excel(&#39;.&#x2F;iris.xlsx&#39;)#读入数据文件</span><br><span class="line">class_list &#x3D; list(iris[&#39;class&#39;].drop_duplicates())#获取数据class列，去重并放入列表</span><br><span class="line"># 第三步：按照类别分sheet存放数据</span><br><span class="line">writer &#x3D; pd.ExcelWriter(&#39;.&#x2F;iris_sheets.xlsx&#39;)#创建数据存放路径</span><br><span class="line">for i in class_list: </span><br><span class="line">    iris1 &#x3D; iris[iris[&#39;class&#39;]&#x3D;&#x3D;i]</span><br><span class="line">    iris1.to_excel(writer,i)</span><br><span class="line">writer.save()#文件保存</span><br><span class="line">writer.close()#文件关闭</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas整理表格数据</title>
    <url>/2021/02/04/Pandas%E6%95%B4%E7%90%86%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_41629698/article/details/105393136">转载</a> 在此感谢作者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data&#x3D;[]</span><br><span class="line">dfd &#x3D; pd.read_excel(&#39;F:\gbh\python\practice\大创\data\武汉疫情数据\迁徙.xlsx&#39;)</span><br><span class="line">#dfd.head(10)</span><br><span class="line">index&#x3D;</span><br><span class="line">dfd[&#39;日期&#39;] &#x3D; pd.to_datetime(dfd[&#39;日期&#39;].astype(&#39;str&#39;))</span><br><span class="line">time&#x3D;[&#39;2020-01-24&#39;,&#39;2020-01-25&#39;,&#39;2020-01-26&#39;,&#39;2020-01-27&#39;,&#39;2020-01-28&#39;,&#39;2020-01-29&#39;,&#39;2020-01-30&#39;,&#39;2020-01-31&#39;,&#39;2020-02-01&#39;,&#39;2020-02-02&#39;,&#39;2020-02-03&#39;]</span><br><span class="line">for i in range(12):</span><br><span class="line">    index+&#x3D;1</span><br><span class="line">    data_china &#x3D; dfd[dfd[&#39;日期&#39;] &#x3D;&#x3D; time[i]]</span><br><span class="line">    print(data_china)</span><br><span class="line">    data.append(data_china)</span><br><span class="line">    #data_china.to_csv(&#39;E:\data_tengxun\迁徙1.23.csv&#39;,index&#x3D;0,encoding&#x3D;&#39;utf_8_sig&#39;)</span><br><span class="line">    data_china.to_csv(&#39;E:\data_tengxun\迁徙1.2&#39;+str(index)+&#39;.csv&#39;,index&#x3D;0,encoding&#x3D;&#39;utf_8_sig&#39;)  </span><br></pre></td></tr></table></figure>
<p>以上代码实现批量筛选<br><br><br>如果是单独筛选，可以使用一下代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data&#x3D;[]</span><br><span class="line">dfd &#x3D; pd.read_excel(&#39;F:\gbh\python\practice\大创\data\武汉疫情数据\迁徙.xlsx&#39;)</span><br><span class="line">#dfd.head(10)</span><br><span class="line"></span><br><span class="line">dfd[&#39;日期&#39;] &#x3D; pd.to_datetime(dfd[&#39;日期&#39;].astype(&#39;str&#39;))</span><br><span class="line">#time&#x3D;[&#39;2020-01-24&#39;,&#39;2020-01-25&#39;,&#39;2020-01-26&#39;,&#39;2020-01-27&#39;,&#39;2020-01-28&#39;,&#39;2020-01-29&#39;,&#39;2020-01-30&#39;,&#39;2020-01-31&#39;,&#39;2020-02-01&#39;,&#39;2020-02-02&#39;,&#39;2020-02-03&#39;]</span><br><span class="line">data_china &#x3D; dfd[dfd[&#39;日期&#39;] &#x3D;&#x3D; &#39;2020-02-03&#39;]</span><br><span class="line">print(data_china)</span><br><span class="line">data.append(data_china)</span><br><span class="line">#data_china.to_csv(&#39;E:\data_tengxun\迁徙1.23.csv&#39;,index&#x3D;0,encoding&#x3D;&#39;utf_8_sig&#39;)</span><br><span class="line">data_china.to_csv(&#39;E:\data_tengxun\迁徙2.03.csv&#39;,index&#x3D;0,encoding&#x3D;&#39;utf_8_sig&#39;)  </span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204000207.png" alt="20210204000207"></p>
</div>




<h2 id="用-pandas-按列合并两个文件"><a href="#用-pandas-按列合并两个文件" class="headerlink" title="用 pandas 按列合并两个文件"></a>用 pandas 按列合并两个文件</h2><p><a href="https://blog.csdn.net/destiny_python/article/details/78666839">我是来学习的</a> 转载自此处，感谢</p>
<p>A 文件：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204000638.png" alt="20210204000638"></p>
</div>


<p>B 文件：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204000742.png" alt="20210204000742"></p>
</div>

<p>可以发现，A 文件中 “汉字井号” 这一列和 B 文件中 “WELL” 这一列的属性相同，以这一列为主键，把 B 文件中 “TIME” 这一列数据添加到 A 文件中，如果 B 文件缺少某些行，则空着，最后 A 文件的行数不变，效果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204000832.png" alt="20210204000832"></p>
</div>

<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">df1 &#x3D; pd.read_csv(u&#39;input.csv&#39;, encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line"> </span><br><span class="line">df2 &#x3D; pd.read_csv(&#39;input1.csv&#39;, encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line"> </span><br><span class="line">outfile &#x3D; pd.merge(df1, df2, how&#x3D;&#39;left&#39;, left_on&#x3D;u&#39;汉字井号&#39;,right_on&#x3D;&#39;WELL&#39;)</span><br><span class="line"> </span><br><span class="line">outfile.to_csv(&#39;outfile.csv&#39;, index&#x3D;False, encoding&#x3D;&#39;gbk&#39;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas的合并及拼接问题</title>
    <url>/2021/02/04/Pandas%E7%9A%84%E5%90%88%E5%B9%B6%E5%8F%8A%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>concat 与其说是连接，更准确的说是拼接。就是把两个表直接合在一起。于是有一个突出的问题，是横向拼接还是纵向拼接，所以 concat 函数的关键参数是 axis 。<br>函数的具体参数是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">concat(objs,axis&#x3D;0,join&#x3D;&#39;outer&#39;,join_axes&#x3D;None,</span><br><span class="line">ignore_index&#x3D;False,keys&#x3D;None,levels&#x3D;None,names&#x3D;None,verigy_integrity&#x3D;False)</span><br></pre></td></tr></table></figure>
<p>objs 是需要拼接的对象集合，一般为列表或者字典</p>
<p>axis=0 是行拼接，拼接之后行数增加，列数也根据 join 来定，join=’outer’时，列数是两表并集。同理 join=’inner’, 列数是两表交集。</p>
<p>在默认情况下，axis=0 为纵向，按行拼接，此时有:</p>
<p><code>concat([df1,df2]) 等价于 df1.append(df2)</code></p>
<p>在 axis=1 时为横向拼接 ，此时有:</p>
<p><code>concat([df1,df2],axis=1) 等价于 merge(df1,df2,left_index=True,right_index=True,how=&#39;outer&#39;)</code></p>
<h3 id="pandas-的连接函数-concat-函数"><a href="#pandas-的连接函数-concat-函数" class="headerlink" title="pandas 的连接函数 concat () 函数"></a>pandas 的连接函数 concat () 函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.concat(objs, axis&#x3D;0, join&#x3D;&#39;outer&#39;, join_axes&#x3D;None, ignore_index&#x3D;False,</span><br><span class="line">          keys&#x3D;None, levels&#x3D;None, names&#x3D;None, verify_integrity&#x3D;False,</span><br><span class="line">          copy&#x3D;True)</span><br></pre></td></tr></table></figure>
<h4 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义:"></a>参数含义:</h4><ul>
<li>objs：Series，DataFrame 或 Panel 对象的序列或映射。如果传递了 dict，则排序的键将用作键参数，除非它被传递，在这种情况下，将选择值（见下文）。任何无对象将被静默删除，除非它们都是无，在这种情况下将引发一个 ValueError。</li>
<li>axis：{0,1，…}，默认为 0。沿着连接的轴。</li>
<li>join：{‘inner’，’outer’}，默认为 “outer”。如何处理其他轴上的索引。outer 为联合和 inner 为交集。</li>
<li>ignore_index：boolean，default False。如果为 True，请不要使用并置轴上的索引值。结果轴将被标记为 0，…，n-1。如果要连接其中并置轴没有有意义的索引信息的对象，这将非常有用。注意，其他轴上的索引值在连接中仍然受到尊重。</li>
<li>join_axes：Index 对象列表。用于其他 n-1 轴的特定索引，而不是执行内部 / 外部设置逻辑。</li>
<li>keys：序列，默认值无。使用传递的键作为最外层构建层次索引。如果为多索引，应该使用元组。</li>
<li>levels：序列列表，默认值无。用于构建 MultiIndex 的特定级别（唯一值）。否则，它们将从键推断。</li>
<li>names：list，default 无。结果层次索引中的级别的名称。</li>
<li>verify_integrity：boolean，default False。检查新连接的轴是否包含重复项。这相对于实际的数据串联可能是非常昂贵的。</li>
<li>copy：boolean，default True。如果为 False，请勿不必要地复制数据。</li>
</ul>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: df1 &#x3D; pd.DataFrame(&#123;&#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],</span><br><span class="line">   ...:                     &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;],</span><br><span class="line">   ...:                     &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;],</span><br><span class="line">   ...:                     &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]&#125;,</span><br><span class="line">   ...:                     index&#x3D;[0, 1, 2, 3])</span><br><span class="line">   ...: </span><br><span class="line"> </span><br><span class="line">In [2]: df2 &#x3D; pd.DataFrame(&#123;&#39;A&#39;: [&#39;A4&#39;, &#39;A5&#39;, &#39;A6&#39;, &#39;A7&#39;],</span><br><span class="line">   ...:                     &#39;B&#39;: [&#39;B4&#39;, &#39;B5&#39;, &#39;B6&#39;, &#39;B7&#39;],</span><br><span class="line">   ...:                     &#39;C&#39;: [&#39;C4&#39;, &#39;C5&#39;, &#39;C6&#39;, &#39;C7&#39;],</span><br><span class="line">   ...:                     &#39;D&#39;: [&#39;D4&#39;, &#39;D5&#39;, &#39;D6&#39;, &#39;D7&#39;]&#125;,</span><br><span class="line">   ...:                      index&#x3D;[4, 5, 6, 7])</span><br><span class="line">   ...: </span><br><span class="line"> </span><br><span class="line">In [3]: df3 &#x3D; pd.DataFrame(&#123;&#39;A&#39;: [&#39;A8&#39;, &#39;A9&#39;, &#39;A10&#39;, &#39;A11&#39;],</span><br><span class="line">   ...:                     &#39;B&#39;: [&#39;B8&#39;, &#39;B9&#39;, &#39;B10&#39;, &#39;B11&#39;],</span><br><span class="line">   ...:                     &#39;C&#39;: [&#39;C8&#39;, &#39;C9&#39;, &#39;C10&#39;, &#39;C11&#39;],</span><br><span class="line">   ...:                     &#39;D&#39;: [&#39;D8&#39;, &#39;D9&#39;, &#39;D10&#39;, &#39;D11&#39;]&#125;,</span><br><span class="line">   ...:                     index&#x3D;[8, 9, 10, 11])</span><br><span class="line">   ...: </span><br><span class="line"> </span><br><span class="line">In [4]: frames &#x3D; [df1, df2, df3]</span><br><span class="line"> </span><br><span class="line">In [5]: result &#x3D; pd.concat(frames)</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204071032.png" alt="20210204071032"></p>
</div>

<p>KEY 参数:</p>
<p><code>result = pd.concat(frames, keys=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204071126.png" alt="20210204071126"></p>
</div>

<p>JOIN 参数:</p>
<p>默认 join = ‘outer’, 为取并集的关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [8]: df4 &#x3D; pd.DataFrame(&#123;&#39;B&#39;: [&#39;B2&#39;, &#39;B3&#39;, &#39;B6&#39;, &#39;B7&#39;],</span><br><span class="line">   ...:                  &#39;D&#39;: [&#39;D2&#39;, &#39;D3&#39;, &#39;D6&#39;, &#39;D7&#39;],</span><br><span class="line">   ...:                  &#39;F&#39;: [&#39;F2&#39;, &#39;F3&#39;, &#39;F6&#39;, &#39;F7&#39;]&#125;,</span><br><span class="line">   ...:                 index&#x3D;[2, 3, 6, 7])</span><br><span class="line">   ...: </span><br><span class="line"> </span><br><span class="line">In [9]: result &#x3D; pd.concat([df1, df4], axis&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204071210.png" alt="20210204071210"></p>
</div>

<p>当设置 join = ‘inner’，则说明为取交集</p>
<p><code>In [10]: result = pd.concat([df1, df4], axis=1, join=&#39;inner&#39;)</code></p>
<p>结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204071315.png" alt="20210204071315"></p>
</div>

<p>如果索引想从原始 DataFrame 重用确切索引：</p>
<p><code>In [11]: result = pd.concat([df1, df4], axis=1, join_axes=[df1.index]) #设置索引为df1的索引</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204071446.png" alt="20210204071446"></p>
</div>

<h3 id="一、concat：沿着一条轴，将多个对象堆叠到一起"><a href="#一、concat：沿着一条轴，将多个对象堆叠到一起" class="headerlink" title="一、concat：沿着一条轴，将多个对象堆叠到一起"></a>一、concat：沿着一条轴，将多个对象堆叠到一起</h3><p>concat 方法相当于数据库中的全连接（union all），它不仅可以指定连接的方式（outer join 或 inner join）还可以指定按照某个轴进行连接。与数据库不同的是，它不会去重，但是可以使用 drop_duplicates 方法达到去重的效果。</p>
<h3 id="二、merge：通过键拼接列"><a href="#二、merge：通过键拼接列" class="headerlink" title="二、merge：通过键拼接列"></a>二、merge：通过键拼接列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类似于关系型数据库的连接方式，可以根据一个或多个键将不同的DatFrame连接起来。该函数的典型应用场景是，针对同一个主键存在两张不同字段的表，根据主键整合到一张表里面。</span><br></pre></td></tr></table></figure>
<h3 id="三、join：主要用于索引上的合并"><a href="#三、join：主要用于索引上的合并" class="headerlink" title="三、join：主要用于索引上的合并"></a>三、join：主要用于索引上的合并</h3><h3 id="四、使用-apply-函数实现-group-by-分组拼接"><a href="#四、使用-apply-函数实现-group-by-分组拼接" class="headerlink" title="四、使用 apply 函数实现 group by 分组拼接"></a>四、使用 apply 函数实现 group by 分组拼接</h3><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204072137.png" alt="20210204072137"></p>
</div>

<p>最后 4 行合并为 1 行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def ab(df):</span><br><span class="line">return&#39;,&#39;.join(df.values)</span><br><span class="line"></span><br><span class="line">df &#x3D; df.groupby([&#39;股票代码&#39;,&#39;股票简称&#39;])[&#39;所属概念&#39;].apply(ab)</span><br><span class="line">df &#x3D; df.reset_index()</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204072207.png" alt="20210204072207"></p>
</div>

<h3 id="python-把几个-DataFrame-合并成一个-DataFrame——merge-append-join-conca"><a href="#python-把几个-DataFrame-合并成一个-DataFrame——merge-append-join-conca" class="headerlink" title="python 把几个 DataFrame 合并成一个 DataFrame——merge,append,join,conca"></a>python 把几个 DataFrame 合并成一个 DataFrame——merge,append,join,conca</h3><p>1、merge</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, how&#x3D;&#39;inner&#39;, on&#x3D;None, left_on&#x3D;None, right_on&#x3D;None,</span><br><span class="line">         left_index&#x3D;False, right_index&#x3D;False, sort&#x3D;True,</span><br><span class="line">         suffixes&#x3D;(&#39;_x&#39;, &#39;_y&#39;), copy&#x3D;True, indicator&#x3D;False)</span><br></pre></td></tr></table></figure>
<ul>
<li>left ︰   对象</li>
<li>right ︰   另一个 对象</li>
<li>on︰   要 加入 的 列   （名称） 。 必须 在 左 、   右 综合 对象 中 找到 。 如果 不 能 通过   left_index   和   right_index   是 假 ， 将 推断   DataFrames   中 的 列 的 交叉点 为 连接 键</li>
<li>left_on ︰   从 左边 的 综合 使用 作为 键 列 。 可以 是 列名 或 数组 的 长度 等于 长度 综合</li>
<li>right_on ︰   从 正确 的 综合 ， 以 用作 键 列 。 可以 是 列名 或 数组 的 长度 等于 长度 综合</li>
<li>left_index ︰  如果为  True ， 则 使用 索引   （行 标签）   从 左 综合 作为 其 联接 键。 在 与 多重   （层次）  的 综合 ， 级别 数 必须 匹配 联接 键 从 右 综合 的 数目<br>r- ight_index ︰   相同 用法 作为 正确 综合   left_index<br>how︰   之一   ‘ 左 ‘， ‘ 右 ‘， ‘ 外在 ‘、   ‘ 内部 ‘。 默认 为 内部 。 每个 方法 的 更 详细 说明 请 参阅 ︰</li>
<li>sort︰   综合 通过 联接 键 按 字典 顺序 对 结果 进行排序 。 默认值 为   True ， 设置 为   False 将 提高 性能 极大地 在 许多 情况下</li>
<li>suffixes︰   字符串 后缀 并 不适 用于 重叠 列 的 元组 。 默认值 为   (‘_x’， ‘_y’)。</li>
<li>copy︰   即使 重新索引 是 不 必要 总是 从 传递 的 综合 对象 ， 复制 的 数据   （默认值 True） 。 在 许多 情况下 不能 避免 ， 但 可能会 提高 性能   /   内存 使用情况 。 可以 避免 复制 上述 案件 有些 病理 但 尽管如此 提供 此 选项 。</li>
<li>indicator︰  将 列 添加 到 输出 综合 呼吁   _merge   与 信息 源 的 每 一行 。 _merge   是 绝对类型 ， 并 对 观测 其 合并 键 只 出现 在   ‘ 左’  的 综合 ， 观测 其 合并 键 只 会出现 在   ‘ 正确’  的 综合 ， 和 两个 如果 观察 合并 关键 发现 在 两个   right_only   left_only  的 值 。</li>
</ul>
<p><code>result = pd.merge(left, right, on=&#39;key&#39;)</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204072600.png" alt="20210204072600"></p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; pd.merge(left, right, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])</span><br><span class="line"></span><br><span class="line">result &#x3D; pd.merge(left, right, how&#x3D;&#39;left&#39;, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])</span><br><span class="line"></span><br><span class="line">result &#x3D; pd.merge(left, right, how&#x3D;&#39;right&#39;, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])</span><br><span class="line"></span><br><span class="line">result &#x3D; pd.merge(left, right, how&#x3D;&#39;outer&#39;, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])</span><br></pre></td></tr></table></figure>
<p>2、append</p>
<p><code>result = df1.append(df2)</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204072716.png" alt="20210204072716"></p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; df1.append(df4)</span><br><span class="line"></span><br><span class="line">result &#x3D; df1.append([df2, df3])</span><br><span class="line"></span><br><span class="line">result &#x3D; df1.append(df4, ignore_index&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>4、join</p>
<p><code>left.join(right, on=key_or_keys)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, left_on&#x3D;key_or_keys, right_index&#x3D;True,</span><br><span class="line">      how&#x3D;&#39;left&#39;, sort&#x3D;False)</span><br></pre></td></tr></table></figure>
<p><code>1.result = left.join(right, on=&#39;key&#39;)</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204072925.png" alt="20210204072925"></p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.result &#x3D; left.join(right, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])</span><br><span class="line"></span><br><span class="line">3.result &#x3D; left.join(right, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;], how&#x3D;&#39;inner&#39;)</span><br></pre></td></tr></table></figure>
<p>4、concat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.concat(objs, axis&#x3D;0, join&#x3D;&#39;outer&#39;, join_axes&#x3D;None, ignore_index&#x3D;False,</span><br><span class="line">          keys&#x3D;None, levels&#x3D;None, names&#x3D;None, verify_integrity&#x3D;False,</span><br><span class="line">          copy&#x3D;True)</span><br></pre></td></tr></table></figure>
<ul>
<li>objs︰   一个 序列 或 系列 、   综合 或 面板 对象 的 映射 。 如果 字典 中 传递 ， 将 作为 键 参数 ， 使用 排序 的 键 ， 除非 它 传递 ， 在 这 种情况下 的 值 将 会 选择   （见 下文）。 任何 没有任何 反对 将 默默地 被 丢弃 ， 除非 他们 都 没有 在 这 种情况下 将 引发   ValueError 。</li>
<li>axis:   {0， 1， …}， 默认值 为 0。 要 连接 沿 轴 。</li>
<li>join :   {‘ 内部 ‘、   ‘ 外 ‘}， 默认   ‘ 外 ‘。 如何 处理 其他   axis(es)   上 的 索引 。 联盟 内 、   外 的 交叉口 。</li>
<li>ignore_index ︰   布尔值 、   默认   False 。 如果 为  True ， 则 不要 串联 轴 上 使用 的 索引 值 。 由此产生 的 轴 将 标记   0， … ， n - 1。 这 是 有用 的 如果 你 串联 串联 轴 没有 有意义 的 索引 信息 的 对象 。 请注意 在 联接 中 仍然 受到尊重 的 其他 轴 上 的 索引 值 。</li>
<li>join_axes ︰   索引 对象 的 列表 。 具体 的 指标 ， 用于 其他   n - 1   轴 而不是 执行 内部 / 外部 设置 逻辑 。</li>
<li>keys ︰   序列 ， 默认 为 无 。 构建 分层 索引 使用 通过 的 键 作为 最 外面 的 级别 。 如果 多个 级别 获得通过 ， 应 包含 元组 。</li>
<li>levels ︰   列表 的 序列 ， 默认 为 无 。 具体 水平   （唯一 值）   用于 构建 多重 。 否则 ， 他们 将 推断 钥匙 。</li>
<li>names ︰   列表中 ， 默认 为 无 。 由此产生 的 分层 索引 中 的 级 的 名称 。</li>
<li>verify_integrity ︰   布尔值 、   默认   False 。 检查 是否 新 的 串联 的 轴 包含 重复项 。 这 可以 是 相对于 实际 数据 串联 非常 昂贵 。<br>副本 ︰   布尔值 、   默认   True 。 如果 为  False ， 请 不要 ， 不必要地 复制 数据 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.frames &#x3D; [df1, df2, df3]</span><br><span class="line"></span><br><span class="line">2.result &#x3D; pd.concat(frames)</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204073202.png" alt="20210204073202"></p>
</div>

<p><code>3.result = pd.concat(frames, keys=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</code></p>
<p><code>4.result.ix[&#39;y&#39;]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    A   B   C   D</span><br><span class="line">4  A4  B4  C4  D4</span><br><span class="line">5  A5  B5  C5  D5</span><br><span class="line">6  A6  B6  C6  D6</span><br><span class="line">7  A7  B7  C7  D7</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5.result &#x3D; pd.concat([df1, df4], axis&#x3D;1)</span><br><span class="line"></span><br><span class="line">6.result &#x3D; pd.concat([df1, df4], axis&#x3D;1, join&#x3D;&#39;inner&#39;)</span><br><span class="line"></span><br><span class="line">7.result &#x3D; pd.concat([df1, df4], axis&#x3D;1, join_axes&#x3D;[df1.index])</span><br><span class="line"></span><br><span class="line">8.result &#x3D; pd.concat([df1, df4], ignore_index&#x3D;True)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas筛选的具体应用</title>
    <url>/2021/02/04/Pandas%E7%AD%9B%E9%80%89%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>stu.xlsx表里的数据如下：</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205120704.png" alt="20210205120704"></p>
</div >

<p>筛选出语文成绩在90以上,且数学成绩在80-120分之间的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stu1&#x3D;st.loc[st.语文.apply(lambda x:x&gt;&#x3D;90)].loc[st.数学.apply(lambda y:80&lt;&#x3D;y&lt;&#x3D;120)]</span><br><span class="line">stu1</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205120917.png" alt="20210205120917"></p>
</div>

<p>筛选出语文成绩在90以上,且数学成绩在80-120分之间的，英语成绩在60分以上的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stu2&#x3D;st.loc[st.语文.apply(lambda x:x&gt;&#x3D;90)].loc[st.数学.apply(lambda y:80&lt;&#x3D;y&lt;&#x3D;120)].loc[st.英语.apply(lambda z:z&gt;60)]</span><br><span class="line">stu2</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205121131.png" alt="20210205121131"></p>
</div>

<p>另一种方式是用函数来筛选，如筛选出英语成绩在90分以上的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def score_60(c):</span><br><span class="line">    return c&gt;90</span><br><span class="line">stu3&#x3D;st.loc[st.英语.apply(score_60)]</span><br><span class="line">stu3</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205121323.png" alt="20210205121323"></p>
</div>

<h3 id="Pandas-两表联合（类似-excel-的-vlookup-操作）"><a href="#Pandas-两表联合（类似-excel-的-vlookup-操作）" class="headerlink" title="Pandas_两表联合（类似 excel 的 vlookup 操作）"></a>Pandas_两表联合（类似 excel 的 vlookup 操作）</h3><p><a href="https://www.cnblogs.com/wodexk/p/10803979.html">转自</a></p>
<p>student 表：</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205121731.png" alt="20210205121731"></p>
</div>

<p>score 表：</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205121826.png" alt="20210205121826"></p>
</div>

<h4 id="要求从-students-表里查出每个学生对应的成绩"><a href="#要求从-students-表里查出每个学生对应的成绩" class="headerlink" title="要求从 students 表里查出每个学生对应的成绩"></a>要求从 students 表里查出每个学生对应的成绩</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">students &#x3D; pd.read_excel(&quot;..&#x2F;016&#x2F;Student_Score.xlsx&quot;,sheet_name&#x3D;&quot;Students&quot;)</span><br><span class="line">scores &#x3D; pd.read_excel(&quot;..&#x2F;016&#x2F;Student_Score.xlsx&quot;,sheet_name&#x3D;&quot;Scores&quot;)</span><br><span class="line">print(students.dtypes)</span><br><span class="line">print(scores.dtypes)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 思路：将学生表和成绩表联合起来，即可查到每个学生对应的成绩，关联的列时ID列</span><br><span class="line"># tables &#x3D; students.merge(scores)    # 如果不设置连接的方式，则默认时内连接</span><br><span class="line"></span><br><span class="line"># 要求把学生表的所有学生都显示出来，包括那些没有成绩的学生:用左连接 how&#x3D;&quot;left&quot;</span><br><span class="line">tables &#x3D; students.merge(scores,how&#x3D;&quot;left&quot;,on&#x3D;&quot;ID&quot;)</span><br><span class="line"></span><br><span class="line"># 把没有匹配到的NaN 改为 0</span><br><span class="line"># tables &#x3D; students.merge(scores,how&#x3D;&quot;left&quot;,on&#x3D;&quot;ID&quot;).fillna(&quot;--&quot;)</span><br><span class="line">tables &#x3D; students.merge(scores,how&#x3D;&quot;left&quot;,on&#x3D;&quot;ID&quot;).fillna(0)</span><br><span class="line"></span><br><span class="line"># 将成绩列的浮点类型改为整数型</span><br><span class="line">tables &#x3D; students.merge(scores,how&#x3D;&quot;left&quot;,on&#x3D;&quot;ID&quot;).fillna(0)</span><br><span class="line">tables.Score &#x3D; tables.Score.astype(int)</span><br><span class="line"></span><br><span class="line">print(tables)</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122009.png" alt="20210205122009"></p>
</div>

<h3 id="Pandas-对某列的内容分列"><a href="#Pandas-对某列的内容分列" class="headerlink" title="Pandas_对某列的内容分列"></a>Pandas_对某列的内容分列</h3><p>Employees 表：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122142.png" alt="20210205122142"></p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">employees &#x3D; pd.read_excel(&quot;..&#x2F;018&#x2F;Employees.xlsx&quot;,index_col&#x3D;&quot;ID&quot;)</span><br><span class="line">employees .head()</span><br></pre></td></tr></table></figure>
<h4 id="对-Full-Name-进行切割分列："><a href="#对-Full-Name-进行切割分列：" class="headerlink" title="对 Full Name 进行切割分列："></a>对 Full Name 进行切割分列：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df &#x3D; employees[&quot;Full Name&quot;].str.split()  # str.split()不写参数，会把分隔的内容放在一个列表里</span><br><span class="line"># df</span><br><span class="line"></span><br><span class="line">df &#x3D; employees[&quot;Full Name&quot;].str.split(expand&#x3D;True)  # expand&#x3D;True  可以把用分割的内容直接分列</span><br><span class="line">employees[&quot;FirstName&quot;]&#x3D;df[0]</span><br><span class="line">employees[&quot;LastName&quot;]&#x3D;df[1]</span><br><span class="line">print(employees)</span><br></pre></td></tr></table></figure>
<p>部分结果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122250.png" alt="20210205122250"></p>
</div>

<h4 id="把分隔后的-FistName-都变成大写"><a href="#把分隔后的-FistName-都变成大写" class="headerlink" title="把分隔后的 FistName 都变成大写"></a>把分隔后的 FistName 都变成大写</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">employees[&quot;FirstName&quot;]&#x3D;employees[&quot;FirstName&quot;].str.upper()</span><br><span class="line">print(employees)</span><br></pre></td></tr></table></figure>
<p>结果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122330.png" alt="20210205122330"></p>
</div>

<h4 id="把分隔的-LastName-都变成小写"><a href="#把分隔的-LastName-都变成小写" class="headerlink" title="把分隔的 LastName 都变成小写"></a>把分隔的 LastName 都变成小写</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">employees[&quot;LastName&quot;]&#x3D;employees[&quot;LastName&quot;].str.lower()</span><br><span class="line">print(employees)</span><br></pre></td></tr></table></figure>
<p>结果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122404.png" alt="20210205122404"></p>
</div>

<h4 id="Series-str-spilt："><a href="#Series-str-spilt：" class="headerlink" title="Series.str.spilt："></a>Series.str.spilt：</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122456.png" alt="20210205122456"></p>
</div>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas设置单元格条件格式</title>
    <url>/2021/02/05/Pandas%E8%AE%BE%E7%BD%AE%E5%8D%95%E5%85%83%E6%A0%BC%E6%9D%A1%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Pandas-设置单元格条件格式-1——-指定值字体变色、指定值设置背景色"><a href="#Pandas-设置单元格条件格式-1——-指定值字体变色、指定值设置背景色" class="headerlink" title="Pandas_设置单元格条件格式 1—— 指定值字体变色、指定值设置背景色"></a>Pandas_设置单元格条件格式 1—— 指定值字体变色、指定值设置背景色</h2><p><a href="https://www.cnblogs.com/wodexk/p/10801344.html">转载于</a></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd  </span><br><span class="line">df &#x3D; pd.read_excel(&#39;..&#x2F;数据&#x2F;测试数据成绩.xls&#39;)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205125354.png" alt="20210205125354"></p>
</div>

<h4 id="一、用-def-函数对三科目低于60分的成绩标识红色字体"><a href="#一、用-def-函数对三科目低于60分的成绩标识红色字体" class="headerlink" title="一、用 def 函数对三科目低于60分的成绩标识红色字体"></a>一、用 def 函数对三科目低于60分的成绩标识红色字体</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def low_score_red(s):</span><br><span class="line">    color &#x3D; &#39;red&#39; if s&lt;60 else &#39;black&#39;</span><br><span class="line">    return f&#39;color:&#123;color&#125;&#39;</span><br></pre></td></tr></table></figure>
<h4 id="二、用-def-函数对每科最高分标记背景色为绿色"><a href="#二、用-def-函数对每科最高分标记背景色为绿色" class="headerlink" title="二、用 def 函数对每科最高分标记背景色为绿色"></a>二、用 def 函数对每科最高分标记背景色为绿色</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def highest_score_green(col):</span><br><span class="line">    return [&#39;background-color:lime&#39; if s&#x3D;&#x3D;col.max() else &#39;background-color:white&#39; for s in col]</span><br></pre></td></tr></table></figure>
<p>引用 def_low_score_red(s) 函数，让分数低于60分的字体变红</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df.style.applymap(low_score_red,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br><span class="line"># df.style.apply(highest_score_green,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205125737.png" alt="20210205125737"></p>
</div>

<p>引用 highest_score_green(col) 函数，让分数低于90分的单元格背景变绿</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.style.apply(highest_score_green,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br></pre></td></tr></table></figure>
<p>部分结果图:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205132448.png" alt="20210205132448"></p>
</div>

<p>同时引用两个 def 函数，让分数低于60分的字体变红，每个科目最高分背景为绿色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.applymap:是对subset所有列的值一起操作</span><br><span class="line">.apply:是对subset里的每一列的值操作</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.style.applymap(low_score_red,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])\</span><br><span class="line">.apply(highest_score_green,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br></pre></td></tr></table></figure>
<p>部分结果图:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205130602.png" alt="20210205130602"></p>
</div>

<h2 id="Pandas-设置单元格条件格式-2——-迷你条形图、用颜色深浅表示值大小"><a href="#Pandas-设置单元格条件格式-2——-迷你条形图、用颜色深浅表示值大小" class="headerlink" title="Pandas_设置单元格条件格式 2—— 迷你条形图、用颜色深浅表示值大小"></a>Pandas_设置单元格条件格式 2—— 迷你条形图、用颜色深浅表示值大小</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd  </span><br><span class="line">df &#x3D; pd.read_excel(&#39;..&#x2F;数据&#x2F;测试数据成绩.xls&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="对每一列的值设置迷你条形图来表示数值的大小"><a href="#对每一列的值设置迷你条形图来表示数值的大小" class="headerlink" title="对每一列的值设置迷你条形图来表示数值的大小"></a>对每一列的值设置迷你条形图来表示数值的大小</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .style.bar （颜色，作用的数值区）</span><br><span class="line">df.style.bar(color&#x3D;&#39;skyblue&#39;,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br></pre></td></tr></table></figure>
<h4 id="用颜色深浅来表示数值的大小，值趣大颜色越深"><a href="#用颜色深浅来表示数值的大小，值趣大颜色越深" class="headerlink" title="用颜色深浅来表示数值的大小，值趣大颜色越深"></a>用颜色深浅来表示数值的大小，值趣大颜色越深</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 需要引入seahorn的调色板:light_palette</span><br><span class="line">import seaborn as sns</span><br><span class="line"></span><br><span class="line"># sns.light_palette:调色板，里面的参数分别是要填充的颜色</span><br><span class="line">color_map &#x3D;  sns.light_palette(&#39;green&#39;,as_cmap&#x3D;True)</span><br><span class="line"># .background_gradient()  表示填充subset参数里所有值的背景色（按列云识别大小填充）</span><br><span class="line">df.style.background_gradient(color_map,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br></pre></td></tr></table></figure>
<p>部分结果图:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205132224.png" alt="20210205132224"></p>
</div>

]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas读取Excel文件时如何指定数据类型</title>
    <url>/2021/03/06/Pandas%E8%AF%BB%E5%8F%96Excel%E6%96%87%E4%BB%B6%E6%97%B6%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="只需指定转换器"><a href="#只需指定转换器" class="headerlink" title="只需指定转换器"></a>只需指定转换器</h3><p>“年龄”列的格式设置为字符串。 装载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.read_excel(&#39;Book1.xlsx&#39;,sheetname&#x3D;&#39;Sheet1&#39;,header&#x3D;0,converters&#x3D;&#123;&#39;names&#39;:str,&#39;ages&#39;:str&#125;)</span><br><span class="line">df</span><br><span class="line">       names ages</span><br><span class="line">   0   bob   05</span><br><span class="line">   1   tom   4</span><br><span class="line">   2   suzy  3</span><br></pre></td></tr></table></figure>
<p>从 keys 开始，keys 函数中的 values 关键字参数可用于指定需要应用于列的数据类型，就像 keys 案例中存在的那样。</p>
<p>在相同的列名称上一起使用 keys 和 values 和参数会导致后者变得模糊不清，而前者获得优先。</p>
<p>1）为了使其不解释 keys，而是传递其原来在文件中之前的所有列内容，我们可以将此 arg 设置为 2970247651138208208 或 dtype，以免混淆数据。 （其中一种情况是数字的前导零，否则将丢失）</p>
<p><code>pd.read_excel(&#39;file_name.xlsx&#39;, dtype=str) # (or) dtype=object</code></p>
<p>2）它甚至支持 dict 映射，其中 keys 构成列名，values 分别设置数据类型，尤其是当您要更改 dtype 所有列的子集时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Assuming data types for &#96;a&#96; and &#96;b&#96; columns to be altered</span><br><span class="line">pd.read_excel(&#39;file_name.xlsx&#39;, dtype&#x3D;&#123;&#39;a&#39;: np.float64, &#39;b&#39;: np.int32&#125;)</span><br></pre></td></tr></table></figure>
<p>read_excel（）函数具有 converters 参数，您可以在其中将函数应用于某些列中的输入。 您可以使用它来将它们保留为字符串。说明文件：</p>
<p>用于转换某些列中的值的函数的字典。 键可以是整数或列标签，值是具有一个输入参数，Excel 单元格内容并返回转换后的内容的函数。</p>
<p>示例代码：</p>
<p><code>pandas.read_excel(my_file, converters = &#123;my_str_column: str&#125;)</code></p>
<p>如果您不知道数据框中的列数和名称，则可以使用此方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">column_list &#x3D; []</span><br><span class="line">df_column &#x3D; pd.read_excel(file_name, &#39;Sheet1&#39;).columns</span><br><span class="line">for i in df_column:</span><br><span class="line">    column_list.append(i)</span><br><span class="line">converter &#x3D; &#123;col: str for col in column_list&#125;</span><br><span class="line">df_actual &#x3D; pd.read_excel(file_name, converters&#x3D;converter)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 column_list 是您的列名的列表。</p>
<p>如果您不知道列名，并且想为所有列指定 str 数据类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table &#x3D; pd.read_excel(&quot;path_to_filename&quot;)</span><br><span class="line">cols &#x3D; table.columns</span><br><span class="line">conv &#x3D; dict(zip(cols ,[str] * len(cols)))</span><br><span class="line">table &#x3D; pd.read_excel(&quot;path_to_filename&quot;, converters&#x3D;conv)</span><br></pre></td></tr></table></figure>
<p>如果密钥的位数固定，则可能应将其存储为文本而不是数字数据。 您可以为此使用 converters 参数或 read_excel。</p>
<p>或者，如果这不起作用，则在将数据读入数据框后对其进行操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df[&#39;key_zfill&#39;] &#x3D; df[&#39;key&#39;].astype(str).str.zfill(4)</span><br><span class="line"></span><br><span class="line">  names   key key_zfill</span><br><span class="line">0   abc     5      0005</span><br><span class="line">1   def  4962      4962</span><br><span class="line">2   ghi   300      0300</span><br><span class="line">3   jkl    14      0014</span><br><span class="line">4   mno    20      0020</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>pip第三方库备份与恢复</title>
    <url>/2021/02/17/Pip%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p><code>pip list //查看当前环境中安装的库</code></p>
<h3 id="导出当前环境-pip-安装的包表"><a href="#导出当前环境-pip-安装的包表" class="headerlink" title="导出当前环境 pip 安装的包表"></a>导出当前环境 pip 安装的包表</h3><p><code>pip freeze &gt; requirements.txt</code></p>
<p>导出的路径为:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217114531.png" alt="20210217114531"></p>
</div>

<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217114951.png" alt="20210217114951"></p>
</div>

<h3 id="根据导出的-pip-安装包表安装-pip-包"><a href="#根据导出的-pip-安装包表安装-pip-包" class="headerlink" title="根据导出的 pip 安装包表安装 pip 包"></a>根据导出的 pip 安装包表安装 pip 包</h3><p><code>pip install -r requirements.txt</code></p>
<p>在进行恢复前，先修改 pip 安装源为国内源，之后进行安装时速度会快很多，键入命令后等待一会即可完成安装。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-pip配置国内镜像源</title>
    <url>/2021/02/02/Python-pip%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<h3 id="推荐的国内镜像站"><a href="#推荐的国内镜像站" class="headerlink" title="推荐的国内镜像站"></a>推荐的国内镜像站</h3><blockquote>
<p>个人推荐清华大学 pypi 镜像站 (<a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/)%EF%BC%8C%E6%AF%8F%E4%BA%94%E5%88%86%E9%92%9F%E5%90%8C%E6%AD%A5%E4%B8%80%E6%AC%A1%EF%BC%8C%E8%B5%84%E6%BA%90%E4%B8%B0%E5%AF%8C%EF%BC%8C%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%BE%88%E5%BF%AB">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/)，每五分钟同步一次，资源丰富，下载速度很快</a><br>清华大学：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p>
</blockquote>
<h3 id="临时使用国内镜像源进行-pip-安装"><a href="#临时使用国内镜像源进行-pip-安装" class="headerlink" title="临时使用国内镜像源进行 pip 安装"></a>临时使用国内镜像源进行 pip 安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; numpy</span><br><span class="line"># 如果上一个提示不受信任，就使用这个，此参数“--trusted-host”表示信任</span><br><span class="line">pip install -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;--trusted-host pypi.douban.com  </span><br></pre></td></tr></table></figure>
<h3 id="永久使用国内镜像源进行-pip-安装"><a href="#永久使用国内镜像源进行-pip-安装" class="headerlink" title="永久使用国内镜像源进行 pip 安装"></a>永久使用国内镜像源进行 pip 安装</h3><p>1.进入相应目录下 C 盘 -&gt;Users / 用户 -&gt;xxx-&gt; 新建 pip 文件夹</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210202102603.png" alt="20210202102603"></p>
</div>

<p>2.进入 pip 文件夹 -&gt; 新建 pip.ini 文件</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210202103008.png" alt="20210202103008"></p>
</div>

<p>3.进入 pip.ini 文件，并添加配置如下：（清华源）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn  # trusted-host 此参数是为了避免麻烦，否则使用的时候可能会提示不受信任</span><br></pre></td></tr></table></figure>
<p>4.修改完成后保存，启动 cmd，使用 “pip install xxx”(xxx 为你要下载的包名)，即可默认使用国内源下载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#我下载的是python的numpy函数库</span><br><span class="line">  pip install numpy</span><br><span class="line">&#x3D;&#x3D;》报错解决</span><br><span class="line">#此命令有可能报错：文件拒绝访问，需要以管理员权限运行cmd窗口</span><br><span class="line">#或者下载失败，可能是被他人挤占导致失败，可以再次输入命令重试即可</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210202103312.png" alt="20210202103312"></p>
</div>]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Python三天打鱼两天晒网_完美版</title>
    <url>/2021/03/21/Python%E4%B8%89%E5%A4%A9%E6%89%93%E9%B1%BC%E4%B8%A4%E5%A4%A9%E6%99%92%E7%BD%91-%E5%AE%8C%E7%BE%8E%E7%89%88/</url>
    <content><![CDATA[<p>三天打鱼两天晒网</p>
<p>问题描述：中国有句俗语叫“三天打鱼两天晒网”。某人从 2010 年 1 月 1 日起开始“三天打鱼两天晒网”，问这个人在以后的某一天中是“打鱼”还是“晒网”。</p>
<p>输入：键盘输入数据或者文件输入测试数据</p>
<p>输出：判断的结果</p>
<p>要求：输入日期的正确性验证，文件测试数据</p>
<p>解题思路：核心思路就是得到给定的日期和给定的最开始的日期之间相隔的天数，然后以天数除以 5，得到余数，通过判断余数是大于 3 还是小于三，大于三则是晒网，小于三则是打鱼。(python)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># date input with the keyboard</span><br><span class="line">def get_days(date_input):</span><br><span class="line">    # get the days</span><br><span class="line">    date_base &#x3D; &#39;2010-01-01&#39;</span><br><span class="line">    # date_input &#x3D; input(&#39;please input the date you want to test with the form xxxx-xx-xx:&#39;)</span><br><span class="line">    # check its form and work out the answer</span><br><span class="line">    date_input &#x3D; datetime.strptime(date_input, &#39;%Y-%m-%d&#39;)</span><br><span class="line">    date_base &#x3D; datetime.strptime(date_base, &#39;%Y-%m-%d&#39;)</span><br><span class="line">    date_days &#x3D; (date_input - date_base).days</span><br><span class="line">    return date_days</span><br><span class="line"></span><br><span class="line"># to work out the result into the file out.txt</span><br><span class="line">def work_result(date_days,date_input):</span><br><span class="line">    mod_day &#x3D; date_days % 5</span><br><span class="line">    # date_input &#x3D; datetime.strptime(date_input, &#39;%Y-%m-%d&#39;)</span><br><span class="line">    with open(&#39;out.txt&#39;, &#39;a&#39;) as file_out:</span><br><span class="line">        if mod_day &lt;&#x3D; 3:</span><br><span class="line">            file_out.write(date_input + &#39;  fishing\n&#39;)</span><br><span class="line">            print(date_input + &#39;  fishing&#39;)</span><br><span class="line">        else:</span><br><span class="line">            file_out.write(date_input + &#39;  webbing\n&#39;)</span><br><span class="line">            print(date_input + &#39;  webbing&#39;)</span><br><span class="line">    file_out.close()</span><br><span class="line"></span><br><span class="line"># test the aoolication with file date</span><br><span class="line">def file_date_test():</span><br><span class="line">    print(&#39;the following is file test&#39;)</span><br><span class="line">    with open(&#39;in.txt&#39;) as file:</span><br><span class="line">        context_line &#x3D; file.readline()</span><br><span class="line">        while context_line:</span><br><span class="line">            # remove the  character &#39;\n&#39;</span><br><span class="line">            context_line &#x3D; context_line.rstrip(&#39;\n&#39;)</span><br><span class="line">            # get the days</span><br><span class="line">            days_in_file &#x3D; get_days(context_line)</span><br><span class="line">            # work out into the file out.txt</span><br><span class="line">            work_result(days_in_file,context_line)</span><br><span class="line">            context_line &#x3D; file.readline()</span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line"># check the date</span><br><span class="line">def isVaildDate(date):</span><br><span class="line">    try:</span><br><span class="line">        time.strptime(date, &quot;%Y-%m-%d&quot;)</span><br><span class="line">        return True</span><br><span class="line">    except:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    date_input &#x3D; input(&#39;please input the date you want to test with the form xxxx-xx-xx:&#39;)</span><br><span class="line">    while not isVaildDate(date_input):</span><br><span class="line">        date_input &#x3D;input(&#39;date is illegal,please check and input it again:&#39;)</span><br><span class="line"></span><br><span class="line">    # expand ths test file use the input</span><br><span class="line">    with open(&#39;in.txt&#39;, &#39;a&#39;) as file_input:</span><br><span class="line">        size &#x3D; os.path.getsize(&#39;in.txt&#39;)</span><br><span class="line">        if size&#x3D;&#x3D;0:</span><br><span class="line">            file_input.write(date_input)</span><br><span class="line">        else:</span><br><span class="line">            file_input.write(&#39;\n&#39;+ date_input)</span><br><span class="line">    file_input.close()</span><br><span class="line"></span><br><span class="line">    # test the application</span><br><span class="line">    date_days &#x3D; get_days(date_input)</span><br><span class="line">    work_result(date_days,date_input)</span><br><span class="line">    # test the file input and output</span><br><span class="line">    file_date_test()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的几种数据类型</title>
    <url>/2021/02/06/Python%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>大体上把 Python 中的数据类型分为如下几类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number（数字）                  包括 int,long,float,complex   </span><br><span class="line">String（字符串）                例如：hello,&quot;hello&quot;,hello   </span><br><span class="line">Bool（布尔）                    包括 True、False   </span><br></pre></td></tr></table></figure>
<p>Python 中的数据结构分为如下几类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List（列表）                    例如：[1,2,3],[1,2,3,[1,2,3],4]   </span><br><span class="line">Dictionary（字典）              例如：&#123;1:&quot;nihao&quot;,2:&quot;hello&quot;&#125;   </span><br><span class="line">Tuple（元组）                   例如：(1,2,3,abc) </span><br><span class="line">set （集合）</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>由于 Python 中认为所有的东西都是对象，所以 Python 不用像其它一些高级语言那样主动声明一个变量的类型。</p>
<p>例如我要给一个变量 i 赋值 100，python 的实现 ：</p>
<p><code>i=100</code>  </p>
<p>C# 的实现：</p>
<p><code>int i = 100;</code>  </p>
<p>下面一一简单介绍这几种数据类型</p>
<p>数字类型</p>
<p>int 和 long</p>
<p>之所以要把 int 和 long 放在一起的原因是 python3.x 之后已经不区分 int 和 long, 统一用 int。python2.x 还是区分的。下面我以 Python2.7 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;i &#x3D; 10  </span><br><span class="line">t&gt;&gt;&gt;ype(i)  </span><br><span class="line">&lt;type &#39;int&#39;&gt;  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt;i&#x3D;10000000000  </span><br><span class="line">&gt;&gt;&gt;type(i)  </span><br><span class="line">&lt;type &#39;long&#39;&gt; </span><br></pre></td></tr></table></figure>
<p>那么为什么 10 就是 int,10000000000 就是 long 呢，当然这就和 int 的最大值有关了，int 类型的最大值为 231-1，即 2147483647，也可以用 sys.maxint。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;2**31-1  </span><br><span class="line">2147483647L  </span><br><span class="line">&gt;&gt;&gt;sys.maxint  </span><br><span class="line">2147483647 </span><br></pre></td></tr></table></figure>
<p>为什么用上面的方法求的值就是 long 型的呢（数字后面加‘L’表示是 long 型），因为 2**31 的值为 2147483648, 这个值是一个 long 型，用一个 long 型减去 1，结果还是一个 long, 但实际上 int 型的最大值就是 2147483647</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;type(2147483647)  </span><br><span class="line">&lt;type &#39;int&#39;&gt;  </span><br><span class="line">&gt;&gt;&gt;type(2147483648)  </span><br><span class="line">&lt;type &#39;long&#39;&gt;  </span><br></pre></td></tr></table></figure>
<p>float 类型</p>
<p>float 类型和其它语言的 float 基本一致，浮点数，说白了，就是带小数点的数，精度与机器相关。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;i &#x3D; 10000.1212  </span><br><span class="line">&gt;&gt;&gt;type(i)  </span><br><span class="line">&lt;type &#39;float&#39;&gt;  </span><br></pre></td></tr></table></figure>
<p>complex：复数类型，具体含义及用法可自行查看相关文档。</p>
<p>字符串类型</p>
<p>字符串的声明有三种方式：单引号、双引号和三引号（包括三个单引号或三个双引号）。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;str1 &#x3D; &#39;hello world&#39;  </span><br><span class="line">&gt;&gt;&gt;str2 &#x3D; &quot;hello world&quot;  </span><br><span class="line">&gt;&gt;&gt;str3 &#x3D; &#39;&#39;&#39;hello world&#39;&#39;&#39;  </span><br><span class="line">&gt;&gt;&gt;str4 &#x3D; &quot;&quot;&quot;hello world&quot;&quot;&quot;  </span><br><span class="line">&gt;&gt;&gt;print str1  </span><br><span class="line">hello world  </span><br><span class="line">&gt;&gt;&gt;print str2  </span><br><span class="line">hello world  </span><br><span class="line">&gt;&gt;&gt;print str3  </span><br><span class="line">hello world  </span><br><span class="line">&gt;&gt;&gt;print str4  </span><br><span class="line">hello world </span><br></pre></td></tr></table></figure>
<p>Python 中的字符串有两种数据类型：str 类型和 unicode 类型。str 类型采用的 ASCII 编码，也就是说它无法表示中文。unicode 类型采用 unicode 编码，能够表示任意字符，包括中文及其它语言。并且 python 中不存在像 c 语言中的 char 类型，就算是单个字符也是字符串类型。字符串默认采用的 ASCII 编码，如果要显示声明为 unicode 类型的话，需要在字符串前面加上 ‘u’ 或者 ‘U’。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;str1 &#x3D; &quot;hello&quot;  </span><br><span class="line">&gt;&gt;&gt;print str1  </span><br><span class="line">hello  </span><br><span class="line">&gt;&gt;&gt;str2 &#x3D; u&quot;中国&quot;  </span><br><span class="line">&gt;&gt;&gt;print str2  </span><br><span class="line">中国 </span><br></pre></td></tr></table></figure>
<p>由于项目中经常出现对字符串的操作，而且由于字符串编码问题出现的问题很多，下面，来说一下关于字符串的编码问题。在与 python 打交道的过程中经常会碰到 ASCII、Unicode 和 UTF-8 三种编码。具体的介绍请参见这篇文章。我简单的理解就是，ASCII 编码适用英文字符，Unicode 适用于非英文字符（例如中文、韩文等），而 utf-8 则是一种储存和传送的格式，是对 Uncode 字符的再编码（以 8 位为单位编码）。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u &#x3D; u&#39; 汉&#39;  </span><br><span class="line">print repr(u) # u&#39;\u6c49&#39;  </span><br><span class="line">s &#x3D; u.encode(&#39;UTF-8&#39;)  </span><br><span class="line">print repr(s) # &#39;\xe6\xb1\x89&#39;  </span><br><span class="line">u2 &#x3D; s.decode(&#39;UTF-8&#39;)  </span><br><span class="line">print repr(u2) # u&#39;\u6c49&#39;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">解释：声明 unicode 字符串” 汉 “，它的 unicode 编码为”\u6c49“，经过 utf-8 编码转换后，它的编码变成”\xe6\xb1\x89“。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">对于编码的经验总结：</span><br><span class="line"></span><br><span class="line">1. 在 python 文件头声明编码格式 ；</span><br><span class="line"></span><br><span class="line">&#96;#-*- coding: utf-8 -*- &#96;</span><br><span class="line"></span><br><span class="line">2. 将字符串统一声明为 unicode 类型，即在字符串前加 u 或者 U;</span><br><span class="line"></span><br><span class="line">3. 对于文件读写的操作，建议适用 codecs.open () 代替内置的 open ()，遵循一个原则，用哪种格式写，就用哪种格式读；</span><br><span class="line"></span><br><span class="line">假设在一个以 ANSI 格式保存的文本文件中有 “中国汉字” 几个字，如果直接用以下代码，并且要在 GUI 上或者在一个 IDE 中打印出来（例如在 sublime text 中，或者在 pydev 中打印），就会出现乱码或者异常，因为 codecs 会依据文本本身的编码格式读取内容：</span><br></pre></td></tr></table></figure>
<p>f = codecs.open(“d:/test.txt”)<br>content = f.read()<br>f.close()<br>print content  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">改用如下方法即可（只对中文起作用）：</span><br></pre></td></tr></table></figure>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>import codecs  </p>
<p>f = codecs.open(“d:/test.txt”)<br>content = f.read()<br>f.close()  </p>
<p>if isinstance(content,unicode):<br>    print content.encode(‘utf-8’)<br>    print “utf-8”<br>else:<br>    print content.decode(‘gbk’).encode(‘utf-8’)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">列表类型</span><br><span class="line"></span><br><span class="line">列表是一种可修改的集合类型，其元素可以是数字、string 等基本类型，也可以是列表、元组、字典等集合对象，甚至可以是自定义的类型。其定义方式如下：</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>nums = [1,2,3,4]<br>type(nums)<br>&lt;type ‘list’&gt;<br>print nums<br>[1, 2, 3, 4]<br>strs = [“hello”,”world”]<br>print strs<br>[‘hello’, ‘world’]<br>lst = [1,”hello”,False,nums,strs]<br>type(lst)<br>&lt;type ‘list’&gt;<br>print lst<br>[1, ‘hello’, False, [1, 2, 3, 4], [‘hello’, ‘world’]]  </p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">用索引的方式访问列表元素，索引从 0 开始，支持负数索引，-1 为最后一个.</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>lst = [1,2,3,4,5]<br>print lst[0]<br>1<br>print lst[-1]<br>5<br>print lst[-2]<br>4 </p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">支持分片操作，可访问一个区间内的元素，支持不同的步长，可利用分片进行数据插入与复制操作</span><br></pre></td></tr></table></figure>
<p>nums = [1,2,3,4,5]<br>print nums[0:3]  #[1, 2, 3] # 前三个元素  </p>
<p>print nums[3:]   #[4, 5]    # 后两个元素  </p>
<p>print nums[-3:]  #[3, 4, 5] # 后三个元素 不支持 nums [-3:0]  </p>
<p>numsclone = nums[:]    </p>
<p>print numsclone    #[1, 2, 3, 4, 5]  复制操作  </p>
<p>print nums[0:4:2]   #[1, 3]    步长为 2  </p>
<p>nums[3:3] = [“three”,”four”]   #[1, 2, 3, ‘three’, ‘four’, 4, 5]  在 3 和 4 之间插入  </p>
<p>nums[3:5] = []    #[1, 2, 3, 4, 5] 将第 4 和第 5 个元素替换为 [] 即删除 [“three”,”four”] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">支持加法和乘法操作</span><br></pre></td></tr></table></figure>
<p>lst1 = [“hello”,”world”]<br>lst2 = [‘good’,’time’]<br>print lst1+lst2  #[‘hello’, ‘world’, ‘good’, ‘time’]  </p>
<p>print lst1*5  #[‘hello’, ‘world’, ‘hello’, ‘world’, ‘hello’, ‘world’, ‘hello’, ‘world’, ‘hello’, ‘world’] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">列表所支持的方法，可以用如下方式查看列表支持的公共方法：</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>[x for x in dir([]) if not x.startswith(“__”)]<br>[‘append’, ‘count’, ‘extend’, ‘index’, ‘insert’, ‘pop’, ‘remove’, ‘reverse’, ‘sort’] </p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96; </span><br><span class="line">def compare(x,y):  </span><br><span class="line">    return 1 if x&gt;y else -1  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">#【append】  在列表末尾插入元素  </span><br><span class="line">lst &#x3D; [1,2,3,4,5]  </span><br><span class="line">lst.append(6)   </span><br><span class="line">print lst     #[1, 2, 3, 4, 5, 6]  </span><br><span class="line">lst.append(&quot;hello&quot;)  </span><br><span class="line">print lst     #[1, 2, 3, 4, 5, 6]  </span><br><span class="line">  </span><br><span class="line">#【pop】  删除一个元素，并返回此元素的值 支持索引 默认为最后一个  </span><br><span class="line">x &#x3D; lst.pop()  </span><br><span class="line">print x,lst     #hello [1, 2, 3, 4, 5, 6]  # 默认删除最后一个元素  </span><br><span class="line">x &#x3D; lst.pop(0)  </span><br><span class="line">print x,lst     #1 [2, 3, 4, 5, 6]  删除第一个元素  </span><br><span class="line">  </span><br><span class="line">#【count】  返回一个元素出现的次数  </span><br><span class="line">print lst.count(2)    #1     </span><br><span class="line">  </span><br><span class="line">#【extend】  扩展列表  此方法与 “+” 操作的不同在于此方法改变原有列表，而 “+” 操作会产生一个新列表  </span><br><span class="line">lstextend &#x3D; [&quot;hello&quot;,&quot;world&quot;]  </span><br><span class="line">lst.extend(lstextend)  </span><br><span class="line">print lst           #[2, 3, 4, 5, 6, &#39;hello&#39;, &#39;world&#39;]  在 lst 的基础上扩展了 lstextend 进来   </span><br><span class="line">  </span><br><span class="line">#【index】  返回某个值第一次出现的索引位置，如果未找到会抛出异常  </span><br><span class="line">print lst.index(&quot;hello&quot;)  #5      </span><br><span class="line">  </span><br><span class="line">#print lst.index (&quot;kitty&quot;) #ValueError: &#39;kitty&#39; is not in list  出现异常  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">#【remove】 移除列表中的某个元素，如果待移除的项不存在，会抛出异常  无返回值  </span><br><span class="line">lst.remove(&quot;hello&quot;)  </span><br><span class="line">print lst     #[2, 3, 4, 5, 6, &#39;world&#39;]  &quot;hello&quot; 被移除  </span><br><span class="line">  </span><br><span class="line">#lst.remove(&quot;kitty&quot;)         #ValueError: list.remove(x): x not in list  </span><br><span class="line">  </span><br><span class="line">#【reverse】  意为反转 没错 就是将列表元素倒序排列，无返回值  </span><br><span class="line">print lst        #[2, 3, 4, 5, 6, &#39;world&#39;]  </span><br><span class="line">lst.reverse()   </span><br><span class="line">print lst        #[2, 3, 4, 5, 6, &#39;world&#39;]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">#【sort】 排序  </span><br><span class="line">print lst    #由于上面的反转 目前排序为 [&#39;world&#39;, 6, 5, 4, 3, 2]  </span><br><span class="line">lst.sort()    </span><br><span class="line">print lst    #排序后  [2, 3, 4, 5, 6, &#39;world&#39;]  </span><br><span class="line">  </span><br><span class="line">nums &#x3D; [10,5,4,2,3]  </span><br><span class="line">print nums     #[10,5,4,2,3]  </span><br><span class="line">nums.sort(compare)  </span><br><span class="line">print nums     #[2, 3, 4, 5, 10]  </span><br></pre></td></tr></table></figure>
<p>列表转换为迭代器。</p>
<p>所谓的迭代器就是具有 next 方法（这个方法在调用时不需要任何参数）的对象。在调用 next 方法时，迭代器会返回它的下一个值。如果 next 方法被调用，但迭代器没有值可以返回，就会引发一个 StopIteration 异常。迭代器相对于列表的优势在于，使用迭代器不必一次性将列表加入内存，而可以依次访问列表的数据。</p>
<p>依然用上面的方法查看迭代器的公共方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; [1,2,3,4,5]  </span><br><span class="line">lstiter &#x3D; iter(lst)  </span><br><span class="line">&gt;&gt;&gt;print [x for x in dir(numiter) if not x.startswith(&quot;__&quot;)]  </span><br><span class="line">&#39;next&#39;]  </span><br></pre></td></tr></table></figure>
<p>没错，只有 next 一个方法，对于一个迭代器，可以这样操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; [1,2,3,4,5]  </span><br><span class="line">lstiter &#x3D; iter(lst)  </span><br><span class="line">  </span><br><span class="line">for i in range(len(lst)):  </span><br><span class="line">    print lstiter.next()  #依次打印  </span><br><span class="line">    1  </span><br><span class="line">    2  </span><br><span class="line">    3  </span><br><span class="line">    4  </span><br><span class="line">    5 </span><br></pre></td></tr></table></figure>
<p>元组类型</p>
<p>元组类型和列表一样，也是一种序列，与列表不同的是，元组是不可修改的。元组的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; (0,1,2,2,2)  </span><br><span class="line">lst1&#x3D;(&quot;hello&quot;,)  </span><br><span class="line">lst2 &#x3D; (&quot;hello&quot;)  </span><br><span class="line">print type(lst1)    #&lt;type &#39;tuple&#39;&gt;  只有一个元素的情况下后面要加逗号 否则就是 str 类型  </span><br><span class="line">print type(lst2)    #&lt;type &#39;str&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>字典类型</p>
<p>字典类型是一种键值对的集合，类似于 C# 中的 Dictionary&lt;object,object&gt; 或 js 中的 json 对象。其初始化方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 &#x3D; &#123;&#125;  </span><br><span class="line">print type(dict1)      #&lt;type &#39;dict&#39;&gt;  声明一个空字典  </span><br><span class="line">  </span><br><span class="line">dict2 &#x3D; &#123;&quot;name&quot;:&quot;kitty&quot;,&quot;age&quot;:18&#125;   #直接声明字典类型  </span><br><span class="line">  </span><br><span class="line">dict3 &#x3D; dict([(&quot;name&quot;,&quot;kitty&quot;),(&quot;age&quot;,18)])  #利用 dict 函数将列表转换成字典  </span><br><span class="line">  </span><br><span class="line">dict4 &#x3D; dict(name&#x3D;&#39;kitty&#39;,age&#x3D;18)           #利用 dict 函数通过关键字参数转换为字典  </span><br><span class="line">  </span><br><span class="line">dict5 &#x3D; &#123;&#125;.fromkeys([&quot;name&quot;,&quot;age&quot;])      #利用 fromkeys 函数将 key 值列表生成字典，对应的值为 None   &#123;&#39;age&#39;: None, &#39;name&#39;: None&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字典基本的操作方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#【添加元素】    </span><br><span class="line">dict1 &#x3D; &#123;&#125;  </span><br><span class="line">dict1[&quot;mykey&quot;] &#x3D; &quot;hello world&quot;     #直接给一个不存在的键值对赋值 即时添加新元素  </span><br><span class="line">  </span><br><span class="line">dict1[(&#39;my&#39;,&#39;key&#39;)] &#x3D; &quot;this key is a tuple&quot;   #字典的键可以是任何一中不可变类型，例如数字、字符串、元组等  </span><br><span class="line">  </span><br><span class="line">#【键值对个数】  </span><br><span class="line">print len(dict1)  </span><br><span class="line">  </span><br><span class="line">#【检查是否含有键】  </span><br><span class="line">print &quot;mykey&quot; in dict1         #True  检查是否含有键为 mykey 的键值对  </span><br><span class="line">print &quot;hello&quot; in dict1         #False  </span><br><span class="line">  </span><br><span class="line">#【删除】  </span><br><span class="line">del dict1[&quot;mykey&quot;]           #删除键为 mykey 的键值对  </span><br></pre></td></tr></table></figure>
<p>继续利用上面的方法查看字典的所有公共方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[x for x in dir(&#123;&#125;) if not x.startswith(&quot;__&quot;)]  </span><br><span class="line">[&#39;clear&#39;, &#39;copy&#39;, &#39;fromkeys&#39;, &#39;get&#39;, &#39;has_key&#39;, &#39;items&#39;, &#39;iteritems&#39;, &#39;iterkeys&#39;, &#39;itervalues&#39;,  </span><br><span class="line"> &#39;keys&#39;, &#39;pop&#39;, &#39;popitem&#39;, &#39;setdefault&#39;, &#39;update&#39;, &#39;values&#39;, &#39;viewitems&#39;, &#39;viewkeys&#39;, &#39;viewvalues&#39;] </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict.clear ()                          删除字典中所有元素  </span><br><span class="line">  </span><br><span class="line">dict.copy ()                          返回字典 (浅复制) 的一个副本  </span><br><span class="line">  </span><br><span class="line">dict.get(key,default&#x3D;None)     对字典 dict 中的键 key, 返回它对应的值 value，如果字典中不存在此键，则返回 default 的值 (注意，参数 default 的默认值为 None)  </span><br><span class="line">  </span><br><span class="line">dict.has_key (key)                 如果键 (key) 在字典中存在，返回 True，否则返回 False. 在 Python2.2 版本引入 in 和 not in 后，此方法几乎已废弃不用了，但仍提供一个 可工作的接口。  </span><br><span class="line">  </span><br><span class="line">dict.items ()                         返回一个包含字典中 (键， 值) 对元组的列表  </span><br><span class="line">  </span><br><span class="line">dict.keys ()                          返回一个包含字典中键的列表  </span><br><span class="line">  </span><br><span class="line">dict.values ()                        返回一个包含字典中所有值的列表  </span><br><span class="line">  </span><br><span class="line">dict.iter ()                            方法 iteritems (), iterkeys (), itervalues () 与它们对应的非迭代方法一样，不同的是它们返回一个迭代器，而不是一个列表。  </span><br><span class="line">  </span><br><span class="line">dict.pop (key [, default])         和方法 get () 相似，如果字典中 key 键存在，删除并返回 dict [key]，如果 key 键不存在，且没有给出 default 的值，引发 KeyError 异常。  </span><br><span class="line">  </span><br><span class="line">dict.setdefault(key,default&#x3D;None)  和方法 set () 相似，如果字典中不存在 key 键，由 dict [key]&#x3D;default 为它赋值。  </span><br><span class="line">  </span><br><span class="line">dict.setdefault(key,default&#x3D;None)   和方法 set () 相似，如果字典中不存在 key 键，由 dict [key]&#x3D;default 为它赋值。 </span><br></pre></td></tr></table></figure>
<p>布尔类型</p>
<p>布尔类型即 True 和 False, 和其它语言中的布尔类型基本一致。下面列出典型的布尔值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print bool(0)   #False  </span><br><span class="line">print bool(1)   #True  </span><br><span class="line">print bool(-1)  #True  </span><br><span class="line">  </span><br><span class="line">print bool([])  #False  </span><br><span class="line">print bool(())  #False  </span><br><span class="line">print bool(&#123;&#125;)  #False  </span><br><span class="line">print bool(&#39;&#39;)  #False  </span><br><span class="line">print bool(None) #False  </span><br></pre></td></tr></table></figure>
<h2 id="python-四种数值类型-int-long-float-complex-介绍"><a href="#python-四种数值类型-int-long-float-complex-介绍" class="headerlink" title="python 四种数值类型 (int,long,float,complex) 介绍"></a>python 四种数值类型 (int,long,float,complex) 介绍</h2><p>Python 支持四种不同的数值类型，包括 int（整数）long（长整数）float（浮点实际值）complex （复数）</p>
<p>数字数据类型存储数值。他们是不可改变的数据类型，这意味着改变数字数据类型的结果，在一个新分配的对象的值。</p>
<p>Number 对象被创建，当你给他们指派一个值。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var1 &#x3D; 1</span><br><span class="line">var2 &#x3D; 10</span><br></pre></td></tr></table></figure>
<p>您也可以删除数字对象的参考，使用 del 语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del 语句的语法是：</span><br><span class="line"></span><br><span class="line">del var1[,var2[,var3[....,varN]]]]</span><br></pre></td></tr></table></figure>
<p>你可以使用 del 语句删除单个对象或多个对象。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure>
<h4 id="Python-支持四种不同的数值类型："><a href="#Python-支持四种不同的数值类型：" class="headerlink" title="Python 支持四种不同的数值类型："></a>Python 支持四种不同的数值类型：</h4><ul>
<li><strong>int</strong>（符号整数）：通常被称为是整数或整数，没有小数点的正或负整数。</li>
<li><strong>long</strong>（长整数）：或渴望，无限大小的整数，这样写整数和一个大写或小写的 L。</li>
<li><strong>float</strong>（浮点实际值）：彩车，代表实数，小数除以整数部分和小数部分的书面。花车也可能是在科学记数法与 E 或指示的 10 次方 é（2.5e2= 2.5×102=250）。</li>
<li><strong>complex</strong>  （复数）：+ BJ 的形式，其中 a，b 是彩车和 J（或 J）表示 - 1 的平方根（这是一个虚数）。 a 是真正的数字部分，b 是虚部。复数不使用 Python 编程。</li>
</ul>
<p>下面是一些数字的例子：</p>
<table>
<thead>
<tr>
<th align="center">int</th>
<th align="center">long</th>
<th align="center">float</th>
<th align="center">complex</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">51924361L</td>
<td align="center">0.0</td>
<td align="center">3.14j</td>
</tr>
<tr>
<td align="center">100</td>
<td align="center">-0x19323L</td>
<td align="center">15.20</td>
<td align="center">45.j</td>
</tr>
<tr>
<td align="center">-786</td>
<td align="center">0122L</td>
<td align="center">-21.9</td>
<td align="center">9.322e-36j</td>
</tr>
<tr>
<td align="center">080</td>
<td align="center">0xDEFABCECBDAECBFBAEl</td>
<td align="center">32.3+e18</td>
<td align="center">.876j</td>
</tr>
<tr>
<td align="center">-0490</td>
<td align="center">535633629843L</td>
<td align="center">-90.</td>
<td align="center">-.6545+0J</td>
</tr>
<tr>
<td align="center">-0x260</td>
<td align="center">-052318172735L</td>
<td align="center">-32.54e100</td>
<td align="center">3e+26J</td>
</tr>
<tr>
<td align="center">0x69</td>
<td align="center">-4721885298529L</td>
<td align="center">70.2-E12</td>
<td align="center">4.53e-7j</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>Python 允许你使用长 L 的小写，但建议您只使用一个大写字母 L，以避免与数字 1 混淆。python 长整数显示一个大写字母 L。</li>
<li>一个复杂的数字组成的有序对一个真正的浮点数字 + BJ，其中 a 是实部和 b 是复数的虚部表示。</li>
</ul>
<h3 id="数字类型转换："><a href="#数字类型转换：" class="headerlink" title="数字类型转换："></a><strong>数字类型转换：</strong></h3><ul>
<li><p>Python 的数字转换内部包含一个共同的评价类型的混合型的表达。但有时，你需要明确强迫一个数字从一个类型到另一个运算符或函数的参数，以满足要求。</p>
</li>
<li><p><strong>int</strong> 类型（X）转换 X 到一个普通整数。</p>
</li>
<li><p><strong>long</strong>（X）转换 X 到一个长整数。</p>
</li>
<li><p><strong>float</strong> 类型（X）转换 X 到浮点数字。</p>
</li>
<li><p><strong>complex</strong> （x）的转换与真正的第 X 部和虚部为零的 x 到一个复杂的数量。 类型复杂（X，Y）转换 x 和 y 的第 X 部和虚部Ÿ复数。 x 和 y 是数值表达式 内置数功能：</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的数据结构</title>
    <url>/2021/02/06/Python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student_list &#x3D; [</span><br><span class="line">    &#123;&#39;name&#39;: &#39;zs&#39;, &#39;age&#39;: 12&#125;,</span><br><span class="line">    &#123;&#39;name&#39;: &#39;ls&#39;, &#39;age&#39;: 23&#125;</span><br><span class="line">]</span><br><span class="line">student_dic &#x3D; &#123;</span><br><span class="line">    &#123;&#39;zs&#39;&#125;:&#123;&#39;sx&#39;,23&#125;,</span><br><span class="line">    &#123;&#39;ls&#39;&#125;:&#123;&#39;ls&#39;,24&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数据结构也就是存储数据的结构，我们对数据组织的方式就叫做数据结构。</p>
</li>
<li><p>比如上面保存学生信息的方式，是以列表的方式组织还是使用字典的方式组织。</p>
</li>
<li><p>数据结构解决的就是一组数据如何保存，保存形式是怎么样的。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="Python-的数据结构"><a href="#Python-的数据结构" class="headerlink" title="Python 的数据结构"></a>Python 的数据结构</h2><h3 id="一、认识-Python-数据结构"><a href="#一、认识-Python-数据结构" class="headerlink" title="一、认识 Python 数据结构"></a>一、认识 Python 数据结构</h3><p>&emsp;&emsp;Python 有 4 个内建的数据结构，它们可以统称为容器（container），因为它们实际上是一些 “东西” 组合而成的结构，而这些 “东西”，可以是数字、字符甚至列表，或是它们的组合。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206162226.png" alt="20210206162226"></p>
</div>

<p>&emsp;&emsp;Python 中的绝大部分数据结构可以被最终分解为三种类型：集合（Set），序列（Sequence），映射（Mapping）。这表明了数据存储时所需的基本单位，其重要性如同欧式几何公理之于欧式空间。</p>
<p>1、集合是独立于标量，序列和映射之外的特殊数据结构，它支持数学理论的各种集合的运算。它的存在使得用程序代码实现数学理论变得方便。</p>
<p>2、序列是 Python 中最为基础的内建类型。它分为七种类型：列表、字符串、元组、Unicode 字符串、字节数组、缓冲区和 xrange 对象。常用的是：列表（List）、字符串（String）、元组（Tuple）。</p>
<p>3、映射在 Python 的实现是数据结构字典（Dictionary）。作为第三种基本单位，映射的灵活使得它在多种场合中都有广泛的应用和良好的可拓展性。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206162317.png" alt="20210206162317"></p>
</div>

<h3 id="二、Python-数据结构之列表"><a href="#二、Python-数据结构之列表" class="headerlink" title="二、Python 数据结构之列表"></a>二、Python 数据结构之列表</h3><h4 id="1、列表的基本操作"><a href="#1、列表的基本操作" class="headerlink" title="1、列表的基本操作"></a>1、列表的基本操作</h4><ul>
<li>all_list = [1,‘word’,{‘like’:‘pythom’},True,[1,2]]</li>
<li>all_list =list((1,‘word’,{‘like’:‘pythom’},True,[1,2]))</li>
<li>长度：len (all_list)</li>
<li>计数：all_list.count (‘word’)</li>
<li>下标：all_list.index (‘word’)</li>
<li>反转：all_list [::-1] 或者 all_list.reverse ()</li>
<li>合并：list1+list2</li>
<li>重复：all_list * 3</li>
<li>判断元素是否存在：‘word’ in all_list</li>
<li>切片与索引：all_list [0]</li>
<li>all_list[-4]</li>
<li>all_list[1:4]</li>
<li>all_list[:3]<ul>
<li>①、列表中每个元素都是可变的；</li>
<li>②、列表中的元素是有序的，每个元素对应一个位置；</li>
<li>③、列表可以容纳 Python 中的任何对象。<h4 id="2、列表的增删改查"><a href="#2、列表的增删改查" class="headerlink" title="2、列表的增删改查"></a>2、列表的增删改查</h4></li>
</ul>
</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163047.png" alt="20210206163047"></p>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163117.png" alt="20210206163117"></p>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163127.png" alt="20210206163127"></p>
</div>

<p>fruit = [1,‘word’,True,‘pear’]</p>
<p>month=[‘January’,‘February’,‘March’,‘April’]</p>
<p>增添</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruit.append(‘July’)</span><br><span class="line">fruit.extend(month)</span><br><span class="line">fruit.insert(1,‘grap’)</span><br><span class="line">fruit.insert(-1,‘apple’)</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruit.remove(‘grape’)</span><br><span class="line">fruit.remove(fruit[0])</span><br><span class="line">fruit.pop(2)</span><br><span class="line">del fruit[0:2]</span><br><span class="line">fruit.clear () # 清空</span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruit[0] &#x3D; (‘orange’)</span><br><span class="line">fruit2 &#x3D; fruit.copy()</span><br></pre></td></tr></table></figure>
<p>查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruit.index(‘pear’)</span><br><span class="line">fruit[3]</span><br></pre></td></tr></table></figure>
<h4 id="3、列表内建函数"><a href="#3、列表内建函数" class="headerlink" title="3、列表内建函数"></a>3、列表内建函数</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163350.png" alt="20210206163350"></p>
</div>

<h3 id="三、Python-数据结构之元组"><a href="#三、Python-数据结构之元组" class="headerlink" title="三、Python 数据结构之元组"></a>三、Python 数据结构之元组</h3><h4 id="1、元组的概念"><a href="#1、元组的概念" class="headerlink" title="1、元组的概念"></a>1、元组的概念</h4><p>&emsp;&emsp;元组与列表和字符串一样，是序列的一种。而元组与列表的唯一不同的元组不能修改，元组和字符串都具有不可变性。列表的可变性可能更方便处理复杂问题，例如更新动态数据等，但很多时候不希望某些处理过程修改对象内容，例如敏感数据，这就需要元组的不可变性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tup &#x3D; (‘Google’, ‘Runoob’, 1997, 2000)</span><br><span class="line">tup1 &#x3D; (50,) # 元组中只包含一个元素时，要在元素后面添加逗号</span><br></pre></td></tr></table></figure>
<ul>
<li>长度：len (tup)</li>
<li>计数：tup.count (‘Google’)</li>
<li>下标：tup.index (‘Google’)</li>
<li>反转：tup [::-1]</li>
<li>合并：tup1+tup2</li>
<li>重复：tup * 3</li>
<li>判断元素是否存在：‘Google’ in tup</li>
<li>切片与索引：tup [0]</li>
<li>tup[1:4]</li>
<li>tup[:3]</li>
<li>元组解包：A,B,C,D=tup # 将元组中各元素分别赋值给对应变量</li>
</ul>
<h4 id="2、元组内建函数"><a href="#2、元组内建函数" class="headerlink" title="2、元组内建函数"></a>2、元组内建函数</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163628.png" alt="20210206163628"></p>
</div>

<h2 id="四、Python-数据结构之字典"><a href="#四、Python-数据结构之字典" class="headerlink" title="四、Python 数据结构之字典"></a>四、Python 数据结构之字典</h2><h4 id="1、字典的概念"><a href="#1、字典的概念" class="headerlink" title="1、字典的概念"></a>1、字典的概念</h4><p>字典（Dictionary）是基础数据结构映射 (Mapping) 的一种。序列是按照顺序来存储数据的，而字典是通过键存储数据。字典的内部实现是基于二叉树 (Binary Tree) 的，数据没有严格的顺序。字典将键映射到值，通过键来调取数据。如果键值本来是有序的，那么我们不应该使用字典，如映射：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163743.png" alt="20210206163743"></p>
</div>

<p>直接用列表 [‘A’,’B’,’C’] 即可，字典的效率比列表差得多。但是在很多情形下，字典比列表更加适用。比如我们手机的通讯录（假设人名均不相同）可以使用字典实现，把人的名字映射到一个电话号码，由于名字是无序的，不能直接用一个列表实现，使用字典直接高效。</p>
<h4 id="2、字典的增删改查"><a href="#2、字典的增删改查" class="headerlink" title="2、字典的增删改查"></a>2、字典的增删改查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code &#x3D; &#123;‘BIDU’:‘Baidu’,‘SINA’:‘Sina’,‘YOKU’:‘Youku’&#125;</span><br><span class="line">code &#x3D; dict([(‘BIDU’,‘Baidu’),(‘SINA’,‘Sina’),(‘YOKU’,‘Youku’)])</span><br></pre></td></tr></table></figure>
<p>插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code[‘QQ’] &#x3D; ‘tengxun’</span><br><span class="line">code.update(&#123;‘FB’:‘Facebook’,‘TSLA’:‘Tesla’&#125;)</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del code[‘FB’]</span><br><span class="line">code_QQ &#x3D; code.pop(‘QQ’)</span><br><span class="line">code.clear () # 清空</span><br></pre></td></tr></table></figure>
<p>修改（赋值）</p>
<p><code>code[‘YOJKU’] = ‘Yoku’</code></p>
<p>查找</p>
<p><code>code[‘FB’]</code></p>
<h4 id="3、映射在-Python-的实现是数据结构字典"><a href="#3、映射在-Python-的实现是数据结构字典" class="headerlink" title="3、映射在 Python 的实现是数据结构字典"></a>3、映射在 Python 的实现是数据结构字典</h4><ul>
<li>①、键－值成对出现；</li>
<li>②、键不能重复；</li>
<li>③、键不可更改，值可修改；</li>
<li>④、键来索引值。<h4 id="4、字典的常用操作"><a href="#4、字典的常用操作" class="headerlink" title="4、字典的常用操作"></a>4、字典的常用操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code &#x3D; &#123;‘BIDU’:‘Baidu’, ‘SINA’:‘Sina’,‘YOKU’:‘Youku’&#125;</span><br><span class="line">len () 测量字典中，键值对的个数</span><br><span class="line">len(code)</span><br><span class="line">keys 返回一个包含字典所有 KEY 的列表</span><br><span class="line">code.keys()</span><br><span class="line">values 返回一个包含字典所有 value 的列表</span><br><span class="line">code.values()</span><br><span class="line">items 返回一个包含所有（键，值）元祖的列表</span><br><span class="line">code.items()</span><br><span class="line">has_key</span><br><span class="line">code.has_key (key) 如果 key 在字典中，返回 True，否则返回 False。</span><br></pre></td></tr></table></figure>
<h3 id="五、Python-数据结构之集合"><a href="#五、Python-数据结构之集合" class="headerlink" title="五、Python 数据结构之集合"></a>五、Python 数据结构之集合</h3></li>
</ul>
<h4 id="1、集合的概念"><a href="#1、集合的概念" class="headerlink" title="1、集合的概念"></a>1、集合的概念</h4><p>Python 有一种特殊的数据类型称为集合。因为它既不是序列也不是映射类型，更不是标量。集合是自成一体的类型。集合是唯一的，不可变的对象是一个无序集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set1 &#x3D; set([2,3,1,4,False,2.5,‘one’])</span><br><span class="line">set2 &#x3D; &#123;‘A’,‘C’,‘D’,‘B’,‘A’,‘B’&#125; # 创建可变集合</span><br><span class="line"></span><br><span class="line">set3 &#x3D; frozenset ([3,2,3,‘one’,frozenset ([1,2]),True]) # 创建不可变集合</span><br></pre></td></tr></table></figure>
<p>集合能够通过表达式操作符支持一般的数学集合运算。这是集合特有的操作，序列和映射不支持这样的表达式。</p>
<h4 id="2、集合的并集"><a href="#2、集合的并集" class="headerlink" title="2、集合的并集"></a>2、集合的并集</h4><p>由属于集合 A 或集合 B 的所有元素组成的集合，称为集合 A 和 B 的并集，数学表达式为 A∪B={x|x∈A 或 x∈B}。在 Python 中可以使用符号 “|” 或者集合方法 union 函数来得出两个集合的并集。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206164047.png" alt="20210206164047"></p>
</div>

<p>A={‘足球’,‘游泳’,‘羽毛球’,‘乒乓球’}</p>
<p>B={‘篮球’,‘乒乓球’,‘羽毛球’,‘排球’}</p>
<p>A|B # 使用符号’|’获取并集</p>
<p>A.union (B) # 使用集合方法 union 函数获取并集</p>
<h4 id="3-集合的交集"><a href="#3-集合的交集" class="headerlink" title="3. 集合的交集"></a>3. 集合的交集</h4><p>同时属于集合 A 和 B 的元素组成的集合，称为集合 A 和 B 的交集，数学表达式为 A∩B={x|x∈A 且 x∈B}。可以利用符号 “&amp;” 或者集合方法 intersection 函数来获取两个集合对象的交集。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206164305.png" alt="20210206164305"></p>
</div>

<p>A={‘足球’,‘游泳’,‘羽毛球’,‘乒乓球’}</p>
<p>B={‘篮球’,‘乒乓球’,‘羽毛球’,‘排球’}</p>
<p>A&amp;B # 使用符号’&amp;’获取交集</p>
<p>A.intersection (B) # 使用集合方法 intersection 函数获取交集</p>
<h4 id="4、集合的差集"><a href="#4、集合的差集" class="headerlink" title="4、集合的差集"></a>4、集合的差集</h4><p>属于集合 A 而不属于集合 B 中的元素所构成的集合，称为集合 A 减集合 B，数学表达式为 A-B={x|x∈A,x∉B}。这个集合也称为集合 A 与集合 B 的差集。反过来，也有差集 B-A={x|x∈B,x∉A}。在 Python 中可以简单地使用减号 “－” 来得到相应的差集，或者可以通过集合方法 difference 函数来实现。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206164412.png" alt="20210206164412"></p>
</div>

<p>A={‘足球’,‘游泳’,‘羽毛球’,‘乒乓球’}</p>
<p>B={‘篮球’,‘乒乓球’,‘羽毛球’,‘排球’}</p>
<p>A-B # 使用减号 “－” 来获取差集</p>
<p>A.difference (B) # 使用集合方法 difference 函数获取差集</p>
<h4 id="5、集合的异或集"><a href="#5、集合的异或集" class="headerlink" title="5、集合的异或集"></a>5、集合的异或集</h4><p>属于集合 A 或集合 B，但不同时属于集合 A 和 B 的元素所组成的集合，称为集合 A 和 B 的异或集，其相当 (A∪B)-(A∩B)。利用符号 “^” 或者集合方法 symmetric_difference 函数即可求出两个集合对象的异或集。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206164453.png" alt="20210206164453"></p>
</div>

<p>A={‘足球’,‘游泳’,‘羽毛球’,‘乒乓球’}</p>
<p>B={‘篮球’,‘乒乓球’,‘羽毛球’,‘排球’}</p>
<p>A^B # 获取异或集</p>
<p>A.symmetric_difference (B) # 使用集合方法 symmetric_difference 函数获取异或集</p>
<h4 id="6、集合内建函数"><a href="#6、集合内建函数" class="headerlink" title="6、集合内建函数"></a>6、集合内建函数</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206164538.png" alt="20210206164538"></p>
</div>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python从字符串中提取数字</title>
    <url>/2021/03/21/Python%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%8F%90%E5%8F%96%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_str &#x3D; &#39;123and456&#39;</span><br><span class="line"></span><br><span class="line">number &#x3D; filter(str.isdigit,  my_str )</span><br><span class="line"></span><br><span class="line"># number &#x3D; 123456</span><br></pre></td></tr></table></figure>
<h3 id="使用正则表达式："><a href="#使用正则表达式：" class="headerlink" title="使用正则表达式："></a>使用正则表达式：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; re.findall(r&#39;\d+&#39;, &#39;hello 42 I\&#39;m a 32 string 30&#39;)</span><br><span class="line"></span><br><span class="line">[&#39;42&#39;, &#39;32&#39;, &#39;30&#39;]</span><br></pre></td></tr></table></figure>
<h3 id="这也将匹配-42-bla42bla。如果您只想要按字边界（空格，句号，逗号）分隔的数字，则可以使用-b："><a href="#这也将匹配-42-bla42bla。如果您只想要按字边界（空格，句号，逗号）分隔的数字，则可以使用-b：" class="headerlink" title="这也将匹配 42 bla42bla。如果您只想要按字边界（空格，句号，逗号）分隔的数字，则可以使用\ b："></a>这也将匹配 42 bla42bla。如果您只想要按字边界（空格，句号，逗号）分隔的数字，则可以使用\ b：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.findall(r&#39;\b\d+\b&#39;, &#39;he33llo 42 I\&#39;m a 32 string 30&#39;)</span><br><span class="line"></span><br><span class="line">[&#39;42&#39;, &#39;32&#39;, &#39;30&#39;]</span><br></pre></td></tr></table></figure>
<p>最终得到一个数字列表而不是字符串列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [int(s) for s in re.findall(r&#39;\b\d+\b&#39;, &#39;he33llo 42 I\&#39;m a 32 string 30&#39;)]</span><br><span class="line"></span><br><span class="line">[42, 32, 30]</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><p>python str.isdigit() 有浮点数的判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.isdigit() 是个很好的工具，用来判断字符串中是否全为数字。而浮点数因为有 &quot;.&quot; ，所以会返还FALSE。</span><br><span class="line"></span><br><span class="line">参考示例：</span><br><span class="line"></span><br><span class="line"># 提示用户输入圆的半径，计算出该圆的周长和面积。要求如下：</span><br><span class="line"># 圆周率 π 值取 3.1415926</span><br><span class="line"># 如果输入的是负数和零，提示半径不能负数或者零</span><br><span class="line"># 计算机的结果保留两位小数</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    PI &#x3D; 3.1415926</span><br><span class="line">    radius &#x3D; input(&quot;请输入圆的半径：&quot;)</span><br><span class="line">    print(radius)</span><br><span class="line">    print(radius.isdigit())</span><br><span class="line">    if radius.isdigit():</span><br><span class="line">        radius &#x3D; float(radius)</span><br><span class="line">        # 计算元的周长和面积</span><br><span class="line">        circle_perimeter &#x3D; 2 * PI * radius</span><br><span class="line">        circle_area &#x3D; PI * radius * radius</span><br><span class="line">        print(&quot;圆的周长：%.2f \n圆的面积：%.2f&quot; % (circle_perimeter, circle_area))</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        print(&quot;半径不能负数或者零&quot;)</span><br><span class="line">以上在输入半径：12.3 就会报错 。</span><br><span class="line"></span><br><span class="line">此时需要replace() 方法语法：</span><br><span class="line"></span><br><span class="line">str.replace(old, new[, max])</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line"></span><br><span class="line">old -- 将被替换的子字符串。</span><br><span class="line">new -- 新字符串，用于替换old子字符串。</span><br><span class="line">max -- 可选字符串, 替换不超过 max 次</span><br><span class="line"></span><br><span class="line">if radius.replace(&quot;.&quot;, &quot;&quot;).isdigit():   # 替换为空即可。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="闰年-判断的两种方式’"><a href="#闰年-判断的两种方式’" class="headerlink" title="闰年 判断的两种方式’"></a>闰年 判断的两种方式’</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先明确  什么是闰年？</span><br><span class="line"></span><br><span class="line">1、能被4整除，但不能被100整除；</span><br><span class="line"></span><br><span class="line">2、能被400整除；</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">方案一：</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    year &#x3D; input(&quot;请输入要判断的年份（例如：2000）：&quot;)</span><br><span class="line">    if  year.isdigit():</span><br><span class="line">        year &#x3D; int(year)</span><br><span class="line">        result &#x3D; (year % 4 &#x3D;&#x3D; 0 and year % 100 !&#x3D; 0) or (year % 400 &#x3D;&#x3D; 0)</span><br><span class="line">        if result:</span><br><span class="line">            s &#x3D; &quot;是&quot;</span><br><span class="line">        else:</span><br><span class="line">            s &#x3D; &quot;不是&quot;</span><br><span class="line">        print(&quot;&#123;0&#125;年&#123;1&#125;闰年&quot;.format(year, s))</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;请输入年份！&quot;)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">方案二：</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    year &#x3D; input(&quot;请输入您要判断的年份（例如：2000）：&quot;)</span><br><span class="line">    if  year.isdigit():</span><br><span class="line">        year &#x3D; int(year)</span><br><span class="line">        result &#x3D; (year&#x2F;400 &#x3D;&#x3D; int(year&#x2F;400))or((year&#x2F;4 &#x3D;&#x3D; int(year&#x2F;4)) and (year&#x2F;100 !&#x3D; int(year&#x2F;100)))</span><br><span class="line">        if result:</span><br><span class="line">            s &#x3D; &quot;是&quot;</span><br><span class="line">        else:</span><br><span class="line">            s &#x3D; &quot;不是&quot;</span><br><span class="line">        print(&quot;&#123;0&#125;年&#123;1&#125;闰年!&quot;.format(year, s))</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;请输入年份！&quot;)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">方案三：</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    year &#x3D; input(&quot;请输入您要判断的年份（例如：2000）：&quot;)</span><br><span class="line">    if  year.isdigit():</span><br><span class="line">        yea &#x3D; int(year)</span><br><span class="line">        if (yea&#x2F;400 &#x3D;&#x3D; int(yea&#x2F;400))or((yea&#x2F;4 &#x3D;&#x3D; int(yea&#x2F;4)) and (yea&#x2F;100 !&#x3D; int(yea&#x2F;100))):</span><br><span class="line">            print(year+&quot;是闰年!&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(year+&quot;不是闰年!&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;请输入年份！&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字典的应用"><a href="#字典的应用" class="headerlink" title="字典的应用"></a>字典的应用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">nums &#x3D; []</span><br><span class="line">for count in range(50):</span><br><span class="line">    nums.append(random.randint(1,100))</span><br><span class="line">sort_nums_dict&#x3D;defaultdict(list)</span><br><span class="line">for num in nums:</span><br><span class="line">    if num&gt;66:</span><br><span class="line">        sort_nums_dict[&#39;大于66的元素&#39;].append(num)</span><br><span class="line">    else:</span><br><span class="line">        sort_nums_dict[&#39;小于66的元素&#39;].append(num)</span><br><span class="line">print(sort_nums_dict)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">s &#x3D; re.findall(r&#39;\d+&#39;, &#39;hello 42 I\&#39;m a 32 string 30&#39;)</span><br><span class="line">list_ &#x3D; []</span><br><span class="line">sum_&#x3D;0</span><br><span class="line">for i in s:</span><br><span class="line">    s1&#x3D;int(i)</span><br><span class="line">    list_.append(s1)</span><br><span class="line">print(list_)</span><br><span class="line">for i in list_:</span><br><span class="line">    sum_+&#x3D;i</span><br><span class="line">print(sum_)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[42, 32, 30]</span><br><span class="line">104</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门必备知识</title>
    <url>/2021/04/24/Python%E5%85%A5%E9%97%A8%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1989 年才诞生，一个名叫吉多·范罗苏姆的荷兰人搞出来的编程语言，可以协助处理一些重复的、繁琐的事务性工作。这个语言最初无人问津，没想到几十年后却风靡全球，火得烫手。</p>
<p>Python 是一种高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 由 Guido van Rossum 于 1989 年底在荷兰国家数学和计算机科学研究所发明，第一个公开发行版发行于 1991 年。</p>
<p>特点</p>
<ul>
<li>易于学习：Python 有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</li>
<li>易于阅读：Python 代码定义的更清晰。</li>
<li>易于维护：Python 的成功在于它的源代码是相当容易维护的。</li>
<li>一个广泛的标准库：Python 的最大的优势之一是丰富的库，跨平台的，在 UNIX，Windows 和 macOS 兼容很好。</li>
<li>互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。</li>
<li>可移植：基于其开放源代码的特性，Python 已经被移植（也就是使其工作）到许多平台。</li>
<li>可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用 C 或 C++ 完成那部分程序，然后从你的 Python 程序中调用。</li>
<li>数据库：Python 提供所有主要的商业数据库的接口。</li>
<li>GUI 编程：Python 支持 GUI 可以创建和移植到许多系统调用。</li>
<li>可嵌入：你可以将 Python 嵌入到 C/C++ 程序，让你的程序的用户获得”脚本化”的能力。</li>
<li>面向对象：Python 是强面向对象的语言，程序中任何内容统称为对象，包括数字、字符串、函数等。</li>
</ul>
<h4 id="交互式解释器"><a href="#交互式解释器" class="headerlink" title="交互式解释器"></a>交互式解释器</h4><p>在命令行窗口执行 python 后，进入 Python 的交互式解释器。exit() 或 Ctrl + D 组合键退出交互式解释器。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>默认情况下，3.x 源码文件都是 UTF-8 编码，字符串都是 Unicode 字符。也可以手动指定文件编码：</p>
<p><code># -*- coding: utf-8 -*-</code><br>或者<br><code># encoding: utf-8</code></p>
<p>注意: 该行标注必须位于文件第一行</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul>
<li>第一个字符必须是英文字母或下划线 _ 。</li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。</li>
</ul>
<p>注：从 3.x 开始，非 ASCII 标识符也是允许的，但不建议。</p>
<h3 id="写代码，如何变得更牛逼"><a href="#写代码，如何变得更牛逼" class="headerlink" title="写代码，如何变得更牛逼"></a>写代码，如何变得更牛逼</h3><p>没有哪个文坛巨匠天生下来就能写出巨著来，他们都是通过阅读大量作品并参考借鉴最后形成自己独特的风格，其实写程序也是一样。</p>
<p>现在很多优秀的软件库都是开源的，这给了我们可以零距离向大牛学习的机会，阅读源代码给我们带来的好处也是非常多的。</p>
<p>1、学习代码风格</p>
<p>优秀的开源软件都来自于经验非常丰富的老司机程序员之手，往往他们写的代码更规范、无论是从可读性还是性能上经过仔细斟酌，不断优化结果。比如著名的 HTTP 请求库 Requests 就是一份不错的源码学习典范，因为里面有教科书似的 Pythonic 代码。</p>
<p>2、理解作者思路</p>
<p>作者实现某个功能，通常是经过多次重构不断改进得以实现最优的解决方案，那么我们可以思考作者为什么要这么做，比如 Cpython 里把小整数缓存到内存中，提高系统性能，你不去看源代码是不知道的，因为书上很少会讲到这些。再比如 Cpython 中的垃圾算法为什么要使用别人都不用的引用计数法呢？因为权衡利弊之后，引用计数是最简单的一种垃圾收集算法，再配合其他算法也能达到很好的效果。</p>
<p>3、提升编程水平</p>
<p>毫无疑问，通过阅读源代码，对自身的成长是非常有帮助的，站在巨人的肩膀上，才看得比别人更远。阅读优秀的源代码是提高编程水平的方式之一</p>
<p>阅读源代码的误区</p>
<p>初学者阅读源代码容易陷入一种误区，认为具备阅读源代码能力才牛逼，于是自己也扎进代码深渊，一开始欣喜若狂，后来开始迷失自我，有始无终，最后一无所获，还打击了自信心。</p>
<p>主要原因是，现在的项目动不动就是几万行的代码，如果一行行的读下去要不了几分钟就放弃了，其次，纯粹的”读”是没用的，还需要有思考。那么如何正确地阅读源代码？</p>
<p>阅读源代码的一些技巧</p>
<p>高效阅读源代码，可以从以下几个方面入手</p>
<p>1、读文档</p>
<p>任何一个优秀的开源项目标配有完善的文档，RTFM(Read The Fucking Manual)是了解开源项目最好的方式之一，同时也为后面阅读源代码提供了基础。</p>
<p>2、找程序入口</p>
<p>找到了文档之后，就根据文档找到程序的入口，从最简单的实例下手</p>
<p>3、跑单元测试</p>
<p>要想知道 API 怎么使用，除了可以查看文档之外，另外一个武器就是跑单元测试，单元测试对每一个方法都做了边界测试，通过阅读测试代码也能知道怎么样去使用这些方法。</p>
<p>4、找最早期版本</p>
<p>往往最开始的版本代码是最简洁的，读起来要轻松很多</p>
<p>5、多搜索一下网络上看看是否有前人做些相关的总结。这也是很好的参考。</p>
<h2 id="python-编程-ide-是什么"><a href="#python-编程-ide-是什么" class="headerlink" title="python 编程 ide 是什么"></a>python 编程 ide 是什么</h2><p>IDE 是 python 集成开发环境，是编写 python 代码的工具，常用的 IDE 有 “pycharm”、“Sublim text”、“vim”、“Eclipse with PyDev”、“Komodo Edit” 等等。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures20210424111424.png" alt="20210424111424"></p>
</div>

<h4 id="Python-IDE，又叫集成开发环境，是用来编写-python-程序的。python-本身自带一款-ide"><a href="#Python-IDE，又叫集成开发环境，是用来编写-python-程序的。python-本身自带一款-ide" class="headerlink" title="Python IDE，又叫集成开发环境，是用来编写 python 程序的。python 本身自带一款 ide."></a>Python IDE，又叫集成开发环境，是用来编写 python 程序的。python 本身自带一款 ide.</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures20210424111811.png" alt="20210424111811"></p>
</div>

<p>Python 是一种广泛运用的解说型、高级编程、通用型编程语言。</p>
<p>Python 首要分为 Python2 和 Python3 两个版别，两个版别间有一些差异 (待续)。</p>
<p>Python 拥有动态类型系统和废物收回功用，可以主动办理内存运用，并且支持多种编程范式，包含面向对象、命令式、函数式和过程式编程。其自身拥有一个巨大而广泛的标准库。</p>
<h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><p>Vim 能够说是 Python 最好的 IDE。Vim 是高级文本编辑器，旨在提供实践的 Unix 编辑器‘Vi’功用，支撑更多更完善的特性集。</p>
<p>Vim 不需求花费太多的学习时间，一旦你需求一个无缝的编程体会，那么就会把 Vim 集成到你的工作流中。</p>
<h4 id="居然没有推荐-vs-code-的？"><a href="#居然没有推荐-vs-code-的？" class="headerlink" title="居然没有推荐 vs code 的？"></a>居然没有推荐 vs code 的？</h4><p>题目描述全符合。</p>
<p>估计不是没有使用过就是没有深入使用过，居然对 vs code 视而不见！</p>
<p>安个插件即安即用啊，也自带 Jupyter notebook。你电脑里要是有几个 Python，点下左下角还能给自由切换。</p>
<p>你们写 Python 就不写别的东西了？偶尔处理个文本，或是写写网页啥的…… 通吃啊。</p>
<p>简单点的可以用 vs code</p>
<p>我感觉主要还是看你以哪方向为主吧</p>
<p>web 方向后期 pycharm 比较好用。如果要做数据方面的可以使用 jupyter</p>
<h2 id="Python-新手入门第一步：什么是-IDE？IDE-有什么用"><a href="#Python-新手入门第一步：什么是-IDE？IDE-有什么用" class="headerlink" title="Python 新手入门第一步：什么是 IDE？IDE 有什么用"></a>Python 新手入门第一步：什么是 IDE？IDE 有什么用</h2><p>前言</p>
<p>写 Python 代码最好的方式莫过于使用集成开发环境（IDE）了。它们不仅能使你的工作更加简单、更具逻辑性，还能够提升编程体验和效率。</p>
<p>每个人都知道这一点。而问题在于，如何从众多选项中选择最好的 Python 开发环境。初级开发者往往面临这个问题。</p>
<p>本文将概述最受程序员欢迎的 Python IDE，以及其他值得考虑的选项。在此之前，我们先来看看 IDE 是什么。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures20210424115921.png" alt="20210424115921"></p>
</div>

<p>什么是 IDE？IDE 有什么用？</p>
<p>IDE 是开发者创建程序时使用的软件包。它通过简单的用户界面集成多个高度关联的组件，从而最大化程序员的生产效率。本质上，IDE 是一种改进代码创建、测试和 debug 流程的工具，它使这些工作更加简单。</p>
<p>IDE 使用的工具包括：</p>
<ul>
<li>文本编辑器</li>
<li>编译器和 / 或解释器</li>
<li>装配自动化工具（assembly automation tool）</li>
<li>调试器（debugger）</li>
<li>有一个与 IDE 相似的术语 —— 代码编辑器（code editor）。我们先来探讨二者的异同。</li>
</ul>
<p>什么是代码编辑器？</p>
<p>代码编辑器是一个能够突出显示语法和安排代码版式的文本编辑器。高级代码编辑器可以开发和修改代码。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures20210424120151.png" alt="20210424120151"></p>
</div>

<p>IDE 和代码编辑器的显著特征</p>
<p>IDE 和代码编辑器有哪些共同优点？它们均可帮助开发者：</p>
<ul>
<li>存储和重新打开脚本</li>
<li>运行代码</li>
<li>debug</li>
<li>突出显示语法</li>
</ul>
<p>最受 Python 开发者欢迎的 IDE</p>
<p>1.PyCharm</p>
<p>PyCharm 由著名软件开发公司 JetBrains 开发。在涉及人工智能和机器学习时，它被认为是最好的 Python IDE。最重要的是，Pycharm 合并了多个库（如 Matplotlib 和 NumPy），帮助开发者探索更多可用选项。</p>
<p>兼容性：Windows、MacOS、Linux</p>
<p>主要插件和功能：</p>
<ul>
<li>内置开发者工具</li>
<li>远程开发能力</li>
<li>实时编辑模式</li>
<li>IPython Notebook</li>
</ul>
<p>优点：</p>
<ul>
<li>PyCharm 支持 web 开发框架，如 Pyramid、Flask 和 Django。</li>
<li>提供智能代码功能，可以执行更精确、快速的 bug 修复。</li>
<li>在 Docker 和 Vagrant 连接和 ssh 终端的帮助下，允许在远程主机上进行程序开发。</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>界面庞杂</p>
</li>
<li><p>其优点的成本高昂</p>
<p>2.Visual Studio Code</p>
</li>
</ul>
<p>Visual Studio Code 有时会与 Visual Studio IDE 混淆，后者并非 Python 使用者常用的工具。VS Code 是完整的代码编辑器，具备很多优秀功能，许多程序员称其为最好的 IDE 编辑器。</p>
<p>兼容性：Windows、Linux、Mac OS</p>
<p>主要插件和功能：</p>
<ul>
<li><p>内置 git</p>
</li>
<li><p>自定义工具扩展插件</p>
</li>
<li><p>断点调试</p>
</li>
<li><p>交互式控制台</p>
</li>
<li><p>优点：</p>
</li>
<li><p>其 Electron 框架允许开发者在几乎所有平台上使用 VS Code。</p>
</li>
<li><p>在编辑器中直接 debug。</p>
</li>
<li><p>支持多个键盘快捷键，以加速编程。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>debug 功能有限。</p>
</li>
<li><p>没有内置模板。</p>
<p>3.VI/Vim</p>
</li>
</ul>
<p>Vim 位列最好的 Python IDE 工具前 5 名。它是一个 modal editor，可以从「文件编辑」中分割文件。相比最初的 Vi，Vim 有了巨大进步，功能更加强大。</p>
<p>兼容性：Windows、Linux、Mac OS、IOS、Android、UNIX、AmigaOS、MorphOS</p>
<p>主要插件和功能：</p>
<ul>
<li>其脚本允许用 Python 执行几乎所有编程任务。</li>
<li>Ctags，帮助实现更好的标记导航。</li>
<li>内置基础词汇补全。</li>
</ul>
<p>优点：</p>
<ul>
<li>具备键盘界面，可以提升效率。</li>
<li>支持多个插件（如版本控制工具、文件管理工具）。</li>
<li>通过 .vimrc 文件实现不同扩展功能（如突出显示搜索结果）。</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>界面笨拙，一些开发者认为其不方便使用。</p>
</li>
<li><p>其 modal editor 需要用户花费一定时间学习。</p>
<p>4.IDLE</p>
</li>
</ul>
<p>IDLE 代码编辑器深受学生欢迎，它是 Python 自带编辑器。该编辑器使用简单、通用，且支持不同设备。在使用更复杂工具之前，开发者可以通过 IDLE 学习基础知识。</p>
<p>兼容性：Windows、Linux、Mac OS</p>
<p>主要插件和功能：</p>
<ul>
<li>tkinter GUI 工具包</li>
<li>多窗口界面</li>
<li>具备对话框、浏览器等配置</li>
</ul>
<p>优点：</p>
<ul>
<li>允许用户突出显示错误、自动编码，并进行准确识别。</li>
<li>具备轻量级 Python shell。</li>
<li>其内置修正功能可以提升性能。</li>
<li>允许用户在编辑器中搜索和替换文件。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持复制到库。</li>
<li>脚本不能超过 100 行代码。</li>
</ul>
<p>对于机器学习、人工智能和大数据，最好的 Python 兼容 IDE</p>
<p>Python 是机器学习、人工智能、大数据等领域中的首选语言之一。这部分将介绍适合这些领域 Python 开发的 IDE。</p>
<p>5.JuPyter/IPython Notebook</p>
<p>Jupyter 是基于 web 的编辑器，它允许开发者构建和运行脚本或 notebook。它相对简单，对用户也更加友好。Jupyter 还使用 Seaborn 和 Matplotlib 执行数据可视化。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>本文概述了大量优秀的 Python IDE 和其他工具。决定使用哪一种工具取决于工具的便利性和对工具的熟练程度。当然，也有大家都喜欢的工具（如 PyCharm），但是你可以多尝试几种工具，看看哪种最适合你。</p>
<p>一些 IDE 适合新手，另一些则更加专业，每一个 IDE 都具备独特的功能和设计。本文仅提供一些选项，读者可以从中选择适合自己的 Python IDE。</p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数应用实例2</title>
    <url>/2021/02/28/Python%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B2/</url>
    <content><![CDATA[<h2 id="函数传值为-list-的坑"><a href="#函数传值为-list-的坑" class="headerlink" title="函数传值为 list 的坑"></a>函数传值为 list 的坑</h2><p>函数传入 list 参数时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f(x,li&#x3D;[]):</span><br><span class="line">    for i in range(x):</span><br><span class="line">        li.append(i*i)</span><br><span class="line">    print(li)</span><br><span class="line">期望结果：</span><br><span class="line">f(4)</span><br><span class="line">#运算结果:[0, 1, 4, 9]</span><br><span class="line">f(5)</span><br><span class="line">#运算结果:[0, 1, 4, 9, 16]</span><br><span class="line">print（‘--------------------------------------’）</span><br><span class="line">#运算结果</span><br><span class="line">f(4)</span><br><span class="line">#运算结果:[0, 1, 4, 9]</span><br><span class="line">f(5)</span><br><span class="line">#运算结果:[0, 1, 4, 9, 0, 1, 4, 9, 16]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当定义函数时，会保存函数中默认参数 list 的值，也就是列表 li=[]；<br>在每次调用的时候如果传递了新的列表，则使用传递的列表，没有传递，使用定义函数时保存的默认参数（li=[]）；<br>上面两次调用中，都没有传递新的列表（使用默认列表 li=[] ），程序会调用定义函数时保存的默认参数 (（li=[]）);<br>列表在 append 的时候会在 li=[] 原来的基础上 append 追加值，所以会产生以上结果.</p>
</blockquote>
<p>通过打印列表的 ID 进行辨识</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f(x,li&#x3D;[]):</span><br><span class="line">    print(&#39;id:&#39;,id(li))</span><br><span class="line">    for i in range(x):</span><br><span class="line">        li.append(i*i)</span><br><span class="line">    print(li)</span><br><span class="line"></span><br><span class="line">f(4)</span><br><span class="line">#id: 2154086435336</span><br><span class="line">#结果:[0, 1, 4, 9]</span><br><span class="line">f(5)</span><br><span class="line">#id: 2154086435336</span><br><span class="line">#结果:[0, 1, 4, 9, 0, 1, 4, 9, 16]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会发现 ID 值是相同的；<br>说明两次执行时使用的都是定义函数时的默认参数 li=[ ]</p>
</blockquote>
<p>执行时往里面传新的列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f(x,li&#x3D;[]):</span><br><span class="line">    for i in range(x):</span><br><span class="line">        li.append(i*i)</span><br><span class="line">    print(li)</span><br><span class="line">f(4)</span><br><span class="line">#结果:[0, 1, 4, 9]</span><br><span class="line">f(5,[])</span><br><span class="line">#结果:[0, 1, 4, 9, 16]</span><br><span class="line">f(6)</span><br><span class="line">#结果:[0, 1, 4, 9, 0, 1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当传递空列表时，函数体当中会使用传递的空列表，没有传递时，使用函数默认值 li=[ ], 所以会产生以上结果。</p>
</blockquote>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>如果想要达到预期的结果，只需要在函数体里进行判断即可:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f(x, li&#x3D;[]):</span><br><span class="line">    if not li:</span><br><span class="line">        # 如果li不为空的话,就往下走(清空列表); 为空就不走</span><br><span class="line">        li &#x3D; []</span><br><span class="line">    for i in range(x):</span><br><span class="line">        li.append(i * i)</span><br><span class="line">    print(li)</span><br><span class="line">f(4)</span><br><span class="line">#结果:[0, 1, 4, 9]</span><br><span class="line">f(5)</span><br><span class="line">#结果:[0, 1, 4, 9,16]</span><br><span class="line">f(6)</span><br><span class="line">#结果:[0, 1, 4, 9,16,25]</span><br></pre></td></tr></table></figure>
<h2 id="向函数传递列表"><a href="#向函数传递列表" class="headerlink" title="向函数传递列表"></a>向函数传递列表</h2><p><a href="https://www.cnblogs.com/OliverQin/p/7801600.html">转载</a></p>
<p>在实际使用中你会发现，向函数传递列表是比较实用的，这种列表可能包含名字、数字、可能更复杂的对象 (字典)</p>
<p>假设向一个函数传递一堆水果，我们说出我们喜欢所有的水果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Obj(fruits):</span><br><span class="line">    for fruit in fruits:</span><br><span class="line">        msg &#x3D; &#39;I like &#39;+fruit+&#39;!&#39;</span><br><span class="line">        print(msg)</span><br><span class="line"></span><br><span class="line">L &#x3D; [&#39;apple&#39;,&#39;orange&#39;]</span><br><span class="line">Obj(L)</span><br></pre></td></tr></table></figure>
<p>我们将 Obj 定义成接受一个水果种类列表，并将其存储在形参 Obj 中，这个函数遍历接受到的列表，然后打印 ‘I like ..!’</p>
<h2 id="在函数中修改列表"><a href="#在函数中修改列表" class="headerlink" title="在函数中修改列表"></a>在函数中修改列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#首先定义一个列表，其中包含要打印的字母</span><br><span class="line">letters &#x3D; [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]</span><br><span class="line">already_letter &#x3D; []</span><br><span class="line"></span><br><span class="line">#模拟阅读每个字母，直到字母读取完毕为止</span><br><span class="line">#将每个已经阅读过的字母转移到列表already_letter中</span><br><span class="line">while letters:</span><br><span class="line">    current_letter &#x3D; letters.pop()</span><br><span class="line">    print(&quot;Printing letter:&quot;+current_letter)</span><br><span class="line">    already_letter.append(current_letter)</span><br><span class="line"></span><br><span class="line">#显示已经读取的所有字母</span><br><span class="line">print(&quot;\nThe follwing letter has been read:&quot;)</span><br><span class="line">for letter in already_letter:</span><br><span class="line">    print(letter)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们首先需要创建一个列表，还创建一个名为 already_letter 的空列表，每个已经阅读过的字母都存储到这个列表中，只要列表中还有字母，while 循环就模拟阅读过程：从该列表中删除一个已经读取的字母，然后将其存储到变量 current_letter 中，并显示一条消息，再将该字母存储到新列表中，等到循环结束后，再打印出所有的字母。</p>
<h2 id="上述程序改编版"><a href="#上述程序改编版" class="headerlink" title="上述程序改编版"></a>上述程序改编版</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def read_letter(letters,already_letter):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    读取每个字母，直到读取完毕为止</span><br><span class="line">    将读取完毕后的字母存储到新的列表中</span><br><span class="line">    :param letters:</span><br><span class="line">    :param already_letter:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    while letters:</span><br><span class="line">        current_letter &#x3D; letters.pop()</span><br><span class="line"></span><br><span class="line">        #模拟读取字母的过程</span><br><span class="line">        print(&quot;Printing letter:&quot; + current_letter)</span><br><span class="line">        already_letter.append(current_letter)</span><br><span class="line">def show_already_letter(already_letter):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    显示已经阅读的所有字母</span><br><span class="line">    :param already_letter:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&quot;\nThe follwing letters has been read:&quot;)</span><br><span class="line">    for letter in already_letter:</span><br><span class="line">        print(letter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">letters &#x3D; [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]</span><br><span class="line">already_letter&#x3D;[]</span><br><span class="line"></span><br><span class="line">read_letter(letters,already_letter)</span><br><span class="line">show_already_letter(already_letter)</span><br></pre></td></tr></table></figure>
<p>我们定义了函数 read_letter (), 它包含 2 个形参：一个需要阅读字母的列表和一个存储已经阅读字母的列表。给定这两个列表，这个函数模拟阅读过程：将字母一个个阅读，然后打印，最后将其转存到存储已阅读的列表中，函数 show_already_letter () 主要是打印已经阅读字母列表，最后四条语句是定义一个列表与一个空列表，调用上面的两个函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的函数中，在读取完毕之后，letters 列表就编程空列表了，那么假如我们想在读取完列表后还保留该列表，该怎么办呢？</p>
<p>使用切片法 [:] 创建列表的副本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def read_letter(letters,already_letter):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    读取每个字母，直到读取完毕为止</span><br><span class="line">    将读取完毕后的字母存储到新的列表中</span><br><span class="line">    :param letters:</span><br><span class="line">    :param already_letter:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    while letters:</span><br><span class="line">        current_letter &#x3D; letters.pop()</span><br><span class="line"></span><br><span class="line">        #模拟读取字母的过程</span><br><span class="line">        print(&quot;Printing letter:&quot; + current_letter)</span><br><span class="line">        already_letter.append(current_letter)</span><br><span class="line">def show_already_letter(already_letter):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    显示已经阅读的所有字母</span><br><span class="line">    :param already_letter:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&quot;\nThe follwing letters has been read:&quot;)</span><br><span class="line">    for letter in already_letter:</span><br><span class="line">        print(letter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">letters &#x3D; [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]</span><br><span class="line">already_letter&#x3D;[]</span><br><span class="line"></span><br><span class="line">read_letter(letters[:],already_letter)</span><br><span class="line">show_already_letter(already_letter)</span><br><span class="line"></span><br><span class="line">print(letters)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数的基础知识</title>
    <url>/2021/02/28/Python%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h3><p>&emsp;&emsp;我们在编程过程中往往会碰到这样的事情 —– 很多地方都用到了相同的一段代码。虽然复制 / 粘贴这段代码不费多大的功夫，但是这样就无声中增加了程序的维护成本。比如，我们后来需求变动了，要修改原来的这段共用代码才能完成目的，这样如果这段代码在很多地方出现，我们只能一处一处的发现并修改。后来我们有个想法，将这段代码单独拿出来，并给这段代码起一个名字，我们在用到这段代码的地方直接使用这个名字来代替这段代码，那如果日后还要修改这里，我们就可以只修改一处，因为名字没有改变，其他使用名字来替换代码的地方也就不需要改变。这样以来即减少了代码的行数，也方便了日后的维护，我们给拿出来的这段代码起了个名字：函数，每个函数都有一个名字，叫函数名，其他的代码使用这个函数的时候，通过函数名调用这个函数就可以了。</p>
<p>函数最主要的目的：封装一个功能。</p>
<a id="more"></a>

<p>一个函数的简单例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login_status &#x3D; 0     # 定义一个记录登录状态的变量</span><br><span class="line"></span><br><span class="line">def welcome_user():  # 定义一个函数，函数的功能就是打印&#39;welcome!&#39;</span><br><span class="line">	print(&#39;Welcome!&#39;)</span><br><span class="line"></span><br><span class="line">while not login_status::</span><br><span class="line">	name &#x3D; input(&#39;Input username here: &#39;)</span><br><span class="line">	if name:</span><br><span class="line">	login_status &#x3D; 1</span><br><span class="line">	welcome_user()</span><br><span class="line"></span><br><span class="line"># do other things</span><br></pre></td></tr></table></figure>
<p>上面的例子，如果用户输入有效的用户名，就会调用函数 welcome_user, 该函数实现打印 “Weclome !” 的作用，接着就跳出 while 循环做其他的工作.</p>
<p>上面简单的介绍了函数的定义和使用，函数的定义就是函数实现功能的那段代码，函数的使用就是通过 函数名 来使用.</p>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数的定义阶段只检查函数的语法，不执行函数.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def hello():</span><br><span class="line">	print(&#39;foo&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>向上面这样的定义是不会有问题的，因为没有调用函数</p>
<p>函数定义的方式简单的分为以下两种</p>
<h4 id="无参数函数"><a href="#无参数函数" class="headerlink" title="无参数函数:"></a>无参数函数:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_hello(): # 函数定义</span><br><span class="line">print(&#39;*&#39;*40)</span><br><span class="line">print(&#39;hello&#39;)</span><br><span class="line">print(&#39;*&#39;*40)</span><br><span class="line"></span><br><span class="line">print_hello() # 函数的使用</span><br></pre></td></tr></table></figure>
<p>上面的函数就是无参数函数，这些函数往往是做一些操作而没有返回值 (return somethings).</p>
<h4 id="有参数函数"><a href="#有参数函数" class="headerlink" title="有参数函数:"></a>有参数函数:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def put_together_hello(name&#x3D;&#39;&#39;)                 # 函数包含一个参数</span><br><span class="line">    valid_user&#x3D;&#39;xiaoming&#39;</span><br><span class="line">    print(&#39;*&#39;*40)</span><br><span class="line">    res_str &#x3D; hello %s&#39; % name</span><br><span class="line">    return res_str                                 # 返回一个字符串</span><br><span class="line"></span><br><span class="line">name &#x3D; input(&#39;Input username here: &#39;)</span><br><span class="line"></span><br><span class="line">result&#x3D;put_together_hello(name)                    给函数传递一个参数</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>我们给上面的函数传递了一个值，这个传给函数的值，通常叫做函数的参并且在函数末尾用 return 返回了一个值，我们在函数调用处用一个新量接收该值，并且打印.</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><pre><code>有参函数的参数可大致分为 5 种情况:

1). 位置参数

2). 关键字参数

3). 默认值参数

4). 可变长参数 (*args,**kwargs)

5). 命名关键字参数

下面分别介绍:
</code></pre>
<p>第一种情况：位置参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_info(name,age):</span><br><span class="line">    print(&#39;your name is %s and your are %d years old&#39; % (name,age))</span><br><span class="line"></span><br><span class="line">name&#x3D;&#39;xiaoming&#39;</span><br><span class="line">age&#x3D;16</span><br><span class="line">print_info(name,age)</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">your name is xiaoming and your are 16 years old</span><br></pre></td></tr></table></figure>
<p>上面是位置参数，简单来说，就是调用的时候，参数的位置，应该和函数定义处的函数位置相同，这样才能打印出正确的信息.</p>
<p>第二种情况：关键字参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_info(name,age):</span><br><span class="line">    print(&#39;your name is %s and your are %d years old&#39; % (name,age))</span><br><span class="line"></span><br><span class="line">name&#x3D;&#39;xiaoming&#39;</span><br><span class="line">age&#x3D;16</span><br><span class="line">print_info(age&#x3D;age,name&#x3D;name)</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">your name is xiaoming and your are 16 years old</span><br></pre></td></tr></table></figure>
<pre><code>   这里传递参数的时候指定了传递参数的关键字，就是将 age 变量赋值给 age 参数，就是将 name 变量赋值给 name 参数。这样的就没有问题.
</code></pre>
<p>第三种情况：默认参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_info(name,age&#x3D;17):</span><br><span class="line">    print(&#39;your name is %s and your are %d years old&#39; % (name,age))</span><br><span class="line"></span><br><span class="line">name&#x3D;&#39;xiaoming&#39;</span><br><span class="line">age&#x3D;16</span><br><span class="line">print_info(age&#x3D;age,name&#x3D;name)</span><br><span class="line"></span><br><span class="line">print_info(&#39;xiaohong&#39;)</span><br><span class="line"></span><br><span class="line">print_info(&#39;xiaohong&#39;,20)</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">your name is xiaoming and your are 16 years old</span><br><span class="line">your name is xiaohomg and your are 17 years old</span><br><span class="line">your name is xiaohong and your are 20 years ol</span><br></pre></td></tr></table></figure>
<pre><code> 上面的例子，函数定义的时候，给了一个默认的参数 age=17, 我们将这样含有这种默认值的参数叫做默认值参数，既然函数已经有一个默认值，因此我们可以给函数传递 age 这个信息，也可以不传 age 信息，如果传了 age 信息，则函数运行的时候会将我们传递的 age 覆盖默认的值 (16). 如果我们没有传递参数信息，则输出函数的时候会输出默认值 (16). 有种情况需要注意，在函数定义的时候，默认值参数必须在没有默认值的参数的右侧.

第四种情况：可变长参数
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_info(name,age,*args,**kwargs):</span><br><span class="line">	print(&#39;your name is %s and your age is %d&#39; % (name,age))</span><br><span class="line">	print(args)</span><br><span class="line">	print(kwargs)</span><br><span class="line"></span><br><span class="line">print_info(&#39;xiaoming&#39;,16,&#39;football&#39;,&#39;baskatball&#39;,favorite_color&#x3D;&#39;black&#39;,vorite_book&#x3D;&#39;A&#39;)</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">yourname is xiaoming and your age is 16</span><br><span class="line">(&#39;football&#39;, &#39;baskatball&#39;) #元组</span><br><span class="line">&#123;&#39;favorite_book&#39;: &#39;A&#39;, &#39;favorite_color&#39;: &#39;black&#39;&#125; #字典</span><br></pre></td></tr></table></figure>
<p>我们这里定义 print_info 函数，顺便打印了除 name 和 age 之外的变量，这里除了函数前面的两个值按位置赋值给 name 和 age 外，其余多传递的值中，单个字符串或其他单个变量的都被赋值给 args, 包含简单语句 “A=B” 的变量都被赋值给 kwargs 变量，从上面我们也可以看出，args 是一个 tuple (元组), 而 kwargs 是一个 dict (字典).</p>
<pre><code>第五种情况：命名关键字参数
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foo(name,age,_,sex&#x3D;&#39;male&#39;,height):</span><br><span class="line">	print(name,age)</span><br><span class="line">	print(sex)</span><br><span class="line">	print(height)</span><br><span class="line"></span><br><span class="line"># * 后定义的参数为命名关键字参数,这类参数必须被传值,而且必须以&quot;变量名&#x3D; 变量值&quot;的形式传值</span><br><span class="line"></span><br><span class="line">foo(&#39;xiaoming&#39;,16,height&#x3D;&#39;185&#39;)</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">xiaoming 16</span><br><span class="line">male</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<p>再来看其他的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foo(*args):</span><br><span class="line">	print(args)</span><br><span class="line"></span><br><span class="line">foo(1,2,3,4)</span><br><span class="line">foo(_[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line"></span><br><span class="line"># * [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;] &#x3D;&#x3D;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;</span><br><span class="line">#&#x3D;&#x3D;&gt;f(*[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) &#x3D;&#x3D;&gt; f(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)</span><br><span class="line"># * 打散后面的参数,使之成为位置参数</span><br></pre></td></tr></table></figure>
<p>再来一个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foo(**kwargs):</span><br><span class="line">	print(kwargs)</span><br><span class="line"></span><br><span class="line">foo(x&#x3D;1,y&#x3D;2)</span><br><span class="line"></span><br><span class="line"># x&#x3D;1,y&#x3D;2 &#x3D;&#x3D; **&#123;&#39;y&#39;:2,&#39;x&#39;:1&#125;</span><br><span class="line"># &#x3D;&#x3D;&gt; foo(**&#123;&#39;y&#39;:2,&#39;x&#39;:1&#125;) &#x3D;&#x3D; foo(x&#x3D;1,y&#x3D;2)</span><br><span class="line"># ** 将后面的字典打散成为关键字参数</span><br><span class="line"></span><br><span class="line"> # 结果</span><br><span class="line"> &#123;&#39;x&#39;:1,&#39;y&#39;:2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二，函数的优点是什么"><a href="#二，函数的优点是什么" class="headerlink" title="二，函数的优点是什么"></a>二，函数的优点是什么</h2><p>1、减少代码重复率。</p>
<p>2、增强代码可阅读性。 # 不可能看一百行才知道你这个东西到底是干什么大的吧。</p>
<h2 id="三、函数的组成部分"><a href="#三、函数的组成部分" class="headerlink" title="三、函数的组成部分"></a>三、函数的组成部分</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_len(): # 关键字，函数名，括号，冒号</span><br><span class="line">    l &#x3D; [1, 2, 3, 4]   # 函数体</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    for i in l:</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">    print(count)</span><br></pre></td></tr></table></figure>
<h2 id="四、执行函数"><a href="#四、执行函数" class="headerlink" title="四、执行函数"></a>四、执行函数</h2><p><code>my len() # 函数名 + 括号</code></p>
<h2 id="五、函数的返回值：return-的作用停止函数体的运行。和-break-的功能一样。并且返回给这个函数一个值。"><a href="#五、函数的返回值：return-的作用停止函数体的运行。和-break-的功能一样。并且返回给这个函数一个值。" class="headerlink" title="五、函数的返回值：return 的作用停止函数体的运行。和 break 的功能一样。并且返回给这个函数一个值。"></a>五、函数的返回值：return 的作用停止函数体的运行。和 break 的功能一样。并且返回给这个函数一个值。</h2><p>1&gt; return 空或者没有 return 时，打印函数执行者时，为 None</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func1():</span><br><span class="line">    print (888)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">def func2():</span><br><span class="line">    print(9)</span><br><span class="line"></span><br><span class="line">print(func1())</span><br><span class="line">print(func2())</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line"></span><br><span class="line">888</span><br><span class="line">None</span><br><span class="line">9</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>2&gt; return 加一个值，返回给函数这个值，这个值是什么类型就返回什么类型</p>
<p>3&gt; return 加多个值是，返回给函数一个由这些值组成的元组，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func1():</span><br><span class="line">    a &#x3D; 8</span><br><span class="line">    return a</span><br><span class="line">def func2():</span><br><span class="line">    a &#x3D; 9</span><br><span class="line">    b &#x3D; 20</span><br><span class="line">    return a, b</span><br><span class="line"></span><br><span class="line">print(func1())</span><br><span class="line">print(func2())</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">(9, 20)</span><br></pre></td></tr></table></figure>
<h2 id="六、函数的传参，函数的参数分为形参和实参"><a href="#六、函数的传参，函数的参数分为形参和实参" class="headerlink" title="六、函数的传参，函数的参数分为形参和实参"></a>六、函数的传参，函数的参数分为形参和实参</h2><p>顾名思义，一个形式上的参数，一个实实在在的参数。</p>
<h4 id="1-形参的角度分类："><a href="#1-形参的角度分类：" class="headerlink" title="1. 形参的角度分类："></a>1. 形参的角度分类：</h4><p>1&gt; 位置参数， 按照顺序 ，一 一对应。就是这个位置我占了，谁在我位置上，我就是谁。先来后到。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227215944.png" alt="20210227215944"></p>
</div>

<p>2&gt; 默认参数，如果你给我一个值，我会将原来默认的参数覆盖掉。如果你不给我传值，就是设置好的默认参数</p>
<p>3&gt; 万能参数，也叫动态参数，*args ，**kwargs</p>
<p>4&gt; 形参的顺序 ：位置参数，*args，默认参数，**kwargs。</p>
<p>1.位置参数是最大的，一定要摆在第一位，实参中的也一样，如果摆在后面肯定报错，要么少了，要么多了</p>
<p>2.*args 实际上也是位置参数，就是实参中在形参中的 _ args 的位置有多少个参数，那就吃多少个参数。</p>
<p>3.如果把默认参数摆在他两前，都被 * args 给吸走了。</p>
<p>4.**kwargs 一定是在最后的。实质上是一个默认参数</p>
<p>5，传参陷阱：如果默认参数是一个可变的数据类型，那么他的内存地址用的是一个。</p>
<p>例 1（传默认参数时的运行结果）：</p>
<div align=cneter>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220504.png" alt="20210227220504"></p>
</div>

<p>运行结果如下:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220551.png" alt="20210227220551"></p>
</div>

<p>例 2（把变量放入局部命名空间）：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220639.png" alt="20210227220639"></p>
</div>

<p>运行结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220651.png" alt="20210227220651"></p>
</div>

<ol>
<li>站在实参的角度分为：位置传参，关键字传参，混合传参。</li>
</ol>
<p>例</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220802.png" alt="20210227220802"></p>
</div>

<p>运行结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220852.png" alt="20210227220852"></p>
</div>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数的应用实例</title>
    <url>/2021/02/28/Python%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="函数二（返回值-传递列表）"><a href="#函数二（返回值-传递列表）" class="headerlink" title="函数二（返回值 / 传递列表）"></a>函数二（返回值 / 传递列表）</h2><p>1.返回值：函数并非总是直接显示输出，它可以处理一些数据，并返回一个或一组值，函数返回的值被称为返回值。在函数中使用 return 语句将值返回到调用函数的代码行。调用返回值的函数时，需要提供一个变量，用于存储返回的值。</p>
<p>2.return 和 print 的区别</p>
<a id="more"></a>

<p>a. 在执行函数的时候 return 无法打印出值，return 返回的结果只能用于给变量赋值，return 返回值只能通过 print 打印出来</p>
<p>b. 在函数中，凡是遇到 return，这个函数就会结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func1():</span><br><span class="line">	for i in range(1, 5):</span><br><span class="line">		print(i)</span><br><span class="line"></span><br><span class="line"># print(func1())输出结果为 1 2 3 4 none 直接 func1 的结果为 1 2 3 4</span><br><span class="line"></span><br><span class="line">def func2():</span><br><span class="line">    for i in range(1, 5):</span><br><span class="line">		return i</span><br><span class="line"></span><br><span class="line"># print(func2())输出结果为 1，直接 func2()没有输出</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">print(func1())</span><br><span class="line">print(func2())</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>返回字典：函数可以返回任何类型的值，包括列表和字典。同时可以使用 while 循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def one_user(user_name, pass_word):</span><br><span class="line">    info &#x3D; &#123;&#39;name&#39;: user_name,</span><br><span class="line">    &#39;password&#39;: pass_word&#125;</span><br><span class="line">    return info</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    print(&#39;you can quit whenever you enter a q&#39;)</span><br><span class="line">    user_name1 &#x3D; input(&#39;create a user name: &#39;)</span><br><span class="line">    if user_name1 &#x3D;&#x3D; &#39;q&#39;:</span><br><span class="line">        break</span><br><span class="line">    pass_word1 &#x3D; input(&#39;create a pass word: &#39;)</span><br><span class="line">    if pass_word1 &#x3D;&#x3D; &#39;q&#39;:</span><br><span class="line">        break</span><br><span class="line">    print(one_user(user_name1, pass_word1))</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>向函数传递列表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def loved_music(new_songs, old_songs):</span><br><span class="line">    while new_songs:</span><br><span class="line">        choosed_song &#x3D; input(&#39;which song do you want to listen? &#39;)</span><br><span class="line">        new_songs.remove(choosed_song)</span><br><span class="line">        old_songs.append(choosed_song)</span><br><span class="line">        for loved_song in old_songs:</span><br><span class="line">            print(&#39;%s is a good song&#39; % loved_song)</span><br><span class="line"></span><br><span class="line">new_songs &#x3D; [&#39;roar&#39;, &#39;lemon&#39;, &#39;sugar&#39;, &#39;hero&#39;]</span><br><span class="line">old_songs &#x3D; []</span><br><span class="line"></span><br><span class="line">loved_music(new_songs[:], old_songs) # 不会修改原列表 new_songs</span><br><span class="line">print(new_songs)</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>传递任意数量的实参</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def favorite_songs(*songs):     # 使用 * 创建一个名为 songs 的空元组，将收到的所有实参都封装到这个元组中</span><br><span class="line">&quot;&quot;&quot;打印最喜欢的音乐&quot;&quot;&quot; # 文档字符串，描述函数的作用</span><br><span class="line">    print(songs)</span><br><span class="line"></span><br><span class="line">favorite_songs(&#39;lemon&#39;, &#39;city song&#39;, &#39;stray&#39;)</span><br></pre></td></tr></table></figure>
<p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后</p>
<ol start="6">
<li>使用任意数量的关键字实参</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def make_car(manufacturer, type, **car_info): # 使用**创建一个字典，将收到的所有键值对都封装到这个字典中</span><br><span class="line"></span><br><span class="line">    car &#x3D; &#123;&#125;</span><br><span class="line">    car[&#39;manufacturer _name&#39;] &#x3D; manufacturer</span><br><span class="line">    car[&#39;type_name&#39;] &#x3D; type</span><br><span class="line">    for key, value in car_info.items():</span><br><span class="line">        car[key] &#x3D; value</span><br><span class="line">    return car</span><br><span class="line"></span><br><span class="line">cars &#x3D; make_car(&#39;subaru&#39;, &#39;outback&#39;, color&#x3D;&#39;blue&#39;, two_package&#x3D;True)</span><br><span class="line">print(cars)</span><br><span class="line">print(make_car(&#39;subaru&#39;, &#39;outback&#39;, color&#x3D;&#39;blue&#39;, two_package&#x3D;True))</span><br></pre></td></tr></table></figure>
<p>#-<em>- coding: utf-8 -</em>-</p>
<p>###函数定义###</p>
<p>#一般函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;&#x3D; 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>
<p>#匿名函数，使用 lambda 创建</p>
<p><code>sum = lambda arg1, arg2: arg1 + arg2;</code></p>
<p>#缺省参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def printinfo( name, age &#x3D; 35 ):</span><br><span class="line">    &quot;打印任何传入的字符串&quot;</span><br><span class="line">    print( &quot;Name: &quot;, name);</span><br><span class="line">    print (&quot;Age &quot;, age);</span><br><span class="line">    return;</span><br></pre></td></tr></table></figure>
<p>#不定长参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def printinfo2( arg1, *vartuple ):</span><br><span class="line">    &quot;打印任何传入的参数&quot;</span><br><span class="line">    print( &quot;输出: &quot;,arg1)</span><br><span class="line">    for var in vartuple:</span><br><span class="line">        print (var)</span><br><span class="line">    return;</span><br></pre></td></tr></table></figure>
<p>###函数定义###</p>
<p>###函数调用###</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printinfo2(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;my_abs&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;) #调用函数 my_abs</span><br><span class="line">absVal&#x3D;my_abs(-3) #按照参数顺序传参</span><br><span class="line">print(&quot;my_abs(-3)&#x3D;&quot;,absVal)</span><br><span class="line">absVal2&#x3D;my_abs(x&#x3D;-4) #关键字参数，可以不按照参数熟悉传参</span><br><span class="line">print(&quot;my_abs(x&#x3D;-4)&#x3D;&quot;,absVal2)</span><br></pre></td></tr></table></figure>
<p>#调用函数 sum</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printinfo2(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sum&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">print (&quot;sum(10,20)&#x3D;&quot;, sum( 10, 20 ))</span><br></pre></td></tr></table></figure>
<p>#调用函数 printinfo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printinfo2(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;printinfo&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">printinfo(&quot;zhangsan&quot;,18);</span><br><span class="line">printinfo(&quot;lisi&quot;);</span><br></pre></td></tr></table></figure>
<p>#调用函数 printinfo2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printinfo2(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;printinfo2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">printinfo2( 10 );</span><br><span class="line">printinfo2( 70, 60, 50 ); ###函数调用###</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python列表切片之负数的含义代码示例</title>
    <url>/2021/03/21/Python%E5%88%97%E8%A1%A8%E5%88%87%E7%89%87%E4%B9%8B%E8%B4%9F%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="python-列表切片之负数的含义代码示例"><a href="#python-列表切片之负数的含义代码示例" class="headerlink" title="python 列表切片之负数的含义代码示例"></a>python 列表切片之负数的含义代码示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; list(range(10))</span><br><span class="line">print(a[::]) #复制一个列表</span><br><span class="line">print(a[::2]) #每隔2个取一次</span><br><span class="line">print(a[::3]) #每隔3个取一次</span><br><span class="line"></span><br><span class="line">print(a[::-1]) #表示反转字符串</span><br><span class="line">print(a[::-2]) #表示反转字符串,每隔2个取一次</span><br><span class="line">print(a[::-3]) #表示反转字符串,每隔3个取一次</span><br><span class="line">#由此得知最后一个位置参数表示间隔数</span><br><span class="line"></span><br><span class="line">print(a[-1::]) #-1表示倒着取1个</span><br><span class="line">print(a[-2::]) #-2表示倒着取2个</span><br><span class="line">print(a[-3::]) #-3表示倒着取3个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(a[-2:-1:]) #-2,-1:表示倒着取下面为-2到-1区间的</span><br><span class="line">print(a[-4:-2:]) #-4:-2:表示倒着取下面为-4到-3区间的</span><br><span class="line">print(a[-5:-1:]) #-4:-2:表示倒着取下面为-4到-3区间的</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line"></span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[0, 2, 4, 6, 8]</span><br><span class="line">[0, 3, 6, 9]</span><br><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br><span class="line">[9, 7, 5, 3, 1]</span><br><span class="line">[9, 6, 3, 0]</span><br><span class="line">[9]</span><br><span class="line">[8, 9]</span><br><span class="line">[7, 8, 9]</span><br><span class="line">[8]</span><br><span class="line">[6, 7]</span><br><span class="line">[5, 6, 7, 8]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python命名规范</title>
    <url>/2021/04/03/Python%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="Python-命名规范"><a href="#Python-命名规范" class="headerlink" title="Python 命名规范"></a>Python 命名规范</h2><h3 id="所有命名规范都要准守这三条"><a href="#所有命名规范都要准守这三条" class="headerlink" title="所有命名规范都要准守这三条"></a>所有命名规范都要准守这三条</h3><p>1.命名只能以字母或者_下划线开头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#错误类名</span><br><span class="line">class 4_Person():</span><br><span class="line">  pass</span><br><span class="line">#错误函数名</span><br><span class="line">def 漂亮():</span><br><span class="line">  pass</span><br></pre></td></tr></table></figure>
<p>2.名字不能包含空格</p>
<p>3.名字不能与关键字重合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#错误函数名，与关键字and重合</span><br><span class="line">def and():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>关键字参考《如何写一个函数》</p>
<p>不能将字符 l(小写字母 l)，’O’’o’(大小写字母 o)、’I’(大写字母 I)用作变量名称，防止和数字 0、1 混淆</p>
<p><strong>模块 module_name</strong></p>
<ul>
<li>与包的规范相同，如 mymodule</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import decoder</span><br><span class="line">import html_parser</span><br><span class="line">#不推荐的这种命名</span><br><span class="line">import Decoder</span><br></pre></td></tr></table></figure>
<p><strong>包 package_name</strong></p>
<ul>
<li><p>应该是简短的、小写的名字，如果下划线可以改善可读性可以加入，如 mypackage</p>
</li>
<li><p><strong>类 ClassName</strong></p>
</li>
<li><p>总是使用首字母大写单词串，如 MyClass(CamelCase 驼峰命名)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person():</span><br><span class="line">    pass</span><br><span class="line">class Elc_Car(Car):</span><br><span class="line">    pass</span><br><span class="line">class _PrivateCar(Car):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<ul>
<li>内部类可以使用额外的前导下划线</li>
</ul>
<p><strong>函数 function_name</strong></p>
<ul>
<li>全部小写，如有多个单词，用*下划线隔开，私有函数可用前导下划线，如例 3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def calculator():</span><br><span class="line">    pass</span><br><span class="line">def private_computer():</span><br><span class="line">    pass</span><br><span class="line">class Person():</span><br><span class="line">    def _private_func():</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p><strong>方法 method_name</strong></p>
<ul>
<li>同函数，小写 + 下划线</li>
</ul>
<p><strong>变量 var_name</strong></p>
<ul>
<li>变量名一般小写，多个单词用_下划线隔开，同函数命</li>
<li>私有类成员使用单一下划线前缀标识</li>
<li>变量名不应该带有类型信息，如 num_list,ani_dict 等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count &#x3D; 0</span><br><span class="line">animal_count &#x3D; 100</span><br></pre></td></tr></table></figure>
<p><strong>全局变量</strong></p>
<ul>
<li><p>全部大写，多个单词用_下划线隔开，如需要阻止导入模块内的全局变量，可以加一个前导下划线，GLOBAL_VAR_NAME，_GLOBAL_VAL</p>
</li>
<li><p>常量和全局变量命名规范相同</p>
</li>
</ul>
<p><strong>异常 ExceptionName</strong></p>
<ul>
<li>以 Error 作为后缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    pass</span><br><span class="line">except ValueError as result:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p><strong>参数 function_parameter_name</strong></p>
<ul>
<li>如果一个函数的参数名称和保留的关键字冲突，通常使用一个后缀下划线</li>
</ul>
<p><strong>常用的命名缩写</strong></p>
<ul>
<li>function 缩写为 fn</li>
<li>text 缩写为 txt</li>
<li>object 缩写为 obj</li>
<li>count 缩写为 cnt</li>
<li>number 缩写为 num</li>
</ul>
<p><strong>前导后缀下划线说明</strong></p>
<ul>
<li>一个前导下划线：表示非公有</li>
<li>一个后缀下划线：避免关键字冲突</li>
<li>两个前导下划线：当命名一个类属性引起名称冲突时使用</li>
<li>两个前导和后缀下划线：有特殊用途的对象或者属性，例如<strong>init</strong>和<strong>str</strong></li>
</ul>
<p><strong>1、缩进</strong></p>
<p>强制缩进的规定，让代码看上去很整齐，强迫症表示很喜欢。</p>
<p><strong>第一种情况：代码块的分割</strong></p>
<p>Python 使用一个冒号和缩进，来分割代码块，代码块指的是类的定义、函数的定义、流程控制中 if、for、while 模块。缩进表示一个代码块的开始，非缩进表示一个代码的结束，相同的缩进表示在代码块中处于相同的级别。</p>
<p>每一级缩进使用一个 tab 键（四个空格）。实际上一个空格就可以，但是一个空格看起来不那么明显，所以用一个 tab 更方便、清楚。</p>
<p>例如下面，就是 2 个代码块（两个代码块之间建议空一行）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一个冒号加换行缩进，开启一个代码块，直到下面一行不缩进了，说明下面一行已经不在这个代码块里了</span><br><span class="line">if a&gt;b:</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">def print_name(var):</span><br><span class="line">    print(var)</span><br><span class="line">    print(&#39;haha&#39;)</span><br></pre></td></tr></table></figure>
<p><strong>第二种情况：换行</strong></p>
<p>有时候写一行代码，特别特别长的时候，就需要换行。文档建议续行与其包裹元素对齐，譬如用括号来垂直对齐，如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 换行后的括号里内容，不超过上一行的括号</span><br><span class="line">foo &#x3D; long_function_name(var_one, var_two,</span><br><span class="line">                         var_three, var_four)</span><br></pre></td></tr></table></figure>
<p><strong>2、命名约定</strong></p>
<p>变量名可以是字母、数字、下划线的组合，不能以数字开头，也不可以用关键字来命名哦！</p>
<p>关键字，就是有特殊意义的字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import keyword</span><br><span class="line">print(keyword.kwlist)</span><br><span class="line">[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, \</span><br><span class="line"> &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;,\</span><br><span class="line"> &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, \</span><br><span class="line"> &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;,\</span><br><span class="line"> &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</span><br></pre></td></tr></table></figure>
<p>除此之外，还有一些其他的规范：</p>
<p>1）Python 里面区分大小写，类名一般使用首字母大写；</p>
<p>2）慎用字母 I（i 的大写）、l（L 的小写）、o、O，因为可能被人错看成数字 1 和 0；</p>
<p>3）命名应既简短又具有描述性。例如，student_name 比 s_n 好，name_length 比 length_of_persons_name 好；</p>
<p>4）在运算符前后各保留一个空格，例如 n == 1；</p>
<p><strong>3、Python 之禅</strong></p>
<p>Python 中内置了一个彩蛋，简单明了地说明了 Python 的哲学，只要输入 import this，然后按下回车就能看到原文，这里贴出中文翻译版本：</p>
<blockquote>
<p>Python 之禅<br>by Tim Peters<br>优美胜于丑陋<br>明了胜于隐晦<br>简洁胜于复杂<br>复杂胜于混乱<br>扁平胜于嵌套<br>宽松胜于紧凑<br>可读性很重要<br>即便是特例，也不可违背这些规则<br>虽然现实往往不那么完美<br>但是不应该放过任何异常<br>除非你确定需要如此<br>如果存在多种可能，不要猜测<br>肯定有一种——通常也是唯一一种——最佳的解决方案<br>虽然这并不容易，因为你不是 Python 之父<br>动手比不动手要好<br>但不假思索就动手还不如不做<br>如果你的方案很难懂，那肯定不是一个好方案<br>如果你的方案很好懂，那肯定是一个好方案<br>命名空间非常有用，我们应当多加利用</p>
</blockquote>
<p>Python 需要使用标识符给变量命名，其实标识符就是用于给程序中变量、类、方法命名的符号（简单来说，标识符就是合法的名字）。</p>
<p>Python 语言的标识符必须以字母、下画线（_）开头，后面可以跟任意数目的字母、数字和下画线（_）。此处的字母并不局限于 26 个英文字母，可以包含中文字符、日文字符等。</p>
<p>由于 Python 3 支持 UTF-8 字符集，因此 Python 3 的标识符可以使用 UTF-8 所能表示的多种语言的字符。Python 语言是区分大小写的，因此 abc 和 Abc 是两个不同的标识符。</p>
<p>Python 2.x 对中文支持较差，如果要在 Python 2.x 程序中使用中文字符或中文变量，则需要在 Python 源程序的第一行增加“#coding:utf-8”，当然别忘了将源文件保存为 UTF-8 字符集。</p>
<p>在使用标识符时，需要注意如下规则：<br>标识符可以由字母、数字、下画线（_）组成，其中数字不能打头。<br>标识符不能是 Python 关键字，但可以包含关键字。<br>标识符不能包含空格。</p>
<p>例如下面变量，有些是合法的，有些是不合法的：</p>
<ul>
<li>abc_xyz：合法。</li>
<li>HelloWorld：合法。</li>
<li>abc：合法。</li>
<li>xyz#abc：不合法，标识符中不允许出现“#”号。</li>
<li>abc1：合法。</li>
<li>1abc：不合法，标识符不允许数字开头。</li>
</ul>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之分数序列求和</title>
    <url>/2021/03/06/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%86%E6%95%B0%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h3 id="分数序列求和，分数自由输入，自由度较高"><a href="#分数序列求和，分数自由输入，自由度较高" class="headerlink" title="分数序列求和，分数自由输入，自由度较高"></a>分数序列求和，分数自由输入，自由度较高</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def eu(a,b):</span><br><span class="line">    if a &lt; b:</span><br><span class="line">        a, b &#x3D; b, a</span><br><span class="line">    r &#x3D; 1</span><br><span class="line">    while r !&#x3D; 0:</span><br><span class="line">        r &#x3D; a % b</span><br><span class="line">        a &#x3D; b</span><br><span class="line">        b &#x3D; r</span><br><span class="line">    return a</span><br><span class="line"></span><br><span class="line">a &#x3D; input(&#39;输入两个分数，以逗号分隔:&#39;)	# 输入两个分数如1&#x2F;2，3&#x2F;4 分数之间用,号分隔</span><br><span class="line">b &#x3D; a.split(&#39;,&#39;)</span><br><span class="line"></span><br><span class="line">num1 &#x3D; b[0].split(&#39;&#x2F;&#39;)</span><br><span class="line">num2 &#x3D; b[1].split(&#39;&#x2F;&#39;)</span><br><span class="line">sum1 &#x3D; int(num1[0])*int(num2[1]) + int(num2[0])*int(num1[1])</span><br><span class="line">sum2 &#x3D; int(num1[1])*int(num2[1])</span><br><span class="line">GCD &#x3D; eu(sum1,sum2)</span><br><span class="line"></span><br><span class="line">c &#x3D; int(sum1&#x2F;GCD)</span><br><span class="line">d &#x3D; int(sum2&#x2F;GCD)</span><br><span class="line"></span><br><span class="line">if c%d &#x3D;&#x3D; 0:</span><br><span class="line">    print(int(c&#x2F;d))</span><br><span class="line">else:</span><br><span class="line">    print(str(c)+ &#39;&#x2F;&#39;+str(d))</span><br></pre></td></tr></table></figure>
<h3 id="实际上用-fractions-模块可以瞬间解决问题"><a href="#实际上用-fractions-模块可以瞬间解决问题" class="headerlink" title="实际上用 fractions 模块可以瞬间解决问题"></a>实际上用 fractions 模块可以瞬间解决问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from fractions import Fraction</span><br><span class="line">a,b &#x3D; (input().split(&#39;,&#39;))</span><br><span class="line">sum&#x3D;Fraction(a)+Fraction(b)</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<h3 id="高级的写法"><a href="#高级的写法" class="headerlink" title="高级的写法"></a>高级的写法</h3><p>使用 Python 编写分数的加减法</p>
<p>基本概念</p>
<p>1.1 最大公约数与最小公倍数</p>
<p>1.1.1 最大公约数(gcd)：</p>
<p>较大的数除较小的数，得到整型余数</p>
<p>较小的数除以余数</p>
<p>最终得到 0，返回另一个数</p>
<p>1.1.2 最小公倍数(lcm)：</p>
<p>lcm=a*b/gcd(a,b)</p>
<p>1.2 最小公倍数与最大公约数类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#目的求lcm</span><br><span class="line">class Rational1(object):</span><br><span class="line">     def __init__(self):#初始化程序</span><br><span class="line">         pass</span><br><span class="line"></span><br><span class="line">     def gcd(a,b):#判断最大公约数</span><br><span class="line">         if not a &gt; b:</span><br><span class="line">             a,b &#x3D; b,a</span><br><span class="line">         while b !&#x3D; 0 :</span><br><span class="line">             remider &#x3D; a%b</span><br><span class="line">             a,b &#x3D; b,remider</span><br><span class="line">             print(&quot;%s&quot; %a)</span><br><span class="line">         return a</span><br><span class="line"></span><br><span class="line">     def lcm(a,b):#返回最小公倍数</span><br><span class="line">         lcm &#x3D; a*b &#x2F;Rational1.gcd(a,b)</span><br><span class="line">         return lcm</span><br><span class="line"></span><br><span class="line">class Rational(object):#以1&#x2F;3,3&#x2F;5为例，输出加法</span><br><span class="line"></span><br><span class="line">     #初始化类</span><br><span class="line">     def __init__(self,numer,denom &#x3D; 1):</span><br><span class="line">         print(&quot;in constuctor&quot;)</span><br><span class="line">         self.numer &#x3D; numer</span><br><span class="line">         self.deom &#x3D; denom</span><br><span class="line"></span><br><span class="line">     def __str__(self):</span><br><span class="line">         print(&quot;in str&quot;)</span><br><span class="line">         return str(self.numer) + &quot;&#x2F;&quot; + str(self.deom)</span><br><span class="line"></span><br><span class="line">     def __repr__(self):</span><br><span class="line">         print(&quot;in repr&quot;)</span><br><span class="line">         return self.__str__()</span><br><span class="line"></span><br><span class="line">     #定义分数的加法</span><br><span class="line">     def __add__(self, f):</span><br><span class="line">         print(&quot; in add&quot;)</span><br><span class="line">         thelcm &#x3D; int(Rational1.lcm(self.deom,f.deom))</span><br><span class="line">         numeratorSum &#x3D; int((thelcm&#x2F;self.deom*self.numer)+(thelcm&#x2F;f.deom*f.numer))</span><br><span class="line">         return Rational(numeratorSum,thelcm)</span><br><span class="line"></span><br><span class="line">     #定义分数的减法</span><br><span class="line">     def __sub__(self, f):</span><br><span class="line">         print(&quot;in sub&quot;)</span><br><span class="line">         thelcm &#x3D; Rational1.lcm(self.deom,f.deom)</span><br><span class="line">         numeratorSub &#x3D; (thelcm&#x2F;self.deom*self.numer)-(thelcm&#x2F;f.deom*f.numer)</span><br><span class="line">         return Rational(numeratorSub,thelcm)</span><br><span class="line"></span><br><span class="line">onehalf &#x3D; Rational(1,3)</span><br><span class="line">threefive &#x3D; Rational(3,5)</span><br><span class="line">thesum &#x3D; onehalf + threefive</span><br><span class="line">print(thesum)</span><br></pre></td></tr></table></figure>
<p>有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前 20 项之和。</p>
<p>#方法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def g(n):</span><br><span class="line">  if n &lt;&#x3D; 2:</span><br><span class="line">    return n</span><br><span class="line">  else:</span><br><span class="line">    return g(n-1) + g(n-2)</span><br><span class="line">sum &#x3D; 0</span><br><span class="line">for i in range(1,21):</span><br><span class="line">  sum +&#x3D; g(i+1)&#x2F;g(i)</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<p>#方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numerator &#x3D; 2</span><br><span class="line">denominator &#x3D; 1</span><br><span class="line">sum &#x3D; 0</span><br><span class="line">while True:</span><br><span class="line">  try:</span><br><span class="line">    n &#x3D; int(input(&quot;请输入一个整数：&quot;))</span><br><span class="line">  except ValueError:</span><br><span class="line">    print(&quot;输入错误，请输入整数&quot;)</span><br><span class="line">  else:</span><br><span class="line">    for i in range(n):</span><br><span class="line">      sum +&#x3D; numerator &#x2F; denominator</span><br><span class="line">      numerator, denominator &#x3D; numerator + denominator, numerator</span><br><span class="line"></span><br><span class="line">    print(sum)</span><br><span class="line">    break</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之求平均数</title>
    <url>/2021/03/06/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B1%82%E5%B9%B3%E5%9D%87%E6%95%B0/</url>
    <content><![CDATA[<h3 id="Python-之读取列表元素个数、元素求和元素平均"><a href="#Python-之读取列表元素个数、元素求和元素平均" class="headerlink" title="Python 之读取列表元素个数、元素求和元素平均"></a>Python 之读取列表元素个数、元素求和元素平均</h3><p>读取列表元素用到的函数：</p>
<p>len()函数</p>
<p>实例：现有一个列表，存放了小区邻居的工资收入，list=[10000,8500,9000,7000,8000,8000,9000,20000,15000,16000,5000]，算一下小区邻居的平均工资收入</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictureseef2741d78243c6b51ba9180cc203ef3.png" alt="eef2741d78243c6b51ba9180cc203ef3"></p>
</div>

<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/picturesc391d7835ab2cf5bf3b9da5c41a5e18e.png" alt="c391d7835ab2cf5bf3b9da5c41a5e18e"></p>
</div>

<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures852fe91c94e35072c8ab501a55a98340.png" alt="852fe91c94e35072c8ab501a55a98340"></p>
</div>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之趣味算法入门</title>
    <url>/2021/03/06/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%B6%A3%E5%91%B3%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="趣味算法入门"><a href="#趣味算法入门" class="headerlink" title="趣味算法入门"></a>趣味算法入门</h3><p>1.百钱买百鸡：中国古代数学家张丘建在他的《算经》中提出了一个著名的 “ 百钱百鸡问题 “： 一只公鸡值五钱，一只母鸡值三钱，三只小鸡值一钱，现在要用百钱买百鸡，请问公鸡、母鸡、小鸡各多少只？</p>
<p>#答案示例如下;</p>
<p>import time #导入 time 模块,以用来计算程序运行的时间,可忽视</p>
<p>time.perf_counter() #与 time 模块中计算时间有关,可忽视</p>
<p>#主体代码块如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for cock in range(0,20):</span><br><span class="line">    for hen in range(0,33-cock):</span><br><span class="line">        chicken&#x3D;100-cock-hen</span><br><span class="line">        if chicken%3&#x3D;&#x3D;0:</span><br><span class="line">            if 5 * cock + 3 * hen + chicken &#x2F; 3 &#x3D;&#x3D; 100:</span><br><span class="line">                print(&#39;公鸡&#123;&#125;只，母鸡&#123;&#125;只，小鸡&#123;&#125;只&#39;.format(cock,hen,chicken))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(time.perf_counter())  #打印出程序运行的时间,可忽视</span><br></pre></td></tr></table></figure>
<p>#解本问题有多种方法，我只写了一种方法，读者可以自己尝试各种方法，再用 time 模块计算每种方法的运行时间。</p>
<p>补充：算法是解决特定问题的方法，是程序设计的基础，是程序设计的灵魂。作为一个算法， 应具备 5 个特性，即有穷性、确定性、可行性、输入和输出。计算机算法可分为两大类， 分别是数值计算算法和非数值计算算法，数值计算的目的是求解数值，例如求方程的根；非数值计算算法主要用于处理事务领域的问题，如排序、查找等。</p>
<p>问题分析:用百钱如果只买公鸡，最多可以买 20 只，但题目要求买一百只，由此可知，所买公鸡的数量肯定在 0-20 之间，同理，母鸡的数量在 0~33 之间在。此把公鸡、母鸡和小鸡的数量分别设为 cock、hen、chicken, 则 cock+hen+chicken=100,因此百钱买百鸡问题就转化成解不定方程组 cock + hen + chicken == 100 和 5 x cock + 3 x hen +chicken/3=100 的问题了。</p>
<p>3.三天打鱼两天晒网：某人从 1990 年 1 月 1 日起开始‘三天打鱼两天晒网’，问这个人在以后的某一天是‘打鱼’还是‘晒网’</p>
<p>提示：闰年为可以被 4 整除并且不能被 100 整除或者能被 400 整除，2 月为 29 天，1 年为 366 天；平年 2 月为 28 天</p>
<p>#解题方法示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time #导入 time 模块,以用来计算程序运行的时间,可忽视</span><br><span class="line"></span><br><span class="line">time.perf_counter() #与 time 模块中计算时间有关,可忽视</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    year&#x3D;int(input(&#39;请输入年份，格式为1900?:&#39;))</span><br><span class="line">    month&#x3D;int(input(&#39;请输入月份，格式为01:&#39;).strip(&#39;0&#39;))</span><br><span class="line">    day&#x3D;int(input(&#39;请输入日期，格式为1:&#39;))</span><br><span class="line">    i&#x3D;0</span><br><span class="line">    daymonth&#x3D;0</span><br><span class="line">    dayear &#x3D; (year - 1900) * 365</span><br><span class="line">    for oneyear in range(1900,year+1):</span><br><span class="line">        if (oneyear % 4 &#x3D;&#x3D; 0 and oneyear % 100 !&#x3D; 0) or oneyear % 400 &#x3D;&#x3D; 0:</span><br><span class="line">            dayear+&#x3D;1</span><br><span class="line">    for i in range(1,month):</span><br><span class="line">        if i in [1,3,5,7,8,10,12]:</span><br><span class="line">            daymonth &#x3D; daymonth + 31</span><br><span class="line">        elif i &#x3D;&#x3D; 2:</span><br><span class="line">            if (year % 4 &#x3D;&#x3D; 0 and year % 100 !&#x3D; 0) or year % 400 &#x3D;&#x3D; 0:</span><br><span class="line">                daymonth &#x3D; daymonth + 28</span><br><span class="line">            else:</span><br><span class="line">                daymonth &#x3D; daymonth + 29</span><br><span class="line">        else:</span><br><span class="line">            daymonth &#x3D; daymonth + 30</span><br><span class="line">    totalday &#x3D; dayear + daymonth + day</span><br><span class="line">    if totalday % 5 in [1,2,3]:</span><br><span class="line">        print(&#39;这一天是打鱼&#39;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;这一天是晒网&#39;)</span><br><span class="line">except:</span><br><span class="line">    print(&#39;输入的类型有误&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(time.perf_counter())  #打印出程序运行的时间,可忽视</span><br></pre></td></tr></table></figure>
<p>#解本问题有多种方法，我只写了一种方法，读者可以自己尝试各种方法，再用 time 模块计算每种方法的运行时间。</p>
<p>4.抓住交通肇事犯:一卡车违反交通规则,撞人后逃跑.现场有三人目击改事件,陈述如下:</p>
<p>甲:牌照的前两位数字是相同的;乙:牌照的后两位数字是相同的;但与前两位不同;丙:四位的车号刚好是一位整数的平方.</p>
<p>#解题方法示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c &#x3D; 1    #同等于c &#x3D; True，但运行效率高</span><br><span class="line">if c:</span><br><span class="line">    for i in range(1,10):</span><br><span class="line">        a &#x3D; i</span><br><span class="line">        if c :</span><br><span class="line">            for i in range(0,10):</span><br><span class="line">                b &#x3D; i</span><br><span class="line">                if a !&#x3D; b and c:</span><br><span class="line">                    x &#x3D; a*1000+a*100+b*10+b</span><br><span class="line">                    y &#x3D; x**(1&#x2F;2)</span><br><span class="line">                    if y-int(y) &#x3D;&#x3D; 0:</span><br><span class="line">                        print(x)</span><br><span class="line">                        c&#x3D;0    #同等于 c &#x3D; False</span><br></pre></td></tr></table></figure>
<p>#解本问题有多种方法，此方法并不是标准答案，读者可以自己尝试各种方法</p>
<p>5.兔子产子问题:有一对兔子,自从出生后的第三个月起每个月都生一对兔子.小兔子长到第三个月后每个月又生一对兔子,假设所有兔子都不死,问三十个月内每个月的兔子总数为多少?</p>
<p>#解题方法示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fib1 &#x3D; 1</span><br><span class="line">fib2 &#x3D; 1</span><br><span class="line">month &#x3D; 1</span><br><span class="line">while month &lt;31 :</span><br><span class="line">    if month &lt;&#x3D; 2:</span><br><span class="line">        print(&#39;第&#123;&#125;月的兔子个数为&#123;&#125;&#39;.format(month,fib1))</span><br><span class="line">        month +&#x3D;1</span><br><span class="line">    else:</span><br><span class="line">        fib &#x3D; fib1 + fib2</span><br><span class="line">        print(&#39;第&#123;&#125;月的兔子个数为&#123;&#125;&#39;.format(month,fib))</span><br><span class="line">        month +&#x3D; 1</span><br><span class="line">        fib2 &#x3D; fib1</span><br><span class="line">        fib1 &#x3D; fib</span><br></pre></td></tr></table></figure>
<p>#方法再次改进，减少参数的使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fib1 &#x3D; 1</span><br><span class="line">fib2 &#x3D; 1</span><br><span class="line">month &#x3D; 1</span><br><span class="line">while month &lt;31 :</span><br><span class="line">    if month &lt;&#x3D; 2:</span><br><span class="line">        print(&#39;第&#123;&#125;月的兔子个数为&#123;&#125;&#39;.format(month,fib1))</span><br><span class="line">        month +&#x3D;1</span><br><span class="line">    else:</span><br><span class="line">        fib1 &#x3D; fib1 + fib2</span><br><span class="line">        fib2 &#x3D; fib1 + fib2</span><br><span class="line">        print(&#39;第&#123;&#125;月的兔子个数为&#123;&#125;&#39;.format(month,fib1))</span><br><span class="line">        print(&#39;第&#123;&#125;月的兔子个数为&#123;&#125;&#39;.format(month+1,fib2))</span><br><span class="line">        month +&#x3D; 2</span><br></pre></td></tr></table></figure>
<p>#解本问题有多种方法，此方法并不是标准答案，读者可以自己尝试各种方法</p>
<p>6.牛顿迭代法求方程的根：方程为：ax<strong>3 + bx</strong>2 + cx + d = 0,系数 a,b,c,d 由主函数输入。</p>
<p>求 x 在 1 附近的一个实根。求出根后，由主函数输出。<br>牛顿迭代法的公式是：x = x0 - f(x0)/f’(x0) 设迭代到|x-x0|&lt;=10**-5 时结束。</p>
<p>#解题方法示例如下;</p>
<p>#输入方程的系数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; int(input(&#39;请输入a的值：&#39;))</span><br><span class="line">b &#x3D; int(input(&#39;请输入b的值：&#39;))</span><br><span class="line">c &#x3D; int(input(&#39;请输入c的值：&#39;))</span><br><span class="line">d &#x3D; int(input(&#39;请输入d的值：&#39;))</span><br><span class="line"></span><br><span class="line">#用牛顿迭代法求方程的根</span><br><span class="line"></span><br><span class="line">x &#x3D; 1.5</span><br><span class="line">i &#x3D;1                            #随机定义一个i的值，是其能够进入while循环语句</span><br><span class="line"></span><br><span class="line">while i &gt;&#x3D;  1e-5:               #（1e-5 &#x3D; 10**-5）</span><br><span class="line">    x0 &#x3D; x                      #用所得的x代替x0原来的值</span><br><span class="line">    f &#x3D; ((a*x0+b)*x0+c)*x0 +d   #f用来描述方程的值</span><br><span class="line">    fd &#x3D; (3*a*x0 + 2*b)*x0 +c   #fd用来描述方程求导之后的值</span><br><span class="line">    x &#x3D; x0 - f&#x2F;fd               #求得更接近方程根的x的值</span><br><span class="line">    i &#x3D; abs(x - x0)</span><br><span class="line"></span><br><span class="line">#输出所求方程的根</span><br><span class="line"></span><br><span class="line">print(&#39;方程的一个根为：&#123;:7f&#125;&#39;.format(x))  #format的格式化输出，输出保留7位小数的浮点数。</span><br></pre></td></tr></table></figure>
<p>#解本问题有多种方法，此方法并不是标准答案，读者可以自己尝试各种方法<br>问题分析：</p>
<p>​ 牛顿迭代法是取 x0 之后，在这个基础上，找到比 x0 更接近的方程的根，一步一步迭代，从而找到更接近方程的近似根。</p>
<p>​ 设 r 是 f(x)=0 的根，选取 x0 作为 r 的初始近似值。过点（x0, f(x0))作为曲线 y = f(x)的切线 L，L 的方程为 y = f(x0) +f‘(x0)(x-x0)，求出 L 于 x 轴交点的横坐标 x1 = x0 -f(x0)/f’(x0)，称 x1 为 r 的一次近似值，过点（x1, f(x1))作为曲线 y = f(x)的切线并求改切线于 x 轴的横坐标 x2 = x1 -f(x1)/f’(x1)，称 x2 为 r 的二次近似值，重复以上过程，得 r 的近似值 xn。上述即为牛顿迭代法的求解过程。</p>
<p>​ 算法设计：</p>
<p>在 1 附近找任意一实数作为 x0 的初值，我们去 1.5，即 x0 = 1.5. 用初值 x0 带入方程中计算此时的 f(x0)及 f’(x0)；程序中 f 用来描述方程的值，fd 用来描述方程求导之后的值。 计算增量 h=f/fd。 计算下一个 x （x = x0-h）。 用所得的 x 代替 x0 原来的值。 若|x - x0|&gt;=1e-5,则转到第三步继续执行，否则转到步骤 7 所求 x 就是方程的根，将其输出。<br>如果你喜欢我的文章,请滑到下方点个推荐再走. ，以给我动力哦；转载请注名出处。然后..请多来做客鸭。</p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路</title>
    <url>/2021/02/14/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文源自知乎网文，有学习的同感，故抄来以此鞭策自己。感谢原作者</p>
<p>&emsp;&emsp;首先不要觉着编程难，只要你认识 26 个英文字母，有一点点小学或初中的词汇量就完全没问题！！要在心理上对自己有信心，不就是个编程嘛，搞他！！抄我也得把他抄下来！！</p>
<a id="more"></a>

<p>&emsp;&emsp;作为过来人建议从最最基础的语法命令开始，能让自己有一个小小的成就感就行，不要贪大，比如打印显示出一句话都能有满满的成就感，从小小的成就感中一点点得体会编程的乐趣，这样心理的抵触感和恐惧会慢慢的消失，伴随而来的就是好奇与探索的欲望，久而久之就会去研究 python 的语法去掌握它。这个小小的成就感非常非常重要！！</p>
<p>&emsp;&emsp;总是有评论区知友问我，不知道如何从 0 入手来获得这种小小的成就感？这里统一回复一下：对于小白来说，有个人引导会比自学要高效的多，尤其容易坚持不下去的小伙伴。可以试试下面这个入门课程，不用本地安装 Python 环境，能直接在网页上敲代码，还有大牛老师的直播课带着入门，能少走很多弯路！只要跟着老师一行行的敲代码，坚持下来会发现其实学 Python 非常容易！</p>
<p>&emsp;&emsp;如果你学完了上面的基础训课程，接下来，可以给自己设立个小目标，来学以致用，比如要用 Python 解决工作或学习中的一个重复复制粘贴的小问题！经过自己查找搜索发现 Python 可以用爬虫解决我这个问题，那就搞他！！</p>
<p>&emsp;&emsp;站在巨人的肩膀上，先去搜一搜有没有几行代码的小爬虫案例，肯定有的，就拿最简单的，爬百度首页，不管是啥，先一把梭，照着代码敲一遍，然后运行，肯定能出来东西，不管是正确结果还是报错，先跑一遍再说！！</p>
<p>&emsp;&emsp;精读代码，滤清思路，照葫芦画瓢，先看看都用了哪些第三方包，爬虫的话觉对是 requests 库了，顾名思义，就是发送请求接受请求的库，如果还不明白就是把这个库想象成你的浏览器，现在他是另一种浏览器了，只是没有界面。不用鼠标点击访问网页，而是用另一种方式，请求和响应，看明白响应的 HTML 代码咋解析呀，网上一搜，就有了另一个库 bs4，以此类推，然后试着用这个代码去请求一下自己的那个目标网址试试看看都返回啥。</p>
<p>&emsp;&emsp;学习过程中，缺啥补啥！哪里不会补哪里！后面你就会了解到 python 除了可以写爬虫，还可以做网站，可以做数据分析，期间就会遇到更底层的困难，emmm 做网络应该更了解一些网络协议，类似 http 协议，以及握手挥手原理，数据请求原理等。</p>
<p>&emsp;&emsp;同时就还需要抓包工具的使用配置，json 等数据格式的学习，html 的学习，js 的学习，总之会发现自己遇到的困难一个接一个，需要的前置知识需要一个坑一个坑的去填，这些应该比较痛苦，但是其乐无穷。</p>
<p>&emsp;&emsp;基础要精通，勤加练习，多看书！python 本身语法学习中还会在面向对象这个概念中卡住，因为之前的语法都是面向过程，写个函数封装起来就完事了，后来遇到面向对象，思路就要转变一下了，三大特性，类的概念，继承，对象，多态，封装，以及各种魔法函数，需要大量练习和理解。</p>
<p>&emsp;&emsp;后来基本的书籍已经满足不了自己了，就去看流畅的 python ，cookbook 等书籍，发现 python 还有很多的特性需要掌握，实在是学无止境。<br>&emsp;&emsp;这些还是 python 语法本身，后面的 python 爬虫就要学习除了网络协议，抓包，以及各种 requests 库，还要学习提高速度多线程，多进程，分布式的抓取，另外还会需要代理 ip，伪登录，等难题。</p>
<p>&emsp;&emsp;在抓数据上已经费了老劲了，接下来就要存数据，数据库得学习一下 mysql sql 语句 mongodb ，redis 都得学习下。</p>
<p>&emsp;&emsp;好不容易存好了数据，就要去分析了，numpy pandas 就又要学习各种函数去学习，于是就又找了一本利用 python 进行数据分析的书。<br>&emsp;&emsp;使劲看完之后，分析数据也差不多了，就要考虑数据展示了，matplotlib seaborn echart 就要学习了 js 语言也要学习了，于是折腾一波，就可以做出基本的数据图表了。</p>
<p>&emsp;&emsp;然后又希望展示到网站，让同事看，于是就又要学习 django flask 这样的网络框架，一顿猛学之后基本就可以展示了。后来发现自己需要优化一下网站，性能更高，耦合度更小一些，要做成前后端分离的形式，于是又去学了 restful 的开发方式和 vue 框架，实现前后端分离。</p>
<p>&emsp;&emsp;后面发现自己的数据分析深度不太够，于是又恶补了一些统计学的知识，于是又进了统计学到机器学习到深度学习的深坑，于是自然语言处理，计算机视觉，这些依靠神经网络的技术也就入门了，当然这些需要一点点的死磕，从线性代数到手写神经网络，到应用框架一步步理解其原理，是最有乐趣的。</p>
<p>&emsp;&emsp;总之小白学 Python 方法总比困难多！你要问我最大的困难是什么？我的答案是如何高度保持持续进取学习应用的好奇心与耐心是最困难的。<br>&emsp;&emsp;编程是一个全新的世界，就像学英语，打开了英语世界，那么编程就是打开了全新的编程世界，日常那些重复的问题、报表等，都变得苍白无力！困难与乐趣同在！</p>
<p>&emsp;&emsp;最后！记录，搜索，基础，这三个很重要！！找个地方写博客记录自己学习历程很重要，解决了任何问题都记录下来，比如这个知乎专栏啥的，不会的问题多搜索答案，肯定能搜到！，反复练习基础语法，理解基础知识，看书，看视频都可以！</p>
<p>&emsp;&emsp;加油吧！人生没有无意义的努力，现在的付出，将来一定会有回报，说不定什么时候就用到了</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Python寻找素数</title>
    <url>/2021/03/21/Python%E5%AF%BB%E6%89%BE%E7%B4%A0%E6%95%B0/</url>
    <content><![CDATA[<h3 id="找素数，利用-else"><a href="#找素数，利用-else" class="headerlink" title="找素数，利用 else"></a>找素数，利用 else</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k &#x3D; 0</span><br><span class="line">for num in range(2, 101):  # 生成从2到100的序列</span><br><span class="line">    for i in range(2, num):</span><br><span class="line">        if num % i &#x3D;&#x3D; 0:</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;生成的素数有:&#123;&#125;&#39;.format(num))</span><br><span class="line">        k +&#x3D; 1</span><br><span class="line"></span><br><span class="line">print(&#39;\n100以内的素数共有&#123;&#125;个&#39;.format(k))</span><br></pre></td></tr></table></figure>
<h3 id="自由输入求素数个数"><a href="#自由输入求素数个数" class="headerlink" title="自由输入求素数个数"></a>自由输入求素数个数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">is_notprime &#x3D; [] #定义空列表，存放非素数</span><br><span class="line">is_prime &#x3D; []    #定义空列表，存放素数</span><br><span class="line"></span><br><span class="line">num &#x3D; input(&#39;Enter some numbers:&#39;).split()  # 由键盘输入一些数字，并以空格分隔</span><br><span class="line"></span><br><span class="line">num_list &#x3D; [int(j) for j in num]      # 用列表推导式并加以强制类型转换把输入的字符数字转换成 int 类型数据</span><br><span class="line"></span><br><span class="line">for s in num_list:</span><br><span class="line">    for i in range(2, s):</span><br><span class="line">        if s % i &#x3D;&#x3D; 0:</span><br><span class="line">            is_notprime.append(s)    # 将非素数添加到非素数空列表</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        is_prime.append(s)   #将是素数的数字添加到素数列表</span><br><span class="line"></span><br><span class="line"># 输出非素数及素数</span><br><span class="line">print(f&#39;非素数的数字有:&#123;is_notprime&#125;&#39;)</span><br><span class="line">print(f&#39;素数的数字有:&#123;is_prime&#125;&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="格式化求阶乘法"><a href="#格式化求阶乘法" class="headerlink" title="格式化求阶乘法"></a>格式化求阶乘法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def jiecheng(n):</span><br><span class="line">    result &#x3D; 1</span><br><span class="line">    while n&gt;0:</span><br><span class="line">        result *&#x3D;n</span><br><span class="line">        n -&#x3D;1</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">for i in range(1,4):</span><br><span class="line">    re &#x3D; jiecheng(i)</span><br><span class="line">    print(f&#39;&#123;i&#125;的阶乘为:&#123;re&#125;&#39;)</span><br><span class="line">#     print()</span><br></pre></td></tr></table></figure>
<h3 id="寻找素数"><a href="#寻找素数" class="headerlink" title="寻找素数"></a>寻找素数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">寻找素数</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">def is_prime(n):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    判断一个数是否是素数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if n &lt;&#x3D; 1:</span><br><span class="line">        return False</span><br><span class="line">    for i in range(2, int(math.sqrt(n) + 1)):</span><br><span class="line">        if n % i &#x3D;&#x3D; 0:</span><br><span class="line">            return False</span><br><span class="line">    return True</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    primes &#x3D; [i for i in range(2,100) if is_prime(i)]    #从 2 开始，因为 1 显然不是质数</span><br><span class="line">    print (primes)</span><br></pre></td></tr></table></figure>
<h3 id="一元二次方程求解"><a href="#一元二次方程求解" class="headerlink" title="一元二次方程求解"></a>一元二次方程求解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">solving a quadratic equation</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">from __future__ import division</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">def quadratic_equation(a,b,c):</span><br><span class="line">    delta &#x3D; b*b - 4*a*c</span><br><span class="line">    if delta&lt;0:</span><br><span class="line">        return False</span><br><span class="line">    elif delta&#x3D;&#x3D;0:</span><br><span class="line">        return -(b&#x2F;(2*a))</span><br><span class="line">    else:</span><br><span class="line">        sqrt_delta &#x3D; math.sqrt(delta)</span><br><span class="line">        x1 &#x3D; (-b + sqrt_delta)&#x2F;(2*a)</span><br><span class="line">        x2 &#x3D; (-b - sqrt_delta)&#x2F;(2*a)</span><br><span class="line">        return x1, x2</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print (&quot;a quadratic equation: x^2 + 2x + 1 &#x3D; 0&quot;)</span><br><span class="line">    coefficients &#x3D; []</span><br><span class="line">    a &#x3D; input(&#39;Enter some numbers:&#39;).split( )</span><br><span class="line">    for i in a:</span><br><span class="line">        coefficients.append(int(i))</span><br><span class="line">    roots &#x3D; quadratic_equation(*coefficients)</span><br><span class="line">    if roots:</span><br><span class="line">        print (&quot;the result is:&quot;,roots)</span><br><span class="line">    else:</span><br><span class="line">        print (&quot;this equation has no solution.&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python序列得到所有元素索引及值的方法</title>
    <url>/2021/02/14/Python%E5%BA%8F%E5%88%97%E5%BE%97%E5%88%B0%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="元祖序列的索引及值"><a href="#元祖序列的索引及值" class="headerlink" title="元祖序列的索引及值"></a>元祖序列的索引及值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; (18,20,&#39;黄&#39;,True,1.2)</span><br><span class="line">for i in range(len(x)):</span><br><span class="line">    print(&#39;这是第&#123;&#125;个字符&#123;&#125;&#39;.format(str(i+1),str(x[i])))</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是第1个字符18</span><br><span class="line">这是第2个字符20</span><br><span class="line">这是第3个字符黄</span><br><span class="line">这是第4个字符True</span><br><span class="line">这是第5个字符1.2</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="获取列表中元素的索引位置"><a href="#获取列表中元素的索引位置" class="headerlink" title="获取列表中元素的索引位置"></a>获取列表中元素的索引位置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;new&#39;, &#39;D&#39;, &#39;z&#39;, &#39;example&#39;, &#39;new&#39;, &#39;two&#39;, &#39;elements&#39;]</span><br><span class="line">print(list1.index(&#39;example&#39;))</span><br><span class="line">print(list1.index(&#39;new&#39;))</span><br><span class="line">print(list1.index(&#39;z&#39;))</span><br><span class="line">print(&#39;c&#39; in list1)</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myList &#x3D; [&#39;Google&#39;, &#39;Runoob&#39;, 1997, &#39;Runoob&#39;]</span><br><span class="line">myListlength &#x3D; len(myList)</span><br><span class="line">print (&#39; 长度为：&#39; + str (myListlength))</span><br><span class="line">for x in myList:</span><br><span class="line">    idx &#x3D; myList.index(x, )</span><br><span class="line">    idxStr &#x3D; str(idx)</span><br><span class="line">#     print(idxStr)</span><br><span class="line">    print(idxStr ,end&#x3D;&#39;&#39;)</span><br><span class="line">    print(&quot;,&quot; + str(x))</span><br><span class="line">    </span><br><span class="line">print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line"></span><br><span class="line">for y in range(myListlength):</span><br><span class="line">    print(str(y) + &quot; , &quot; + str(myList[y]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码的结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">长度为：4</span><br><span class="line">0,Google</span><br><span class="line">1,Runoob</span><br><span class="line">2,1997</span><br><span class="line">1,Runoob</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0 , Google</span><br><span class="line">1 , Runoob</span><br><span class="line">2 , 1997</span><br><span class="line">3 , Runoob</span><br></pre></td></tr></table></figure>
<h3 id="下面的例子使用-L-列表，找到-2-所在的位置："><a href="#下面的例子使用-L-列表，找到-2-所在的位置：" class="headerlink" title="下面的例子使用 L 列表，找到 2 所在的位置："></a>下面的例子使用 L 列表，找到 2 所在的位置：</h3><h5 id="方法一，使用-enumerate-函数，它不仅可以直接列出位置，还可以列出值："><a href="#方法一，使用-enumerate-函数，它不仅可以直接列出位置，还可以列出值：" class="headerlink" title="方法一，使用 enumerate 函数，它不仅可以直接列出位置，还可以列出值："></a>方法一，使用 enumerate 函数，它不仅可以直接列出位置，还可以列出值：</h5><p><code>L = [2,4,5,6,2,6,0,4]</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i,j in enumerate(L):</span><br><span class="line">　　if j &#x3D;2:</span><br><span class="line">　　print(i,j)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0   2</span><br><span class="line"></span><br><span class="line">4   2</span><br></pre></td></tr></table></figure>
<h5 id="方法二，直接用-index-函数："><a href="#方法二，直接用-index-函数：" class="headerlink" title="方法二，直接用 index 函数："></a>方法二，直接用 index 函数：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [2,4,5,6,2,6,0,4]</span><br><span class="line">print(L.index(2))</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<pre><code>0 

4
</code></pre>
<h5 id="方法三，使用-for-循环："><a href="#方法三，使用-for-循环：" class="headerlink" title="方法三，使用 for 循环："></a>方法三，使用 for 循环：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [2,4,5,6,2,6,0,4] </span><br><span class="line"></span><br><span class="line">for i in L:</span><br><span class="line">　　if L[i] &#x3D;&#x3D; 2:</span><br><span class="line">　　print(i)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line"></span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h4 id="此处有个小知识点，找到某元素出现的第一个位置："><a href="#此处有个小知识点，找到某元素出现的第一个位置：" class="headerlink" title="此处有个小知识点，找到某元素出现的第一个位置："></a>此处有个小知识点，找到某元素出现的第一个位置：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [2,4,5,6,2,6,0,4]</span><br><span class="line">for i in L:</span><br><span class="line">　　if L[i] &#x3D;&#x3D; 2:</span><br><span class="line">　　print(i)</span><br><span class="line">　　break</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<pre><code>    0
</code></pre>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件操作练习</title>
    <url>/2021/03/21/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="文件操作练习，两数相加求和并输出到文件"><a href="#文件操作练习，两数相加求和并输出到文件" class="headerlink" title="文件操作练习，两数相加求和并输出到文件"></a>文件操作练习，两数相加求和并输出到文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;文件操作练习，两数相加求和并输出到文件&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    a1 &#x3D;input(&#39;Enter the first number(q or Q is quit):&#39;)   # 输入一个数或字母进行判断</span><br><span class="line">    if a1.lower() &#x3D;&#x3D; &#39;q&#39;:   # 如果输入的是q或者Q，则退出程序</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        a &#x3D; int(a1)      # 将输入的数字字符串强制转换成 int 整型数，进行计算</span><br><span class="line">        b &#x3D; int(input(&#39;Enter the second number:&#39;))</span><br><span class="line">        c &#x3D; str(a+b)</span><br><span class="line">        f &#x3D; open (&#39;d:&#x2F;out1.txt&#39;,&#39;a+&#39;)   #以追加的方式写入文件</span><br><span class="line">        f.write(f&#39;&#123;str(a)&#125; + &#123;str(b)&#125; &#x3D; &#123;c&#125;&#39; + &#39; \n&#39;)    # 格式化输出加法算式</span><br><span class="line">        f.seek(0)                                # 将鼠标指针移动到文件的开始处</span><br><span class="line">        print(f.read())   # 读出文件并打印输出到屏幕</span><br><span class="line">        f.close()         # 关闭文件</span><br></pre></td></tr></table></figure>
<h3 id="另一种写法，推荐使用"><a href="#另一种写法，推荐使用" class="headerlink" title="另一种写法，推荐使用"></a>另一种写法，推荐使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;out0.docx&#39;,&#39;a+&#39;) as f,\</span><br><span class="line">    open(&#39;out0.docx&#39;,&#39;r+&#39;) as f1:    # 可同时操作多个文件，注意格式，一定是在代码块内写</span><br><span class="line"></span><br><span class="line">    f.write(&#39;dkalkdlak&#39;)</span><br><span class="line">    f.write(&#39;123456&#39;)</span><br><span class="line">    f.seek(0)</span><br><span class="line">    print(f1.read())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件路径问题汇总</title>
    <url>/2021/02/14/Python%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="Python-中-os-listdir-函数用法"><a href="#Python-中-os-listdir-函数用法" class="headerlink" title="Python 中 os.listdir () 函数用法"></a>Python 中 os.listdir () 函数用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.listdir() </span><br></pre></td></tr></table></figure>
<p>语法格式：</p>
<blockquote>
<p>os.listdir(path)</p>
</blockquote>
<p>1、参数</p>
<blockquote>
<p>path—- 需要列出的目录路径</p>
</blockquote>
<p>2、返回值</p>
<blockquote>
<p>返回指定路径下的文件和文件夹列表。</p>
</blockquote>
<a id="more"></a>

<p>实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"> </span><br><span class="line">path &#x3D; r&#39;D:\APK\data1&#39;</span><br><span class="line">file_list &#x3D;os.listdir(path)</span><br><span class="line"></span><br><span class="line">print(file_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：1、2 为文件夹，123.txt 为文件</p>
<p><code>[&#39;Iris-setosa.xlsx&#39;, &#39;Iris-versicolor.xlsx&#39;, &#39;Iris-virginica.xlsx&#39;, &#39;文件夹 1&#39;, &#39;文件夹 2&#39;]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 输出所有文件和文件夹</span><br><span class="line">for filename in file_list:</span><br><span class="line">    print(filename)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210214151032.png" alt="20210214151032"> </p>
</div>

<h2 id="listdir-完整路径"><a href="#listdir-完整路径" class="headerlink" title="listdir 完整路径"></a>listdir 完整路径</h2><ul>
<li>列表推导式写法</li>
</ul>
<p><code>filenames=[os.path.join(file_folder, file) for file in os.listdir(file_folder)]</code></p>
<ul>
<li>for循环写法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for filename in file_list:</span><br><span class="line">    filedir &#x3D; os.path.join(path,filename)</span><br><span class="line">    print(filedir)</span><br></pre></td></tr></table></figure>
运行结果:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\APK\data1\Iris-setosa.xlsx</span><br><span class="line">D:\APK\data1\Iris-versicolor.xlsx</span><br><span class="line">D:\APK\data1\Iris-virginica.xlsx</span><br><span class="line">D:\APK\data1\文件夹 1</span><br><span class="line">D:\APK\data1\文件夹 2</span><br></pre></td></tr></table></figure>
<h2 id="python-中的-os-listdir-os-listdir-os-listdir-os-listdir-path-的区别"><a href="#python-中的-os-listdir-os-listdir-os-listdir-os-listdir-path-的区别" class="headerlink" title="python 中的 os.listdir (),os.listdir (.),os.listdir (..),os.listdir (path) 的区别"></a>python 中的 os.listdir (),os.listdir (.),os.listdir (..),os.listdir (path) 的区别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 为空时，默认为当前路径，返回当前路径下的文件名和文件夹名：</span><br><span class="line"></span><br><span class="line">os.listdir()</span><br><span class="line"></span><br><span class="line">2. 返回当前目录下的文件名和文件夹名:</span><br><span class="line"></span><br><span class="line">os.listdir(.)</span><br><span class="line"></span><br><span class="line">3. 当前上一级目录下的文件名和文件夹名:</span><br><span class="line"></span><br><span class="line">os.listdir(..)</span><br><span class="line"></span><br><span class="line">4. 某一具体目录下的文件名和文件夹名：</span><br><span class="line"></span><br><span class="line">os.listdir(path)</span><br></pre></td></tr></table></figure>
<h2 id="模块-os-中的-walk-函数"><a href="#模块-os-中的-walk-函数" class="headerlink" title="模块 os 中的 walk () 函数"></a>模块 os 中的 walk () 函数</h2><p>python 中 os.walk 是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情。</p>
<h3 id="1、导入模块"><a href="#1、导入模块" class="headerlink" title="1、导入模块"></a>1、导入模块</h3><p>要使用 os.walk, 首先要载入该函数</p>
<p>可以使用以下两种方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">from os import walk</span><br></pre></td></tr></table></figure>
<h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><p>os.walk 的函数声明为:</p>
<p><code>walk(top, topdown=True, οnerrοr=None, followlinks=False)</code></p>
<p>参数:</p>
<blockquote>
<p>top 是你所要便利的目录的地址</p>
</blockquote>
<p>topdown 为真，则优先遍历 top 目录，否则优先遍历 top 的子目录 (默认为开启)</p>
<p>onerror 需要一个 callable 对象，当 walk 需要异常时，会调用</p>
<p>followlinks 如果为真，则会遍历目录下的快捷方式 (linux 下是 symbolic link) 实际所指的目录 (默认关闭)</p>
<p>os.walk 的返回值是一个生成器 (generator), 也就是说我们需要不断的遍历它，来获得所有的内容。</p>
<p>每次遍历的对象都是返回的是一个三元组 (root,dirs,files)</p>
<ul>
<li>root 所指的是当前正在遍历的这个文件夹的本身的地址</li>
<li>dirs 是一个 list ，内容是该文件夹中所有的目录的名字 (不包括子目录)</li>
<li>files 同样是 list , 内容是该文件夹中所有的文件 (不包括子目录)</li>
<li>如果 topdown 参数为真，walk 会遍历 top 文件夹，与 top 文件夹中每一个子目录。</li>
</ul>
<h4 id="模块-os-中的-walk-函数可以遍历文件夹下所有的文件。"><a href="#模块-os-中的-walk-函数可以遍历文件夹下所有的文件。" class="headerlink" title="模块 os 中的 walk () 函数可以遍历文件夹下所有的文件。"></a>模块 os 中的 walk () 函数可以遍历文件夹下所有的文件。</h4><p><code>os.walk(top, topdown=Ture, onerror=None, followlinks=False)</code></p>
<p>该函数可以得到一个三元 tupple (dirpath, dirnames, filenames).</p>
<p>参数含义：</p>
<ul>
<li><p>dirpath：string，代表目录的路径；</p>
</li>
<li><p>dirnames：list，包含了当前 dirpath 路径下所有的子目录名字（不包含目录路径）；</p>
</li>
<li><p>filenames：list，包含了当前 dirpath 路径下所有的非目录子文件的名字（不包含目录路径）。</p>
</li>
<li><p>注意，dirnames 和 filenames 均不包含路径信息，如需完整路径，可使用 os.path.join (dirpath, dirnames)</p>
</li>
</ul>
<p>代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-  </span><br><span class="line"></span><br><span class="line">import os </span><br><span class="line"></span><br><span class="line">def file_name(file_dir):  </span><br><span class="line">  for root, dirs, files in os.walk(file_dir): </span><br><span class="line">    print(root) #当前目录路径 </span><br><span class="line">    print(dirs) #当前路径下所有子目录 </span><br><span class="line">    print(files) #当前路径下所有非目录子文件</span><br></pre></td></tr></table></figure>
<p>当需要特定类型的文件时，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*- </span><br><span class="line"></span><br><span class="line">import os </span><br><span class="line"></span><br><span class="line">def file_name(file_dir):  </span><br><span class="line">  L&#x3D;[]  </span><br><span class="line">  for root, dirs, files in os.walk(file_dir): </span><br><span class="line">    for file in files: </span><br><span class="line">      if os.path.splitext(file)[1] &#x3D;&#x3D; &#39;.jpeg&#39;: </span><br><span class="line">        L.append(os.path.join(root, file)) </span><br><span class="line">  return L</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line">import os</span><br><span class="line">mypath &#x3D; &quot;C:\\Users\\LiLong\\Desktop\\tt&quot;</span><br><span class="line"></span><br><span class="line">for root , dirs, files in os.walk(mypath):</span><br><span class="line">    print(root)</span><br><span class="line">    print(dirs)</span><br><span class="line">    print(files)</span><br><span class="line">print(&#39;..................................................&#39;)    </span><br><span class="line">for root,dirs,files in os.walk(mypath):</span><br><span class="line">    print(root)</span><br><span class="line">    for dr in dirs:</span><br><span class="line">        print(dr)</span><br><span class="line">    for name in files:</span><br><span class="line">        if name.endswith(&quot;.txt&quot;):</span><br><span class="line">            print(os.path.join(root, name))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">path &#x3D; &#39;&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#39;</span><br><span class="line">for root,dirs,files in os.walk(path):</span><br><span class="line">        print root,dirs,files</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort [&#39;test&#39;] [&#39;nameout.txt&#39;, &#39;namelist.txt&#39;, &#39;namesorttest.py&#39;]</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;test [] [&#39;nameout.txt&#39;, &#39;name2.txt&#39;, &#39;namelist.txt&#39;, &#39;namesort.py&#39;]</span><br></pre></td></tr></table></figure>
<h3 id="获得所有子文件路径（os-path-join-使用）"><a href="#获得所有子文件路径（os-path-join-使用）" class="headerlink" title="获得所有子文件路径（os.path.join 使用）"></a>获得所有子文件路径（os.path.join 使用）</h3><p>由于 os.walk 获得的并不是路径，所以需要将其内容进行连接得到路径。</p>
<p>这时使用 python 自带函数 os.path.join, 其语法为：</p>
<p><code>os.path.join(path1[, path2[, ...]])</code></p>
<p>其中嵌套的 [] 表示写在最前面的是高级目录，后面的是低级的，也就是按参数排列顺序拼接。</p>
<p>举例：</p>
<p><code>os.path.join(&quot;home&quot;, &quot;me&quot;, &quot;mywork&quot;)</code></p>
<p>在 Linux 系统上会返回 home/me/mywork</p>
<p>在 Windows 系统上会返回 home\me\mywork</p>
<blockquote>
<p>可能大家已经注意到了，此函数并不是简单的字符串连接函数，你不需要在输入的参数字符串中加入分隔符，函数会根据你的系统自动加入对应的分隔符，这也是这个函数存在的意义所在。</p>
</blockquote>
<p>所以我们正好使用 os.path.join() 来处理上面生成的遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">path &#x3D; &#39;&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#39;</span><br><span class="line">for root,dirs,files in os.walk(path):</span><br><span class="line">        for file in files:</span><br><span class="line">                print(os.path.join(root,file))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;nameout.txt</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;namelist.txt</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;namesorttest.py</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;test&#x2F;nameout.txt</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;test&#x2F;name2.txt</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;test&#x2F;namelist.txt</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;test&#x2F;namesort.py</span><br></pre></td></tr></table></figure>
<h4 id="接下来是大量的例子"><a href="#接下来是大量的例子" class="headerlink" title="接下来是大量的例子"></a>接下来是大量的例子</h4><p>Python– 遍历文件夹下所有文件和目录的方法（os.walk (rootdir) 函数返回一个三元素元祖）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import os.path</span><br><span class="line"></span><br><span class="line"># This folder is custom</span><br><span class="line">rootdir &#x3D; &#39;&#x2F;Users&#x2F;macbookpro&#x2F;Desktop&#x2F;test&#39;</span><br><span class="line">for parent, dirnames, filename in os.walk(rootdir):</span><br><span class="line">    # Case1: traversal the directories</span><br><span class="line">    for dirname in dirnames:</span><br><span class="line">        print(&quot;Parent folder:&quot;, parent)</span><br><span class="line">        print(&quot;Dirname:&quot;, filename)</span><br><span class="line">    # Case2: traversal the files</span><br><span class="line">    for filename in filenames:</span><br><span class="line">        print(&quot;Parent folder:&quot;, parent)</span><br><span class="line">        print(&quot;Filename:&quot;, filename)</span><br></pre></td></tr></table></figure>
<p>解释说明：os.walk (rootdir) 函数返回一个三元素元祖，其中 parent 是父目录，dirnames 是所有文件夹名字（不包含路径），filenames 是所有文件的名字（不包含路径）</p>
<p>以上，case1、case2 分别演示了遍历该文件夹下（/Users/macbookpro/Desktop/test）的所有目录、文件的方法</p>
<h4 id="1、综合例子"><a href="#1、综合例子" class="headerlink" title="1、综合例子"></a>1、综合例子</h4><p>简单的例子</p>
<p>保持目录 a 的目录结构，在 b 中创建对应的文件夹，并把 a 中所有的文件加上后缀 _bak</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">Root &#x3D; &#39;a&#39;</span><br><span class="line">Dest &#x3D; &#39;b&#39;</span><br><span class="line"></span><br><span class="line">for (root, dirs, files) in os.walk(Root):</span><br><span class="line">    new_root &#x3D; root.replace(Root, Dest, 1)</span><br><span class="line">    if not os.path.exists(new_root):</span><br><span class="line">        os.mkdir(new_root)</span><br><span class="line">    </span><br><span class="line">    for d in dirs:</span><br><span class="line">        d &#x3D; os.path.join(new_root, d)</span><br><span class="line">        if not os.path.exists(d):</span><br><span class="line">            os.mkdir(d)</span><br><span class="line">    </span><br><span class="line">    for f in files:</span><br><span class="line">        # 把文件名分解为 文件名.扩展名</span><br><span class="line">        # 在这里可以添加一个 filter，过滤掉不想复制的文件类型，或者文件名</span><br><span class="line">        (shotname, extension) &#x3D; os.path.splitext(f)</span><br><span class="line">        # 原文件的路径</span><br><span class="line">        old_path &#x3D; os.path.join(root, f)</span><br><span class="line">        new_name &#x3D; shotname + &#39;_bak&#39; + extension</span><br><span class="line">        # 新文件的路径</span><br><span class="line">        new_path &#x3D; os.path.join(new_root, new_name)</span><br><span class="line">        try:</span><br><span class="line">            # 复制文件</span><br><span class="line">            open(new_path, &#39;wb&#39;).write(open(old_path, &#39;rb&#39;).read())</span><br><span class="line">        except IOError as e:</span><br><span class="line">            print(e)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python求前n项阶乘和与平方和</title>
    <url>/2021/03/22/Python%E6%B1%82%E5%89%8Dn%E9%A1%B9%E9%98%B6%E4%B9%98%E5%92%8C%E4%B8%8E%E5%B9%B3%E6%96%B9%E5%92%8C/</url>
    <content><![CDATA[<h3 id="输入一个整数，计算阶乘然后求和"><a href="#输入一个整数，计算阶乘然后求和" class="headerlink" title="输入一个整数，计算阶乘然后求和"></a>输入一个整数，计算阶乘然后求和</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">factorial = <span class="number">1</span></span><br><span class="line">sum1 = <span class="number">0</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入一个整数，计算阶乘然后求和:&#x27;</span>))</span><br><span class="line">str1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">		factorial = factorial * j</span><br><span class="line">    print(<span class="built_in">str</span>(i) + <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, factorial)</span><br><span class="line">    sum1 = sum1 + factorial</span><br><span class="line">    factorial = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n != j:</span><br><span class="line">        str1 = str1 + <span class="built_in">str</span>(j) + <span class="string">&#x27;!+&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str1 = str1 + <span class="built_in">str</span>(j) + <span class="string">&#x27;!&#x27;</span></span><br><span class="line">print(str1, <span class="string">&#x27;=&#x27;</span>, sum1)</span><br></pre></td></tr></table></figure>
<h3 id="前-n-项数字之和平方用函数来写"><a href="#前-n-项数字之和平方用函数来写" class="headerlink" title="前 n 项数字之和平方用函数来写"></a>前 n 项数字之和平方用函数来写</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aSum</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> += i * i</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">print(aSum(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h3 id="for-循环来写"><a href="#for-循环来写" class="headerlink" title="for 循环来写"></a>for 循环来写</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">sum1 = <span class="number">0</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Type n:&#x27;</span>))</span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    total += i * i 				<span class="comment"># total += i **2  也是可以的</span></span><br><span class="line">    print(<span class="built_in">str</span>(i)+ <span class="string">&#x27;^2&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, total)</span><br><span class="line">    sum1 = sum1 + total</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n != i:</span><br><span class="line">        str1 = str1 + <span class="built_in">str</span>(i) + <span class="string">&#x27;^2+&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str1 = str1 + <span class="built_in">str</span>(i) + <span class="string">&#x27;^2&#x27;</span></span><br><span class="line">print(str1, <span class="string">&#x27;=&#x27;</span>, sum1)</span><br></pre></td></tr></table></figure>
<h3 id="平方和与平方和之差"><a href="#平方和与平方和之差" class="headerlink" title="平方和与平方和之差"></a>平方和与平方和之差</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_sum_difference</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>((<span class="number">3</span> * n ** <span class="number">2</span> + <span class="number">2</span> * n) * (<span class="number">1</span> - n ** <span class="number">2</span>) / <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">print(square_sum_difference(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_sum_difference</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(n * (n + <span class="number">1</span>) * (<span class="number">2</span> * n + <span class="number">1</span>) / <span class="number">6</span> - (n * (n + <span class="number">1</span>) / <span class="number">2</span>)** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(square_sum_difference(<span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<h3 id="前-n-项数字之和平方"><a href="#前-n-项数字之和平方" class="headerlink" title="前 n 项数字之和平方"></a>前 n 项数字之和平方</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_sum</span>(<span class="params">numbers</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,numbers+<span class="number">1</span>):</span><br><span class="line">        total = total + each</span><br><span class="line">    <span class="keyword">return</span> total ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">print(square_sum(<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python特性介绍</title>
    <url>/2021/06/26/Python%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><strong>所谓变量，在我理解下来应该是用来装内容的名字，百度上说是这样的</strong></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210618092121.png" alt="20210618092121"></p>
</div>

<p>在学 C 时，使用变量前都需要提前进行声明，而在python使用时不需要提前声明，只要想用就可以直接使用<br>举个栗子</p>
<p>大部分了解过的人，应该都能看出来，<br>变量有一些需要注意的地方</p>
<blockquote>
<p>在使用变量之前，需要先进行赋值</p>
<p>变量名可以用字母、数字、下划线，但不能用数字开头，这倒是和&gt; C一样</p>
<p>字母大小写是不同的</p>
<p>等号(＝)是赋值的意思，将右边的值赋给右边</p>
<p>尽量将变量名与要表达的意思一致</p>
</blockquote>
<h2 id="人们为什么使用python"><a href="#人们为什么使用python" class="headerlink" title="人们为什么使用python"></a>人们为什么使用python</h2><h3 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h3><ul>
<li>Python的设计侧重于代码的可读性，一致性和软件质量，这使得python与其他脚本语言区分开来。因Python强大的可读性，在维护性和重用性方面有很大的优势。Python也支持面向对象(OOP)，使得程序的重用性大大提升。</li>
</ul>
<h3 id="提高开发者的效率"><a href="#提高开发者的效率" class="headerlink" title="提高开发者的效率"></a>提高开发者的效率</h3><ul>
<li>相对于一些静态编译语言，java，C++等，python的代码量往往只有他们的1/5~1/3，这种代码量就意味值python就更具维护性，更能提高开发者的效率。并且Python语言可以立即运行，不需要传统语言的编译和链接等步骤。进一步提高了程序员的效率。</li>
</ul>
<h3 id="程序的可移植性"><a href="#程序的可移植性" class="headerlink" title="程序的可移植性"></a>程序的可移植性</h3><ul>
<li><p>Python程序可以在多个主流计算机平台运行，不需要修改代码。比如一些文件操作与管理等操作系统接口，在设计时，都考虑了程序的可移植性。</p>
<h3 id="标准库的支持"><a href="#标准库的支持" class="headerlink" title="标准库的支持"></a>标准库的支持</h3></li>
<li><p>Python有强大的标准库支持，这些标准库支持一系列的应用级编程任务。此外更多的还有很多python第三方支持工具，让Python有更强大的活力。</p>
</li>
</ul>
<h3 id="组件集成"><a href="#组件集成" class="headerlink" title="组件集成"></a>组件集成</h3><ul>
<li><p>python脚本可以灵活的与其他定制程序轻松地与应用程序的其他部分进行通信。这种集成可以让python成为名副其实的“胶水语言”，Python可以调用C，C++等程序，也可以被C,C++调用。</p>
<h3 id="享受乐趣"><a href="#享受乐趣" class="headerlink" title="享受乐趣"></a>享受乐趣</h3></li>
<li><p>应用级的编程享受，让开发者避免繁琐的编程工作，直接调用标准库或三方库，就能轻易完成自己的目标。</p>
</li>
</ul>
<h2 id="Python是脚本语言吗？"><a href="#Python是脚本语言吗？" class="headerlink" title="Python是脚本语言吗？"></a>Python是脚本语言吗？</h2><p>Python是一种多用途的编程语言，时常在扮演脚本语言的角色。一般来说，Python可定义为面向对象的脚本语言。实际上，往往人们从以下几个“角色”来使用Python：</p>
<ul>
<li>shell工具</li>
</ul>
<p>这只用到了Python语言价值的其中一小部分，这里的python常常用来调用其他程序，或者当作一个脚本处理任务，比如处理文本等等</p>
<ul>
<li>控制语言</li>
</ul>
<p>Python的简洁，可以让他在各个场合充当一个控制角色，比如控制各个相关设备及程序之间的沟通和测试，或者是充当相关不同程序之间的“连接层”。</p>
<ul>
<li>使用快捷</li>
</ul>
<p>常常充当“脚本程序”的Python，就意味着它有脚本一样的快捷性，但是它的功能与能力远远超出脚本的范畴。它的灵活性和便捷能更快提高开发速度，更增加了探索研究与递增的开发编程模式的效率（这也是Python在机器学习上热门的原因）。</p>
<h2 id="Python的缺点是什么？"><a href="#Python的缺点是什么？" class="headerlink" title="Python的缺点是什么？"></a>Python的缺点是什么？</h2><p>与C语言这类静态编译语言来说，Python的执行速度还不够快，目前的Python是将源码编译（或者说转化）为字节码，之后再将字节码解释出来，因为字节码是一种平台无关的格式，字节码就具有可移植性。python没有像C语言那样将代码编译成为二进制代码（可用于芯片的指令），所以Python没有静态编译语言的执行速度快。</p>
<p>Python在发展过程中，一直对执行速度再做改进，比如在解释器内部，一些需要执行速度的操作，往往是由c语言在执行，他们都有C语言的执行速度（Numpy就是一个双语言混编策略的一个重要例子）。总得来说，Python在开发过程中带来的收益比执行效率上的损失更为重要，尤其是在如今计算机的处理速度下。</p>
<h2 id="使用python能做些什么"><a href="#使用python能做些什么" class="headerlink" title="使用python能做些什么"></a>使用python能做些什么</h2><ul>
<li><p>系统编程： 对操作系统服务的内置接口，使其成为编写可移植的系统管理的维护工具和组件的理想语言。</p>
</li>
<li><p>用户图形接口：python快速，简洁的开发模式，十分适合GUI程序，一些内置的TKinter的标准面向对象接口，可以让python生成本地观感的GUI,并且可以通过可移植性，在任何操作平台上运行。</p>
</li>
<li><p>Internet脚本：python提供许多的网络接口和标准Internet模块，使得python在网络的服务器端或是客户端都能发挥巨大的作用。还有许多强大的第三方工具，让python在处理网络时有更多选择。</p>
</li>
<li><p>组件集成：Python作为控制语言时，曾涉及它的组件集成的角色。Python可以通过C/C++系统进行扩展，并能够嵌套C/C++系统的特性，使其成为一种灵活的黏合语言。</p>
</li>
<li><p>数据库编程：Python提供了对所有主流数据库系统的接口。</p>
</li>
<li><p>数值计算和科学计算编程</p>
</li>
</ul>
<h2 id="Python有哪些技术上的优点"><a href="#Python有哪些技术上的优点" class="headerlink" title="Python有哪些技术上的优点"></a>Python有哪些技术上的优点</h2><ul>
<li>面向对象：支持面向对象编程</li>
<li>免费开源</li>
<li>可移植：几乎在所有主流的操作系统上都能运行python</li>
<li>功能强大<ul>
<li>动态类型</li>
<li>自动内存管理：无需“垃圾回收”，Python能够代替你执行底层的内存管理</li>
<li>大型程序支持</li>
<li>内置对象类型</li>
<li>内置工具和齐全的第三方库工具</li>
<li>简单易用易学</li>
</ul>
</li>
</ul>
<h2 id="Python-编程快速上手，小白学习第一章课后习题1"><a href="#Python-编程快速上手，小白学习第一章课后习题1" class="headerlink" title="Python 编程快速上手，小白学习第一章课后习题1"></a>Python 编程快速上手，小白学习第一章课后习题1</h2><ul>
<li><p>print()函数将括号内的字符串显示在屏幕上–输出</p>
</li>
<li><p>input()函数 等待用户在键盘上输入一些文本，并按下回车键–输入</p>
</li>
<li><p>len()函数接受一个字符串，并求值为该字符串中字符的数目</p>
</li>
<li><p>+操作符只能加两个整数，或连接两个字符串。不能让一个整数和一个字符</p>
</li>
<li><p>串相加，这不符合python的语法。</p>
</li>
<li><p>str()、int()、float()函数将分别求值为传入的字符串、整数和浮点数形式。 </p>
</li>
<li><p>这里写代码片# This program says hello and asks for my name.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(‘Hello world !’) #print()函数将括号内的字符串显示在屏幕上</span><br><span class="line"></span><br><span class="line">print(‘What is your name ?’) # ask for their name</span><br><span class="line"></span><br><span class="line">myName&#x3D;input() #input()函数 等待用户在键盘上输入一些文本，并按下回车键</span><br><span class="line"></span><br><span class="line">print(‘hai~ I love you , ‘+myName)</span><br><span class="line"></span><br><span class="line">print(‘The length of your name is:’)</span><br><span class="line"></span><br><span class="line">print(len(myName)) #len()函数求值为一个整型，即字符串中字符的个数</span><br><span class="line"></span><br><span class="line">print(‘What is your age ?’) # ask for their age</span><br><span class="line"></span><br><span class="line">myAge&#x3D;input()</span><br><span class="line"></span><br><span class="line">print(‘You will be ‘+str(int(myAge)+1)+’ in a year.’)</span><br></pre></td></tr></table></figure>
<p>图示：</p>
</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210618095332.png" alt="20210618095332"></p>
</div>


<p>课后习题1</p>
<p>1．下面哪些是操作符，哪些是值？</p>
<p>‘hello’ -88.8 - / + 5<br>答：操作符包括 ：* 、-、/、+；值包括：’hello’、-88.8、5</p>
<p>2．下面哪个是变量，哪个是字符串？</p>
<p>spam（变量）</p>
<p>‘spam’（字符串）</p>
<p>3．说出 3 种数据类型。</p>
<p>答：整形（int）、浮点型（float）、字符串(str)</p>
<p>4．表达式由什么构成？所有表达式都做什么事？</p>
<p>答：表达式含”值”和”操作符”，并且总是可以求值</p>
<p>5．本章介绍了赋值语句，如 spam = 10。表达式和语句有什么区别？</p>
<p>答： 表达式：表达是某件事</p>
<p>语句：表达是做某件事</p>
<p>赋值语句包含一个变量名，一个等号，以及存储的值。而表达式是求值</p>
<p>8．为什么 eggs 是有效的变量名，而 100 是无效的？</p>
<p>变量名规则</p>
<p>遵从以下3条规则：</p>
<p>1.只能是一个词</p>
<p>2.只能包含字母 数字和下划线</p>
<p>3.不能以数字开头</p>
<p>100不满足第三条规则</p>
<p>9．哪 3 个函数能分别取得一个值的整型、浮点型或字符串版本？<br>10．为什么这个表达式会导致错误？如何修复？</p>
<p>答：需要转换类型’I have eaten ’ + str(99 )+ ’ burritos.’</p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python环境搭建</title>
    <url>/2021/04/24/Python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>其实 Python 已经是一个很老的编程语言了，到现在（2019 年） Python 已经高龄 28 岁，比很多程序员的年龄都大。现在之所以这么流行和社区、人工智能的发展，有很大的关系。</p>
<p>千里之行始于足下，今天我们先来学习 Python 环境搭建。</p>
<h2 id="Python-介绍"><a href="#Python-介绍" class="headerlink" title="Python 介绍"></a>Python 介绍</h2><p>Python（英国发音：/ˈpaɪθən/ 美国发音：/ˈpaɪθɑːn/）是一种广泛使用的解释型、高级编程、通用型编程语言，由吉多·范罗苏姆创造，第一版发布于 1991 年。可以视之为一种改良（加入一些其他编程语言的优点，如面向对象）的 LISP。</p>
<p>Python 的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。相比于 C++ 或 Java，Python 让开发者能够用更少的代码表达想法。不管是小型还是大型程序，该语言都试图让程序的结构清晰明了。</p>
<p>与 Scheme、Ruby、Perl、Tcl 等动态类型编程语言一样，Python 拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。</p>
<p>Python 解释器本身几乎可以在所有的操作系统中运行。Python 的其中一个解释器 CPython 是用 C 语言编写的、是一个由社群驱动的自由软件，当前由 Python 软件基金会管理。</p>
<p>1989 年的圣诞节期间，由 Python 的创始人为吉多·范罗苏姆，业余时间开发。Python 的历史参考：人生苦短，我用 Python。</p>
<p>注意：本系列教程基于 Python 3.X</p>
<h2 id="Python-环境搭建"><a href="#Python-环境搭建" class="headerlink" title="Python 环境搭建"></a>Python 环境搭建</h2><h3 id="Win-安装"><a href="#Win-安装" class="headerlink" title="Win 安装"></a>Win 安装</h3><p>打开 Python 官网 <a href="https://www.python.org/downloads/%E9%80%89%E6%8B%A9%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%88%96%E8%80%85%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E5%AF%B9%E5%BA%94%E7%9A%84%E7%89%88%E6%9C%ACpython-374%EF%BC%88https://www.python.org/downloads/release/python-374/%EF%BC%89%E3%80%82">https://www.python.org/downloads/选择最新版本下载，或者直接打开对应的版本python-374（https://www.python.org/downloads/release/python-374/）。</a><br>打开页面会看到有一个列表，如下图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures68579c3f12b9e7321a72454cb67e3861.jpg" alt="68579c3f12b9e7321a72454cb67e3861"></p>
</div>

<p>x86 是 32 位，x86-64 是 64 位。</p>
<p>可以通过下面 3 种途径获取 python：</p>
<ul>
<li>web-based installer 是需要通过联网完成安装的</li>
<li>executable installer 是可执行文件(*.exe)方- 式安装</li>
<li>embeddable zip file 嵌入式版本，可以集成到其它应用中。</li>
</ul>
<p>Windows x86 选择下载 ：[Windows executable installer(<a href="https://www.python.org/ftp/python/3.7.4/python-3.7.4.exe">https://www.python.org/ftp/python/3.7.4/python-3.7.4.exe</a>)</p>
<p>下载完成，双击 exe 文件进行安装，如下图，并按照圈中区域进行设置，切记要勾选打钩的框，然后再点击 Customize installation 进入到下一步：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures2e164557ffe9d9c976bb84642a738dfe.jpg" alt="2e164557ffe9d9c976bb84642a738dfe"></p>
</div>

<p>一路选择 Next，直至安装成功。</p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python统计list中各元素出现的次数</title>
    <url>/2021/02/14/Python%E7%BB%9F%E8%AE%A1list%E4%B8%AD%E5%90%84%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h3 id="用-python-统计-list-中各元素出现的次数（同理统计字符串中各字符出现的次数）"><a href="#用-python-统计-list-中各元素出现的次数（同理统计字符串中各字符出现的次数）" class="headerlink" title="用 python 统计 list 中各元素出现的次数（同理统计字符串中各字符出现的次数）"></a>用 python 统计 list 中各元素出现的次数（同理统计字符串中各字符出现的次数）</h3><p>统计 list 中各元素出现的次数，下面的方法也适用于统计字符串中各字符出现的次数</p>
<a id="more"></a>

<h4 id="1、用字典的形式来处理"><a href="#1、用字典的形式来处理" class="headerlink" title="1、用字典的形式来处理"></a>1、用字典的形式来处理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; &quot;abhcjdjje&quot;</span><br><span class="line"></span><br><span class="line">a_dict &#x3D; &#123;&#125;</span><br><span class="line">for i in a:</span><br><span class="line">　　a_dict[i] &#x3D; a.count(i)</span><br><span class="line">print(a_dict)</span><br></pre></td></tr></table></figure>
<p>结果如下:<br><code>&#123;&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;h&#39;: 1, &#39;c&#39;: 1, &#39;j&#39;: 3, &#39;d&#39;: 1, &#39;e&#39;: 1&#125;</code> </p>
<h4 id="2、用-count-函数直接打印出来"><a href="#2、用-count-函数直接打印出来" class="headerlink" title="2、用 count 函数直接打印出来"></a>2、用 count 函数直接打印出来</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [2,4,5,6,2,6,0,4]</span><br><span class="line">for i in L:</span><br><span class="line">　　print (&quot;% d 的次数:% d&quot;%(i,L.count (i)))</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2的次数:2</span><br><span class="line">4的次数:2</span><br><span class="line">5的次数:1</span><br><span class="line">6的次数:2</span><br><span class="line">2的次数:2</span><br><span class="line">6的次数:2</span><br><span class="line">0的次数:1</span><br><span class="line">4的次数:2</span><br></pre></td></tr></table></figure>
<h4 id="3、用-collections-的-Counter-函数"><a href="#3、用-collections-的-Counter-函数" class="headerlink" title="3、用 collections 的 Counter 函数"></a>3、用 collections 的 Counter 函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line">L &#x3D; [2,4,5,6,2,6,0,4]</span><br><span class="line">result &#x3D; Counter(L)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p><code>Counter(&#123;2: 2, 4: 2, 6: 2, 5: 1, 0: 1&#125;)</code></p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语法基础练习题</title>
    <url>/2021/03/06/Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h3 id="两数之间的素数个数（求素数算法大全）"><a href="#两数之间的素数个数（求素数算法大全）" class="headerlink" title="两数之间的素数个数（求素数算法大全）"></a>两数之间的素数个数（求素数算法大全）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、这种易理解</span><br><span class="line">L1 &#x3D; []</span><br><span class="line">count &#x3D; 0</span><br><span class="line">for x in range(1, 100):</span><br><span class="line">    n &#x3D; 0</span><br><span class="line">    for y in range(1, x + 1):</span><br><span class="line">        if x % y &#x3D;&#x3D; 0:</span><br><span class="line">            n &#x3D; n + 1</span><br><span class="line">    if n &#x3D;&#x3D; 2:</span><br><span class="line">        count +&#x3D;1</span><br><span class="line">        L1.append(x)</span><br><span class="line">print(L1)</span><br><span class="line">print(count)</span><br><span class="line"></span><br><span class="line">2、计算 2-100 之间素数的个数，返回结果。格式化字符串，标准</span><br><span class="line"></span><br><span class="line">def primeNum(f):</span><br><span class="line">    def f1():</span><br><span class="line">        sum_pri &#x3D; 0</span><br><span class="line">        for i in range(2,101):</span><br><span class="line">            for j in  range(2,i):</span><br><span class="line">                if i % j &#x3D;&#x3D; 0:</span><br><span class="line">                    break</span><br><span class="line">                elif j &#x3D;&#x3D; i - 1:</span><br><span class="line">                    sum_pri +&#x3D; 1</span><br><span class="line">        return f(sum_pri+1)</span><br><span class="line">    return f1</span><br><span class="line">@primeNum</span><br><span class="line">def f(p):</span><br><span class="line">    print(&quot;2-100之间共有&#123;&#125;个素数&quot;.format(p))</span><br><span class="line">f()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="批量生成虚拟姓名"><a href="#批量生成虚拟姓名" class="headerlink" title="批量生成虚拟姓名"></a>批量生成虚拟姓名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">firstname &#x3D; &#39;赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许&#39;</span><br><span class="line"></span><br><span class="line">second &#x3D; &#39;中万斯近元伟丽利国士文连百宏可立成海友南广云基&#39;</span><br><span class="line"></span><br><span class="line">third &#x3D; &#39;隆智渝顺乐天杰夫煜兵思霆炜祺亮剀炫翔维瑞韬嘉林庆玮勤栋源路焕霖彩明邦闻朵皓瀚荣奕涓艺&#39;</span><br><span class="line"></span><br><span class="line">namelist &#x3D; []</span><br><span class="line"></span><br><span class="line">many &#x3D; input(&#39;请输入需要生成姓名的数量:\n&#39;)</span><br><span class="line">for i in range(int(many)):</span><br><span class="line">    data &#x3D; [2,3]</span><br><span class="line">    namelen &#x3D; random.choice(data)</span><br><span class="line">    if namelen&#x3D;&#x3D;2:</span><br><span class="line">        newname &#x3D; random.choice(firstname)+random.choice(second)</span><br><span class="line">    else:</span><br><span class="line">        newname &#x3D; random.choice(firstname)+random.choice(second)+random.choice(third)</span><br><span class="line">    namelist.append(newname)</span><br><span class="line"></span><br><span class="line">print(&#39;生成的虚拟姓名列表为:\n&#39; + &#39;\n&#39;.join(namelist))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="初学函数，求幂指数练手程序"><a href="#初学函数，求幂指数练手程序" class="headerlink" title="初学函数，求幂指数练手程序"></a>初学函数，求幂指数练手程序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def jiecheng(num,zhishu):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    求一个数的幂指数</span><br><span class="line">    :param num:</span><br><span class="line">    :param zhi:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&#39;结果是：&#39;)</span><br><span class="line">    restult &#x3D; num ** zhi</span><br><span class="line">    return restult</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    num &#x3D; input(&#39;一个数\（输入q退出程序）:&#39;)</span><br><span class="line">    if num.lower() &#x3D;&#x3D;&#39;q&#39;:</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        num &#x3D; int(num)</span><br><span class="line">    zhi &#x3D; int(input(&#39;请输入这个数的指数：&#39;))</span><br><span class="line">    res &#x3D; jiecheng(num,zhishu)</span><br><span class="line">    print(&#39;最后的结果是:&#39;+ str(res))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="获取汉字区位码"><a href="#获取汉字区位码" class="headerlink" title="获取汉字区位码"></a>获取汉字区位码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def getcode(chinese):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取汉字对应的区位码</span><br><span class="line">    :param 单个汉字</span><br><span class="line">    :return:获取到的区位码</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    barry &#x3D; chinese.encode(&#39;gb2312&#39;)</span><br><span class="line">    code &#x3D; &#39;&#123;:02d&#125;&#39;.format(barry[0] - 160) + &#39;&#123;:02d&#125;&#39;.format(barry[1] - 160)</span><br><span class="line">    return code</span><br><span class="line">while 1:</span><br><span class="line">    name &#x3D; input(&#39;请输入姓名:&#39;)</span><br><span class="line">    for word in name:</span><br><span class="line">        print(word,getcode(word))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="python-文件操作"><a href="#python-文件操作" class="headerlink" title="python 文件操作"></a>python 文件操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 1)创建一个一级目录</span><br><span class="line">path &#x3D; &#39;c:\\demo&#39;</span><br><span class="line"></span><br><span class="line">if not os.path.exists(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line">    print(&#39;目录创建成功&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;目录已经存在&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2)删除一个一级目录</span><br><span class="line">path &#x3D; &#39;c:\\demo&#39;</span><br><span class="line">if os.path.exists(path):</span><br><span class="line">    os.rmdir(path)</span><br><span class="line">    print(&#39;目录删除成功&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;目录不存在&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="批量创建文件操作"><a href="#批量创建文件操作" class="headerlink" title="批量创建文件操作"></a>批量创建文件操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import datetime</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    path &#x3D; input(&#39;请输入文件保存地址：&#39;)</span><br><span class="line">    num &#x3D; int(input(&#39;请输入创建文件的数量：&#39;))</span><br><span class="line">    for i in range(num):</span><br><span class="line">        t &#x3D; datetime.datetime.now()</span><br><span class="line">        file &#x3D; os.path.join(path,t.strftime(&#39;%Y%m%d%H%M%S&#39;) + &#39;.txt&#39;)</span><br><span class="line">        open(file,&#39;w&#39;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">    print(&#39;创建成功！&#39;)</span><br><span class="line">    os.startfile(path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="函数求最大-、小、个数的练习"><a href="#函数求最大-、小、个数的练习" class="headerlink" title="函数求最大 、小、个数的练习"></a>函数求最大 、小、个数的练习</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def findmax(*l):</span><br><span class="line">    if l &#x3D;&#x3D; []:</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        Max &#x3D; l[0]</span><br><span class="line">        for i in l:</span><br><span class="line">            if i &gt; Max:</span><br><span class="line">                Max &#x3D; i</span><br><span class="line">        return Max</span><br><span class="line"></span><br><span class="line">def findmin(*l):</span><br><span class="line">    if l &#x3D;&#x3D; []:</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        Min &#x3D; l[0]</span><br><span class="line">        for i in l:</span><br><span class="line">            if i &lt; Min:</span><br><span class="line">                Min &#x3D; i</span><br><span class="line">        return Min</span><br><span class="line"></span><br><span class="line">def findlen(*l):</span><br><span class="line">    a &#x3D; len(l)</span><br><span class="line">    return a</span><br><span class="line"></span><br><span class="line">x &#x3D; input(&#39;请输入数字，并用空格隔开:&#39;).split()   #.split()用于分隔关对字符串进行切片操作</span><br><span class="line">last &#x3D; []</span><br><span class="line">for i in x:</span><br><span class="line">    last.append(int(i))</span><br><span class="line">print(&#39;max:&#39;,findmax(*last))</span><br><span class="line">print(&#39;min:&#39;,findmin(*last))</span><br><span class="line">print(&#39;max:&#39;,findlen(*last))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="函数复习-给定数字区间求素数个数"><a href="#函数复习-给定数字区间求素数个数" class="headerlink" title="函数复习 给定数字区间求素数个数"></a>函数复习 给定数字区间求素数个数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def sushu(lower,upper):</span><br><span class="line">    lei &#x3D; []</span><br><span class="line">    for num in range(lower,upper+1):</span><br><span class="line">        if num &gt; 1:</span><br><span class="line">            for i in range(2,num):</span><br><span class="line">                if (num % i ) &#x3D;&#x3D; 0:</span><br><span class="line">                    break</span><br><span class="line">            else:</span><br><span class="line">                lei.append(num)</span><br><span class="line">    print(&#39;求的素数共计&#39;+ str(len(lei)) +&#39;个。\n&#39;,&#39;分别是:&#39;,lei)</span><br><span class="line">while 1:</span><br><span class="line">    lower &#x3D; int(input(&#39;输入区间最小值:&#39;))</span><br><span class="line">    upper &#x3D; int(input(&#39;输入区间最大值:&#39;))</span><br><span class="line">    sushu(lower, upper)</span><br><span class="line">    print()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="计算题基础练习"><a href="#计算题基础练习" class="headerlink" title="计算题基础练习"></a>计算题基础练习</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">计算1-2+3-4+5-6+...+99的积是多少</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">sum &#x3D; 0</span><br><span class="line">for i in range(1,100):</span><br><span class="line">    if i % 2 &#x3D;&#x3D; 0:</span><br><span class="line">        sum -&#x3D;  i</span><br><span class="line">    else:</span><br><span class="line">        sum +&#x3D; i</span><br><span class="line">print(sum)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fib_recur(n):</span><br><span class="line">    assert n &gt;&#x3D; 0</span><br><span class="line">    if n in (0, 1):</span><br><span class="line">        return n</span><br><span class="line">    return fib_recur(n - 1) + fib_recur(n - 2)</span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">    print(fib_recur(i), end&#x3D;&quot; &quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2）递推法</span><br><span class="line"></span><br><span class="line">def fib_loop(n):</span><br><span class="line">    a, b &#x3D; 0, 1</span><br><span class="line">    for i in range(n):</span><br><span class="line">        a, b &#x3D; b, a + b</span><br><span class="line">    return a</span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">    print(fib_loop(i), end&#x3D;&quot; &quot;)</span><br></pre></td></tr></table></figure>
<h3 id="求-2-22-222…的和"><a href="#求-2-22-222…的和" class="headerlink" title="求 2+22+222…的和"></a>求 2+22+222…的和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; eval(input(&#39;请输入一个数字:&#39;))</span><br><span class="line">n &#x3D; eval(input(&#39;请输入次数n:&#39;))</span><br><span class="line">sum &#x3D; []</span><br><span class="line">sum2 &#x3D; 0</span><br><span class="line">s1 &#x3D; 0</span><br><span class="line">i &#x3D; 0</span><br><span class="line">while i &lt;&#x3D; n-1:</span><br><span class="line">    s1 &#x3D;s1+(a*(10**i))</span><br><span class="line">    sum.append(s1)</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line">sum1 &#x3D; [str(i) for i in sum]</span><br><span class="line">for j in sum:</span><br><span class="line">    sum2 +&#x3D; j</span><br><span class="line">print(&#39;+&#39;.join(sum1),&#39;&#x3D;&#39;,sum2)</span><br><span class="line"></span><br><span class="line">2）看了大神的写法</span><br><span class="line"></span><br><span class="line">a &#x3D; input(&#39;输入数字&gt;&gt;&gt;&#39;)</span><br><span class="line">count &#x3D; int(input(&#39;几个数字相加&gt;&gt;&gt;&#39;))</span><br><span class="line">ret &#x3D; []</span><br><span class="line">for i in range(1,count+1):</span><br><span class="line">    ret.append(int(a*i))</span><br><span class="line">sum1 &#x3D; [str(j) for j in ret]</span><br><span class="line">print(&#39;+&#39;.join(sum1),&#39;&#x3D;&#39;,sum(ret))</span><br></pre></td></tr></table></figure>
<h3 id="吃桃子问题"><a href="#吃桃子问题" class="headerlink" title="吃桃子问题"></a>吃桃子问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">peach &#x3D; 1</span><br><span class="line">print(&#39;第10天吃之前就剩1个桃子&#39;)</span><br><span class="line">for i in range(9,0,-1):</span><br><span class="line">    p &#x3D; (peach+1) * 2</span><br><span class="line">print(&#39;第1天共摘了&#123;&#125;个桃子&#39;.format(peach))</span><br></pre></td></tr></table></figure>
<h3 id="循环求一个数的阶乘"><a href="#循环求一个数的阶乘" class="headerlink" title="循环求一个数的阶乘"></a>循环求一个数的阶乘</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">      if x &#x3D;&#x3D; 0:</span><br><span class="line">           return 0</span><br><span class="line">      elif x &#x3D;&#x3D; 1:</span><br><span class="line">           return 1</span><br><span class="line">      else:</span><br><span class="line">            return (x * f(x - 1))</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">        info &#x3D; int(input(&#39;&gt;&gt;&gt;:&#39;))</span><br><span class="line">        print(f(info))</span><br><span class="line">        info &#x3D; input(&#39;还想试试吗？(输入n退出)&#39;)</span><br><span class="line">        if info &#x3D;&#x3D; &#39;n&#39;:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>
<h3 id="3-和-5-的倍数之和"><a href="#3-和-5-的倍数之和" class="headerlink" title="3 和 5 的倍数之和"></a>3 和 5 的倍数之和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum &#x3D; 0</span><br><span class="line">l &#x3D; []</span><br><span class="line">for i in range(1,1000):</span><br><span class="line">    if i%3 &#x3D;&#x3D; 0 and i%5 &#x3D;&#x3D; 0:</span><br><span class="line">        sum +&#x3D; 1</span><br><span class="line">        l.append(i)</span><br><span class="line">print(l)</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契数列数列之和"><a href="#斐波那契数列数列之和" class="headerlink" title="斐波那契数列数列之和"></a>斐波那契数列数列之和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum &#x3D; 0</span><br><span class="line">a,b &#x3D; 0,1</span><br><span class="line">while b &lt; 4000000:</span><br><span class="line">    if b%2 &#x3D;&#x3D; 0:</span><br><span class="line">        sum +&#x3D; b</span><br><span class="line">    a,b &#x3D; b,a+b</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<h3 id="format-格式化输出"><a href="#format-格式化输出" class="headerlink" title="format 格式化输出"></a>format 格式化输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mystring &#x3D; input(&#39;输入一带有字母数字特殊符号的字符串:&#39;)</span><br><span class="line">alpha &#x3D; 0</span><br><span class="line">space &#x3D; 0</span><br><span class="line">number &#x3D; 0</span><br><span class="line">other &#x3D; 0</span><br><span class="line">for i in mystring:</span><br><span class="line">    if i &gt;&#x3D; &#39;a&#39; and i &lt;&#x3D; &#39;z&#39; or i &gt;&#x3D; &#39;A&#39; and i &lt;&#x3D; &#39;Z&#39;:</span><br><span class="line">        alpha +&#x3D; 1</span><br><span class="line">    elif i &gt;&#x3D; &#39;0&#39; and i &lt;&#x3D; &#39;9&#39;:</span><br><span class="line">        number +&#x3D; 1</span><br><span class="line">    elif i.isspace():</span><br><span class="line">        space +&#x3D; 1</span><br><span class="line">    else:</span><br><span class="line">        other +&#x3D; 1</span><br><span class="line">print(&#39;alpha:&#123;&#125;,number:&#123;&#125;,space:&#123;&#125;,other:&#123;&#125;&#39;.format(alpha,number,space,other))</span><br></pre></td></tr></table></figure>
<h3 id="1000-以内的完数（经典）"><a href="#1000-以内的完数（经典）" class="headerlink" title="1000 以内的完数（经典）"></a>1000 以内的完数（经典）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in range(1,1001):</span><br><span class="line">    factor &#x3D; []</span><br><span class="line">    for i in range(1,x):</span><br><span class="line">        if x%i &#x3D;&#x3D; 0:</span><br><span class="line">            factor.append(i)</span><br><span class="line">    if sum(factor) &#x3D;&#x3D; x:</span><br><span class="line">        print(x)</span><br></pre></td></tr></table></figure>
<h3 id="时间的格式化"><a href="#时间的格式化" class="headerlink" title="时间的格式化"></a>时间的格式化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">now &#x3D; datetime.now()</span><br><span class="line">print(now.strftime(&#39;%Y-%m-%d&#39;))</span><br><span class="line">print(now.strftime(&#39;%Y%m%d&#39;))</span><br></pre></td></tr></table></figure>
<h3 id="自定义输入数据的个数并对其进去大小求平均值"><a href="#自定义输入数据的个数并对其进去大小求平均值" class="headerlink" title="自定义输入数据的个数并对其进去大小求平均值"></a>自定义输入数据的个数并对其进去大小求平均值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fact():</span><br><span class="line">    l &#x3D; []</span><br><span class="line">    for i in range(5):</span><br><span class="line">        temp &#x3D; input(&#39;请输入第%d个数字&#39;%(i+1))</span><br><span class="line">        temp1 &#x3D; int(temp)</span><br><span class="line">        l.append(temp1)</span><br><span class="line">    print(l)</span><br><span class="line">def fact1(l):</span><br><span class="line">    l.sort()</span><br><span class="line">    l2 &#x3D; l[1:-1]</span><br><span class="line">    return round((sum(l2)&#x2F;len(l2)),1)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"></span><br><span class="line">    fact()</span><br><span class="line">    print(fact1(l))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst &#x3D; []</span><br><span class="line">y &#x3D; int(input(&#39;请输入您所要数据的个数:&#39;))</span><br><span class="line">for i in range(y):</span><br><span class="line">    tmp &#x3D; input(&#39;请输入%d个数:&#39;%(i+1))</span><br><span class="line">    tmp1 &#x3D; float(tmp)</span><br><span class="line">    lst.append(tmp1)</span><br><span class="line"></span><br><span class="line">print(&#39;你输入的数据为:&#39;)</span><br><span class="line">print(lst)</span><br><span class="line">lst.sort()</span><br><span class="line">lst1 &#x3D; lst[1:-1]</span><br><span class="line">x &#x3D; round((sum(lst1)&#x2F;len(lst1)),1)</span><br><span class="line">print(&#39;这组数的最大值为&#123;&#125;,最小值为&#123;&#125;,平均值为&#123;&#125;&#39;.format(max(lst),min(lst),x))</span><br><span class="line"></span><br><span class="line">2 下次一定用函数来写</span><br><span class="line"></span><br><span class="line">def getMaxMinAvgoflist(list):</span><br><span class="line">    Max &#x3D; max(list)</span><br><span class="line">    Min &#x3D; min(list)</span><br><span class="line">    sum &#x3D; 0.0</span><br><span class="line">    for i in range(len(list)):</span><br><span class="line">        sum +&#x3D; list[i]</span><br><span class="line">        Avg &#x3D; 1.0*sum&#x2F;len(list)</span><br><span class="line">        return  (Max,Min,Avg)</span><br><span class="line">l &#x3D; [1,2,4,5]</span><br><span class="line">print(getMaxMinAvgoflist(l))</span><br></pre></td></tr></table></figure>
<h3 id="Python-键盘输入转换为列表的实例"><a href="#Python-键盘输入转换为列表的实例" class="headerlink" title="Python 键盘输入转换为列表的实例"></a>Python 键盘输入转换为列表的实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python 输入字符串转列表是为了方便后续处理，这种操作在考试的时候比较多见。</span><br><span class="line"></span><br><span class="line">1. 在 Python3.0 以后，键盘输入使用 input 函数</span><br><span class="line"></span><br><span class="line">eg1.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; x&#x3D;input</span><br><span class="line">&gt;&gt;&gt; 123</span><br><span class="line">123</span><br><span class="line">在命令行没有任何显示，输入 123 后直接赋值给 x，并打印。</span><br><span class="line"></span><br><span class="line">eg2.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; x&#x3D;input(&quot;请输入...&quot;)</span><br><span class="line">请输入...123</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">123</span><br><span class="line">在命令行显示 “请输入…”，显示的字符对输入没有任何影响，输入字符后直接赋值给 x。</span><br><span class="line"></span><br><span class="line">2. 仅仅使用 input 是无法解决大部分数据处理的，通常输入的字符串需要分割处理，python 使用 split () 函数进行分割</span><br><span class="line"></span><br><span class="line">eg1.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; x&#x3D;input()</span><br><span class="line">1,2,3,4</span><br><span class="line">&gt;&gt;&gt; xlist&#x3D;x.split(&quot;,&quot;)</span><br><span class="line">&gt;&gt;&gt; print(xlist)</span><br><span class="line">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]</span><br><span class="line">但是这样仍然不够，输入的是数字，我们希望列表也是数字，所以还需要进一步转换</span><br><span class="line"></span><br><span class="line">eg2.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; x&#x3D;input()</span><br><span class="line">1,2,3,4</span><br><span class="line">&gt;&gt;&gt; xlist&#x3D;x.split(&quot;,&quot;)</span><br><span class="line">&gt;&gt;&gt; print(xlist)</span><br><span class="line">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]</span><br><span class="line">&gt;&gt;&gt; xlist &#x3D; [int(xlist[i]) for i in range(len(xlist))] #for循环，把每个字符转成int值</span><br><span class="line">&gt;&gt;&gt; print(xlist)</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">split (“”) 函数的参数可以是任何分隔符，包括（a,b,c….;1,2,3…;%,!,*, 空格）</span><br><span class="line"></span><br><span class="line">eg3.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; x&#x3D;input()</span><br><span class="line">1 2 3 4</span><br><span class="line">&gt;&gt;&gt; xlist&#x3D;x.split(&quot; &quot;)</span><br><span class="line">&gt;&gt;&gt; print(xlist)</span><br><span class="line">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]</span><br><span class="line">&gt;&gt;&gt; xlist &#x3D; [int(xlist[i]) for i in range(len(xlist))]</span><br><span class="line">&gt;&gt;&gt; print(xlist)</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<h3 id="sum-函数及自定义函数复习（学习啊）"><a href="#sum-函数及自定义函数复习（学习啊）" class="headerlink" title="sum()函数及自定义函数复习（学习啊）"></a>sum()函数及自定义函数复习（学习啊）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(lst):</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    avg &#x3D; 0</span><br><span class="line">    for i in range(len(lst)):</span><br><span class="line">        sum +&#x3D; lst[i]</span><br><span class="line">        avg &#x3D; sum&#x2F;len(lst)</span><br><span class="line">    return (sum,avg)</span><br><span class="line">    # print(sum,avg)</span><br><span class="line"></span><br><span class="line">l &#x3D; [1,2,3,4,5]</span><br><span class="line">print(func(l))</span><br><span class="line"></span><br><span class="line">2）进阶版</span><br><span class="line">def getMaxMinAvgoflist(list):</span><br><span class="line">    Max &#x3D; max(list)</span><br><span class="line">    Min &#x3D; min(list)</span><br><span class="line">    sum &#x3D; 0.0</span><br><span class="line">    for i in range(len(list)):</span><br><span class="line">        sum +&#x3D; list[i]</span><br><span class="line">        Avg &#x3D; 1.0*sum&#x2F;len(list)</span><br><span class="line">    print(&#39;max:&#123;&#125;,min:&#123;&#125;,ave:&#123;&#125;&#39;.format(Max,Min,Avg))</span><br><span class="line"> # return  (Max,Min,Avg)  # 函数的返回值为元组</span><br><span class="line"></span><br><span class="line">l &#x3D; []</span><br><span class="line">geshu &#x3D; int(input(&#39;请输入你需要的个数:&#39;))</span><br><span class="line">for i in range(geshu):</span><br><span class="line">    temp &#x3D; input(&#39;请输入%d个数:&#39;%(i+1))</span><br><span class="line">    temp &#x3D; float(temp)</span><br><span class="line">    l.append(temp)</span><br><span class="line"></span><br><span class="line">getMaxMinAvgoflist(l)</span><br></pre></td></tr></table></figure>
<h3 id="忘的快了，用可控循环做一个有趣的小例子"><a href="#忘的快了，用可控循环做一个有趣的小例子" class="headerlink" title="忘的快了，用可控循环做一个有趣的小例子"></a>忘的快了，用可控循环做一个有趣的小例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Brithday(id):</span><br><span class="line">    year &#x3D; id[6:10]</span><br><span class="line">    month &#x3D; id[10:12]</span><br><span class="line">    date &#x3D; id[12:14]</span><br><span class="line">    sex &#x3D; id[16:17]</span><br><span class="line">    sex &#x3D; int(sex)</span><br><span class="line">    if sex % 2:</span><br><span class="line">        sex &#x3D; &#39;男&#39;</span><br><span class="line">    else:</span><br><span class="line">        sex &#x3D; &#39;女&#39;</span><br><span class="line">    print(&#39;你好呀 %s！你是%s生，你的生日是:%s年%s月%s日&#39; % (name, sex, year, month, date))</span><br><span class="line"></span><br><span class="line">name &#x3D; input(&#39;请输入姓名:&#39;)</span><br><span class="line">id &#x3D; input(&#39;请输入你的身份证号:&#39;)</span><br><span class="line">Brithday(id)</span><br><span class="line">while 1:</span><br><span class="line">    info &#x3D; input(&#39;还想试试吗？(Yes 继续&#x2F; no 退出)&#39;)</span><br><span class="line">    if info &#x3D;&#x3D; &#39;no&#39;:</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        name &#x3D; input(&#39;请输入姓名:&#39;)</span><br><span class="line">        id &#x3D; input(&#39;请输入你的身份证号:&#39;)</span><br><span class="line">        Brithday(id)</span><br></pre></td></tr></table></figure>
<h3 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">print(&#39;---计算从出生到现在你生活了多少天，多少小时，多少秒---&#39;)</span><br><span class="line">day_srt &#x3D; input(&#39;请按 年-月-日 的格式输入日期:&#39;)</span><br><span class="line">t_day &#x3D; datetime.datetime.strptime(day_srt,&#39;%Y-%m-%d&#39;)</span><br><span class="line">day_now &#x3D; datetime.datetime.now()</span><br><span class="line">day_s &#x3D; (day_now - t_day).days</span><br><span class="line">xiaoshi &#x3D; ((day_now - t_day).days)*24</span><br><span class="line">miao &#x3D; (day_now - t_day).seconds</span><br><span class="line"></span><br><span class="line">print(&#39;你共生活了:&#39;,day_s,&#39;天&#39;)</span><br><span class="line">print(&#39;你共生活了:&#39;,xiaoshi,&#39;时&#39;)</span><br><span class="line">print(&#39;你共生活了:&#39;,miao,&#39;秒&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="输入一串数字，求其对应的平方数"><a href="#输入一串数字，求其对应的平方数" class="headerlink" title="输入一串数字，求其对应的平方数"></a>输入一串数字，求其对应的平方数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l &#x3D; []</span><br><span class="line">number &#x3D; input(&#39;请输入数字以空格 隔开&gt;&gt;&gt;:&#39;).split()</span><br><span class="line">number &#x3D; [int(x) for x in number]</span><br><span class="line">for i in number:</span><br><span class="line">    i &#x3D; i**2</span><br><span class="line">    l.append(i)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>
<h3 id="再来一次复习-求阶乘-循环体控制"><a href="#再来一次复习-求阶乘-循环体控制" class="headerlink" title="再来一次复习 求阶乘 循环体控制"></a>再来一次复习 求阶乘 循环体控制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 求一个数的阶乘的小程序，用循环控制实现</span><br><span class="line"></span><br><span class="line">def jiecheng(num):</span><br><span class="line">    if num &lt; 0:</span><br><span class="line">        return -1</span><br><span class="line">    if num &#x3D;&#x3D; 0:</span><br><span class="line">        return 1</span><br><span class="line">    return num * jiecheng(num - 1)</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    try:</span><br><span class="line">        num &#x3D; input(&#39;提示:输入&quot;q&quot;退出程序。\n请输入一个数字:&#39;)</span><br><span class="line">        if num.lower() &#x3D;&#x3D; &#39;q&#39;:</span><br><span class="line">            break</span><br><span class="line">        num &#x3D; int(num)</span><br><span class="line">    except:</span><br><span class="line">        print(&#39;输入的数字不正确！&#39;)</span><br><span class="line">        continue</span><br><span class="line">    jiecheng(num)</span><br><span class="line">    print(num * jiecheng(num - 1))</span><br></pre></td></tr></table></figure>
<h3 id="每日一更"><a href="#每日一更" class="headerlink" title="每日一更"></a>每日一更</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line"># Created by danding at 2019&#x2F;10&#x2F;31</span><br><span class="line"></span><br><span class="line">from math import *</span><br><span class="line"></span><br><span class="line">def jiechenghe(num):</span><br><span class="line">    list &#x3D; []</span><br><span class="line">    k &#x3D; 1</span><br><span class="line">    for i in range(1,num+1):</span><br><span class="line">        k &#x3D; k*i</span><br><span class="line">        list.append(k)</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    for i in list:</span><br><span class="line">        sum +&#x3D; i</span><br><span class="line"></span><br><span class="line">    print(&#39;前&#123;&#125;项的阶乘和是:&#123;&#125;&#39;.format(num,sum))</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    try:</span><br><span class="line">        num &#x3D; input(&#39;提示:输入&quot;q&quot;退出程序。\n请输入前几项数字的阶乘和:&#39;)</span><br><span class="line">        if num.lower()&#x3D;&#x3D;&#39;q&#39;:</span><br><span class="line">            break</span><br><span class="line">        num &#x3D; int(num)</span><br><span class="line">    except:</span><br><span class="line">        print(&#39;请输入数！&#39;)</span><br><span class="line">        continue</span><br><span class="line">    jiechenghe(num)</span><br></pre></td></tr></table></figure>
<h3 id="python-复习求素数"><a href="#python-复习求素数" class="headerlink" title="python 复习求素数"></a>python 复习求素数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num_pri &#x3D; []</span><br><span class="line">l&#x3D;[]</span><br><span class="line">for i in range(2,101):</span><br><span class="line">    for j in range(2,i):</span><br><span class="line">        if (i %j) &#x3D;&#x3D; 0:</span><br><span class="line">            num_pri.append(i)</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        l.append(i)</span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">print(num_pri)</span><br></pre></td></tr></table></figure>
<h3 id="素数，输入任多个数，求其中的素"><a href="#素数，输入任多个数，求其中的素" class="headerlink" title="素数，输入任多个数，求其中的素"></a>素数，输入任多个数，求其中的素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; []</span><br><span class="line">b &#x3D; []</span><br><span class="line">n &#x3D; input(&#39;Enter some numbers:&#39;).split()</span><br><span class="line"></span><br><span class="line">c &#x3D; [int(j) for j in n]</span><br><span class="line"></span><br><span class="line">for s in c:</span><br><span class="line">    for i in range(2, s):</span><br><span class="line">        if s % i &#x3D;&#x3D; 0:</span><br><span class="line">            a.append(s)</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        b.append(s)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python遍历文件实例</title>
    <url>/2021/02/15/Python%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="listdir-读取某一目录下面的所有文件"><a href="#listdir-读取某一目录下面的所有文件" class="headerlink" title="listdir 读取某一目录下面的所有文件"></a>listdir 读取某一目录下面的所有文件</h2><p>某一文件下面的.txt文本比较多，那么怎么才能讲该文件夹下面的所有的文件中的内容读取出来，这样就需要一个函数直接读取某一文件夹里面所有的文件。</p>
<p>在python中listdir就可以实现上述的功能</p>
<p>程序代码如下所示：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def data_all():##该函数主要是将所有的.txt文本合并成一个文件</span><br><span class="line">    f1 &#x3D; open(&#39;.&#x2F;data_all.txt&#39;,&#39;w&#39;,encoding&#x3D;&#39;utf8&#39;)</span><br><span class="line">    path &#x3D; &#39;.&#x2F;1&#x2F;&#39;</span><br><span class="line">    file_name &#x3D; os.listdir(path)</span><br><span class="line">    # print(file_name)</span><br><span class="line">    for file in file_name:</span><br><span class="line">        with open(path+file,encoding&#x3D;&#39;utf8&#39;) as fp:</span><br><span class="line">            for line in fp.readlines():</span><br><span class="line">                line &#x3D; line.strip()</span><br><span class="line">                if line &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">                    continue</span><br><span class="line">                f1.write(line+&#39;\n&#39;)</span><br><span class="line">    f1.close()</span><br><span class="line">data_all()</span><br></pre></td></tr></table></figure>
<h2 id="python-下递归遍历目录和文件-方法"><a href="#python-下递归遍历目录和文件-方法" class="headerlink" title="python 下递归遍历目录和文件(方法)"></a>python 下递归遍历目录和文件(方法)</h2><h4 id="方法一：递归调用："><a href="#方法一：递归调用：" class="headerlink" title="方法一：递归调用："></a>方法一：递归调用：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">#coding:utf8</span><br><span class="line"> </span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">def dirlist(path, allfile):</span><br><span class="line">	filelist &#x3D;  os.listdir(path)</span><br><span class="line"> </span><br><span class="line">	for filename in filelist:</span><br><span class="line">		filepath &#x3D; os.path.join(path, filename)</span><br><span class="line">		if os.path.isdir(filepath):</span><br><span class="line">			dirlist(filepath, allfile)</span><br><span class="line">		else:</span><br><span class="line">			allfile.append(filepath)</span><br><span class="line">	return allfile</span><br><span class="line"> </span><br><span class="line">print dirlist(&quot;&#x2F;home&#x2F;yuan&#x2F;testdir&quot;, [])	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="方法二：os-walk"><a href="#方法二：os-walk" class="headerlink" title="方法二：os.walk()"></a>方法二：os.walk()</h4><p>该函数式穿件一个生成器对象来遍历整棵目录树。</p>
<p>top 指定目录的顶级，而 topdown 是一个布尔值，用于指示由上而下（默认值）还是由下而上来遍历目录。返回的生成器将生成元组（dirpath，dirnames，filenames），其</p>
<p>中 dirpath 是一个字符串，包含通向目录的路径，dirnames 是 dirpath 中所有子目录的一个列表，而 filename 是 dirpath 中文件的一个列表，不包括目录。oneerror </p>
<p>参数是一个接受单个参数的函数。</p>
<p>如果处理期间出现任何错误，将使用 os.error 的是咧来调用此函数。默认行为时忽略错误。如果由上而下地遍历目录，修改 dirnames 将影响到遍历过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">g &#x3D; os.walk(&quot;&#x2F;home&#x2F;yuan&#x2F;testdir&quot;)</span><br><span class="line"></span><br><span class="line">for path,d,filelist in g:</span><br><span class="line">	print d;</span><br><span class="line">	for filename in filelist:</span><br><span class="line">		print os.path.join(path, filename)</span><br></pre></td></tr></table></figure>
<h4 id="递归实现文件反向输出："><a href="#递归实现文件反向输出：" class="headerlink" title="递归实现文件反向输出："></a>递归实现文件反向输出：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!user&#x2F;bin&#x2F;python</span><br><span class="line">fr &#x3D; open(&#39;aa.txt&#39;,&#39;r&#39;)</span><br><span class="line">fw &#x3D; open(&#39;b.txt&#39;, &#39;w+&#39;)</span><br><span class="line"> </span><br><span class="line">def restr(s):                 #递归实现函数</span><br><span class="line">	str1 &#x3D; s.readline()     </span><br><span class="line">	if len(str1) !&#x3D; 0:</span><br><span class="line">		restr(s)</span><br><span class="line">	fw.write(str1)</span><br><span class="line"> </span><br><span class="line">restr(fr)	</span><br><span class="line">fr.close()</span><br><span class="line">fw.close()</span><br></pre></td></tr></table></figure>
<h2 id="遍历文件"><a href="#遍历文件" class="headerlink" title="遍历文件"></a>遍历文件</h2><ol>
<li>第一个参数 fpath 是遍历打印所有的文件路径<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import os</span><br><span class="line">path &#x3D; r&quot;D:\APK\data1&quot;  # 查找文件的路径</span><br><span class="line">for fpath, dirname, fnames in os.walk(path):</span><br><span class="line">    print(fpath)  # 所有的文件夹路径 </span><br></pre></td></tr></table></figure>
运行结果:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\APK\data1</span><br><span class="line">D:\APK\data1\文件夹 1</span><br><span class="line">D:\APK\data1\文件夹 2</span><br></pre></td></tr></table></figure></li>
<li>第二个参数 dirname 是遍历打印所有的文件夹名称</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import os</span><br><span class="line">path &#x3D; r&quot;D:\APK\data1&quot;  # 查找文件的路径</span><br><span class="line">for fpath, dirname, fnames in os.walk(path):</span><br><span class="line">    print(dirname)  # 所有的文件名 </span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;文件夹 1&#39;, &#39;文件夹 2&#39;]</span><br><span class="line">[]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>第三个参数 fnames 是遍历打印所有的文件名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import os</span><br><span class="line">path &#x3D; r&quot;D:\APK\data1&quot;  # 查找文件的路径</span><br><span class="line">for fpath, dirname, fnames in os.walk(path):</span><br><span class="line">    print(fnames)  # 所有的文件名</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;Iris-setosa.xlsx&#39;, &#39;Iris-versicolor.xlsx&#39;, &#39;Iris-virginica.xlsx&#39;]</span><br><span class="line">[]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h4 id="遍历所有的文件"><a href="#遍历所有的文件" class="headerlink" title="遍历所有的文件"></a>遍历所有的文件</h4></li>
<li><p>遍历查找文件夹内所有的子文件（不包含文件夹）</p>
</li>
<li><p>用 endswith 判断查找后置是.py 结尾的</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def get_files(path&#x3D;&#39;D:\APK\data1&#39;, rule&#x3D;&quot;.xlsx&quot;):</span><br><span class="line">    all &#x3D; []</span><br><span class="line">    for fpathe,dirs,fs in os.walk(path):   # os.walk是获取所有的目录</span><br><span class="line">        for f in fs:</span><br><span class="line">            filename &#x3D; os.path.join(fpathe,f)</span><br><span class="line">            if filename.endswith(rule):  # 判断是否是&quot;xxx&quot;结尾</span><br><span class="line">                all.append(filename)</span><br><span class="line">    return all</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    b &#x3D; get_files(r&quot;D:\APK\data1&quot;)</span><br><span class="line">    for i in b:</span><br><span class="line">        print (i)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\APK\data1\Iris-setosa.xlsx</span><br><span class="line">D:\APK\data1\Iris-versicolor.xlsx</span><br><span class="line">D:\APK\data1\Iris-virginica.xlsx</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode_Picgo_Github图床上传失败解决方法</title>
    <url>/2021/05/01/VsCode-Picgo-Github%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>前言</p>
<p>写 Markdown 的时候，插入图片总是插入本地图片，这就导致把笔记发给别人的时候必须要打包发送。<br>后来发现了 Picgo 这款软件，可以把图片上传到图床，然后在 VsCode 中插入网络图片链接，发笔记的时候就不用再把图片打包了。<br>但使用 Picgo 一段时间后，发现 Github 图床总是上传失败，于是总结了以下问题。</p>
<p>总结</p>
<p>目前知道的 Github 图床问题有：</p>
<ul>
<li>Token 未更新</li>
<li>仓库名称带空格，配置时需要变为 -</li>
<li>无法上传 PNG</li>
<li>图片名称不能带 +</li>
<li>仓库中已存在相同名称的图片</li>
</ul>
<h2 id="在-VsCode-中编写代码时"><a href="#在-VsCode-中编写代码时" class="headerlink" title="在 VsCode 中编写代码时"></a>在 VsCode 中编写代码时</h2><p>在格式控制中有一项是这样的，通过 Ctrl + , 打开 setting 设置，然后在格式化控制中有一项 Format On Type ‘控制编辑器在键入一行后是否自动格式化该行’。由于之前一直用着这一功能很好用，这也是选择该编辑器的一个原因，前几天突然一个插件升级要重新加载编辑器，由于自己也没看清是什么插件，后来这项功能一直不能用了，自己折腾了四、五天，重启了无数次，安装又卸载了无数个插件，真是累的快吐血了，最后真的想放弃了。又一个无心的举动，发现了问题。原来是 VsCode 中的 Python 插件版本更新所导致的这个问题。于是乎又查看如果使用之前版本的插件，最后发现真是这是个问题引起的。现在解决了，心里真是很爽的。又可以像以前一样使用此工功能了。只不过扩展插件栏一直提示要更新，现在也不管那么多了，只要好用就行。 </p>
<h2 id="修改版本号为此版："><a href="#修改版本号为此版：" class="headerlink" title="修改版本号为此版："></a>修改版本号为此版：</h2><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/%E9%80%89%E6%8B%A9%E6%8C%87%E5%AE%9A%E7%9A%84Python%E6%8F%92%E4%BB%B6%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7.png" alt="选择指定的Python插件的版本号"></p>
</div>

<h2 id="禁止版本更新方法："><a href="#禁止版本更新方法：" class="headerlink" title="禁止版本更新方法："></a>禁止版本更新方法：</h2><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/%E4%BF%AE%E6%94%B9Python%E6%8F%92%E4%BB%B6%E7%89%88%E6%9C%AC%E5%B9%B6%E7%A6%81%E6%AD%A2%E6%9B%B4%E6%96%B0.png" alt="修改Python插件版本并禁止更新"></p>
</div>]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode中添加用户代码片段</title>
    <url>/2021/05/01/VsCode%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
    <content><![CDATA[<h2 id="常用的用户代码片段"><a href="#常用的用户代码片段" class="headerlink" title="常用的用户代码片段"></a>常用的用户代码片段</h2><p>添加方法：VsCode 右下角，单击’设置’小齿轮按钮，之后选择用户代码片段，在命令行单击添加全局代码片段，在大括号里写上下代码即可。</p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;读文件&quot;:&#123;</span><br><span class="line">		&quot;prefix&quot;: &quot;files&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;with open($&#123;1:文件全路径&#125;) as 文件:&quot;,</span><br><span class="line">			&quot;\t内容 &#x3D; 文件.read()&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;读取某文件&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;读所有文件&quot;:&#123;</span><br><span class="line">		&quot;prefix&quot;: &quot;allfiles&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;import os&quot;,</span><br><span class="line">			&quot;filepath &#x3D;&#39;.&#39;&quot;,</span><br><span class="line">			&quot;for filenames in os.listdir(filepath):&quot;,</span><br><span class="line">			&quot;\twith open(os.path.join(filepath,filenames)) as f:&quot;,</span><br><span class="line">			&quot;\t\twords &#x3D; f.read()&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;读取某目录下所有文件&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些常用片段"><a href="#一些常用片段" class="headerlink" title="一些常用片段"></a>一些常用片段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;Print with space lines&quot;: &#123;</span><br><span class="line">		&quot;prefix&quot;: &quot;pp&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;print(&#39;\\n&#39;*2, $1)&quot;,</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;Print with space lines&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F;这是分隔线</span><br><span class="line"></span><br><span class="line">	&quot;class init&quot;: &#123;</span><br><span class="line">		&quot;scope&quot;: &quot;python&quot;,</span><br><span class="line">		&quot;prefix&quot;: &quot;class $1 $2&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;class $1(object):&quot;,</span><br><span class="line">			&quot;    def __init__(self$2):&quot;,</span><br><span class="line">			&quot;        self.&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;auto class init&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;class pass&quot;: &#123;</span><br><span class="line">		&quot;scope&quot;: &quot;python&quot;,</span><br><span class="line">		&quot;prefix&quot;: &quot;classpass $1&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;class $1: pass&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;auto class pass&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;def pass&quot;: &#123;</span><br><span class="line">		&quot;scope&quot;: &quot;python&quot;,</span><br><span class="line">		&quot;prefix&quot;: &quot;defpass $1&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;def $1(): pass&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;auto def pass&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;get path&quot;: &#123;</span><br><span class="line">		&quot;scope&quot;: &quot;python&quot;,</span><br><span class="line">		&quot;prefix&quot;: &quot;import os&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;import os&quot;,</span><br><span class="line">			&quot;&quot;,</span><br><span class="line">			&quot;def getScriptPath():&quot;,</span><br><span class="line">			&quot;    return os.path.split(os.path.realpath(__file__))[0]&quot;,</span><br><span class="line">			&quot;&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;auto getScriptPath&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;env init&quot;: &#123;</span><br><span class="line">		&quot;scope&quot;: &quot;python&quot;,</span><br><span class="line">		&quot;prefix&quot;: &quot;import sys&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;#!&#x2F;usr&#x2F;bin&#x2F;env python&quot;,</span><br><span class="line">			&quot;# coding:utf-8&quot;,</span><br><span class="line">			&quot;&quot;,</span><br><span class="line">			&quot;import sys&quot;,</span><br><span class="line">			&quot;reload(sys)&quot;,</span><br><span class="line">			&quot;sys.setdefaultencoding(&#39;utf-8&#39;)&quot;,</span><br><span class="line">			&quot;&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;auto set utf8&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;logging&quot;: &#123;</span><br><span class="line">		&quot;scope&quot;: &quot;python&quot;,</span><br><span class="line">		&quot;prefix&quot;: &quot;import logging $1&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;import logging&quot;,</span><br><span class="line">			&quot;&quot;,</span><br><span class="line">			&quot;logger &#x3D; logging.getLogger(__name__)&quot;,</span><br><span class="line">			&quot;logger.setLevel(level&#x3D;logging.INFO)&quot;,</span><br><span class="line">			&quot;handler &#x3D; logging.FileHandler(&#39;$1&#39;)&quot;,</span><br><span class="line">			&quot;handler.setLevel(level&#x3D;logging.INFO)&quot;,</span><br><span class="line">			&quot;formatter &#x3D; logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)&quot;,</span><br><span class="line">			&quot;handler.setFormatter(formatter)&quot;,</span><br><span class="line">			&quot;logger.addHandler(handler)&quot;,</span><br><span class="line">			&quot;&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;auto logging&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;args&quot;: &#123;</span><br><span class="line">		&quot;scope&quot;: &quot;python&quot;,</span><br><span class="line">		&quot;prefix&quot;: &quot;*a&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;*args, **kwargs&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;auto *args&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;closure&quot;: &#123;</span><br><span class="line">		&quot;scope&quot;: &quot;python&quot;,</span><br><span class="line">		&quot;prefix&quot;: &quot;proxy $1 $2 $3&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">			&quot;def $1(func):&quot;,</span><br><span class="line">			&quot;    def proxy(*args, **kwargs):&quot;,</span><br><span class="line">			&quot;        $2&quot;,</span><br><span class="line">			&quot;        result &#x3D; func(*args, **kwargs)&quot;,</span><br><span class="line">			&quot;        $3&quot;,</span><br><span class="line">			&quot;        return result&quot;,</span><br><span class="line">			&quot;    return proxy&quot;,</span><br><span class="line">			&quot;&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;auto closure&quot;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Quick info&quot;: &#123;</span><br><span class="line">	&quot;prefix&quot;: &quot;info&quot;,</span><br><span class="line">	&quot;body&quot;: [</span><br><span class="line">		&quot;#! &#x2F;usr&#x2F;bin&#x2F;env python&quot;,</span><br><span class="line">		&quot;# author : BJxo&quot;,</span><br><span class="line">		&quot;# date : $CURRENT_YEAR&#x2F;$CURRENT_MONTH&#x2F;$CURRENT_DATE&quot;</span><br><span class="line">		&quot;\nimport os&quot;,</span><br><span class="line">		&quot;import sys&quot;,</span><br><span class="line">		&quot;import pandas&quot;,</span><br><span class="line">		&quot;from datetime import datetime&quot;,</span><br><span class="line">		&quot;$0&quot;,</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode快捷键及小技巧</title>
    <url>/2021/02/17/VsCode%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ul>
<li>「Ctrl + F」当前文件内搜索，当选中文本时直接按「Ctrl + F」，可直接填写搜索内容，界面如下：</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217131854.png" alt="20210217131854"></p>
</div>

<hr>
<a id="more"></a>

<ul>
<li>「Ctrl + D」当选中文本时直接按「Ctrl + D」，可直接同时选中其他相同文本（按一次 ‘D’，选中一个，可按住不放），可进行同时编辑，界面如下：</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217131911.png" alt="20210217131911"></p>
</div>

<hr>
<ul>
<li><p>「Ctrl + E」当前文件内按「Ctrl + E」, 输入文件名可快速打开其他文件</p>
<br>
</li>
<li><p>「F2」重命名一个变量</p>
<br>
- 选中一个变量，然后按 F2，弹出一个小窗口，在里面输入内容后按回车，所有该变量都会被重命名。（注意：在 js 文件中，如果这个变量没有用 var 或者 const 或者 let 声明，会无法重命名）

</li>
</ul>
<hr>
<ul>
<li>「按住 alt，用鼠标左键点击」可以出现多个光标，输入的代码可以在光标处同时增加</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20191007144725963.gif" alt="20191007144725963"></p>
</div>

<hr>
<ul>
<li>「按 shift+alt，再使用鼠标拖动」可以出现竖直的列光标，同时可以选中多列</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/tuodong.gif" alt="tuodong"></p>
</div>

<hr>
<h2 id="VS-Code-使用技巧整理"><a href="#VS-Code-使用技巧整理" class="headerlink" title="VS Code 使用技巧整理"></a>VS Code 使用技巧整理</h2><h4 id="一、多光标插入功能"><a href="#一、多光标插入功能" class="headerlink" title="一、多光标插入功能"></a>一、多光标插入功能</h4><p>Alt + 鼠标左键，添加多光标输入</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217133338.png" alt="20210217133338"></p>
</div>

<hr>
<h4 id="二、自由多行选择"><a href="#二、自由多行选择" class="headerlink" title="二、自由多行选择"></a>二、自由多行选择</h4><p>Alt 键 + 鼠标左键拖动选择各行的部分内容</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217133415.png" alt="20210217133415"></p>
</div>

<hr>
<h4 id="三、列选择"><a href="#三、列选择" class="headerlink" title="三、列选择"></a>三、列选择</h4><p>Shift+Alit + 鼠标左键拖动，选中拖动的区域内容</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217133842.png" alt="20210217133842"></p>
</div>

<hr>
<h4 id="四、将自动高亮的变量、字符一次性替换："><a href="#四、将自动高亮的变量、字符一次性替换：" class="headerlink" title="四、将自动高亮的变量、字符一次性替换："></a>四、将自动高亮的变量、字符一次性替换：</h4><p>双击变量，右键‘更改所有匹配项’。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217134125.png" alt="20210217134125"></p>
</div>

<hr>
<p>或者</p>
<p>双击变量，Ctrl+F2</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217134138.png" alt="20210217134138"></p>
</div>



<ul>
<li><p>格式调整</p>
<ul>
<li>代码行缩进 Ctrl+[， Ctrl+]</li>
<li>折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+]</li>
<li>Ctrl+C Ctrl+V 如果不选中，默认复制或剪切一整行</li>
<li>代码格式化：Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code</li>
<li>修剪空格 Ctrl+Shift+X</li>
<li>上下移动一行： Alt+Up 或 Alt+Down</li>
<li>向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down</li>
<li>在当前行下边插入一行 Ctrl+Enter</li>
<li>在当前行上方插入一行 Ctrl+Shift+Enter</li>
</ul>
<br>
</li>
<li><p>光标相关</p>
<ul>
<li>移动到行首：Home</li>
<li>移动到行尾：End</li>
<li>移动到文件结尾：Ctrl+End</li>
<li>移动到文件开头：Ctrl+Home</li>
<li>移动到后半个括号 Ctrl+Shift+]</li>
<li>选中当前行 Ctrl+i（双击）</li>
<li>选择从光标到行尾 Shift+End</li>
<li>选择从行首到光标处 Shift+Home</li>
<li>删除光标右侧的所有字 Ctrl+Delete</li>
<li>Shrink/expand selection： Shift+Alt+Left 和 Shift+Alt+Right</li>
<li>Multi-Cursor：可以连续选择多处，然后一起修改，Alt+Click 添加 cursor 或者 Ctrl   - +Alt+Down 或 Ctrl+Alt+Up</li>
<li>同时选中所有匹配的 Ctrl+Shift+L</li>
<li>Ctrl+D 下一个匹配的也被选中 (被我自定义成删除当前行了，见下边 Ctrl+Shift+K)</li>
<li>回退上一个光标操作 Ctrl+U</li>
</ul>
<br>
</li>
<li><p>构代码</p>
<ul>
<li>跳转到定义处：F12</li>
<li>定义处缩略图：只看一眼而不跳转过去 Alt+F12</li>
<li>列出所有的引用：Shift+F12</li>
<li>同时修改本文件中所有匹配的：Ctrl+F12</li>
<li>重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件 - 都修改过了。</li>
<li>跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转</li>
<li>查看 diff 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右    - 键选择 Compare with ‘file_name_you_chose’.</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><p>查找替换</p>
<ul>
<li>查找 Ctrl+F</li>
<li>查找替换 Ctrl+H</li>
<li>整个文件夹中查找 Ctrl+Shift+F<br>
</li>
</ul>
</li>
<li><p>显示相关</p>
<ul>
<li>全屏:F11</li>
<li>zoomIn/zoomOut：Ctrl + =/Ctrl + -</li>
<li>侧边栏显 / 隐：Ctrl+B</li>
<li>预览 markdown Ctrl+Shift+V<br>
</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>自动保存：File -&gt; AutoSave ，或者 Ctrl+Shift+P，输入 auto</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode插件同步到云</title>
    <url>/2021/02/28/Vscode%E6%8F%92%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%88%B0%E4%BA%91/</url>
    <content><![CDATA[<h3 id="安装-Settings-Sync"><a href="#安装-Settings-Sync" class="headerlink" title="安装 Settings Sync"></a>安装 Settings Sync</h3><p>Vscode 插件中心直接搜索安装即可。</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210210184154.png" alt="20210210184154"></p>
</div>

<a id="more"></a>

<h3 id="github-生成-token-和-gistid"><a href="#github-生成-token-和-gistid" class="headerlink" title="github 生成 token 和 gistid"></a>github 生成 token 和 gistid</h3><p>token 获取步骤：</p>
<p>网址：github：<a href="https://github.com/">https://github.com/</a></p>
<p>路径：Settings -&gt; Developer settings -&gt; Personal access tokens</p>
<p>操作：点击按钮 Generate new token 新增一个 token，选择 gistid 即可。</p>
<p>记住生成的 token 值</p>
<p>gistid 获取步骤</p>
<p>网址：github：<a href="https://github.com/">https://github.com/</a></p>
<p>路径： 点击右上角 + 号 New gist</p>
<p>操作： 任意填写 gist 描述 -&gt; 点击生成私钥 (英文的) -&gt; 记录下来</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210210185647.png" alt="20210210185647"></p>
</div>

<h3 id="配置本设备-gistId-和-token"><a href="#配置本设备-gistId-和-token" class="headerlink" title="配置本设备 gistId 和 token"></a>配置本设备 gistId 和 token</h3><ul>
<li>Ctrl + P / F1，弹出命令窗口</li>
<li>输入 &gt; sync</li>
<li>选择 Advaced Options</li>
</ul>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210210184505.png" alt="20210210184505"></p>
</div>

<h3 id="填写-gistid-和-token-即可"><a href="#填写-gistid-和-token-即可" class="headerlink" title="填写 gistid 和 token 即可"></a>填写 gistid 和 token 即可</h3><div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210210200919.png" alt="20210210200919"></p>
</div>

<p>同步、下载</p>
<p>上载设定</p>
<p>按 Shift + Alt + U（macOS：Shift + Option + U）</p>
<blockquote>
<p>在命令面板中键入 “&gt; 同步”，以顺序下载 / 上传</p>
</blockquote>
<p>首次下载或上传时，欢迎页面将自动打开，您可以在其中配置 “设置同步”。</p>
<p>选择上传后，上传设置后。您将看到 “摘要” 详细信息以及每个上传的文件和扩展名的列表。</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210210201241.png" alt="20210210201241"></p>
</div>

<h3 id="在其他电脑下载插件和配置"><a href="#在其他电脑下载插件和配置" class="headerlink" title="在其他电脑下载插件和配置"></a>在其他电脑下载插件和配置</h3><p>在 Vscode 的插件扩展中输入 sync 查找并安装，按 ctrl+p 输入 ‘&gt;sync’ ，在弹出窗口中选择高级设置，并打开 github 设置，在打开的网页中输入 github 的用户名和密码，本地配置已完成，之后用快捷键即可进行下载配置。</p>
<p><strong>Setting Sync 快捷键</strong></p>
<p>上传： Shift + Alt + U (Sync: Update / Upload Settings)</p>
<p>下载： Shift + Alt + D (Sync: Download Settings)</p>
<p>如果快捷键有冲突，可 Ctrl + K + S 快捷键设置配置其它快捷键 或 Ctrl + P / F1 在命令窗口输入 &gt;sync 即会出现相应命令供选择</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>os.startfile自动打开文件夹及文件的操作</title>
    <url>/2021/08/22/os-startfile%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8F%8A%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="python-写入文件自动换行问题的方法"><a href="#python-写入文件自动换行问题的方法" class="headerlink" title="python 写入文件自动换行问题的方法"></a>python 写入文件自动换行问题的方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_result</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    writeresult=<span class="built_in">open</span>(<span class="string">&#x27;C:/Users/win/Desktop/aa.txt&#x27;</span>,<span class="string">&#x27;a+&#x27;</span>)</span><br><span class="line">    str1=writeresult.write(<span class="built_in">str</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    writeresult.close()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    a=<span class="built_in">input</span>(<span class="string">&#x27;enter some strs:&#x27;</span>)</span><br><span class="line">    write_result(a)</span><br></pre></td></tr></table></figure>
<pre><code>enter some strs:12
enter some strs:123
enter some strs:1234
enter some strs:12345
enter some strs:123456
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(os.startfile(r&#x27;D:\11&#x27;))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_files_in_dir</span>(<span class="params">path</span>):</span></span><br><span class="line">	<span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">		filepath = os.path.join(path,file)</span><br><span class="line">		<span class="keyword">if</span> os.path.isdir(filepath):</span><br><span class="line">			open_files_in_dir(filepath)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			os.startfile(filepath)</span><br><span class="line">		</span><br><span class="line">path = <span class="string">r&#x27;D:\11&#x27;</span></span><br><span class="line">open_files_in_dir(<span class="string">r&quot;C:\Users\win\Desktop\ccc&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>python 用什么打开文件_用 python 打开文件夹的三种方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一、利用 explorer.exe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 explorer.exe 执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start_directory = r&#x27;C:\ 代码 \ 软件包&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os.system(&quot;explorer.exe %s&quot; % start_directory)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二、用 os.startfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import os</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start_directory = r&#x27;C:\ 代码 \ 软件包&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os.startfile(start_directory)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三、利用 subprocess</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 subprocess</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startfile</span>(<span class="params">filename</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        os.startfile(filename)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">        subprocess.Popen([<span class="string">&#x27;xdg-open&#x27;</span>, filename])</span><br><span class="line"></span><br><span class="line">start_directory = <span class="string">&#x27;D:/11/9.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line">startfile(start_directory)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习方法及极简介绍</title>
    <url>/2021/06/12/python%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%9E%81%E7%AE%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>这个世界上根本没有正确的选择，我们只不过是要努力奋斗，使当初的选择变得正确。</p>
<pre><code>                                                      —— 村上春树
</code></pre>
<p>计算机基础基础</p>
<p>组成</p>
<p>硬件：输入设备 + 输出设备 + 存储设备<br>软件：系统 + 应用软件</p>
<p>语言发展</p>
<p>机器语言 - 汇编语言 - 高级语言</p>
<p>交互方式</p>
<p>TUI：命令行<br>GUI：图形界面</p>
<p>学习方法</p>
<p>三遍</p>
<blockquote>
<p>1、对战视频练习一遍代码（抄）</p>
<p>2、脱离视频，自己写一遍代码（背）</p>
<p>3、结合自身实际去实践（吸收）</p>
</blockquote>
<p>（一）、Python 的开发环境</p>
<p>Python 诞生于 20 世纪 90 年代初，是一种解释型、面向对象、动态数据类型的高级程序设计语言，是最受欢迎的程序设计语言之一。</p>
<p>编写、编译和运行 Python 程序有以下 3 种方法。</p>
<ol>
<li><p>使用交互式解释器</p>
</li>
<li><p>使用 Windows 命令行命令执行 Python 程序</p>
</li>
</ol>
<p>在 Windows 7 中安装 python 程序后，在开始菜单的所有程序中会出现一个 Python 3.6 分组。单击其下面的 Python 3.6 (command line - 32 bit) 菜单项，就可以打开 python 命令窗口。也可以打开 Windows 命令窗口，然后运行 python 命令，来打开 python 命令窗口</p>
<ol start="3">
<li>使用集成开发环境编写和执行 Python 程序</li>
</ol>
<p>IDLE 的启动文件是 idle.bat，它的位置在 Python 安装目录下，运行 idle.bat，即可打开文本编辑器 IDLE。也可以在开始菜单的所有程序中，选择 Python 3.6 分组下面的 IDLE (Python 3.6  32 bit) 菜单项，打开 IDLE 窗口。</p>
<p>（二）、Python 语言的基本语法</p>
<p>Python 程序结构涉及代码块、注释、语句分隔、语句续航和关键字与大小写等内容。</p>
<ol>
<li>用缩进表示代码块</li>
</ol>
<p>Python 程序是依靠代码块的缩进（空格）来体现代码之间的逻辑关系的，缩进结束就表示一个代码块结束了。在包含代码嵌套时，应注意同级的代码块，其缩进量应保持相同（不同可能会导致出错或得到意外的结果）。通常，语句末尾的冒号表示代码块的开始。在 if、for、while、函数、类等定义中都会使用到代码块。</p>
<p>（1）代码注释</p>
<p>注释用于为程序添加说明性的文字。Python 在运行程序时，会忽略被注释的内容。Python 注释有单行注释和多行注释：单行注释用 “#” 表示注释开始，“#” 之后的内容不会被执行。单行注释可以单独占一行，也可放在语句末尾；多行注释是用三个英文的单引号 “’’’” 或双引号 “”””” 作为注释的开始和结束符号。</p>
<p>（2）语句续行</p>
<p>Python 中的一条语句占一行，没有类似于 Java 中的分号等语句结束符号。在遇到较长的语句时，可使用语句续行符号，将一条语句写在多行之中。</p>
<p>Python 有两种续行方式。一种是使用 “\” 符号；另一种续行方式是在使用括号（包括圆括号 ()、方括号 [] 和大括号 {} 等）时，括号中的内容可分多行书写，括号中的空白和换行符都会被忽略。</p>
<p>（3）标识符与关键字</p>
<p>标识符是计算机语言中允许作为名字的有效字符串集合。Python 标识符命名规则和其他大部分用 C 编写的高级语言相似，有以下一些命名规则：名字必须以字母或者下划线‘_’开始；数字不能作为首字符；当名字包含多个单词时，可以使用下划线_来连接，例如 monty_Python；名字不能是关键字。名字不能出现分隔符、标点符号或者运算符。</p>
<p>Python 中的名字是区分大小写的。比如 myClass、MyClass、myclass 是不同的。名字长度不限。</p>
<p>（三）、Python 语言的基本输入输出</p>
<p>在 Python 程序中，通常用 input（）和 print（）函数来执行基本的输入和输出。</p>
<ol>
<li>基本输入</li>
</ol>
<p>input（）函数用于获得用户输入数据，其基本格式为：</p>
<p>用户输入的数据 = input（提示字符串）</p>
<p>其中，变量和提示字符串均可省略。可输入数字、字符串和其它对象，input 函数将用户输入以字符串返回。用户按【Enter】键完成输入，【Enter】键之前的全部字符均作为输入内容。</p>
<p>如果需要输入整数或小数，则需要使用 int 或 float 函数进行转。</p>
<ol start="2">
<li>基本输出</li>
</ol>
<p>print () 函数最简单的应用就是输出字符串，print () 函数的参数列表可以有多个参数，格式如下：</p>
<p>print(“…%s…%s…” %(string1, string2,…stringn))</p>
<p>输出时 string1, string2,…stringn 会出现在对应的 % s 位置。</p>
<p>（四）、Python 的常量、变量和对象</p>
<ol>
<li>常量</li>
</ol>
<p>常量指在程序的执行过程中不变的量。通常直接写出的数据就是常量，如 1,2,3,4,5,6 等。直接写出的数据一般称为字面量，用符号表示的常量一般称为符号常量。</p>
<p>Python 中常用的两个符号表示的常量是 True 和 False，它们分别表示逻辑判断中的‘真’和‘假’，实际的数值分别是 1 和 0。也有一些包含在模块中的用符号表示的常量，常用的如 math 模块中的 pi 和 e。</p>
<ol start="2">
<li>对象</li>
</ol>
<p>Python 中，一切皆对象。对象是某个类型事物的一个具体的实例。对象的类型决定了对象支持的操作，也定义了对象的取值范围。Type（）函数返回对象的类型。</p>
<ol start="3">
<li>变量</li>
</ol>
<p>指向对象的值的名称就是变量。变量是一个标识符，通过等号（=）赋值运算创建，变量指向一个对象。从变量到对象的连接称为引用。</p>
<p>变量使用前需要先赋值，多个变量可以引用同一个对象，一个变量也可以引用不同的对象，引用不同的对象时，id 也就不同的</p>
<p>Python 中的变量不需要声明，可以随时赋不同类型的值</p>
<p>（五）、Python 语言的数据类型</p>
<p>数据类型决定了程序如何存储和处理数据。Python 完善的数据类型系统，使得在 Python 程序中可以轻松完成各种数据处理。Python 中的数据类型分为数字类型、序列类型、集合类型、字典类型等。</p>
<p>1、数字类型</p>
<p>数字类型是那些能进行算术运算、位运算和数学函数运算的数据类型，包括：整数（int，无小数点的数）、浮点数（float，带小数点的数）、复数、其他数字类型等。</p>
<p>2、序列类型</p>
<p>序列类型表示的是若干有序的数据，分不可变序列类型和可变序列类型：</p>
<p>不可变序列的数据类型有字符串、元组和字节序列</p>
<p>可变序列有列表、字节数组等。</p>
<p>3、其他类型</p>
<p>包括：集合数据类型、字典数据类型和 Pyhton 一切皆有类型。</p>
<p>（六）、Python 语言的运算符</p>
<p>对数据的变换统称为运算，表示运算的符号称为运算符，参与运算的数据称为操作数。运算符分为：一元运算符和二元运算符。</p>
<p>运算符有：算术运算符、比较运算符、对象运算符、逻辑运算符、复合运算符等。</p>
<p>（七）Python 语言的常用语句</p>
<p>Python 提供判断语句、循环语句和其他语句 pass、break、continue 语句等。</p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python实用的几个文件操作的案例</title>
    <url>/2021/06/12/python%E5%AE%9E%E7%94%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大神总结的python实用的几个文件操作的案例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-python-进行文件的读写"><a href="#2-python-进行文件的读写" class="headerlink" title="2. python 进行文件的读写"></a>2. python 进行文件的读写</h2><p>文件的读写在 python 中比较常见， 文件读取的时候， 首先要判断文件是否存在， 若文件操作就进行读取， 否则报错。</p>
<p>2.1 文件读操作<br>文件读操作可以的函数有 read (), 这个是读取整个文件， 还有 readlines () 这个是一行行的进行读取并保存到列表中。 下面直接上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(filename) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">raise</span> FileNotFoundError(<span class="string">&#x27;%s not exists&#x27;</span> % (filename,))</span><br><span class="line">    </span><br><span class="line">    f = <span class="built_in">open</span>(filename, encoding=<span class="string">&#x27;utf-8&#x27;</span>)   <span class="comment"># 后面那个是指定编码  一般平台默认编码格式是utf-8</span></span><br><span class="line">    content = f.read()</span><br><span class="line">    f.close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(filename) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">raise</span> FileNotFoundError(<span class="string">&#x27;%s not exists&#x27;</span> % (filename,))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, encoding=<span class="string">&#x27;gbk&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()    <span class="comment">#  这时候读完了之后自动关闭</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line">content = read_file(<span class="string">r&quot;D:\a.txt&quot;</span>)</span><br><span class="line">print(content)</span><br><span class="line"></span><br><span class="line">content = read_file(<span class="string">r&quot;D:\学习方法.txt&quot;</span>)</span><br><span class="line">print(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>&#39;Hey, Python

I just love  Python so much,

and want to get the whole  Python stack by this 60-days column

and believe Python !&#39;
计算机基础基础
组成
硬件：输入设备 + 输出设备 + 存储设备
软件：系统 + 应用软件

语言发展
机器语言 - 汇编语言 - 高级语言

交互方式
TUI：命令行
GUI：图形界面

学习方法
三遍
1、对战视频练习一遍代码（抄）
2、脱离视频，自己写一遍代码（背）
3、结合自身实际去实践（吸收）

理想的人终究 过不好这一生，不快乐
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面是按行读的效果：按行读时，是把每一行都放进列表，输入的是列表</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;文件按行读&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file_line</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filename):</span><br><span class="line">        <span class="keyword">raise</span> FileNotFoundError(<span class="string">&#x27;%s not exists&#x27;</span> % filename)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.readlines()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">con = read_file_line(<span class="string">r&quot;D:\a.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">con</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<pre><code>[&quot;&#39;Hey, Python\n&quot;,
 &#39;\n&#39;,
 &#39;I just love  Python so much,\n&#39;,
 &#39;\n&#39;,
 &#39;and want to get the whole  Python stack by this 60-days column\n&#39;,
 &#39;\n&#39;,
 &quot;and believe Python !&#39;&quot;]
</code></pre>
<p>好了， 基于上面的这个就可以写一个统计文件里面所有单词的出现次数了。 先走一遍这个过程： 我获取到文件的内容， 然后进行分词， 分开之后才能统计个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面是一个统计单词个数的例子</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict  </span><br><span class="line"><span class="comment">#这里的defaultdict(function_factory)构建的是一个类似dictionary的对象，</span></span><br><span class="line"><span class="comment">#其中keys的值，自行确定赋值，但是values的类型，是function_factory的类实例，</span></span><br><span class="line"><span class="comment">#而且具有默认值。比如default(int)则创建一个类似dictionary对象，里面任何的values都是int的实例，</span></span><br><span class="line"><span class="comment">#而且就算是一个不存在的key, d[key] 也有一个默认值，这个默认值是int()的默认值0.</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">rec = re.<span class="built_in">compile</span>(<span class="string">&#x27;\s+&#x27;</span>)      <span class="comment"># 匹配一个或者多个空格</span></span><br><span class="line">dd = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\a.txt&quot;</span>, <span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        clean_line = line.strip()</span><br><span class="line">        <span class="keyword">if</span> clean_line:</span><br><span class="line">            words = rec.split(clean_line)</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">                dd[word] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dd = <span class="built_in">sorted</span>(dd.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">dd</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<pre><code>[(&#39;Python&#39;, 4),
 (&#39;and&#39;, 2),
 (&quot;&#39;Hey,&quot;, 1),
 (&#39;I&#39;, 1),
 (&#39;just&#39;, 1),
 (&#39;love&#39;, 1),
 (&#39;so&#39;, 1),
 (&#39;much,&#39;, 1),
 (&#39;want&#39;, 1),
 (&#39;to&#39;, 1),
 (&#39;get&#39;, 1),
 (&#39;the&#39;, 1),
 (&#39;whole&#39;, 1),
 (&#39;stack&#39;, 1),
 (&#39;by&#39;, 1),
 (&#39;this&#39;, 1),
 (&#39;60-days&#39;, 1),
 (&#39;column&#39;, 1),
 (&#39;believe&#39;, 1),
 (&quot;!&#39;&quot;, 1)]
</code></pre>
<h2 id="2-2-文件写操作"><a href="#2-2-文件写操作" class="headerlink" title="2.2 文件写操作"></a>2.2 文件写操作</h2><p>文件写操作时，需要首先判断要写入的文件路径是否存在。若不存在，通过 mkdir 创建出路径；否则，直接写入文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span>(<span class="params">file_path, file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">        os.mkdir(file_path)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    whole_path_filename = os.path.join(file_path, file_name)</span><br><span class="line">    </span><br><span class="line">    to_write_content = <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">                        Hey, Python</span></span><br><span class="line"><span class="string">                        I just love Python so much,</span></span><br><span class="line"><span class="string">                        and want to get the whole python stack by this 60-days column</span></span><br><span class="line"><span class="string">                        and believe!</span></span><br><span class="line"><span class="string">                        &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(whole_path_filename, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(to_write_content)</span><br><span class="line">write_to_file(<span class="string">&#x27;d:/1/&#x27;</span>,<span class="string">&#x27;b.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>获取文件名及文件的后缀名<br>有时候我们拿到一个文件名的时候， 名字上带有路径， 这时候我们可以用 os.path.split 方法实现路径和文件名的分离。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file_ext = os.path.split(<span class="string">&#x27;d:/1/b.txt&#x27;</span>)</span><br><span class="line">ipath, ifile = file_ext</span><br><span class="line"></span><br><span class="line">print(ipath, ifile)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>d:/1 b.txt
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os.path 模块，splitext 能够优雅地提取文件后缀。</span></span><br><span class="line"></span><br><span class="line">file_extension = os.path.splitext(<span class="string">&#x27;d:/1/b.txt&#x27;</span>)</span><br><span class="line">file_extension     <span class="comment"># .py</span></span><br></pre></td></tr></table></figure>



<pre><code>(&#39;d:/1/b&#39;, &#39;.txt&#39;)
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于上面的这个操作， 就可以获取某个目录下面指定后缀名的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某个目录下指定后缀名的文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_file</span>(<span class="params">work_dir, extension=<span class="string">&#x27;jpg&#x27;</span></span>):</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(work_dir):</span><br><span class="line">        <span class="comment">#print(filename)</span></span><br><span class="line">        splits = os.path.splitext(filename)</span><br><span class="line">        ext = splits[<span class="number">1</span>]      <span class="comment"># 拿到扩展名</span></span><br><span class="line">        <span class="keyword">if</span> ext == <span class="string">&#x27;.&#x27;</span>+extension:</span><br><span class="line">            lst.append(filename)</span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line">r = find_file(<span class="string">r&#x27;d:/test/&#x27;</span>,<span class="string">&#x27;xlsx&#x27;</span>)</span><br><span class="line">r</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<pre><code>[&#39;1.xlsx&#39;,
 &#39;1155.xlsx&#39;,
 &#39;2.xlsx&#39;,
 &#39;21.xlsx&#39;,
 &#39;d1.xlsx&#39;,
 &#39;d2.xlsx&#39;,
 &#39;diff.xlsx&#39;,
 &#39;la.xlsx&#39;]
</code></pre>
<p>这个还是很实用的， 比如在 CNN 的一些任务中， 很多图片都是以.jpg 的形式存放到文件夹里面的， 我们这时候就需要先获取到所有的.jpg 文件， 然后再通过一些方式把图片转成矩阵的表示形式， 这样我们的网络才会认识。</p>
<p>下面再整理一个批量修改文件后缀名的例子， 比如我想把某个目录下所有的.xls 转成.xlsx 文件。这个要怎么做？ 依然是先梳理一下逻辑：</p>
<p>首先要遍历所给的目录<br>拿到各个文件的后缀名<br>看看后缀名是否是需要修改的后缀名， 如果是就进行重命名操作<br>有了这个逻辑， 代码就比较好写了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_rename</span>(<span class="params">work_dir, old_ext, new_ext</span>):</span></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(work_dir):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取文件后缀</span></span><br><span class="line">        split_file = os.path.splitext(filename)</span><br><span class="line">        file_ext = split_file[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> old_ext == file_ext:   <span class="comment"># 定位需要修改后缀名的文件</span></span><br><span class="line">            newfile = split_file[<span class="number">0</span>] + new_ext   <span class="comment"># 修改后文件的完整名称</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 重命名</span></span><br><span class="line">            os.rename(</span><br><span class="line">                os.path.join(work_dir, filename),</span><br><span class="line">                os.path.join(work_dir, newfile)</span><br><span class="line">            )</span><br><span class="line">batch_rename(<span class="string">r&quot;D:\test\excel\data&quot;</span>,<span class="string">&#x27;.xls&#x27;</span>,<span class="string">&#x27;.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_rename</span>(<span class="params">work_dir, old_ext, new_ext</span>):</span></span><br><span class="line">    print(new_ext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(work_dir):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取文件后缀</span></span><br><span class="line">        split_file = os.path.splitext(filename)</span><br><span class="line">        file_ext = split_file[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> old_ext == file_ext:   <span class="comment"># 定位需要修改后缀名的文件</span></span><br><span class="line">            newfile = split_file[<span class="number">0</span>] + new_ext   <span class="comment"># 修改后文件的完整名称</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 重命名</span></span><br><span class="line">            os.rename(</span><br><span class="line"></span><br><span class="line">                os.path.join(work_dir, filename),</span><br><span class="line">                os.path.join(work_dir, newfile)</span><br><span class="line">            </span><br><span class="line">            )</span><br><span class="line">    print(<span class="string">&quot;完成重命名&quot;</span>)</span><br><span class="line">    print(os.listdir(work_dir))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python解析器和Python-IDE的区别</title>
    <url>/2021/04/24/python%E8%A7%A3%E6%9E%90%E5%99%A8%E5%92%8CPython-IDE%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>经常会有刚刚入门 Python 的初学者把 PythonIDE 与 Python 解释器弄混，其实它们是有本质区别的，有些人还会误认为配置 Python 环境就是配置 IDE 工具。那么，PythonIDE 和解释器的区别是什么呢？下面就带大家好好认识一下 Python IDE 和解释器。</p>
<p>1、Python IDE</p>
<p>IDE (Integrated Development Environment)，全称是集成开发环境，是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套 (组) 都可以叫集成开发环境。常见的 IDE 工具有 Pycharm，Visual Studio Code，Vim 等等。</p>
<p>2、解释器</p>
<p>(1) 什么是解释器</p>
<p>我们都知道，Python 是一门解释型语言，解释器是 Python 运行必不可少的一种工具。所以，我们搭建 Pyhton 环境，本质上就是对 Pyhton 进行配置或者定制。而解释器是能够执行用其他计算机语言编写的程序的系统软件，它是一种编译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般偏低，但是解释器的实现较为简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。</p>
<p>(2) Python 解释器</p>
<p>当我们编写 Python 代码时，我们得到的是一个包含 Python 代码的以.py 为扩展名的文本文件。要运行代码，就需要 Python 解释器去执行.py 文件。由于整个 Python 语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写 Python 解释器来执行 Python 代码 (当然难度很大)。事实上，确实存在多种 Python 解释器。</p>
<p>(3) 常见的 Python 解释器</p>
<ul>
<li><strong>A</strong>、CPython：</li>
</ul>
<p>当我们从 Python 官方网站下载并安装好 Python2.7 后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用 C 语言开发的，所以叫 CPython。在命令行下运行 Python 就是启动 CPython 解释器。CPython 是使用最广的 Python 解释器。教程的所有代码也都在 CPython 下执行的。</p>
<ul>
<li><strong>B</strong>、IPython：IPython</li>
</ul>
<p>是基于 CPython 之上的一个交互式解释器，也就是说，IPython 只是在交互方式上有所增强，但是执行 Python 代码的功能和 CPython 是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了 IE。</p>
<ul>
<li><strong>C</strong>、PyPy：</li>
</ul>
<p>PyPy 是另一个 Python 解释器，它的目标是执行速度。PyPy 采用 JIT 技术，对 Python 代码进行动态编译 (注意不是解释)，所以可以显著提高 Python 代码的执行速度。绝大部分 Python 代码都可以在 PyPy 下运行，但是 PyPy 和 CPython 有一些是不同的，这就导致相同的 Python 代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到 PyPy 下执行，就需要了解 PyPy 和 CPython 的不同点。</p>
<ul>
<li><strong>D</strong>、Jython：</li>
</ul>
<p>Jython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。</p>
<ul>
<li><strong>E</strong>、IronPython：</li>
</ul>
<p>IronPython 和 Jython 类似，只不过 IronPython 是运行在微软.Net 平台上的 Python 解释器，可以直接把 Python 代码编译成.Net 的字节码。</p>
<p>3、Python IDE 和解释器的区别</p>
<p>集成开发环境 (IDE) 可以去绑定和调用 Python 解释器进行代码编辑、运行和调试等，但他不等同于解释器。我们配置 IDE 工具的操作，绝大多数都是在调整我们使用工具的方式，只有对解释器的配置，才是对代码运行环境的调整。</p>
<p>综上所述，Python IDE 和解释器的区别还是很大的，大家可千万不要把两者的概念混淆了！</p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>一文理解Python字符串和编码</title>
    <url>/2021/06/14/%E4%B8%80%E6%96%87%E7%90%86%E8%A7%A3Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="整数类型和变量"><a href="#整数类型和变量" class="headerlink" title="整数类型和变量"></a>整数类型和变量</h2><p>1.python 字符串前面加上’r’的作用</p>
<p>这种情况其实是这样子的， 比如下面这两行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 &#x3D; &#39;hello, \&#39;Adam\&#39;&#39;</span><br><span class="line">s2 &#x3D; r&#39;hello, \&#39;Adam\&#39;&#39;</span><br><span class="line"></span><br><span class="line">print(s1)      # hello, &#39;Adam&#39;</span><br><span class="line">print(s2)     # hello, \&#39;Adam\&#39;</span><br></pre></td></tr></table></figure>
<p>‘r’是防止字符转义的 如果路径中出现’\t’的话 不加 r 的话 \t 就会被转义 而加了’r’之后’\t’就能保留原有的样子。</p>
<p>在 Python 的 string 前面加上‘r’， 是为了告诉编译器这个 string 是个 raw string，不要转意 backslash ‘’ 。 例如，\n 在 raw string 中，是两个字符，\ 和 n， 而不会转意为换行符。由于正则表达式和 \ 会有冲突，因此，当一个字符串使用了正则表达式后，最好在前面加上’r’。</p>
<p>2.动态语言 VS 静态语言</p>
<p>python 中的变量往往是采用动态语言的方式，所谓动态语言， 就是说变量本身类型不固定， 我们看一下 python 中的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 123   # a是整数</span><br><span class="line">a &#x3D; &#39;ABC&#39;  # a变成字符串</span><br></pre></td></tr></table></figure>
<p>与动态语言对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如 Java 是静态语言，赋值语句如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 123; &#x2F;&#x2F; a是整数类型变量</span><br><span class="line">a &#x3D; &quot;ABC&quot;; &#x2F;&#x2F; 错误：不能把字符串赋给整型变量</span><br></pre></td></tr></table></figure>
<p>3.变量在进行赋值的时候，python 解释器到底在干什么？</p>
<p>我们看下面的代码， 捋一捋计算机内部的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; &#39;ABC&#39;</span><br><span class="line">b &#x3D; a</span><br><span class="line">a &#x3D; &#39;XYZ&#39;</span><br><span class="line">print(b)    # ABC</span><br></pre></td></tr></table></figure>
<p>我们可能一下子就知道结果， 但是你知道解释器到底在干什么事情吗？ 也就是为什么会有这样的结果？ 这个我直接引用廖雪峰老师画的图了：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210614153608.png" alt="20210614153608"></p>
</div>

<p>Python 支持多种数据类型，在计算机内部，可以把任何数据都看成一个 “对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p>
<p>对变量赋值 x=y 是把变量 x 指向真正的对象， 该对象是变量 y 所指向的。 随后对变量 y 的赋值不影响变量 x 的指向。</p>
<p>4.Python 中的两种除法： / 和 //</p>
<ul>
<li><p>/ 计算结果是浮点数，即使两个整数恰好整除，结果也是浮点数</p>
</li>
<li><p>// 表示地板除法， 两个整数的除法依然是整数， 浮点数相除最后也是整数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9&#x2F;3 &#x3D; 3.0</span><br><span class="line">10 &#x2F;&#x2F; 3 &#x3D; 3</span><br></pre></td></tr></table></figure>
<p>PS: Python 的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如 Java 对 32 位整数的范围限制在 - 2147483648-2147483647。Python 的浮点数也没有大小限制，但是超出一定范围就直接表示为 inf（无限大）。</p>
</li>
</ul>
<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><p>这一块我需要好好的整理了， 之前没太仔细的学习这块， 导致有些东西似懂非懂。</p>
<p>1.字符编码的问题（捋一捋 ASCII，GB2312，Utf-8，Unicode）</p>
<p>字符串也是一种数据类型，但是字符串比较特殊的是一个编码问题， 因为计算机只能处理数字， 如果要处理文本， 就需要先把文本转换成数字。</p>
<p>最早的计算机在设计时采用 8 个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是 255（二进制 11111111 = 十进制 255），如果要表示更大的整数，就必须用更多的字节，两个字节可以表示的最大整数是 65535。</p>
<p>计算机是美国人发明的， 因此，最早只有 127 个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号， 这个编码表被称为 ASCII 编码。 比如大写字母 A 的编码时 65， 小写字母 z 的编码时 122。</p>
<p>但是要处理中文，显然一个字节是不够的， 至少需要两个字节， 而且还不能和 ASCII 编码冲突， 所以中国制定了 GB2312 编码，用来把中文编进去。</p>
<p>但是全世界有上百种语言， 像中国一样，每个国家有各国的标准， 那很容易就乱了套， 出现冲突，也就是在多语言混合的文本中，会出现乱码的问题。因此， Unicode 应运而生， Unicode 把所有语言都统一到一套编码里，就不会再有乱码问题了， 看这个名字也能看出来</p>
<p>现在就可以来看看 ASCII 编码和 Unicode 编码的区别：ASCII 编码是 1 个字节， 而 Unicode 编码通常 2 个字节</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210614153813.png" alt="20210614153813"></p>
</div>

<p>但是这样统一成 Unicode 编码，乱码问题从此消失， 但是，如果你写的如果全是英文， 用 Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上都会造成一种浪费。所以本着节约的精神， 又出现了把 Unicode 编码转换成 “可变长” 的 UTF-8 编码。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。如果你要传输的文本包含大量英文字符，用 UTF-8 编码就能节省空间。</p>
<p>所以这个就是这几种编码之间的关系了，之前遇到编码问题总是心态一崩， 现在终于搞清楚了这些编码之间的逻辑了。</p>
<p>搞清楚了 ASCII、Unicode 和 UTF-8 的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码 , 比如用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210614153904.png" alt="20210614153904"></p>
</div>

<p>浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210614153948.png" alt="20210614153948"></p>
</div>

<p>2.Python 的字符串</p>
<p>在最新的 Python 3 版本中，字符串是以 Unicode 编码的，也就是说，Python 的字符串支持多语言， 可以使用 ord () 函数获取字符的整数表示， chr () 函数把编码转成对应的字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ord(&#39;A&#39;)    # 65</span><br><span class="line">ord(&#39;中&#39;)   # 20013</span><br><span class="line">chr(25991)   # 文</span><br></pre></td></tr></table></figure>
<p>由于 Python 的字符串类型是 str， 在内存中以 Unicode 表示， 一个字符对应若干个字节。** 如果要在网络上传输， 或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes。** Python 中 bytes 类型的数据用 b 前缀的单引号或者双引号表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X1 &#x3D; &#39;ABC&#39;</span><br><span class="line">X2 &#x3D; b&#39;ABC&#39;</span><br></pre></td></tr></table></figure>
<p>注意，这两个是不一样的， X1 是个字符串， X2 虽然和 X1 显示的内容一样，但 bytes 的每个字符都只占用一个字节。</p>
<p>以 Unicode 表示的 str 通过 encode () 方法可以编码为指定的 bytes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;ABC&#39;.encode(&#39;ascii&#39;)   # b&#39;ABC&#39;</span><br><span class="line">&#39;中文&#39;.encode(&#39;utf-8&#39;)    # b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;</span><br><span class="line">&#39;中文&#39;.encode(&#39;ascii&#39;)    # 这个会报错， 中文不能转成ASCII编码</span><br></pre></td></tr></table></figure>
<p>如果我们从网络或磁盘上读取了字节流， 那么读到的数据就是 bytes。 要把 bytes 变为 str， 就需要用 decode () 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#39;ABC&#39;.decode(&#39;ascii&#39;)   # &#39;ABC&#39;</span><br><span class="line">b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;)  # 中文</span><br></pre></td></tr></table></figure>
<p>如果 bytes 中包含无法解码的字节，用 decode () 方法会报错， 如果只有一小部分是无效的字节， 可以传入 errors=’ignore’忽略错误的字节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;)   # 会报错</span><br><span class="line">b&#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;, errors&#x3D;&#39;ignore&#39;)  # ‘中’</span><br></pre></td></tr></table></figure>
<p>3.len () 函数计算字符串长度</p>
<p>我们知道， 如果 len (str) 会计算包含多少个字符， 但是你知道吗？ 如果 len (bytes) 呢， 就会计算字节数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len(&#39;中文&#39;)    # 2</span><br><span class="line">len(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)   # 6</span><br></pre></td></tr></table></figure>
<p>由于 Python 源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当 Python 解释器读取源代码时，为了让它按 UTF-8 编码读取，我们通常在文件开头写上这两行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure>
<p>现在终于知道为啥需要加这两行了， 第一行注释是为了告诉 Linux/OS X 系统，这是一个 Python 可执行程序，Windows 系统会忽略这个注释；第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p>
<ol start="4">
<li>总结梳理</li>
</ol>
<p>最后梳理一遍知识， 首先 python 的基础知识里面抠了点细节，比如那个字符串前面的小 r，这个代表转义失效。 然后就是动态语言和静态语言的区别，还有两种除法。 在字符串编码那块整理了各种编码以及之间的关系，从 ASCII，GB2312， UNicode，utf-8。 然后就是基本的类型，像列表，元组，字典集合等一些细节部分，可变不可变对象等。 函数部分， 整理了函数起别名，空函数，返回多个值的内部原理。 还有各种函数参数，必选参数，默认参数，可变参数 (*num)，关键字参数 (** kw), 命名关键字参数等。 最后介绍了两种递归的细节，关于尾递归，参数里面要传入当前结果或者路径。 下面一张思维导图把知识拎起来：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210614154742.png" alt="20210614154742"></p>
</div>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>不同工作表中筛选数据后并保存到同名工作表新表且自动打开</title>
    <url>/2021/07/08/%E4%B8%8D%E5%90%8C%E5%B7%A5%E4%BD%9C%E8%A1%A8%E4%B8%AD%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE%E5%90%8E%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E5%90%8C%E5%90%8D%E5%B7%A5%E4%BD%9C%E8%A1%A8%E6%96%B0%E8%A1%A8%E4%B8%94%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取excel 某个sheet下的数据,将其转化为列表数据，方便操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_excel_sheet_data</span>(<span class="params">filename, sheetname</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        df = pd.read_excel(filename, sheet_name=sheetname)</span><br><span class="line">        dataList = df.to_dict(orient=<span class="string">&#x27;records&#x27;</span>)  <span class="comment"># 转换为列表</span></span><br><span class="line">        <span class="keyword">return</span> dataList</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">&#x27;未能打开此文件，请确认文件名及路径是否正确&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取excel 所有sheet表名，并将其转化为列表返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_excel_sheet_list</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        df = pd.read_excel(filename, sheet_name=<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> df.keys()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fileName = <span class="string">&#x27;D:/test/xlsx/Notes_111.xlsx&#x27;</span></span><br><span class="line">    sheetList = get_excel_sheet_list(fileName)  <span class="comment"># 获取sheet列表</span></span><br><span class="line">    print(sheetList)</span><br><span class="line">    writer = pd.ExcelWriter(<span class="string">&quot;D:/test/xlsx/新数据.xlsx&quot;</span>, engin=<span class="string">&#x27;openpyxl&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sheetList:  <span class="comment"># 遍历每个sheet名称</span></span><br><span class="line">        sheetData = get_excel_sheet_data(fileName, i)   <span class="comment"># 读取每个sheet下的数据</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> sheetData:  <span class="comment"># 取出每一项的数据</span></span><br><span class="line">            <span class="comment"># do something</span></span><br><span class="line">            <span class="comment"># 依次根据sheet名称对“新数据.xlsx”此文件多次写入Sheet</span></span><br><span class="line">            pd_look = pd.DataFrame(sheetData)</span><br><span class="line">            pd_look.to_excel(writer, sheet_name=i, index=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 最后保存写入，并释放</span></span><br><span class="line">    writer.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有操作成功示例</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据时间创建工作表名子</span></span><br><span class="line">path = <span class="string">r&quot;D:\test\xlsx&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作表名字</span></span><br><span class="line">date_rand = time.strftime(<span class="string">&quot;%H-%M-%S&quot;</span>, time.localtime()) <span class="comment"># &quot;%Y-%m-%d&quot; 按日期创建文件</span></span><br><span class="line">out_file_name = path+<span class="string">&#x27;\%s.xlsx&#x27;</span> % date_rand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取excel 某个sheet下的数据,将其转化为列表数据，方便操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_excel_sheet_data</span>(<span class="params">filename, sheetname</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        df = pd.read_excel(filename, sheet_name=sheetname)</span><br><span class="line">        <span class="keyword">return</span> df </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">&#x27;未能打开此文件，请确认文件名及路径是否正确&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取excel 所有sheet表名，并将其转化为列表返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_excel_sheet_list</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        df = pd.read_excel(filename, sheet_name=<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> df.keys()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fileName = <span class="string">&#x27;D:/test/xlsx/Notes_222.xlsx&#x27;</span></span><br><span class="line">    sheetList = get_excel_sheet_list(fileName)  <span class="comment"># 获取sheet列表</span></span><br><span class="line">    print(sheetList)</span><br><span class="line">    writer = pd.ExcelWriter(out_file_name,engine=<span class="string">&#x27;openpyxl&#x27;</span>)</span><br><span class="line">    <span class="comment"># 加上这一句是为了不覆盖掉原xlsx文件里的工作表,要加入 engine=&#x27;openpyxl&#x27; 引擎</span></span><br><span class="line"><span class="comment">#     book = load_workbook(writer.path)</span></span><br><span class="line">    <span class="comment"># 加上这一句是为了不覆盖掉原xlsx文件里的工作表，同时也 import 入 from openpylx import load_workbook</span></span><br><span class="line"><span class="comment">#     writer.book = book</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sheetList:  <span class="comment"># 遍历每个sheet名称</span></span><br><span class="line">        sheetData = get_excel_sheet_data(fileName, i)   <span class="comment"># 读取每个sheet下的数据</span></span><br><span class="line">        df=sheetData[sheetData[<span class="string">&#x27;code&#x27;</span>]==<span class="number">111</span>] <span class="comment"># do something</span></span><br><span class="line">        print(df)</span><br><span class="line">        <span class="comment"># 依次根据sheet名称对“新数据.xlsx”此文件多次写入Sheet</span></span><br><span class="line">        df.to_excel(writer, sheet_name=i, index=<span class="literal">False</span>)</span><br><span class="line">            </span><br><span class="line">    writer.save()  <span class="comment"># 最后保存写入，并释放</span></span><br><span class="line">    os.startfile(path)  <span class="comment"># 推荐此种写法</span></span><br><span class="line">    <span class="comment"># os.system(&#x27;explorer.exe &#x27; + path) # 程序执行完后自动打开目标文件夹 </span></span><br></pre></td></tr></table></figure>
<pre><code>dict_keys([&#39;Sheet1&#39;])
   code       city
0   111         NY
1   111         CA
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sPath=<span class="string">r&#x27;d:\test1&#x27;</span></span><br><span class="line">os.startfile(sPath)</span><br><span class="line"><span class="comment"># os.system(&#x27;explorer.exe &#x27; + sPath)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    print(time.localtime())</span><br><span class="line"></span><br><span class="line">    year = time.localtime().tm_year</span><br><span class="line">    month = time.localtime().tm_mon</span><br><span class="line">    day = time.localtime().tm_mday</span><br><span class="line"></span><br><span class="line">    hour = time.localtime().tm_hour</span><br><span class="line">    minute = time.localtime().tm_min</span><br><span class="line">    second = time.localtime().tm_sec</span><br><span class="line"></span><br><span class="line">    print(year, <span class="string">&#x27;年&#x27;</span>, month, <span class="string">&#x27;月&#x27;</span>, day, <span class="string">&#x27;日&#x27;</span>)</span><br><span class="line">    print(hour, <span class="string">&#x27;时&#x27;</span>, minute, <span class="string">&#x27;分&#x27;</span>, second, <span class="string">&#x27;秒&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>time.struct_time(tm_year=2021, tm_mon=7, tm_mday=7, tm_hour=16, tm_min=30, tm_sec=37, tm_wday=2, tm_yday=188, tm_isdst=0)
2021 年 7 月 7 日
16 时 30 分 37 秒
</code></pre>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>不同方法读取excel中的多个不同sheet表格性能比较</title>
    <url>/2021/02/06/%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95%E8%AF%BB%E5%8F%96excel%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8Csheet%E8%A1%A8%E6%A0%BC%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p><a href="https://www.jb51.net/article/190704.htm">转自脚本之家</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方法1</span><br><span class="line">def read_excel(path):</span><br><span class="line">  df&#x3D;pd.read_excel(path,None)</span><br><span class="line">  print(df.keys())</span><br><span class="line">  # for k,v in df.items():</span><br><span class="line">  #   print(k)</span><br><span class="line">  #   print(v)</span><br><span class="line">  #   print(type(v))</span><br><span class="line">  return df</span><br><span class="line"> </span><br><span class="line"># 方法2</span><br><span class="line">def read_excel1(path):</span><br><span class="line">  data_xls &#x3D; pd.ExcelFile(path)</span><br><span class="line">  print(data_xls.sheet_names)</span><br><span class="line">  data&#x3D;&#123;&#125;</span><br><span class="line">  for name in data_xls.sheet_names:</span><br><span class="line">    df&#x3D;data_xls.parse(sheetname&#x3D;name,header&#x3D;None)</span><br><span class="line">    data[name]&#x3D;df</span><br><span class="line">    # print(df)</span><br><span class="line">    # print(name)</span><br><span class="line">  return data</span><br><span class="line"> </span><br><span class="line"># 方法3</span><br><span class="line">def read_excel2(path):</span><br><span class="line">  data_xls &#x3D; pd.io.excel.ExcelFile(path)</span><br><span class="line">  data&#x3D;&#123;&#125;</span><br><span class="line">  print(data_xls.sheet_names)</span><br><span class="line">  for name in data_xls.sheet_names:</span><br><span class="line">    df&#x3D;pd.read_excel(data_xls,sheetname&#x3D;name,header&#x3D;None)</span><br><span class="line">    data[name]&#x3D;df</span><br><span class="line">  return data</span><br></pre></td></tr></table></figure>
<h3 id="结论：若读取多个-sheet-表格时，方法-2-和方法-3-相对于方法-1-的效率较高。"><a href="#结论：若读取多个-sheet-表格时，方法-2-和方法-3-相对于方法-1-的效率较高。" class="headerlink" title="结论：若读取多个 sheet 表格时，方法 2 和方法 3 相对于方法 1 的效率较高。"></a>结论：若读取多个 sheet 表格时，方法 2 和方法 3 相对于方法 1 的效率较高。</h3><p>需要解决的问题：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075001.png" alt="20210206075001"></p>
</div>

<p>方法 1 的解析结果:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075043.png" alt="20210206075043"></p>
</div>

<p>方法 2 的解析结果:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075101.png" alt="20210206075101"></p>
</div>

<p>方法 3 的解析结果:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075119.png" alt="20210206075119"></p>
</div>

<h2 id="Python-对-Excel-按列值筛选并拆分表格到多个文件的代码"><a href="#Python-对-Excel-按列值筛选并拆分表格到多个文件的代码" class="headerlink" title="Python 对 Excel 按列值筛选并拆分表格到多个文件的代码"></a>Python 对 Excel 按列值筛选并拆分表格到多个文件的代码</h2><h4 id="场景：集团中心下发本省数据时，并未按地市、业务拆分，现需要按地市、业务拆分并分发到地市。"><a href="#场景：集团中心下发本省数据时，并未按地市、业务拆分，现需要按地市、业务拆分并分发到地市。" class="headerlink" title="场景：集团中心下发本省数据时，并未按地市、业务拆分，现需要按地市、业务拆分并分发到地市。"></a>场景：集团中心下发本省数据时，并未按地市、业务拆分，现需要按地市、业务拆分并分发到地市。</h4><p>本文利用 Python 的 pandas 包实现了以上场景。</p>
<p>注：本示例代码只实现按单列拆分，如果需要多列筛选拆分，请修改本示例中的 filter_column_name 与 city_name_to_list，并多套一层循环。</p>
<p>now, show u the code: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Fri Nov 1 09:53:30 2019</span><br><span class="line">@author: lanxuxml</span><br><span class="line"></span><br><span class="line">应用场景：</span><br><span class="line"></span><br><span class="line"> 包含多个sheet的Excel 需要按列筛选出来另存为其它文件</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import pandas as pd</span><br><span class="line">split_excel_name_head &#x3D; &#39;name_head_&#39;</span><br><span class="line">split_excel_name_tail &#x3D; &#39;_name_tail.xlsx&#39;</span><br><span class="line">xlsx_name &#x3D; &#39;x:\xxxx\xxxxxxxx.xls&#39;</span><br><span class="line">#用来筛选的列名</span><br><span class="line">filter_column_name &#x3D; &#39;column_name&#39;</span><br><span class="line">#将该列去重后保存为list</span><br><span class="line">df &#x3D; pd.read_excel(xlsx_name)</span><br><span class="line">city_names &#x3D; df[filter_column_name].unique().tolist()</span><br><span class="line">#获取所有sheet名</span><br><span class="line">df &#x3D; pd.ExcelFile(xlsx_name)</span><br><span class="line">sheet_names &#x3D; df.sheet_names</span><br><span class="line">#不需要筛选的sheet名</span><br><span class="line">sheet_not_filter_names &#x3D; sheet_names[9:2]</span><br><span class="line">for city_name in city_names:</span><br><span class="line">  city_excel_name &#x3D; split_excel_name_head + str(city_name) + split_excel_name_tail</span><br><span class="line">  writer &#x3D; pd.ExcelWriter(city_excel_name)</span><br><span class="line">  #将city_name转为list</span><br><span class="line">  #如果是两列筛选，在此处多套上一层循环</span><br><span class="line">  #如果是多列筛选，请修改代码使用多维list进行循环遍历</span><br><span class="line">  city_name_to_list &#x3D; []</span><br><span class="line">  city_name_to_list.append(city_name)</span><br><span class="line">  for sheet_name in sheet_names:</span><br><span class="line">    tmp_df &#x3D; pd.read_excel(xlsx_name, sheet_name&#x3D;sheet_name)</span><br><span class="line">    if sheet_name not in sheet_not_filter_names:</span><br><span class="line">      #如果是两列筛选，在此处添加一行代码</span><br><span class="line">     tmp_sheet &#x3D; tmp_df[tmp_df[filter_column_name].isin(city_name_to_list)]</span><br><span class="line">    else:</span><br><span class="line">     tmp_sheet &#x3D; tmp_df</span><br><span class="line">    tmp_sheet.to_excel(excel_writer&#x3D;writer, sheet_name&#x3D;sheet_name, encoding&#x3D;&quot;utf-8&quot;, index&#x3D;False)</span><br><span class="line">  writer.save()</span><br><span class="line">  writer.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-读取-Excel-表格文件的方法"><a href="#python-读取-Excel-表格文件的方法" class="headerlink" title="python 读取 Excel 表格文件的方法"></a>python 读取 Excel 表格文件的方法</h2><p>python 读取 Excel 表格文件，例如获取这个文件的数据:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075741.png" alt="20210206075741"></p>
</div>

<p>#引入Excel库的xlrd<br>import xlrd</p>
<p>2、获取 Excel 文件的位置并且读取进来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#导入需要读取Excel表格的路径</span><br><span class="line">data &#x3D; xlrd.open_workbook(r&#39;C:\Users\NHT\Desktop\Data\\test1.xlsx&#39;)</span><br><span class="line">table &#x3D; data.sheets()[0]</span><br></pre></td></tr></table></figure>
<p>3、读取指定的行和列的内容，并将内容存储在列表中（将第三列的时间格式转换）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建一个空列表，存储Excel的数据</span><br><span class="line">tables &#x3D; []</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#将excel表格内容导入到tables列表中</span><br><span class="line">def import_excel(excel):</span><br><span class="line">  for rown in range(excel.nrows):</span><br><span class="line">   array &#x3D; &#123;&#39;road_name&#39;:&#39;&#39;,&#39;bus_plate&#39;:&#39;&#39;,&#39;timeline&#39;:&#39;&#39;,&#39;road_type&#39;:&#39;&#39;,&#39;site&#39;:&#39;&#39;&#125;</span><br><span class="line">   array[&#39;road_name&#39;] &#x3D; table.cell_value(rown,0)</span><br><span class="line">   array[&#39;bus_plate&#39;] &#x3D; table.cell_value(rown,1)</span><br><span class="line">   #将Excel表格中的时间格式转化</span><br><span class="line">   if table.cell(rown,2).ctype &#x3D;&#x3D; 3:</span><br><span class="line">     date &#x3D; xldate_as_tuple(table.cell(rown,2).value,0)</span><br><span class="line">     array[&#39;timeline&#39;] &#x3D; datetime.datetime(*date)</span><br><span class="line">   array[&#39;road_type&#39;] &#x3D; table.cell_value(rown,3)</span><br><span class="line">   array[&#39;site&#39;] &#x3D; table.cell_value(rown,4)</span><br><span class="line">   tables.append(array)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、运行程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">  #将excel表格的内容导入到列表中</span><br><span class="line">  import_excel(table)</span><br><span class="line">  #验证Excel文件存储到列表中的数据</span><br><span class="line">  for i in tables:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5、最终的运行效果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075948.png" alt="20210206075948"></p>
</div>

<p>6、完整的程序代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import xlrd</span><br><span class="line">from xlrd import xldate_as_tuple</span><br><span class="line">import datetime</span><br><span class="line">#导入需要读取的第一个Excel表格的路径</span><br><span class="line">data1 &#x3D; xlrd.open_workbook(r&#39;C:\Users\NHT\Desktop\Data\\test.xlsx&#39;)</span><br><span class="line">table &#x3D; data1.sheets()[0]</span><br><span class="line">#创建一个空列表，存储Excel的数据</span><br><span class="line">tables &#x3D; []</span><br><span class="line">#将excel表格内容导入到tables列表中</span><br><span class="line">def import_excel(excel):</span><br><span class="line">  for rown in range(excel.nrows):</span><br><span class="line">   array &#x3D; &#123;&#39;road_name&#39;:&#39;&#39;,&#39;bus_plate&#39;:&#39;&#39;,&#39;timeline&#39;:&#39;&#39;,&#39;road_type&#39;:&#39;&#39;,&#39;site&#39;:&#39;&#39;&#125;</span><br><span class="line">   array[&#39;road_name&#39;] &#x3D; table.cell_value(rown,0)</span><br><span class="line">   array[&#39;bus_plate&#39;] &#x3D; table.cell_value(rown,1)</span><br><span class="line">   if table.cell(rown,2).ctype &#x3D;&#x3D; 3:</span><br><span class="line">     date &#x3D; xldate_as_tuple(table.cell(rown,2).value,0)</span><br><span class="line">     array[&#39;timeline&#39;] &#x3D; datetime.datetime(*date)</span><br><span class="line">   array[&#39;road_type&#39;] &#x3D; table.cell_value(rown,3)</span><br><span class="line">   array[&#39;site&#39;] &#x3D; table.cell_value(rown,4)</span><br><span class="line">   tables.append(array)</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">  #将excel表格的内容导入到列表中</span><br><span class="line">  import_excel(table)</span><br><span class="line">  for i in tables:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用-python-对-excel-表格处理的一些小功能"><a href="#使用-python-对-excel-表格处理的一些小功能" class="headerlink" title="使用 python 对 excel 表格处理的一些小功能"></a>使用 python 对 excel 表格处理的一些小功能</h2><p>pandas 库的一些应用</p>
<p>文件读入</p>
<p>代码如下，每一句后面都有注释！<br>包括知识点：</p>
<ol>
<li>excel 文件的写入和输出；</li>
<li>检验表格中是否有 NaN，有即删除一行；</li>
<li>把表格某列中所有某字母替换成另一字母，所有某数字替换成另一数字；</li>
<li>检验表格某列中每一格是 Y 还是 N，是 Y 就在新列中对应输出 1，反之则为 0；</li>
<li>对表格中多列进行运算<br>（首先要配置 pandas 库，如果需要读取和写入文件，要配置 xlsxwriter 库）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import xlsxwriter </span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;my_pacifier.xlsx&#39;) #excel表格文件读入，括号里面写文件地址</span><br><span class="line">word&#x3D;word.replace([&#39;n&#39;,&#39;y&#39;],[&#39;N&#39;,&#39;Y&#39;])  #把excel表里的所有n替换成N，y替换成Y</span><br><span class="line">word&#x3D;word.dropna(axis&#x3D;0)    #如果表格里有一行中有NaN，即删除这一行</span><br><span class="line">word[&#39;m&#39;] &#x3D; word[&#39;a&#39;].str.contains(&#39;Y&#39;).astype(int)   #如果列索引为a的这一列中有Y则对应新列中取值为1</span><br><span class="line">word[&#39;n&#39;]&#x3D;word[&#39;vine&#39;].str.contains(&#39;Y&#39;).astype(int)</span><br><span class="line">word[&#39;n&#39;]&#x3D;word[&#39;n&#39;].replace(1,2)      #把列索引为n的这一列中所有为1的值转换为2</span><br><span class="line">s &#x3D; word.apply(lambda word: word[&#39;a&#39;] *(word[&#39;m&#39;]+word[&#39;n&#39;]) , axis&#x3D;1)    #s列是由表格中其他列的计算得到</span><br><span class="line">word[&#39;Si&#39;]&#x3D;(s - s.min())&#x2F;(s.max() - s.min()) #对s列中的值进行归一化处理</span><br><span class="line">print(word[&#39;Si&#39;])                             &#x2F;&#x2F;打印索引为Si的列</span><br><span class="line">#print(s)</span><br><span class="line">#print(word[&#39;n&#39;])</span><br><span class="line">word.to_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;SVVp.xlsx&#39;,engine&#x3D;&#39;xlsxwriter&#39;)      &#x2F;&#x2F;输出excel文件到电脑中</span><br><span class="line">print(&#39;finished&#39;) </span><br></pre></td></tr></table></figure>
<p>计算表格中每一行的英文单词数</p>
<p>包含知识点:</p>
<ol>
<li>dataframe 和字典、列表的转换；</li>
<li>如何遍历字典；</li>
<li>计算 dataframe 中每一列的英文句子中的单词数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import xlsxwriter </span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;reviewh.xlsx&#39;)  #里面只有一列数据</span><br><span class="line">c&#x3D;[]      #列表，用来统计每一行的英文句子的英文单词个数</span><br><span class="line">word&#x3D;word.set_index(word.index).T.to_dict(&#39;list&#39;) #把这一列数据按dataframe的索引转换成字典     </span><br><span class="line">for key,value in word.items():    #遍历字典</span><br><span class="line">  s&#x3D;str(value)           #先把表格里当前行的内容转换成字符串</span><br><span class="line">  a&#x3D;s.split(&#39; &#39;)          #把英文句子按空格分割</span><br><span class="line">  num_s&#x3D;len(a)            #计算出单词个数</span><br><span class="line">  c.append(num_s)          #添加到c中</span><br><span class="line">c&#x3D;pd.DataFrame(c)           #由列表转换为dataframe</span><br><span class="line">c.to_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;counth.xlsx&#39;,engine&#x3D;&#39;xlsxwriter&#39;)  &#x2F;&#x2F;输出成新的文件</span><br><span class="line">print(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>
简单用 textblob 进行自然语言情感分析</li>
</ol>
<p>用 NLP 简单分析表格中每一格的英文句子的情感极性和主观性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from textblob import TextBlob</span><br><span class="line">import xlsxwriter </span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;reviewh.xlsx&#39;)</span><br><span class="line">c&#x3D;[]</span><br><span class="line">word&#x3D;word.set_index(word.index).T.to_dict(&#39;list&#39;)</span><br><span class="line">for key,value in word.items(): </span><br><span class="line">  s&#x3D;str(value)</span><br><span class="line">  blob &#x3D; TextBlob(s)     #把s转化成textblob对象</span><br><span class="line">  blob &#x3D; blob.sentences   #利用TextBlob句子标记化句子</span><br><span class="line">  first &#x3D; blob[0].sentiment   #对标记化后的句子进行情感分析（我这里只有一个句子，如果有很多句就添加second&#x3D;blob[1].sentiment）</span><br><span class="line">  c.append(first.polarity)    #这里只添加了情感极性，如果还需要主观性，就直接用first</span><br><span class="line">c&#x3D;pd.DataFrame(c)</span><br><span class="line">c.to_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;NLPh.xlsx&#39;,engine&#x3D;&#39;xlsxwriter&#39;)</span><br><span class="line">print(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>
<p>判断一行中是不是有两列值都与其他行重复（可推广至多列）</p>
<p>判断表中是不是有在同一行中 a 列和 b 列值都相同的情况。如第一行中 a=1，b=2，第 4 行中 a=1，b=2，则这两行相同；如果第 8 行中 a=1，b=3，则它和第一行不重复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import xlsxwriter</span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;my_hair_dryer.xlsx&#39;)</span><br><span class="line">x&#x3D;word[&#39;a&#39;]     </span><br><span class="line">y&#x3D;word[&#39;b&#39;]</span><br><span class="line">z&#x3D;pd.concat([x,y],axis&#x3D;1)#对axis&#x3D;1即把两列按行对齐，即左右拼接成一张表       </span><br><span class="line">z[&#39;repeat&#39;]&#x3D;z.duplicated()  #判断表中有没有重复的，如果有则输出为true</span><br><span class="line">ll &#x3D; z[&#39;repeat&#39;].values.tolist()   #把这一列转变成列表   </span><br><span class="line">if &#39;True&#39; in ll:   #遍历列表，如果里面有true，就说明有重复，就输出yes</span><br><span class="line">  print(&#39;yes&#39;)</span><br><span class="line">print(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>
<p>对表格中的两列自定义函数运算</p>
<p>（此处定义的是除法运算）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import xlsxwriter </span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;my_hair_dryer.xlsx&#39;)</span><br><span class="line">def chu(x,y):</span><br><span class="line">  if y&#x3D;&#x3D;0:   #分母为0，则不运算，结果直接为0</span><br><span class="line">    result&#x3D;0</span><br><span class="line">  else:</span><br><span class="line">    result&#x3D;x&#x2F;y</span><br><span class="line">  return result</span><br><span class="line">s &#x3D; word.apply(lambda word:chu(word[&#39;helpful_votes&#39;],word[&#39;total_votes&#39;]), axis&#x3D;1)</span><br><span class="line">s.to_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;voteh.xlsx&#39;,engine&#x3D;&#39;xlsxwriter&#39;)</span><br><span class="line">print(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>
<p>判断表格中某列中是否有空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import xlsxwriter </span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;my_hair_dryer.xlsx&#39;)</span><br><span class="line">train&#x3D;word[&#39;review_date&#39;]</span><br><span class="line">print(train.isnull().any())   #有空即输出true</span><br></pre></td></tr></table></figure>
<p>对表格某列中时间格式的修正</p>
<p>原格式是月 / 日 / 年，如 1/11/2014，改为标准 datetime 格式 2014-01-11（此处还要舍去后面的 00：00：00），方便之后画图，也方便排序等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import datetime  #引入库</span><br><span class="line"></span><br><span class="line">#导入数据集</span><br><span class="line">data &#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;Exx.xlsx&#39;)</span><br><span class="line"></span><br><span class="line">data &#x3D; data.loc[:, [&#39;review_date&#39;]] # 获取数据集中列名为review_date</span><br><span class="line">#s&#x3D; pd.to_datetime(data[&#39;review_date&#39;], format&#x3D;&#39;%m&#x2F;%d&#x2F;%Y&#39;)</span><br><span class="line"></span><br><span class="line"># 标准化日期，获取时间的“年、月、日”</span><br><span class="line">def change_date(s):</span><br><span class="line">  s &#x3D; datetime.datetime.strptime(s, &quot;%m&#x2F;%d&#x2F;%Y&quot;) #这里是原格式的形式，俺是月&#x2F;日&#x2F;年，可根据实际情况修改 </span><br><span class="line">  # 把日期标准化，如把1&#x2F;11&#x2F;2014变成2014-01-011 00:00:00</span><br><span class="line">  s &#x3D; str(s) # 上一步把date转化为了时间格式，此处把date转回str格式</span><br><span class="line">  return s[:10] #只获取年月日的方法,即“位置10”之前的字符串</span><br><span class="line">  #字符串的切片</span><br><span class="line"></span><br><span class="line">data[&#39;review_date&#39;] &#x3D; data[&#39;review_date&#39;].map(change_date) </span><br><span class="line"># 用change_date函数处理列表中date这一列，如把“1&#x2F;11&#x2F;2014”转化为“2014-01-11”</span><br><span class="line">#data &#x3D; data.sort_values(by&#x3D;&#39;review_date&#39;) # 按date这一列进行排序，根据需要采用</span><br><span class="line">data.to_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;Exxx.xlsx&#39;,engine&#x3D;&#39;xlsxwriter&#39;)</span><br><span class="line">print(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>
<p>运用 matplotlib 画时间序列图，重叠图</p>
<p>画时间序列图<br>（如果要画重叠图，记得 x 要一样，y 可以不一样，然后用 plt.plot (x,y0,x,y1,x,y2) 即可画出重叠图）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib</span><br><span class="line">import datetime</span><br><span class="line">from statsmodels.graphics.factorplots import interaction_plot</span><br><span class="line">import xlsxwriter </span><br><span class="line">data&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;Exx.xlsx&#39;)</span><br><span class="line"># # create data </span><br><span class="line">s&#x3D;data[&#39;E&#39;]      #y轴</span><br><span class="line">e0&#x3D;s[2907:5043]</span><br><span class="line">t&#x3D;data[&#39;review_date&#39;] </span><br><span class="line">t0&#x3D;t[2907:5043]</span><br><span class="line">y0 &#x3D;e0.values.tolist()</span><br><span class="line">x0 &#x3D; pd.to_datetime(t0)     #x轴</span><br><span class="line"># # plot</span><br><span class="line">plt.plot(x0,y0)        </span><br><span class="line">plt.gcf().autofmt_xdate()</span><br><span class="line">plt.grid(ls &#x3D; &#39;--&#39;)      #设置背后的网格线</span><br><span class="line">plt.show()  #最后一定要show()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么社会上到处都是有才华的穷人</title>
    <url>/2021/08/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A4%BE%E4%BC%9A%E4%B8%8A%E5%88%B0%E5%A4%84%E9%83%BD%E6%98%AF%E6%9C%89%E6%89%8D%E5%8D%8E%E7%9A%84%E7%A9%B7%E4%BA%BA/</url>
    <content><![CDATA[<p>社会上有很多才华横溢的穷人。</p>
<p>比如，我见过有人在知乎上发表一篇文章，是讲转基因食品的优缺点，然后有个杠精就在底下提出反对意见，然后就跟作者在下面杠了几十条，来来回回的。</p>
<p>最终就是一场骂战，而且骂的很难听。</p>
<p>我点开他的头像，是xx大学的硕士。</p>
<p>我就知道这个人肯定是个才华横溢的穷鬼。</p>
<p>他每天都要花上几个小时在网上跟别人互喷，而且他自认为自己是有理有据的，懂科学，有文化，有学识，文笔好。</p>
<p>只不过，粉丝很少，才一百多个。</p>
<p>而且我能判断出来，他每天把这么多宝贵时间，这么多正面情绪，都投入到跟赚钱毫无关系的网络互喷当中，他一定很穷。</p>
<p>这类人属于把宝贵的时间和情绪都白白浪费掉的畜生。这种人如果想要翻身，就先要夺回自己大脑的主权，重新拥有独立思考的能力。</p>
<p>而不是每天看各种虚假的新闻和砖家的报道。</p>
<p>你要知道，不论是支持转基因还是反对转基因的大V（包括崔Y元和白Y松），他们的目的都是为了聚集粉丝，然后赚钱。</p>
<p>再比如那些房产大V，也分成两类，有一类是唱衰zg房地产的，每篇文章都会写这种字样：重磅，国家终于要对房地产下手了！明年房价必跌！</p>
<p>还有一类大V，一直鼓吹房地产是最好的投资，一直发布利好消息。</p>
<p>这两类人可以连续10年写文章支持自己的观点，而且他们都能赚的盆满钵满。</p>
<p>是每年都能赚的盆满钵满。</p>
<p>只有那些没有独立思考能力的傻狗，还在评论区里互喷，为大V源源不断地带去热度。</p>
<p>以上是第一类有才华的穷人。</p>
<p>第二类有才华的穷人，他们的执行力非常差。</p>
<p>我之前有个朋友是某985大学的本科毕业生，大概在2019年的时候，我跟他讲了很多知乎和公众号的玩法，而且把教程都给他了。</p>
<p>就在上周，他看我朋友圈发的收款截图，然后他跟我说，兄弟，你再跟我说说自媒体怎么做，我现在房贷快还不起了，我们单位又降薪了（国企）。</p>
<p>我说，自从上次我跟你讲完之后，你写过多少篇文章了？</p>
<p>他把知乎、公众号和抖音都给我看了一下，我发现他一共才发了不到10篇内容。</p>
<p>我就问他，之前不是说的好好的吗，你一周发一篇，而且你的文笔也不错啊。</p>
<p>然后他说，一直没有找准方向，而且感觉自己的写作方法需要训练，报过一个写作课，但是从来没有认真实践过……</p>
<p>我就知道，他也是那种才华横溢的穷人。</p>
<p>这种人看起来很有才华，也很有目标，但终其一生，他什么成就都不会有的。</p>
<p>因为他永远只是“想做事”，永远都觉得条件不成熟，要等一等，再等一等。</p>
<p>他们不知道，行动的最好时机就是现在，立刻，马上。</p>
<p>条件永远是不成熟的，干着干着你就成熟了。</p>
<p>很多人就是因为太“聪明”，什么事还没干就先把自己否定了。</p>
<p>最后一类有才华的穷人，是受弱势文化荼毒太深的人，这种病很难治。</p>
<p>比如，他们月薪过万，但是仍然用着千元机，经常卡顿影响自己的工作和体验。你让他换个5000元的iPhone, 比杀了他都难受，坚决不换。</p>
<p>再比如，你跟他说，要偶尔买件贵的东西，偶尔坐一次头等舱奖励自己，他们听了之后会非常抵触，他们会拿出“艰苦奋斗”“不能铺张浪费”那套说辞。</p>
<p>另外，这种人一般也非常自律，每天都有自己的读书计划，锻炼计划，早睡早起学英语。</p>
<p>书上和励志故事里面，都会讲这些是大人物都应该具备的品质。</p>
<p>我想说，这些都是忽悠穷鬼的说辞。</p>
<p>你如果想稳定地上个班，一直打工到退休，月薪从几千涨到一万多，甚至两万多，这辈子就这样过了，那么完全没问题，你可以一直节俭下去，自律下去。</p>
<p>但如果你想做一番事业，赚大钱的话，不是光靠艰苦奋斗和自律就能完成的。</p>
<p>贪婪的人都比自律的人要有出息。</p>
<p>因为自律是反人性的，真正的自律不是自虐，让自己受苦，而是应该调动更大的欲望，来征服眼前的小欲望。</p>
<p>xx传统文化的本质，就是把人教成N隶的文化，把人教成废物的文化。</p>
<p>比如，它会一直教你压制欲望，抵制欲望。</p>
<p>但欲望这个东西是大自然赋予我们的，是刻在基因里面的，你怎么抵制？</p>
<p>还不如适当的疏导，适当的享受，享受作为人的乐趣。</p>
<p>一旦你体验过欲望满足的感觉，你才会有更大的奋斗激情，你的潜力也会慢慢被激发出来。</p>
<p>很多人没有体验过“特权”和“权力”的感觉。</p>
<p>你坐一次头等舱，你就知道“优先权”是什么感觉了，而且这种感觉会让人欲罢不能，很可能沾上就戒不掉了。</p>
<p>戒不掉了怎么办？那就只能努力开拓更多的收入渠道，必须让头等舱成为自己出行的标配。</p>
<p>这绝对是一种正向的激励机制，那些喜欢“艰苦奋斗文化”的人，会一直缺失这种激励机制。</p>
<p>再比如，做自媒体的，你必须要体验“一呼百应”“众人追随”的感觉。</p>
<p>我在写作群和VIP群一直跟大家说，无论你是做抖音的，还是做知乎的，你一定要想方设法获取一大批追随者。哪怕初期的内容全是抄袭的，复制的，改编的也行。</p>
<p>总之呢，如果有几千、几万人关注你，留言支持你，为你打赏，为你买单，你就有了一点“呼风唤雨”的感觉，这种体验就是权力的感觉。</p>
<p>一旦你体验过，就会上瘾的，从此就一发不可收拾。想要维持这种感觉，就只能继续深耕，继续修炼，让自己的影响力越来越大。</p>
<p>最后你会发现，所有的成长，都是在尝到甜头之后发生的，而不是吃苦吃出来的。</p>
<p>夸一个穷人如何节俭，就如同夸一个太监道德如何高尚、不乱搞女人一样残忍。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么非要上学</title>
    <url>/2021/05/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E8%A6%81%E4%B8%8A%E5%AD%A6/</url>
    <content><![CDATA[<p>很多时候所谓教育，就是大人想把自己已经明白的道理讲给孩子们听。只可惜，真正听进去的人并不多。</p>
<blockquote>
<p>“为什么非要上学？不读书也能赚钱养活自己”<br>“大学毕业后一样得找工作，为什么不能现在就去打工？”</p>
</blockquote>
<p>当孩子问起这些问题，一场生活教育，比你唠叨千万句更管用。</p>
<p>上学那么重要，为什么孩子就是不懂？</p>
<p>时代变了。以前大家穷，上学就是为了能分配工作、走出老家、养家糊口、出人头地。</p>
<p>而现在呢，大部分孩子都从小不愁吃穿，家长甚至都不舍得让做家务，从小学起就被逼在读书的军备竞赛中，和一本又一本的书、一道又一道的题打交道，逼久了、逼急了，孩子们不知道为什么要逼自己，为什么必须要努力。</p>
<p>在应试教育之外，我们缺乏了生活教育。</p>
<p>这些鲜活的生活，给孩子看看，比你唠叨千万句还管用。</p>
<p>①带孩子去老家走走，哪怕是早已破败的院落。都说改变阶层要靠三代人的努力，但毁掉可能只需要一代。让孩子知道父辈是怎么打拼下了现在的生活，然后问问孩子是想要继续往上走，还是倒退回去。</p>
<p>②带孩子去机场、高铁站、火车站、汽车站走走，看看每个地方行人的言谈举止、衣食住行。让孩子知道人虽生而平等，但生活质量，是分三六九等的，想要哪种生活，得靠自己去争取。</p>
<p>③带孩子去招聘现场走走。让孩子知道在求职的第一关，面试官就会看学历的，博士、硕士、本科，双一流、985、211，对不同求职者，态度是不一样的。不同的工作，薪酬、待遇也是千差万别的。让孩子了解，想做的工作，需要怎样的学历和能力，现在是否已经具备。</p>
<p>但仔细研究就可以知道，除了被耽误了的学习天赋外，是他超出常人的努力和付出。</p>
<p>“辛苦是辛苦，但相比种地的辛苦、在工地搬石头的辛苦，这又算得了什么呢？”</p>
<p>吃过了生活的苦的人，更能忍受读书的苦，因为他更明白这一份苦后面隐藏的甜。</p>
<p>今天吃读书的苦，明天才能享生活的甜。</p>
<p>为什么要好好读书？知乎上有一个高赞回答：</p>
<p>就像课堂上老师说的，你现在读书不是为了别人，而是为了自己。</p>
<p>生活这破烂玩意儿会使了老劲摧残你，不会跟你讲什么道理，你只能默默承受，或者拼命反抗。</p>
<p>而在你真正直面生活之前，能让自己的起点高点，就高点，再高点。</p>
<p>这样当生活魔抓伸出尖锐的指甲时，你至少还能选择用什么样的姿势去接受挑战。</p>
<h2 id="孩子一天天长大，这些话记得和孩子聊一聊…"><a href="#孩子一天天长大，这些话记得和孩子聊一聊…" class="headerlink" title="孩子一天天长大，这些话记得和孩子聊一聊…"></a>孩子一天天长大，这些话记得和孩子聊一聊…</h2><p>父母是孩子漫漫人生路上最初接触的人，也是第一位导师，对于孩子的成长、发展起到不可或缺的作用。</p>
<p>其实，除了学习、成绩，还有一些事你也必须讲给孩子。</p>
<p>今天我们一起来走近一位智慧母亲，看一看她是如何用信的方式与孩子沟通，一起倾听她的谆谆教诲与殷殷牵挂。</p>
<p>写这信给你，基于三个原因：</p>
<blockquote>
<p>第一，你正站在人生节点上：回首，是悄然溜走的童年时光；向前，青春的帷幕徐徐向你开启。 </p>
<p>第二，有些话，我们不跟你说，没有人会跟你说。</p>
<p>第三，彼此约定：我们好好工作，你好好读书，谁也不让谁操心。</p>
</blockquote>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>不管大小，一定要有目标。</p>
<p>人可以没有伟大理想，但不能失去目标。</p>
<p>目标感的建立会决定一个人一生的高度，有目标的人生是蓝图，没有目标的人生是拼图。</p>
<p>目标是一个人前进的动力，每一个从小就有目标的孩子，都是未来很厉害的孩子。</p>
<p>《人生设计在童年》的作者高燕定先生曾说：</p>
<p>“从小开始人生规划，设立人生目标，可以在教育资源有限、生存竞争日益激烈的社会上保有立足之地，拥有美好的人生。”</p>
<p>目标决定了一个人是否有立足之地，目标是一个人美好人生的起源。</p>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>用心打磨自己的性格。</p>
<p>在家里，独生子女个个都是小皇帝，但在学校，皇帝太多，没人会把你当回事！</p>
<p>除非你的成绩更优秀、你的才艺更出众、你的表现更出色，老师才会当你是块宝。</p>
<p>社会也一样，以后，要别人瞧不起还是尊重，都靠自己负责。</p>
<h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h3><p>身体是学习的本钱。</p>
<p>在学校，学习是主要的，但不是唯一的，身体健康也很重要。</p>
<p>有人说，人生在世总要被比来比去，同学间搞聚会，要比就比：20岁比学历、30岁比能力、40岁比阅历、50岁比财力、60岁比体力、70岁比病历、80岁翻黄历，人生几十载，归根到底就是比身体，孩子，好好锻炼吧。</p>
<h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>坚持，坚持，再坚持。</p>
<p>一个人的未来由知识、能力、态度决定。知识可以通过学习获得，能力也可以在实践中增长，而态度却由习惯养成。</p>
<p>现在，端正态度还来得及。未来，我希望你所做的一切，都既利己又利人。</p>
<h3 id="自己"><a href="#自己" class="headerlink" title="自己"></a>自己</h3><p>既不自傲也不自卑。</p>
<blockquote>
<p>在学校，老师没有义务对你好，除非你首先尊重老师；</p>
<p>同学没有义务关心你，除非你首先关心同学；</p>
<p>在你的一生中，也没有人有义务要对你好，除了我和你爸。</p>
</blockquote>
<p>不要以为世界少了自己，地球就转不了，不要以为个人渺小，就自我放弃和抛弃。</p>
<h3 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h3><p>朋友是能和你一起哭的人。</p>
<p>交友就像投资。投资当然要考虑回报，能从朋友身上学习到任何一点优秀的品质，那都是回报。如果你找了个朋友，而朋友最后没有给你回报，只能证明你投资失败。</p>
<p>记住，在朋友落难时，一定要施以援手。</p>
<p>因为，与自己一起笑过的人易忘记，与自己一起哭过的人最难忘。这就是为什么雪中送炭比锦上添花更有意义。</p>
<h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p>父母的这些小心思。</p>
<p>为人父母，谁都渴望与子女的距离短些，但随着儿女的成长，属于你们的天空肯定会越来越广阔，与父母的空间距离与时间距离也肯定会越来越远。</p>
<p>做父母的，当然特别在乎自己到底能够占据儿女多大的天空位置！</p>
<p>因为，父母的天空与儿女的天空恰恰相反——随着一天天老去而变得愈来愈小。</p>
<p>我凡人百姓，同样拥有大众情怀，同样在乎你是否常在身边。父母的儿女情长，你是否读得懂？</p>
<h3 id="得失"><a href="#得失" class="headerlink" title="得失"></a>得失</h3><p>永远不要去计较得失。</p>
<p>一个人，不可能永远得意，也不可能永远失意。</p>
<blockquote>
<p>得意时，你要清醒，这个世界上有太多比自己厉害的人，要记得自己的渺小；</p>
<p>失意时，不退缩，坚持下去，过去是怎样走过来的，现在就怎样走过去。</p>
</blockquote>
<h3 id="亲人"><a href="#亲人" class="headerlink" title="亲人"></a>亲人</h3><p>家，是你最温暖的港湾。</p>
<p>亲人只有一次缘分，这辈子，即使无法与你一路伴行，但在风雨交加的时候，总会想着为你遮风挡雨一程！</p>
<p>即使不能与你一路并肩作战，但在艰难险阻的时候，总会想着与你一同分担苦痛！</p>
<p>这辈子，无论我们和你会相处多久，都请好好珍惜共聚的时光，下辈子，无论爱与不爱，都不会再见。</p>
<h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>对于小学家长，你还有很多年，不过时间真的过得很快……</p>
<p>对于初中生家长，你可能还有三年的时间来陪孩子慢慢长大，可对于高中生家长，去读大学前的这段时间可能就是你日夜陪伴孩子的最后一段。</p>
<p>日后，他会买一张票远去求学，会找一座城落根打拼，会挑一个人恋爱结婚，会生一个娃守护一生。余生，他会离你越来越远。</p>
<p>珍惜彼此相伴的日子，和他好好聊聊天，也告诉他，你一直都会在他身后。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>人最重要的能力是什么</title>
    <url>/2021/02/16/%E4%BA%BA%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E8%83%BD%E5%8A%9B%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>人最重要的能力是什么</p>
<p>随时保持内心平静的能力</p>
<p>我开始第一个想到的是「坚持」，后来我认为不对。</p>
<a id="more"></a>

<p>「坚持」仅仅是成功所必备的能力，并不是人生最重要的能力，亦不是我们最缺乏的能力。</p>
<p>坚持的目的是为了成功，成功的目的是为了幸福。然而我见过很多人能成功，但并不幸福。</p>
<p>要讨论人生最重要的能力，我们必须要放眼于整个人生：</p>
<p>人到底追求什么？</p>
<p>很多人会说「要一份成功的事业」、「要赚大把钱」、「要找到自己相爱的人厮守一生」。</p>
<p>我们纵观这些欲望，无一不在诉求着一个共同的追求：幸福。</p>
<p>我在以前诉说过，人要达到理想中的幸福状态是很难的。因为我们大多数人理解的幸福为：我想要干嘛就干嘛。</p>
<p>但是想想，如果一个人真的能随心所欲，想得到什么就能得到什么。那么他剩下的，就只有无聊了。这时他会到处找事做，寻找新的欲望。</p>
<p>我见过坐拥千万的富翁，他们买了一个又一个的包，玩了一个又一个的女人。然而他们表现出来的并不是幸福，而是永不满足的焦虑。</p>
<p>一个包买回来，用几天又马上束之高阁，因为他看中了又一个更漂亮的包。</p>
<p>我见过退休的老干部，老两口一个月上万工资。然而经常为儿子没有找到公务员的工作烦恼，儿子娶媳妇的事烦恼，孙子的教育烦恼。</p>
<p>儿子不在身边，他们又烦恼「厅里的灯没有关怎么办」，「房门是不是锁紧了」，「我的高血压什么时候能治愈，我还能活多久」。</p>
<p>无时不刻处在焦虑和不安之中，换而言之，他们并没有达到自己想象中的幸福状态。</p>
<p>反观我自己，我小的时候期盼快读大学，那样就不用天天上学听家长唠叨成绩了。</p>
<p>后来进了大学，我又期盼着早点出来工作。因为工作就有工资，有钱，有钱才有自由。</p>
<p>现在我出来工作这么多年，我又想着退休——我想退休的人整天浇浇花、散散步，那一定会很幸福了吧。</p>
<p>在看了别人的生活、以及读了一些书以后，我开始明白，一个人如果没有刻意地去修炼，在社会的这座染缸里搅成一团，是永远没法安宁的。</p>
<p>他永远觉得此时此刻是最痛苦的时候，而我现在的痛苦，是为了明天的光明，明天一定会过得比今天好。</p>
<p>事实上这是一种幻觉，明天不一定会更好，还有可能会更坏。</p>
<p>一个不平静的人，无论给他什么样的条件，他都不得安宁，因为他没有获得幸福的能力。</p>
<p>我们生而为人，既不能活在过去，亦不能活在未来，我们所拥有的，只有一分一秒正在流逝的当下。所以把握住当下，这一分一秒的平静就是最重要的。</p>
<p>看了我的答案肯定会有人说：「我觉得你所谓的平静还不够，我要追求的是天天开心。」</p>
<p>我们很多时候所谓的开心，即感官之快乐。</p>
<p>同样是愉悦，做爱和读书带来的就不一样。前者的快乐亦即感官的快乐，这种感觉让人飘飘然，茫然而不知所措。而后者则悠远而绵长，回味无穷，因为它是平静的。</p>
<p>一个人如果很容易快乐，那么相应的，他也将很容易哭泣。因为他感性，情绪波动大。而同样的一件事情，带来的痛苦往往比快乐大得多。</p>
<p>试想想，同样是一万块钱，是你得到时的快乐多还是失去时的痛苦多？</p>
<p>年轻的时候，对所有能让人开心的事，要保持谨慎的态度：比如熬夜玩游戏；比如性爱；比如抽烟；比如喝酒。</p>
<p>最后我们会发现，每一个能让你开心的事情，背后都会付出更为沉重的代价。</p>
<p>一个懂得审时度势的人，应该学会避免不必要的痛苦，而不是去一味追求快乐。</p>
<p>关于这个话题太大，和我们讨论的题目关系不大，所以用一句话概括之，即「片刻之欢愉，不如须臾之宁静」。</p>
<p>我记得有一次搭地铁，整个车厢里的人都显得很焦躁。和无数个早晨一样，人们都显出一副很忙的样子，不停地按手机，打电话，聊天刷微信，抖腿，东张西望。</p>
<p>唯有一个女生静静地坐在那里，手安静地放在膝盖上，一动不动，像一棵树一样，不争不取，不偏不倚，安静地生长。注视着她，我想起了一首诗：</p>
<p>草在结它的种子，</p>
<p>风在摇它的叶子，</p>
<p>我们站着，不说话。</p>
<p>就十分美好。</p>
<p>有些人注定要在人群中卓尔不群，因为她的修养，因为她的气质。</p>
<p>我以前根本不知道自己要追求怎样的女孩，孝顺？多金？漂亮？聪明？</p>
<p>在这一刻我明白了，这就是我要追求的人，要追求的人生。</p>
<p>2</p>
<p>独处的能力</p>
<p>总有一天，你会明白，独处的能力有多重要。</p>
<p>你是否也有过这样的时刻？</p>
<p>高中的时候，很清楚的记得女生上厕所都喜欢三两结伴一起去。不是因为彼此刚好都有需求，只是想有个人说说话不无聊。</p>
<p>大学食堂，多是两人或以上一起吃饭。如果是一个人吃饭，便打包回宿舍。不是人多坐不下，而是一个人吃饭的身影显得孤单又凄凉。</p>
<p>电影院，更多的是一对对的情侣和三两成群的好友。不是一个人不能感受，而是好像有人一起分享悲喜和情怀才够味儿。</p>
<p>一个人的时候，似乎无论何处，总是叫人觉着孤单，羞赧而别扭。</p>
<p>在这个人以群居的社会，我们好像很难忍受「一个人」。在这个快节奏的时代，我们好像很难专注「一个人」。课本、课堂也从来没有教育过我们如何学会独处的能力，如何享受一个人的时光。</p>
<p>而这两年，我已慢慢习得了这种能力。</p>
<p>因为逐渐意识到，即便是和自己有着血浓于水关系的父母，也终有别离的一天；</p>
<p>即便是关系再好的朋友也有因自己的生活而顾不上你的时刻；</p>
<p>即便是情深的伉俪也有生死别离到来的那一日；</p>
<p>即便有了孩子也是一个独立于你的个体，终有一日他将渴望一个没有你介入的世界。</p>
<p>那么这些时刻、这些岁月里，一个无法享受独处的人，是很难拥有真正的幸福和快乐的。</p>
<p>你必须要知道的是：</p>
<p>生病了，没有人能替你难受。那句被网友调侃了无数次的「多喝开水多休息」就是最好的灵丹妙药。</p>
<p>脆弱的时刻，没有人能给予你真正的强大，只有自己筑建坚强，自己给予自己力量。</p>
<p>悲伤的时候，没有人能擦干你心里的眼泪，即便他用纸巾温柔地拭去你脸上的泪水。</p>
<p>失意的时候，没有人在乎你蕴藏的才华和能力。只有不断积蓄能量用行动挥以他们最漂亮的一拳。</p>
<p>学会独立，习得独处能力，享受「一个人」。我开始爱上一个人的生活，一个人的时光。</p>
<p>一个人，读书，写字，绘画，听音乐。一个人吃饭，一个人出行，一个人看一场电影，一个人专心地练琴。一个人的夏日撑伞，一个人的冬日穿暖。一个人的日子里，照顾好自己的身体，安放好自己的情绪。</p>
<p>在我看来，即便恋爱了也该坚持拥有一个人的时光。</p>
<p>两个人在一起，是为了多一个人分享你一个人时的精彩与诗意，而不是去填补你一个人时的空洞与虚无。</p>
<p>两个人在一起，千万不要奢求由另一个人给予你一个人时没有的东西。</p>
<p>「雪中送炭」固然让人温暖，但如果你自己就是那块炭，拥有自燃产热的能力，那么是不是就没那么惧怕「寒冬飘雪」了？</p>
<p>比起「雪中送炭」，我更希望两个人在一起，是「锦上添花」。</p>
<p>你来与不来，我都是匹锦；你来更好，你不来我也很美。</p>
<p>英国心理学家唐纳德 · 温尼科特（Donald<br>W.Winnicott）说过，他认为恋人间完美的相处关系是「窝在爱人怀里孤独」。</p>
<p>我始终觉得，在所有形式的恋爱中，异地恋更是一场美好的恋爱。</p>
<p>能坚持下来的异地恋，在相爱的基础上，更多的是发生在两个人格独立和精神独立的人之间。它经受住了时间和距离的考验，更是练就了彼此独处的能力和拥抱孤独的心性。</p>
<p>而当你进入婚姻后，更该保留一个人独处的时光。</p>
<p>正如高伟所说，每个女人其实都是独身女人。女人灵魂的成长几乎是个人的事情，女人成长中的疼痛没有人可以代替。</p>
<p>婚姻里，即便是感情再好的夫妻，也不可能做到让两个原本必然存在差异的个体事事相通全然理解。</p>
<p>那么，一个人的时光里，避开那些繁杂和琐碎，沉浸专注于自己。</p>
<p>自己与自己对话，自己取悦自己，去排解那些不被理解的忧伤。然后，一个优雅的转身，和爱人互相扶持，和婚姻握手讲和。</p>
<p>蒋勋说，我渴望孤独；珍惜孤独。好像只有孤独，生命可以变得丰富而华丽。他说，孤独没有什么不好。使孤独变得不好，是因为你害怕孤独。</p>
<p>龙应台说，有些事，只能一个人做；有些关，只能一个人过；有些路，只能一个人走。</p>
<p>她说，修行的路，总是孤独的，因为智慧必然来自孤独。</p>
<p>对于他们的文字，我感同身受。</p>
<p>因为专注于一个人的时光，我坚持写了 15 年的日记，毕业后坚持了近 450 天的背单词。</p>
<p>我始终没有放弃从小热爱的绘画，我开始练钢琴，开始下厨，开始伺弄花草，开始着手微信公众号。</p>
<p>所有喜欢的事，所有想做的事，都在一个人的时光里，被温柔以待。</p>
<p>一个人的时光里，还有许多想学的事。例如：烘焙、PPT、摄影。我开始相信，孤独是饱满的。正像此刻在深夜码字的我，孤独而饱满。</p>
<p>一个人，还有许许多多的好处。</p>
<p>一个人吃饭，可以自在地享用美食，不用在意别人吃饭的快慢。</p>
<p>一个人跑步，可以按着自己的节奏，不用迎合别人跑步的速度。</p>
<p>一个人逛街，可以随性地挑选与试穿，不必担心旁人可能逐渐消磨的耐性。</p>
<p>一个人看电影，可以尽情欢笑与哭泣，不必惆怅那张哭花的脸取代了原本的精致妆容。</p>
<p>一个人旅行，不用配合别人的时间，「说走就走」不再是几次三番合计不下后的奢望。</p>
<p>一个人看风景，才能更清楚地看清沿途的美，因为那是仅属于你和风景之间单独的私会。</p>
<p>……</p>
<p>一个人的时光，你自由，任性，潇洒，放荡不羁。</p>
<p>所以，请试着去学会「一个人」，去习得独处的能力。你会发现，这种能力将让你受用一生。</p>
<p>少年读书之际，让你抵得住周遭的诱惑，在自律与孤独中求知。</p>
<p>青春等待爱情的岁月，让你更笃定「不将就」，更有底气更有自信去对抗世俗和年龄。</p>
<p>暮年之际，让你更有勇气与力量去面对另一半的离开，依旧精彩地过活。</p>
<p>杨绛先生在《我们仨》中深情描述了她和丈夫钱钟书的伉俪情深，和女儿钱瑗的母女情深。然而在女儿和丈夫相继去世后，仅剩一人的她又写了两本书，翻译和口述了各一本书，把丈夫钱钟书<br>7 万页的笔记整理成英文和中文笔记分别出版。</p>
<p>有人说，「人生最曼妙的风景，竟是内心的淡定与从容。我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系。」</p>
<p>我想，只有一个具有强大独处能力的人，才能在如此悲痛之余，继续建树生命的智慧和光芒。</p>
<p>我想，杨绛就是高伟口中「将孤独培育成孤绝」的女人。</p>
<p>总有那么些时刻，需要你用孤独去对抗；总有那些个岁月，需要你一个人踽踽独行。</p>
<p>我们必须明白，我们从孤独而来，最终回到孤独。</p>
<p>我依然记得那一晚，一个人去影院。买票时，售票小姐说，「一张吗？」</p>
<p>我说，「是的，一张。」</p>
<p>售票小姐不确定地又问了一遍，「是一个人吗？」</p>
<p>我说，「是的，就一个人，买一张票。」</p>
<p>语气平和而笃定。</p>
<p>终有一日，你不再是忍受「一个人」，而是享受「一个人」，你将拥有从未有过的平静和从容。</p>
<p>是的，世界很喧嚣，网络很热闹。而我希望，我们终将用独处时的平静和从容去感知生活中的鸟语花香，去对抗人生中的风雨飘摇。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>代码实现多个Excel合并的花式操作要求</title>
    <url>/2021/08/22/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AAExcel%E5%90%88%E5%B9%B6%E7%9A%84%E8%8A%B1%E5%BC%8F%E6%93%8D%E4%BD%9C%E8%A6%81%E6%B1%82/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一、合并指定目录下的所有订单表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">files = Path(<span class="string">&quot;orders/orders1&quot;</span>).glob(<span class="string">&quot;*.xlsx&quot;</span>)</span><br><span class="line">dfs = [pd.read_excel(f) <span class="keyword">for</span> f <span class="keyword">in</span> files]</span><br><span class="line">df = pd.concat(dfs)</span><br><span class="line">df.to_excel(<span class="string">&quot;result2.xlsx&quot;</span>,index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二、合并指定目录下的指定订单表</span></span><br><span class="line"></span><br><span class="line">dfs = [pd.read_excel(f) <span class="keyword">for</span> f <span class="keyword">in</span> (<span class="string">&#x27;orders/orders1/order1.xlsx&#x27;</span>,<span class="string">&#x27;orders/orders1/order2.xlsx&#x27;</span>)]</span><br><span class="line">df = pd.concat(dfs)</span><br><span class="line">df.to_excel(<span class="string">&quot;result3.xlsx&quot;</span>,index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 三、合并指定目录指定订单表的指定字段</span></span><br><span class="line"></span><br><span class="line">table1 = pd.read_excel(<span class="string">&quot;orders/orders1/order1.xlsx&quot;</span>)</span><br><span class="line">table2 = pd.read_excel(<span class="string">&#x27;orders/orders1/order2.xlsx&#x27;</span>)</span><br><span class="line">part1 = table1.iloc[:,<span class="number">2</span>]  <span class="comment">#取order1.xlsx第3列的所有行</span></span><br><span class="line">part2 = table2.iloc[:,[<span class="number">8</span>,<span class="number">9</span>]]  <span class="comment">#取order2.xlsx的第9、10列的所有行</span></span><br><span class="line">result4 = pd.concat([part1,part2],axis = <span class="number">1</span> ) <span class="comment">#合并  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上注意axis=1表示横向合并。打印一下result4，长这样</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 四、合并所有目录下的所有订单表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file_list = os.walk(<span class="string">&quot;./&quot;</span>)</span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dir_path,dirs,files <span class="keyword">in</span> file_list:</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        file_path = os.path.join(dir_path,f) <span class="comment">#重构文件路径</span></span><br><span class="line">        print(file_path)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;xlsx&#x27;</span> <span class="keyword">in</span> f:    <span class="comment">#只要xlsx文件</span></span><br><span class="line">            df = pd.read_excel(file_path) <span class="comment">#将Excel转成DataFrame</span></span><br><span class="line">            result.append(df)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">df = pd.concat(result) <span class="comment">#多个DataFrame合成一个</span></span><br><span class="line">df.to_excel(<span class="string">&quot;result4.xlsx&quot;</span>,index=<span class="literal">False</span>) <span class="comment">#导入到一个新的Excel中</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_image_filepaths</span>(<span class="params">dataset_dir</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dataset_dir):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">            fp = os.path.join(root, name)</span><br><span class="line">            <span class="keyword">if</span> name.endswith(<span class="string">&quot;.jpg&quot;</span>):</span><br><span class="line">                result.append(fp)</span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line"></span><br><span class="line">find_image_filepaths(<span class="string">r&quot;C:\Users\win\Desktop\1 - 副本&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 批量读取 excel</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line">path=<span class="string">r&quot;C:\Users\win\Desktop\1 - 副本&quot;</span></span><br><span class="line">filename_list = os.listdir(<span class="string">r&quot;C:\Users\win\Desktop\1 - 副本&quot;</span>)</span><br><span class="line">train_data=[]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> filename_list:</span><br><span class="line">    train_data.append(pd.read_excel(path+<span class="string">&#x27;/&#x27;</span>+item))</span><br><span class="line">train_data=pd.concat(train_data)</span><br><span class="line">train_data</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>使用apply函数操作任意列数据</title>
    <url>/2021/08/24/%E4%BD%BF%E7%94%A8apply%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C%E4%BB%BB%E6%84%8F%E5%88%97%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;首先创建一个DataFrame&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>:[x//<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)],</span><br><span class="line">                   <span class="string">&#x27;b&#x27;</span>:[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)],</span><br><span class="line">                   <span class="string">&#x27;c&#x27;</span>:[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)]&#125;)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>3</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2</td>
      <td>4</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Example1：a列所有的值+10&quot;&quot;&quot;</span></span><br><span class="line">df1=df.copy()</span><br><span class="line">df1[<span class="string">&#x27;a&#x27;</span>]=df1[<span class="string">&#x27;a&#x27;</span>].apply(<span class="keyword">lambda</span> x:x+<span class="number">10</span>)</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>10</td>
      <td>0</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>10</td>
      <td>1</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>11</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>11</td>
      <td>3</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>12</td>
      <td>4</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Example2：a列第1~3行的值+10&quot;&quot;&quot;</span></span><br><span class="line">df2=df.copy()</span><br><span class="line">df2.loc[<span class="number">1</span>:<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>]=df2.loc[<span class="number">1</span>:<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>].apply(<span class="keyword">lambda</span> x:x+<span class="number">10</span>)</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>10</td>
      <td>1</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>11</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>11</td>
      <td>3</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2</td>
      <td>4</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Example3：b列中小于c列、或大于k的值+10&quot;&quot;&quot;</span></span><br><span class="line">df3=df.copy()</span><br><span class="line">k=<span class="number">3</span></span><br><span class="line">index=df3.query(<span class="string">&#x27;b&lt;c|b&gt;@k&#x27;</span>).index.values</span><br><span class="line">df3.loc[index,<span class="string">&#x27;b&#x27;</span>]=df3.loc[index,<span class="string">&#x27;b&#x27;</span>].apply(<span class="keyword">lambda</span> x: x+<span class="number">10</span>)</span><br><span class="line">df3</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>10</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>11</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>3</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2</td>
      <td>14</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Example4：新增d列，且d=a+c+10&quot;&quot;&quot;</span></span><br><span class="line">df4=df.copy()</span><br><span class="line">df4[<span class="string">&#x27;d&#x27;</span>]=df4.apply(<span class="keyword">lambda</span> col:col[<span class="string">&#x27;a&#x27;</span>]+col[<span class="string">&#x27;c&#x27;</span>]+<span class="number">10</span>,axis=<span class="number">1</span>)</span><br><span class="line">df4</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>4</td>
      <td>14</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>3</td>
      <td>13</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td>13</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>3</td>
      <td>1</td>
      <td>12</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2</td>
      <td>4</td>
      <td>0</td>
      <td>12</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Example5：a列的值改为b列-10，新增d列，且值为c列+10&quot;&quot;&quot;</span></span><br><span class="line">df5 = df.copy()</span><br><span class="line"><span class="comment"># 同时修改多列的值时，是在操作DataFrame的一个区间，如果不新增列直接操作DataFrame，会因为无对应区间而产生bug</span></span><br><span class="line">df5[<span class="string">&#x27;d&#x27;</span>] = <span class="literal">None</span></span><br><span class="line"><span class="comment"># apply函数返回的是一个Series，不能将Series直接赋值给DataFrame，需要转化为List</span></span><br><span class="line"><span class="comment"># DataFrame接受的赋值格式为一个嵌套List：[[row1], [row2], ... [rowN]]</span></span><br><span class="line"><span class="comment"># 因此apply内的函数应该返回一个list,对应于[rowi]，apply返回的Series转化为List，对应于嵌套List的外层</span></span><br><span class="line">df5[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]] = df5.apply(<span class="keyword">lambda</span> col:[col[<span class="string">&#x27;b&#x27;</span>]-<span class="number">10</span>, col[<span class="string">&#x27;c&#x27;</span>]+<span class="number">10</span>], axis=<span class="number">1</span>).tolist()</span><br><span class="line">df5</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-10</td>
      <td>0</td>
      <td>4</td>
      <td>14</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-9</td>
      <td>1</td>
      <td>3</td>
      <td>13</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-8</td>
      <td>2</td>
      <td>2</td>
      <td>12</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-7</td>
      <td>3</td>
      <td>1</td>
      <td>11</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-6</td>
      <td>4</td>
      <td>0</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Example6：基于Example5的操作，但仅操作a列的值变化后小于-8的行, d列如果有空值，则填充为0&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 将Example6的条件写为函数, 注意返回值为列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="keyword">if</span> b-<span class="number">10</span> &lt; -<span class="number">8</span>:</span><br><span class="line">        fa = b - <span class="number">10</span></span><br><span class="line">        fd = c + <span class="number">10</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fa = a</span><br><span class="line">        fd = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> [fa, fd]</span><br><span class="line"></span><br><span class="line">df6 = df.copy()</span><br><span class="line">df6[<span class="string">&#x27;d&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">df6[[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>]]=df6.apply(<span class="keyword">lambda</span> col:func(col[<span class="string">&#x27;a&#x27;</span>], col[<span class="string">&#x27;b&#x27;</span>], col[<span class="string">&#x27;c&#x27;</span>]), axis=<span class="number">1</span>).tolist()</span><br><span class="line">df6</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-10</td>
      <td>0</td>
      <td>4</td>
      <td>14</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-9</td>
      <td>1</td>
      <td>3</td>
      <td>13</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>3</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2</td>
      <td>4</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pandas 详解二十六之 Apply-- 对行、列用函数处理</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">俗话说，工欲善其事，必先利其器。在这里形容 apply 函数再合适不过了，apply 函数，可以说是 pandas 中自由度最高的函数。不过，是否能发挥其巨大威力，取决于我们的创造力。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在本博文中，首先通过简单例子来说明 apply 的用法，然后通过俩个高级例子来演示常用的用法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1 简单例子来说明 apply 的用法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">df1=pd.DataFrame(&#123;<span class="string">&#x27;sex&#x27;</span>:<span class="built_in">list</span>(<span class="string">&#x27;FFMFMMF&#x27;</span>),<span class="string">&#x27;smoker&#x27;</span>:<span class="built_in">list</span>(<span class="string">&#x27;YNYYNYY&#x27;</span>),<span class="string">&#x27;age&#x27;</span>:[<span class="number">21</span>,<span class="number">30</span>,<span class="number">17</span>,<span class="number">37</span>,<span class="number">40</span>,<span class="number">18</span>,<span class="number">26</span>],<span class="string">&#x27;weight&#x27;</span>:[<span class="number">120</span>,<span class="number">100</span>,<span class="number">132</span>,<span class="number">140</span>,<span class="number">94</span>,<span class="number">89</span>,<span class="number">123</span>]&#125;)</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sex</th>
      <th>smoker</th>
      <th>age</th>
      <th>weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>F</td>
      <td>Y</td>
      <td>21</td>
      <td>120</td>
    </tr>
    <tr>
      <th>1</th>
      <td>F</td>
      <td>N</td>
      <td>30</td>
      <td>100</td>
    </tr>
    <tr>
      <th>2</th>
      <td>M</td>
      <td>Y</td>
      <td>17</td>
      <td>132</td>
    </tr>
    <tr>
      <th>3</th>
      <td>F</td>
      <td>Y</td>
      <td>37</td>
      <td>140</td>
    </tr>
    <tr>
      <th>4</th>
      <td>M</td>
      <td>N</td>
      <td>40</td>
      <td>94</td>
    </tr>
    <tr>
      <th>5</th>
      <td>M</td>
      <td>Y</td>
      <td>18</td>
      <td>89</td>
    </tr>
    <tr>
      <th>6</th>
      <td>F</td>
      <td>Y</td>
      <td>26</td>
      <td>123</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_age</span>(<span class="params">age</span>):</span></span><br><span class="line">    <span class="keyword">if</span> age &gt;=<span class="number">18</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">df1[<span class="string">&#x27;age&#x27;</span>].apply(bin_age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<pre><code>0    1
1    1
2    0
3    1
4    1
5    1
6    1
Name: age, dtype: int64
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df1[&#x27;age&#x27;].apply(lambda x : 1 if x &gt;18 else 0)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2 取出抽烟和不抽烟的体重前二</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">df,col,n=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> df.sort_values(by=col)[-n:]</span><br><span class="line">df1.groupby(<span class="string">&#x27;smoker&#x27;</span>).apply(topp,col=<span class="string">&#x27;weight&#x27;</span>,n=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># df1 对象根据:’smoker’列，groupby 分组成抽烟和不抽烟二组，</span></span><br><span class="line"><span class="comment"># 然后每一组作为参数传进自定义的 top 函数，对于 top 函数的其余参数，</span></span><br><span class="line"><span class="comment"># 在 apply 函数作为关键字参数即可。对于自定义的 top 函数返回的 </span></span><br><span class="line"><span class="comment"># DataFrame 对象，将其所有返回的结果（在这是返回俩次）用 concat 连接，</span></span><br><span class="line"><span class="comment"># 形成最终结果。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>sex</th>
      <th>smoker</th>
      <th>age</th>
      <th>weight</th>
    </tr>
    <tr>
      <th>smoker</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">N</th>
      <th>4</th>
      <td>M</td>
      <td>N</td>
      <td>40</td>
      <td>94</td>
    </tr>
    <tr>
      <th>1</th>
      <td>F</td>
      <td>N</td>
      <td>30</td>
      <td>100</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Y</th>
      <th>2</th>
      <td>M</td>
      <td>Y</td>
      <td>17</td>
      <td>132</td>
    </tr>
    <tr>
      <th>3</th>
      <td>F</td>
      <td>Y</td>
      <td>37</td>
      <td>140</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">3 根据性别、年龄求每个人的含水量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">据科学数据表明：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">婴儿含水量 70%~80%</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">成年男性体内含水量 60%~65%</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">而成年女性体内含水量只是 50%~60%</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">（男人才是水做的～_~）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">water</span>(<span class="params">one_row</span>):</span></span><br><span class="line">    <span class="comment">#婴儿</span></span><br><span class="line">    <span class="keyword">if</span> one_row[<span class="string">&#x27;age&#x27;</span>]==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> one_row[<span class="string">&#x27;weight&#x27;</span>]*<span class="number">0.7</span></span><br><span class="line">    <span class="comment">#成年男女</span></span><br><span class="line">    <span class="keyword">if</span> one_row[<span class="string">&#x27;sex&#x27;</span>]==<span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> one_row[<span class="string">&#x27;weight&#x27;</span>]*<span class="number">0.6</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> one_row[<span class="string">&#x27;weight&#x27;</span>]*<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">df1.apply(water,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<pre><code>0    60.0
1    50.0
2    79.2
3    70.0
4    56.4
5    53.4
6    61.5
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">首先我们必须弄清楚，之前都是对列进行操作，而现在是求每一行，</span></span><br><span class="line"><span class="string">也就是每个人的含水量，即对行进行操作，故应用 apply 函数时 axis=1。</span></span><br><span class="line"><span class="string">而每一次应用自定义的 water 函数时，传进的一行是 Series 对象，</span></span><br><span class="line"><span class="string">每次返回单值，最终组合成 Series 对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4 总结</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">首先，我们要弄清操作的元素是行还是列，若对每一行进行 apply，则 axis=1。其次，编写好 apply 应用的函数，注意传进的参数和返回值的类型是单值、Series 或 DataFrame。最后，groupby 和 apply 组合，运用得当将会产生巨大的威力！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">table = pd.DataFrame(&#123;<span class="string">&#x27;cnt1&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,np.nan,<span class="number">4</span>,np.nan,<span class="number">6</span>],</span><br><span class="line">                      <span class="string">&#x27;cnt2&#x27;</span>:[<span class="number">5</span>,<span class="number">10</span>,np.nan,np.nan,<span class="number">6</span>,<span class="number">10</span>]&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#写成一句</span></span><br><span class="line">table[<span class="string">&#x27;sub&#x27;</span>] = table.apply(<span class="keyword">lambda</span> row: row[<span class="string">&#x27;cnt1&#x27;</span>] <span class="keyword">if</span> (pd.isnull(row[<span class="string">&#x27;cnt1&#x27;</span>]) | pd.isnull(row[<span class="string">&#x27;cnt2&#x27;</span>])) <span class="keyword">else</span> (row[<span class="string">&#x27;cnt1&#x27;</span>]-row[<span class="string">&#x27;cnt2&#x27;</span>]),axis = <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">table</span><br><span class="line"></span><br><span class="line"><span class="comment">#写成函数</span></span><br><span class="line"><span class="comment"># def my_test(x,y):</span></span><br><span class="line"><span class="comment">#     if pd.isnull(x) | pd.isnull(y):</span></span><br><span class="line"><span class="comment">#         return x</span></span><br><span class="line"><span class="comment">#     else:</span></span><br><span class="line"><span class="comment">#         return x-y</span></span><br><span class="line"><span class="comment"># table[&#x27;sub&#x27;] = table.apply(lambda row: my_test(row[&#x27;cnt1&#x27;],row[&#x27;cnt2&#x27;]),axis = 1 )</span></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>cnt1</th>
      <th>cnt2</th>
      <th>sub</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.0</td>
      <td>5.0</td>
      <td>-4.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2.0</td>
      <td>10.0</td>
      <td>-8.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.0</td>
      <td>NaN</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>NaN</td>
      <td>6.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>6.0</td>
      <td>10.0</td>
      <td>-4.0</td>
    </tr>
  </tbody>
</table>
</div>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>写给刚入门编程（python）的同学</title>
    <url>/2021/04/17/%E5%86%99%E7%BB%99%E5%88%9A%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B%EF%BC%88python%EF%BC%89%E7%9A%84%E5%90%8C%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="写给谁"><a href="#写给谁" class="headerlink" title="写给谁"></a>写给谁</h2><p>刚准备入手学习 python 编程的大学生或者研究生。</p>
<h2 id="你为什么学-python"><a href="#你为什么学-python" class="headerlink" title="你为什么学 python"></a>你为什么学 python</h2><ul>
<li>当你做实验（生物信息学，地理信息学，计量经济学，心理学，运筹学，图像处理，语音处理，信号处理，嵌入式，linux 等）的时候，需要编程，而且需要 python。</li>
<li>深度学习大火，科室的实验开始使用深度学习的分析方法</li>
</ul>
<p>可能你还有其他的理由，像是需要建立网站，或者是纯粹想要自学，抑或是你想要从事软件开发的工作。</p>
<h2 id="你为什么惦记或者自学了很久却迟迟未入门"><a href="#你为什么惦记或者自学了很久却迟迟未入门" class="headerlink" title="你为什么惦记或者自学了很久却迟迟未入门"></a>你为什么惦记或者自学了很久却迟迟未入门</h2><ul>
<li>担心自己投入了大量的时间却没有收获，或者在毕业后，甚至在刚做完实验后 python 就没用了。</li>
</ul>
<p>一门编程语言都没有深入学习过的人，常常误认为 java，c++，python， JavaScript 等编程语言的差别非常大。但是，在你开始学习它们之中的一个的时候，你学到的大部分知识其实都只是现代编程语言的基本元素：变量，运算符，语句，控制流，函数，面向对象，文件读写，使用第三方库。甚至当你学习数据结构与算法的时候，你仍然没有太多涉及到一个语言的特性。作者前几天就见识了一个刚学会 python 的计算机教授用自己的 C 语言风格写出的 python 数据结构与算法书，真的被震惊到了。</p>
<p>但是，当你学习到这一步的时候，甚至还没开始学数据结构与算法的时候，你就已经可以开始做很多事情了。结合你的本专业（比如前面列出的那些）知识，以及一些专业的算法库，你就能使用你选择的编程语言，进行专业领域的探索和科学研究了。这个时候，你的注意力就不再在编程语言上了，而是你的课题。你的眼中只有宝石，而编程语言只是你用来打磨宝石的锉子。</p>
<ul>
<li><p>那各个编程语言之间究竟有哪些不同呢？</p>
<p>编程语言，就像是手机或者电脑的操作系统，其最大的财富，是它们的生态，也就是适用的软件包。当你开始深入探索，改进，甚至自己做一个大型的软件包的时候，可能就是需要重新思考使用什么的语言的时候了。比如说，当你需要学习做一个大型网站，或者需要做一个和手机淘宝差不多的 app 出来的时候。当然，这个时候的你再认真考量之后自然会有自己的选择。</p>
</li>
</ul>
<h2 id="我学习-python-了一段时间了，也跟着教材做过小项目，但是总觉得自己啥都不会？"><a href="#我学习-python-了一段时间了，也跟着教材做过小项目，但是总觉得自己啥都不会？" class="headerlink" title="我学习 python 了一段时间了，也跟着教材做过小项目，但是总觉得自己啥都不会？"></a>我学习 python 了一段时间了，也跟着教材做过小项目，但是总觉得自己啥都不会？</h2><ul>
<li>没有找到好的入门教材</li>
</ul>
<p>计算机技术社区是最拥抱开源的社区，当你在网上找不到好的数学，物理，经济学教材的时候，你可以抱怨说：适合我的教材还没有被写出来。然而，当你找计算机技术教材的时候，你只能抱怨说：适合我的教材还没有和我遇见。动动手，逛逛各种技术社区和论坛，优质技术资料是无穷无尽的～</p>
<ul>
<li>被 python 的灵活性所迷惑</li>
</ul>
<p>如果 python 是你的第一门编程语言，那么你是很容易被 python 愚弄的。python 的最大特性是灵活，但是语言的灵活性却也是刺向初学者的利剑。毕竟，很多人学习 C 语言这门以严谨刻板著称的语言的时候，都会经常被自己所写出的程序所捉弄。</p>
<p>这个时候，请记住：</p>
<p>1，先选择一本知识点齐全的 python 基础教材放在手边，牢固掌握 python 的面向对象用法，并且知道 python 有哪些高级的函数式编程和面向对象编程的知识，在不懂的时候随时查阅。做完这些预备动作，才跟着某些教材做一些小项目。</p>
<p>2，永远清楚你正在使用的变量的数据类型。如果不清楚，使用 type (a) 查询 a 的数据类型。</p>
<p>很多初学者看别人写的程序，常常有一种错觉：所有的变量都是适合所有操作的，str 类型可以 print，list 类型也可以 print；它们都还都支持遍历，甚至还都支持加法，那不就是说所有的类型都支持所有的操作了？然而并不是，当你这么想时，你已经把 python 当成了魔法，而不是遵循客观规律的科学工具了。</p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式程序测试</title>
    <url>/2021/04/17/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h4 id="实例-020：高空抛物"><a href="#实例-020：高空抛物" class="headerlink" title="实例 020：高空抛物"></a>实例 020：高空抛物</h4><p><strong>题目:</strong> 一球从 100 米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第 10 次落地时，共经过多少米？第 10 次反弹多高？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">high = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入起始高度:&#x27;</span>))</span><br><span class="line">times = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入次数:&#x27;</span>))</span><br><span class="line">high_all = []</span><br><span class="line">high_each = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, times + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        high_all.append(high)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        high_all.append(<span class="number">2</span> * high)</span><br><span class="line">    high /= <span class="number">2</span></span><br><span class="line">    high_each.append(high)</span><br><span class="line">    print(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>次经历的总路程为:<span class="subst">&#123;high&#125;</span>&#x27;</span>)</span><br><span class="line">s = <span class="built_in">sum</span>(high_all)</span><br><span class="line">last_time = high_each[-<span class="number">1</span>]</span><br><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;times&#125;</span>次经历的总路程为:<span class="subst">&#123;s&#125;</span>&#x27;</span>)</span><br><span class="line">print(<span class="string">f&#x27;第<span class="subst">&#123;times&#125;</span>次反弹高度为:<span class="subst">&#123;last_time&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>请输入起始高度:200
请输入次数:10
1次经历的总路程为:100.0
2次经历的总路程为:50.0
3次经历的总路程为:25.0
4次经历的总路程为:12.5
5次经历的总路程为:6.25
6次经历的总路程为:3.125
7次经历的总路程为:1.5625
8次经历的总路程为:0.78125
9次经历的总路程为:0.390625
10次经历的总路程为:0.1953125
10次经历的总路程为:599.21875
第10次反弹高度为:0.1953125
</code></pre>
<p>2）函数写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bounce</span>(<span class="params">num</span>):</span></span><br><span class="line">    height = <span class="number">100</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        total += height</span><br><span class="line">        height /= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> total, height</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t, h = bounce(<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">f&#x27;它在第10次落地时，共经过<span class="subst">&#123;t&#125;</span>米，第10次反弹高度是<span class="subst">&#123;h&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>3）简单写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">100</span>]  <span class="comment">#每个‘反弹落地’过程经过的路程，第1次只有落地（100米）</span></span><br><span class="line">h = <span class="number">100</span>  <span class="comment">#每个‘反弹落地’过程，反弹的高度，第1次为100米</span></span><br><span class="line">print(<span class="string">&#x27;第1次从%s米高落地，走过%s米，之后又反弹至%s米。&#x27;</span> % (h, a[<span class="number">0</span>], h/<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>):  <span class="comment">#第1次已初始化，再循环9次</span></span><br><span class="line">    a.append(h)  <span class="comment">#先计算路程，再高度减半，因为一个‘反弹落地’为2个高度</span></span><br><span class="line">    h = h / <span class="number">2</span></span><br><span class="line">    print(<span class="string">&#x27;第%s次从%s米高落地，共走过%s米，之后又反弹至%s米。&#x27;</span> % (i, h, <span class="built_in">sum</span>(a), h / <span class="number">2</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的实例应用去除图片水印</title>
    <url>/2021/08/22/%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8%E5%8E%BB%E9%99%A4%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 PDF 文档 分割成图片</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> fitz</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pyMuPDF_fitz</span>(<span class="params">pdfPath, imagePath</span>):</span></span><br><span class="line">    startTime_pdf2img = datetime.datetime.now()  <span class="comment"># 开始时间</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;imagePath=&quot;</span>+imagePath)</span><br><span class="line">    pdfDoc = fitz.<span class="built_in">open</span>(pdfPath)</span><br><span class="line">    <span class="keyword">for</span> pg <span class="keyword">in</span> <span class="built_in">range</span>(pdfDoc.pageCount):</span><br><span class="line">        page = pdfDoc[pg]</span><br><span class="line">        rotate = <span class="built_in">int</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 每个尺寸的缩放系数为1.3，这将为我们生成分辨率提高2.6的图像。</span></span><br><span class="line">        <span class="comment"># 此处若是不做设置，默认图片大小为：792X612, dpi=72</span></span><br><span class="line">        zoom_x = <span class="number">1.33333333</span>  <span class="comment"># (1.33333333--&gt;1056x816)   (2--&gt;1584x1224)</span></span><br><span class="line">        zoom_y = <span class="number">1.33333333</span></span><br><span class="line">        mat = fitz.Matrix(zoom_x, zoom_y).preRotate(rotate)</span><br><span class="line">        pix = page.getPixmap(matrix=mat, alpha=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(imagePath):  <span class="comment"># 判断存放图片的文件夹是否存在</span></span><br><span class="line">            os.makedirs(imagePath)  <span class="comment"># 若图片文件夹不存在就创建</span></span><br><span class="line"></span><br><span class="line">        pix.writePNG(imagePath+<span class="string">&#x27;/&#x27;</span>+<span class="string">&#x27;images_%s.png&#x27;</span> % pg)  <span class="comment"># 将图片写入指定的文件夹内</span></span><br><span class="line"></span><br><span class="line">    endTime_pdf2img = datetime.datetime.now()  <span class="comment"># 结束时间</span></span><br><span class="line">    print(<span class="string">&#x27;pdf2img时间=&#x27;</span>, (endTime_pdf2img - startTime_pdf2img).seconds)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pdfPath = <span class="string">r&quot;D:\教学工具软件\冰点文库下载器 3.2.10 去广告版\冰点文库下载器 3.2.10 去广告版\kpdf\哪些人适合学Python培训，你在其中吗？.pdf&quot;</span></span><br><span class="line">    imagePath = <span class="string">r&quot;D:\1jieya\image&quot;</span></span><br><span class="line">    pyMuPDF_fitz(pdfPath, imagePath)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图片去除水印，配合上一个程序使用</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># img = Image.open(r&quot;D:\1jieya\image\images_0.png&quot;)</span></span><br><span class="line"><span class="comment"># width, height = img.size</span></span><br><span class="line"><span class="comment"># for pos in product(range(width), range(height)):</span></span><br><span class="line"><span class="comment">#     if sum(img.getpixel(pos)[:3]) &gt; 600:</span></span><br><span class="line"><span class="comment">#         img.putpixel(pos, (255, 255, 255))</span></span><br><span class="line"><span class="comment"># img.save(r&quot;C:\Users\win\Desktop\removed_1.png&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = <span class="string">r&quot;D:\1jieya\image&quot;</span></span><br><span class="line">output = <span class="string">r&quot;D:\1jieya\remove&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span>():</span></span><br><span class="line">    <span class="keyword">for</span> image_name <span class="keyword">in</span> os.listdir(<span class="built_in">input</span>):</span><br><span class="line">        print(image_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(os.path.join(<span class="built_in">input</span>, image_name))</span><br><span class="line">        width, height = img.size</span><br><span class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> product(<span class="built_in">range</span>(width), <span class="built_in">range</span>(height)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(img.getpixel(pos)[:<span class="number">3</span>]) &gt; <span class="number">600</span>:</span><br><span class="line">                img.putpixel(pos, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line">        img.save(os.path.join(output, image_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    modify()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 批量将图片修改为指定大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter, ImageDraw</span><br><span class="line"></span><br><span class="line"><span class="comment"># im = Image.open(r&quot;C:\Users\win\Desktop\ccc\20200706130733539.png&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取图片的格式，大小，以及模式</span></span><br><span class="line"><span class="comment"># print(im.format, im.size, im.mode)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定图片的像素</span></span><br><span class="line"><span class="comment"># im.thumbnail((720, 1280))</span></span><br><span class="line"><span class="comment"># im.save(r&quot;C:\Users\win\Desktop\ccc\128_128.jpg&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 旋转图片的方向</span></span><br><span class="line"><span class="comment"># dest_im = im.rotate(90)</span></span><br><span class="line"><span class="comment"># dest_im.save(r&quot;C:\Users\win\Desktop\ccc\90.png&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给图片添加滤镜</span></span><br><span class="line"><span class="comment"># dest_im = im.filter(ImageFilter.GaussianBlur)</span></span><br><span class="line"><span class="comment"># dest_im.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 图片反转</span></span><br><span class="line"><span class="comment"># dest_im = im.transpose(Image.FLIP_LEFT_RIGHT)</span></span><br><span class="line"><span class="comment"># dest_im = im.transpose(Image.FLIP_TOP_BOTTOM)</span></span><br><span class="line"><span class="comment"># dest_im.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片上写文字</span></span><br><span class="line"><span class="comment"># image = Image.open(r&quot;C:\Users\win\Desktop\ccc\20200706130733539.png&quot;)</span></span><br><span class="line"><span class="comment"># img_draw = ImageDraw.Draw(image)</span></span><br><span class="line"><span class="comment"># img_draw.text((1270, 1250), &#x27;hello world!&#x27;, fill=&#x27;green&#x27;)</span></span><br><span class="line"><span class="comment"># image.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量将图片的大小设置为指定大小</span></span><br><span class="line"></span><br><span class="line">in_path = <span class="string">r&quot;C:\Users\win\Desktop\ccc&quot;</span></span><br><span class="line">out_path = os.path.join(in_path, <span class="string">&#x27;modify&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_path):</span><br><span class="line">    os.makedirs(out_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span>():</span></span><br><span class="line">    <span class="keyword">for</span> image_name <span class="keyword">in</span> os.listdir(in_path):</span><br><span class="line">        cur_dir = in_path + <span class="string">&#x27;/&#x27;</span> + image_name</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(cur_dir):</span><br><span class="line">            print(<span class="string">f&#x27;正在处理:<span class="subst">&#123;cur_dir&#125;</span>&#x27;</span>)</span><br><span class="line">            im = Image.<span class="built_in">open</span>(cur_dir)</span><br><span class="line">            im.thumbnail((<span class="number">1280</span>, <span class="number">720</span>))</span><br><span class="line">            im.save(os.path.join(out_path, image_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    modify()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>创建Markdown文章图床</title>
    <url>/2021/01/27/%E5%88%9B%E5%BB%BAMarkdown%E6%96%87%E7%AB%A0%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="VSCode-Github-PicGo-jsDelivr-搭建稳定快速高效图床"><a href="#VSCode-Github-PicGo-jsDelivr-搭建稳定快速高效图床" class="headerlink" title="VSCode + Github + PicGo + jsDelivr 搭建稳定快速高效图床"></a><center>VSCode + Github + PicGo + jsDelivr 搭建稳定快速高效图床</center></h1><p>&emsp;&emsp;图床是个什么玩意就不多说了，比较喜欢的是利用 Picgo 插件的 Github 图床，但是其服务器不在国内，访问起来比较的慢，甚至无法访问。所以需要利用到 jsDelivr CDN 加速 (jsDelivr 是一个免费开源的 CDN 解决方案)，Picgo 插件一键上传，GIthub 和 jsDelivr 又是知名大厂，不怕他删库跑路。</p>
<a id="more"></a>

<h4 id="这是转载的，感谢作者！"><a href="#这是转载的，感谢作者！" class="headerlink" title="这是转载的，感谢作者！"></a>这是转载的，感谢作者！</h4><h2 id="新建-Github-仓库"><a href="#新建-Github-仓库" class="headerlink" title="新建 Github 仓库"></a>新建 Github 仓库</h2><h4 id="1-创建新仓库，必须是-public"><a href="#1-创建新仓库，必须是-public" class="headerlink" title="1.创建新仓库，必须是 public"></a>1.创建新仓库，必须是 public</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/00.png" alt="00"></p>
</div>

<h4 id="2-进入个人设置页面，选择开发者设置"><a href="#2-进入个人设置页面，选择开发者设置" class="headerlink" title="2.进入个人设置页面，选择开发者设置"></a>2.进入个人设置页面，选择开发者设置</h4><div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/11.png" alt="11"></p>
</div>

<h4 id="3-选择-Personal-access-tokens，选择生成新-token，此-token-是图床上传时验证身份用的"><a href="#3-选择-Personal-access-tokens，选择生成新-token，此-token-是图床上传时验证身份用的" class="headerlink" title="3.选择 Personal access tokens，选择生成新 token，此 token 是图床上传时验证身份用的"></a>3.选择 Personal access tokens，选择生成新 token，此 token 是图床上传时验证身份用的</h4><div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/22.png" alt="22"></p>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/33.png" alt="33"></p>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/44.png" alt="44"></p>
</div>

<h4 id="4-添加描述，然后将-repo-选上"><a href="#4-添加描述，然后将-repo-选上" class="headerlink" title="4.添加描述，然后将 repo 选上"></a>4.添加描述，然后将 repo 选上</h4><div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/55.png" alt="55"></p>
</div>

<h4 id="5-将生成的字符串保存，关闭页面后将再也无法看到这个字符串了"><a href="#5-将生成的字符串保存，关闭页面后将再也无法看到这个字符串了" class="headerlink" title="5.将生成的字符串保存，关闭页面后将再也无法看到这个字符串了"></a>5.将生成的字符串保存，关闭页面后将再也无法看到这个字符串了</h4><div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/66.png" alt="66"></p>
</div>

<h2 id="picgo-设置"><a href="#picgo-设置" class="headerlink" title="picgo 设置"></a>picgo 设置</h2><p>打开软件，安装相关插件</p>
<div align =center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/0.png" alt="0"></p>
</div>

<p>1.在 VsCode 左侧扩展栏里找到 PicGo 扩展项</p>
<br>

<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/1.png" alt="1"></p>
</div>

<p>2.左键单击 PiGgo 右下角的的齿轮图标，打开‘扩展设置’项</p>
<div align =center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/2.png" alt="2"></p>
</div>

<p>3.打开后的界面里的具体设置为：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/3.png" alt="3"></p>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/30.png" alt="30"></p>
</div>

<h4 id="具体设置为"><a href="#具体设置为" class="headerlink" title="具体设置为:"></a>具体设置为:</h4><p>1.current 设置为 GitHub</p>
<p>2.Branch 是我们仓库的分支，默认为 master</p>
<p>3.custom url 使我们图片上传的连接，有两种方式可以使用</p>
<ul>
<li><p>1.原生方式</p>
<ul>
<li><p>1.使用 GitHub 原生连接，格式为 <a href="https://raw.githubusercontent.com/[%E7%94%A8%E6%88%B7%E5%90%8D]/[%E4%BB%93%E5%BA%93%E5%90%8D]/[%E5%88%86%E6%94%AF%E5%90%8D]">https://raw.githubusercontent.com/[用户名]/[仓库名]/[分支名]</a></p>
</li>
<li><p>2.我的例子 <a href="https://raw.githubusercontent.com/leiyu1997/PicBed/master">https://raw.githubusercontent.com/leiyu1997/PicBed/master</a></p>
</li>
<li><p>3.原生方式有一个弊端就是国内速度比较感人。</p>
</li>
</ul>
</li>
<li><p>2.cdn 加速方式</p>
<ul>
<li><p>1.格式为 <a href="https://cdn.jsdelivr.net/gh/[%E7%94%A8%E6%88%B7%E5%90%8D]/[%E4%BB%93%E5%BA%93%E5%90%8D]@[%E5%88%86%E6%94%AF%E5%90%8D]">https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@[分支名]</a></p>
</li>
<li><p>2.我的例子 <a href="https://cdn.jsdelivr.net/gh/leiyu1997/PicBed@master">https://cdn.jsdelivr.net/gh/leiyu1997/PicBed@master</a></p>
</li>
<li><p>3.cdn 加速的优点是国内访问速度比较快</p>
</li>
</ul>
</li>
</ul>
<br>

<p><strong>Ctrl + Alt + U 图片在剪贴板上</strong></p>
<br>

<p><strong>Ctrl + Alt + E 从文件夹中选择图片</strong></p>
<p>注意：如果重新安装安装软件或重新安装 PicGo 插件，则要重新设置上述操作。否则无法上传图片。</p>
<h3 id="接下来就是愉快的写作过程了，如丝般顺滑。啧啧！"><a href="#接下来就是愉快的写作过程了，如丝般顺滑。啧啧！" class="headerlink" title="接下来就是愉快的写作过程了，如丝般顺滑。啧啧！"></a>接下来就是愉快的写作过程了，如丝般顺滑。啧啧！</h3><!--  这是一种注释
&ensp;&ensp; 等待
<br/>
&emsp;等等
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;等等-->
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>初具完整程序风格_字幕繁简互转</title>
    <url>/2021/08/29/%E5%88%9D%E5%85%B7%E5%AE%8C%E6%95%B4%E7%A8%8B%E5%BA%8F%E9%A3%8E%E6%A0%BC-%E5%AD%97%E5%B9%95%E7%B9%81%E7%AE%80%E4%BA%92%E8%BD%AC/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> youtube_dl</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">r&#x27;设置下载文件保存的目录路径&#x27;</span>)  <span class="comment"># 自定义设置下载文件保存的目录路径</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    ydl_opts = &#123;&#125;</span><br><span class="line">    ysurl=<span class="built_in">input</span>(<span class="string">&#x27;要下载视频的地址:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> ysurl==<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        print(<span class="string">&#x27;已退出程序！&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">with</span> youtube_dl.YoutubeDL(ydl_opts) <span class="keyword">as</span> ydl:</span><br><span class="line">        print(<span class="string">&#x27;正在下载:&#x27;</span>)</span><br><span class="line">        ydl.download([ysurl])</span><br></pre></td></tr></table></figure>
<pre><code>要下载视频的地址:
已退出程序！
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> youtube_dl</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="comment"># 设定</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">os.chdir(r&#x27;设置下载文件保存的目录路径&#x27;)  # 自定义设置下载文件保存的目录路径 或者用以下方法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">destPath = <span class="string">&#x27;D:/Download/&#x27;</span>    <span class="comment"># 音频文件存放的目标字串</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    videoPage = <span class="built_in">input</span>(<span class="string">&#x27;要下载视频地址:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> videoPage==<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        print(<span class="string">&#x27;已退出程序！&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    ydl_opts = &#123;                              <span class="comment"># 设定下载选项</span></span><br><span class="line">                <span class="string">&#x27;outtmpl&#x27;</span>: destPath+<span class="string">&#x27;%(title)s.%(ext)s&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;best&#x27;</span>,                </span><br><span class="line">                &#125;    </span><br><span class="line">    print(<span class="string">&#x27;正在下载:&#x27;</span>)</span><br><span class="line">    ydl = youtube_dl.YoutubeDL(ydl_opts)</span><br><span class="line">    ydl.download([videoPage])                 <span class="comment"># 下载视频</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    a=<span class="built_in">input</span>(<span class="string">&#x27;shuru:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> a==<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>shuru:2
123
shuru:
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> opencc</span><br><span class="line">converter = opencc.OpenCC(<span class="string">&#x27;t2s.json&#x27;</span>)</span><br><span class="line">converter.convert(<span class="string">&#x27;沒有對她更溫柔&#x27;</span>)  <span class="comment"># 漢字</span></span><br></pre></td></tr></table></figure>
<pre><code>&#39;没有对她更温柔&#39;
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 繁体中文与简体中文相互转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 繁体转简体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> opencc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Traditional2Simplified</span>(<span class="params">sentence</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将sentence中的繁体字转为简体字</span></span><br><span class="line"><span class="string">    :param sentence: 待转换的句子</span></span><br><span class="line"><span class="string">    :return: 将句子中繁体字转换为简体字之后的句子</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    cc=opencc.OpenCC(<span class="string">&#x27;t2s&#x27;</span>)</span><br><span class="line">    sentence = cc.convert(sentence)</span><br><span class="line">    <span class="keyword">return</span> sentence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    traditional_sentence = <span class="string">&#x27;憂郁的臺灣烏龜&#x27;</span></span><br><span class="line">    simplified_sentence = Traditional2Simplified(traditional_sentence)</span><br><span class="line">    print(simplified_sentence)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>忧郁的台湾乌龟
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简体转繁体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Simplified2Traditional</span>(<span class="params">sentence</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将sentence中的简体字转为繁体字</span></span><br><span class="line"><span class="string">    :param sentence: 待转换的句子</span></span><br><span class="line"><span class="string">    :return: 将句子中简体字转换为繁体字之后的句子</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    cc=opencc.OpenCC(<span class="string">&#x27;s2t&#x27;</span>)</span><br><span class="line">    sentence = cc.convert(sentence)</span><br><span class="line">    <span class="keyword">return</span> sentence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    simplified_sentence = <span class="string">&#x27;忧郁的台湾乌龟&#x27;</span></span><br><span class="line">    traditional_sentence = Simplified2Traditional(simplified_sentence)</span><br><span class="line">    print(traditional_sentence)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>憂鬱的臺灣烏龜
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 完整代码 二合一高级写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> opencc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Traditional2Simplified</span>(<span class="params">sentence</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将sentence中的繁体字转为简体字</span></span><br><span class="line"><span class="string">    :param sentence: 待转换的句子</span></span><br><span class="line"><span class="string">    :return: 将句子中繁体字转换为简体字之后的句子</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    cc=opencc.OpenCC(<span class="string">&#x27;t2s&#x27;</span>)</span><br><span class="line">    sentence = cc.convert(sentence)</span><br><span class="line">    <span class="keyword">return</span> sentence</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Simplified2Traditional</span>(<span class="params">sentence</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将sentence中的简体字转为繁体字</span></span><br><span class="line"><span class="string">    :param sentence: 待转换的句子</span></span><br><span class="line"><span class="string">    :return: 将句子中简体字转换为繁体字之后的句子</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    cc=opencc.OpenCC(<span class="string">&#x27;s2t&#x27;</span>)</span><br><span class="line">    sentence = cc.convert(sentence)</span><br><span class="line">    <span class="keyword">return</span> sentence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    traditional_sentence = <span class="string">&#x27;憂郁的臺灣烏龜&#x27;</span></span><br><span class="line">    simplified_sentence = Traditional2Simplified(traditional_sentence)</span><br><span class="line">    print(simplified_sentence)</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(2) 主要函数：</span></span><br><span class="line"><span class="string">・ t2s – 繁体转简体</span></span><br><span class="line"><span class="string">・ s2t – 简体转繁体</span></span><br><span class="line"><span class="string">・ mix2t – 混合转繁体</span></span><br><span class="line"><span class="string">・ mix2s – 混合转简体</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<pre><code>忧郁的台湾乌龟
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3 实例：</span></span><br><span class="line"><span class="keyword">import</span> opencc</span><br><span class="line"><span class="comment"># 第一步打开文本文件，for 读取每句繁体</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\t.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    question_labels = f.readlines()</span><br><span class="line"></span><br><span class="line">q_zh = []   <span class="comment">#   Data中问题的中文</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> question_labels:</span><br><span class="line">    line=line.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    q_zh.append(line)</span><br><span class="line"></span><br><span class="line">print(q_zh)</span><br><span class="line"><span class="comment"># [&#x27;請問京都議定書規定幾個工業國家的二氧化碳排放量限制？&#x27;, &#x27;請問首位自費太空旅行的觀光客為誰？&#x27;,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步转换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Traditional2Simplified</span>(<span class="params">sentence</span>):</span></span><br><span class="line">    </span><br><span class="line">    cc=opencc.OpenCC(<span class="string">&#x27;t2s&#x27;</span>)</span><br><span class="line">    sentence = cc.convert(sentence)</span><br><span class="line">    <span class="keyword">return</span> sentence</span><br><span class="line"></span><br><span class="line">q_zh_jian = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> q_zh:</span><br><span class="line">    q_zh_jian.append(Traditional2Simplified(line))</span><br><span class="line"></span><br><span class="line">print(q_zh_jian)</span><br><span class="line"><span class="comment"># [&#x27;请问京都议定书规定几个工业国家的二氧化碳排放量限制？&#x27;, &#x27;请问首位自费太空旅行的观光客为谁？&#x27;, &#x27;请问</span></span><br></pre></td></tr></table></figure>
<pre><code>[&#39;每晚陪伴你&#39;, &#39;時光再慢&#39;, &#39;相聚再久&#39;, &#39;總得散&#39;, &#39;幾十年後&#39;, &#39;當我離開人間&#39;, &#39;塵歸塵&#39;, &#39;土歸土&#39;, &#39;這個世間&#39;, &#39;從此沒有了你我&#39;, &#39;還有什麼化不開的恩怨&#39;, &#39;路的盡頭&#39;, &#39;還有路&#39;, &#39;生命的盡頭&#39;, &#39;能有啥&#39;, &#39;一個坑一抔土&#39;, &#39;沒了愛&#39;, &#39;再思念都無法陪伴&#39;, &#39;甚至連爭吵都成了奢求&#39;, &#39;今天亦安將和大家&#39;, &#39;分享的是&#39;, &#39;下次你路過&#39;, &#39;人間已無我&#39;, &#39;在開始今天的節目之前&#39;, &#39;能點撃訂閱和小鈴鐺&#39;, &#39;你的點贊和評論&#39;, &#39;是我最大的動力&#39;, &#39;感謝大家的喜歡&#39;, &#39;深夜讀書因你們而精彩&#39;, &#39;人的一生並不長&#39;, &#39;2歲蹣跚學步&#39;, &#39;20多歲讀書生涯結束&#39;, &#39;30歲成家立業&#39;, &#39;50歲時&#39;, &#39;孩子走你走過的路&#39;, &#39;一切都被安排得妥妥噹噹&#39;, &#39;人生既是失去&#39;, &#39;也是得到&#39;, &#39;我們在其中徘徊&#39;, &#39;在其中接受&#39;, &#39;最後葉落歸根&#39;, &#39;這一切&#39;, &#39;是否像一場夢&#39;, &#39;有人也曾在心底&#39;, &#39;反問過自己&#39;, &#39;這一生的顛沛流離&#39;, &#39;卻過著普通人的生活&#39;, &#39;真的值得嗎&#39;, &#39;曾經我也思考過這様的問題&#39;, &#39;那時剛成家立業&#39;, &#39;後來與爺爺的一次聊天中&#39;, &#39;他告訴我&#39;, &#39;人生的幸福&#39;, &#39;其實全憑個人內心&#39;, &#39;平凡中可以是福&#39;, &#39;落魄中也可以是福&#39;, &#39;如果一個人的內心不夠強大&#39;, &#39;即使腰纏萬貫&#39;, &#39;也不一定是福&#39;, &#39;要勇敢的學會&#39;, &#39;直面慘淡的人生&#39;, &#39;短暫的是時間&#39;, &#39;脆弱的是感情&#39;, &#39;聽過一段話&#39;, &#39;人的一生&#39;, &#39;遇到愛&#39;, &#39;遇到好感&#39;, &#39;都不稀奇&#39;, &#39;難得的是遇到珍惜你的人&#39;, &#39;這個世上&#39;, &#39;短暫的是時間&#39;, &#39;脆弱的是感情&#39;, &#39;生命中有一些人&#39;, &#39;與我們擦肩了&#39;, &#39;卻來不及遇見&#39;, &#39;遇見了&#39;, &#39;卻來不及相識&#39;, &#39;相識了&#39;, &#39;卻來不及熟悉&#39;, &#39;熟悉了卻還是要說再見&#39;, &#39;每個人生來唯一&#39;, &#39;不會再有第二個自己&#39;, &#39;每個人只活一次&#39;, &#39;憑什麼不能被珍惜&#39;, &#39;余光中有句話&#39;, &#39;下次你路過&#39;, &#39;人間已無我&#39;, &#39;人和人之間&#39;, &#39;也只有一次的緣分&#39;, &#39;無論相處多久&#39;, &#39;不管愛或不愛&#39;, &#39;有些人&#39;, &#39;下辈子都無法再遇見了&#39;, &#39;就用力愛&#39;, &#39;能珍惜的&#39;, &#39;就別不在意&#39;, &#39;余光中說過這様一句話&#39;, &#39;下次你路過&#39;, &#39;人間已無我&#39;, &#39;把人與人之間的關係&#39;, &#39;體現的淋漓盡致&#39;, &#39;人這一生&#39;, &#39;有幾輩子可以活&#39;, &#39;滿打滿算不過幾十年&#39;, &#39;加在一起不過三萬多天&#39;, &#39;真的不長&#39;, &#39;我們每一個人&#39;, &#39;都是獨一無二的&#39;, &#39;我們和人相伴&#39;, &#39;也許下一刻就是最後一刻&#39;, &#39;這一路走來&#39;, &#39;有多少人和我們擦肩&#39;, &#39;然後徹底的留在記憶&#39;, &#39;明明就是同一個城市&#39;, &#39;可卻幾十年不曾相遇&#39;, &#39;最讓人惋惜的&#39;, &#39;不是一開始就陌生&#39;, &#39;而是明明很熟悉&#39;, &#39;慢慢的變成了陌生人&#39;, &#39;通訊錄裡的名字&#39;, &#39;佈滿了灰塵&#39;, &#39;朋友圈裡的動態&#39;, &#39;從沒翻看過&#39;, &#39;失望攬夠了&#39;, &#39;便是離開的時候&#39;, &#39;知乎上有個問題&#39;, &#39;感情中&#39;, &#39;最遺憾的時刻&#39;, &#39;是什麼時候&#39;, &#39;其中有個高讚的回答&#39;, &#39;在一起時&#39;, &#39;沒有對她更溫柔&#39;, &#39;在一起時&#39;]
[&#39;每晚陪伴你&#39;, &#39;时光再慢&#39;, &#39;相聚再久&#39;, &#39;总得散&#39;, &#39;几十年后&#39;, &#39;当我离开人间&#39;, &#39;尘归尘&#39;, &#39;土归土&#39;, &#39;这个世间&#39;, &#39;从此没有了你我&#39;, &#39;还有什么化不开的恩怨&#39;, &#39;路的尽头&#39;, &#39;还有路&#39;, &#39;生命的尽头&#39;, &#39;能有啥&#39;, &#39;一个坑一抔土&#39;, &#39;没了爱&#39;, &#39;再思念都无法陪伴&#39;, &#39;甚至连争吵都成了奢求&#39;, &#39;今天亦安将和大家&#39;, &#39;分享的是&#39;, &#39;下次你路过&#39;, &#39;人间已无我&#39;, &#39;在开始今天的节目之前&#39;, &#39;能点撃订阅和小铃铛&#39;, &#39;你的点赞和评论&#39;, &#39;是我最大的动力&#39;, &#39;感谢大家的喜欢&#39;, &#39;深夜读书因你们而精彩&#39;, &#39;人的一生并不长&#39;, &#39;2岁蹒跚学步&#39;, &#39;20多岁读书生涯结束&#39;, &#39;30岁成家立业&#39;, &#39;50岁时&#39;, &#39;孩子走你走过的路&#39;, &#39;一切都被安排得妥妥当当&#39;, &#39;人生既是失去&#39;, &#39;也是得到&#39;, &#39;我们在其中徘徊&#39;, &#39;在其中接受&#39;, &#39;最后叶落归根&#39;, &#39;这一切&#39;, &#39;是否像一场梦&#39;, &#39;有人也曾在心底&#39;, &#39;反问过自己&#39;, &#39;这一生的颠沛流离&#39;, &#39;却过著普通人的生活&#39;, &#39;真的值得吗&#39;, &#39;曾经我也思考过这様的问题&#39;, &#39;那时刚成家立业&#39;, &#39;后来与爷爷的一次聊天中&#39;, &#39;他告诉我&#39;, &#39;人生的幸福&#39;, &#39;其实全凭个人内心&#39;, &#39;平凡中可以是福&#39;, &#39;落魄中也可以是福&#39;, &#39;如果一个人的内心不够强大&#39;, &#39;即使腰缠万贯&#39;, &#39;也不一定是福&#39;, &#39;要勇敢的学会&#39;, &#39;直面惨淡的人生&#39;, &#39;短暂的是时间&#39;, &#39;脆弱的是感情&#39;, &#39;听过一段话&#39;, &#39;人的一生&#39;, &#39;遇到爱&#39;, &#39;遇到好感&#39;, &#39;都不稀奇&#39;, &#39;难得的是遇到珍惜你的人&#39;, &#39;这个世上&#39;, &#39;短暂的是时间&#39;, &#39;脆弱的是感情&#39;, &#39;生命中有一些人&#39;, &#39;与我们擦肩了&#39;, &#39;却来不及遇见&#39;, &#39;遇见了&#39;, &#39;却来不及相识&#39;, &#39;相识了&#39;, &#39;却来不及熟悉&#39;, &#39;熟悉了却还是要说再见&#39;, &#39;每个人生来唯一&#39;, &#39;不会再有第二个自己&#39;, &#39;每个人只活一次&#39;, &#39;凭什么不能被珍惜&#39;, &#39;余光中有句话&#39;, &#39;下次你路过&#39;, &#39;人间已无我&#39;, &#39;人和人之间&#39;, &#39;也只有一次的缘分&#39;, &#39;无论相处多久&#39;, &#39;不管爱或不爱&#39;, &#39;有些人&#39;, &#39;下辈子都无法再遇见了&#39;, &#39;就用力爱&#39;, &#39;能珍惜的&#39;, &#39;就别不在意&#39;, &#39;余光中说过这様一句话&#39;, &#39;下次你路过&#39;, &#39;人间已无我&#39;, &#39;把人与人之间的关系&#39;, &#39;体现的淋漓尽致&#39;, &#39;人这一生&#39;, &#39;有几辈子可以活&#39;, &#39;满打满算不过几十年&#39;, &#39;加在一起不过三万多天&#39;, &#39;真的不长&#39;, &#39;我们每一个人&#39;, &#39;都是独一无二的&#39;, &#39;我们和人相伴&#39;, &#39;也许下一刻就是最后一刻&#39;, &#39;这一路走来&#39;, &#39;有多少人和我们擦肩&#39;, &#39;然后彻底的留在记忆&#39;, &#39;明明就是同一个城市&#39;, &#39;可却几十年不曾相遇&#39;, &#39;最让人惋惜的&#39;, &#39;不是一开始就陌生&#39;, &#39;而是明明很熟悉&#39;, &#39;慢慢的变成了陌生人&#39;, &#39;通讯录里的名字&#39;, &#39;布满了灰尘&#39;, &#39;朋友圈里的动态&#39;, &#39;从没翻看过&#39;, &#39;失望揽够了&#39;, &#39;便是离开的时候&#39;, &#39;知乎上有个问题&#39;, &#39;感情中&#39;, &#39;最遗憾的时刻&#39;, &#39;是什么时候&#39;, &#39;其中有个高赞的回答&#39;, &#39;在一起时&#39;, &#39;没有对她更温柔&#39;, &#39;在一起时&#39;]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\t.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> question_labels <span class="keyword">in</span> f.readlines():</span><br><span class="line">        question_labels=question_labels.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        print(question_labels)</span><br></pre></td></tr></table></figure>
<pre><code>請問京都議定書規定幾個工業國家的二氧化碳排放量限制？，
請問首位自費太空旅行的觀光客為誰？
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3 实例：</span></span><br><span class="line"><span class="keyword">import</span> opencc</span><br><span class="line"><span class="comment"># 第一步打开文本文件，for 读取每句繁体</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\t.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    question_labels = f.readlines()</span><br><span class="line"></span><br><span class="line">q_zh = []  <span class="comment"># Data中问题的中文</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> question_labels:</span><br><span class="line">    line = line.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    q_zh.append(line)</span><br><span class="line"></span><br><span class="line">print(q_zh)</span><br><span class="line"><span class="comment"># [&#x27;請問京都議定書規定幾個工業國家的二氧化碳排放量限制？&#x27;, &#x27;請問首位自費太空旅行的觀光客為誰？&#x27;,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步转换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Traditional2Simplified</span>(<span class="params">sentence</span>):</span></span><br><span class="line"></span><br><span class="line">    cc = opencc.OpenCC(<span class="string">&#x27;t2s&#x27;</span>)</span><br><span class="line">    sentence = cc.convert(sentence)</span><br><span class="line">    <span class="keyword">return</span> sentence</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q_zh_jian = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> q_zh:</span><br><span class="line">    q_zh_jian.append(Traditional2Simplified(line))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\t2s1.txt&quot;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> w:</span><br><span class="line">    <span class="keyword">for</span> wr <span class="keyword">in</span> q_zh_jian:</span><br><span class="line">        w.write(wr+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;转换已完成，请到设置目录查看！&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[&#39;每晚陪伴你&#39;, &#39;時光再慢&#39;, &#39;相聚再久&#39;, &#39;總得散&#39;, &#39;幾十年後&#39;, &#39;當我離開人間&#39;, &#39;塵歸塵&#39;, &#39;土歸土&#39;, &#39;這個世間&#39;, &#39;從此沒有了你我&#39;, &#39;還有什麼化不開的恩怨&#39;, &#39;路的盡頭&#39;, &#39;還有路&#39;, &#39;生命的盡頭&#39;, &#39;能有啥&#39;, &#39;一個坑一抔土&#39;, &#39;沒了愛&#39;, &#39;再思念都無法陪伴&#39;, &#39;甚至連爭吵都成了奢求&#39;, &#39;今天亦安將和大家&#39;, &#39;分享的是&#39;, &#39;下次你路過&#39;, &#39;人間已無我&#39;, &#39;在開始今天的節目之前&#39;, &#39;能點撃訂閱和小鈴鐺&#39;, &#39;你的點贊和評論&#39;, &#39;是我最大的動力&#39;, &#39;感謝大家的喜歡&#39;, &#39;深夜讀書因你們而精彩&#39;, &#39;人的一生並不長&#39;, &#39;2歲蹣跚學步&#39;, &#39;20多歲讀書生涯結束&#39;, &#39;30歲成家立業&#39;, &#39;50歲時&#39;, &#39;孩子走你走過的路&#39;, &#39;一切都被安排得妥妥噹噹&#39;, &#39;人生既是失去&#39;, &#39;也是得到&#39;, &#39;我們在其中徘徊&#39;, &#39;在其中接受&#39;, &#39;最後葉落歸根&#39;, &#39;這一切&#39;, &#39;是否像一場夢&#39;, &#39;有人也曾在心底&#39;, &#39;反問過自己&#39;, &#39;這一生的顛沛流離&#39;, &#39;卻過著普通人的生活&#39;, &#39;真的值得嗎&#39;, &#39;曾經我也思考過這様的問題&#39;, &#39;那時剛成家立業&#39;, &#39;後來與爺爺的一次聊天中&#39;, &#39;他告訴我&#39;, &#39;人生的幸福&#39;, &#39;其實全憑個人內心&#39;, &#39;平凡中可以是福&#39;, &#39;落魄中也可以是福&#39;, &#39;如果一個人的內心不夠強大&#39;, &#39;即使腰纏萬貫&#39;, &#39;也不一定是福&#39;, &#39;要勇敢的學會&#39;, &#39;直面慘淡的人生&#39;, &#39;短暫的是時間&#39;, &#39;脆弱的是感情&#39;, &#39;聽過一段話&#39;, &#39;人的一生&#39;, &#39;遇到愛&#39;, &#39;遇到好感&#39;, &#39;都不稀奇&#39;, &#39;難得的是遇到珍惜你的人&#39;, &#39;這個世上&#39;, &#39;短暫的是時間&#39;, &#39;脆弱的是感情&#39;, &#39;生命中有一些人&#39;, &#39;與我們擦肩了&#39;, &#39;卻來不及遇見&#39;, &#39;遇見了&#39;, &#39;卻來不及相識&#39;, &#39;相識了&#39;, &#39;卻來不及熟悉&#39;, &#39;熟悉了卻還是要說再見&#39;, &#39;每個人生來唯一&#39;, &#39;不會再有第二個自己&#39;, &#39;每個人只活一次&#39;, &#39;憑什麼不能被珍惜&#39;, &#39;余光中有句話&#39;, &#39;下次你路過&#39;, &#39;人間已無我&#39;, &#39;人和人之間&#39;, &#39;也只有一次的緣分&#39;, &#39;無論相處多久&#39;, &#39;不管愛或不愛&#39;, &#39;有些人&#39;, &#39;下辈子都無法再遇見了&#39;, &#39;就用力愛&#39;, &#39;能珍惜的&#39;, &#39;就別不在意&#39;, &#39;余光中說過這様一句話&#39;, &#39;下次你路過&#39;, &#39;人間已無我&#39;, &#39;把人與人之間的關係&#39;, &#39;體現的淋漓盡致&#39;, &#39;人這一生&#39;, &#39;有幾輩子可以活&#39;, &#39;滿打滿算不過幾十年&#39;, &#39;加在一起不過三萬多天&#39;, &#39;真的不長&#39;, &#39;我們每一個人&#39;, &#39;都是獨一無二的&#39;, &#39;我們和人相伴&#39;, &#39;也許下一刻就是最後一刻&#39;, &#39;這一路走來&#39;, &#39;有多少人和我們擦肩&#39;, &#39;然後徹底的留在記憶&#39;, &#39;明明就是同一個城市&#39;, &#39;可卻幾十年不曾相遇&#39;, &#39;最讓人惋惜的&#39;, &#39;不是一開始就陌生&#39;, &#39;而是明明很熟悉&#39;, &#39;慢慢的變成了陌生人&#39;, &#39;通訊錄裡的名字&#39;, &#39;佈滿了灰塵&#39;, &#39;朋友圈裡的動態&#39;, &#39;從沒翻看過&#39;, &#39;失望攬夠了&#39;, &#39;便是離開的時候&#39;, &#39;知乎上有個問題&#39;, &#39;感情中&#39;, &#39;最遺憾的時刻&#39;, &#39;是什麼時候&#39;, &#39;其中有個高讚的回答&#39;, &#39;在一起時&#39;, &#39;沒有對她更溫柔&#39;, &#39;在一起時&#39;]
</code></pre>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>判断某个文件夹下有几个Excel文件及按条件筛选数据</title>
    <url>/2021/07/08/%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%9C%89%E5%87%A0%E4%B8%AAExcel%E6%96%87%E4%BB%B6%E5%8F%8A%E6%8C%89%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,xlrd</span><br><span class="line"> </span><br><span class="line">data_path = os.path.join(<span class="string">&#x27;D:\jupyter notebook&#x27;</span>,<span class="string">&#x27;test&#x27;</span>)<span class="comment">#os.path.join()函数：连接两个或更多的路径名</span></span><br><span class="line">print(data_path)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#获取目录下所有Excel中sheet</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTables</span>():</span></span><br><span class="line">    <span class="keyword">for</span> excel <span class="keyword">in</span> os.listdir(data_path):<span class="comment">#os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表</span></span><br><span class="line">        print(excel)</span><br><span class="line">        <span class="keyword">if</span> excel.startswith(<span class="string">&#x27;~&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        excelPath = os.path.join(data_path, excel)<span class="comment">#拼接路径</span></span><br><span class="line">        excels = xlrd.open_workbook(excelPath)</span><br><span class="line">        sheetNames = excels.sheet_names()<span class="comment">#获取目录下所有sheet的名字，sheetNames为list类型</span></span><br><span class="line">        print(<span class="string">&#x27;sheetNames:&#x27;</span>,sheetNames)</span><br><span class="line">        <span class="comment"># 循环从sheetNames中读取sheet表，返回的是sheet的内存地址</span></span><br><span class="line">        <span class="keyword">for</span> sheet <span class="keyword">in</span> sheetNames:</span><br><span class="line">            table = excels.sheet_by_name(sheet)</span><br><span class="line">        print(<span class="string">&#x27;table:&#x27;</span>,table)</span><br><span class="line">        <span class="keyword">return</span> table</span><br><span class="line"><span class="comment">#从getTables()中返回的table中提取数据，sheet中的数据组成一个列表，Excel中的表头和数据分别组成key:value的格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span>(<span class="params">sheets</span>):</span></span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, sheets.nrows):</span><br><span class="line">        data.append(<span class="built_in">dict</span>(<span class="built_in">zip</span>(sheets.row_values(<span class="number">1</span>), sheets.row_values(i))))</span><br><span class="line">    print(<span class="string">&#x27;读取出的data:&#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    getData(getTables())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xlsx_to_csv_pd</span>():</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#sheet_name=None 表示读取全部 sheet，或者 sheet_name=[0,10]，此处用 sheet_name，而不是用 sheetname</span></span><br><span class="line">    data_xls = pd.read_excel(<span class="string">r&#x27;D:\jupyter notebook\test\21体侧数据模板.xls&#x27;</span>,sheet_name=<span class="literal">None</span>,index_col=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> data_xls:</span><br><span class="line">        data_xls[key].to_csv(<span class="string">r&#x27;D:\jupyter notebook\test\key&#x27;</span> +  <span class="string">&#x27;.csv&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                             </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:                        </span><br><span class="line">    xlsx_to_csv_pd()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#模块功能：判断某个文件夹下有几个Excel文件，每个Excel有几个Sheet及Sheet Name</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFileNames</span>(<span class="params">path</span>):</span></span><br><span class="line">    filenames = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> i, filename <span class="keyword">in</span> <span class="built_in">enumerate</span>(filenames):</span><br><span class="line">         <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">            iSpecialFile=i+<span class="number">1</span></span><br><span class="line">            sFileName=filename</span><br><span class="line">         print(<span class="string">&#x27;==================第%s个文件=========================&#x27;</span>%(i+<span class="number">1</span>))</span><br><span class="line">         print(<span class="string">&#x27;文件名：%s&#x27;</span>%(filename))</span><br><span class="line">         getSheetNames(path,filename)</span><br><span class="line">    print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;--------------------选择指定的第几个文件-------------------------&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;指定的是第%s个文件:&#x27;</span>%iSpecialFile+sFileName )</span><br><span class="line">    print(<span class="string">&#x27;----------------------------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSheetNames</span>(<span class="params">path,sFileName</span>):</span></span><br><span class="line">    wb = openpyxl.load_workbook(path+<span class="string">&#x27;\\&#x27;</span>+sFileName)</span><br><span class="line">    <span class="comment"># 获取workbook中所有的表格</span></span><br><span class="line">    sheets = wb.sheetnames</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环遍历所有sheet</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sheets)):</span><br><span class="line">        sheet = wb[sheets[i]]</span><br><span class="line">        print(<span class="string">&#x27;第&#x27;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&#x27;个sheet Name: &#x27;</span> + sheet.title)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path=<span class="string">r&#x27;D:\jupyter notebook\xx&#x27;</span></span><br><span class="line">    getFileNames(path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line">students = pd.read_excel(<span class="string">&#x27;./Students.xlsx&#x27;</span>)</span><br><span class="line">students</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">students11 = students.loc[students.Age.apply(<span class="keyword">lambda</span> a:<span class="number">18</span>&lt;=a&lt;=<span class="number">30</span>)].loc[students.Chinese.apply(<span class="keyword">lambda</span> b:b&gt;=<span class="number">90</span>)]</span><br><span class="line">students11</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score_85</span>(<span class="params">b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> b&gt;=<span class="number">85</span></span><br><span class="line">students = students.loc[students.Chinese.apply(score_85)]</span><br><span class="line">students</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students22 = students.loc[students.Math.apply(<span class="keyword">lambda</span> b:b&gt;=<span class="number">95</span>)]</span><br><span class="line">students22</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">st = pd.read_excel(<span class="string">&#x27;./stu.xlsx&#x27;</span>)</span><br><span class="line">st</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu1=st.loc[st.语文.apply(<span class="keyword">lambda</span> x:x&gt;=<span class="number">90</span>)].loc[st.数学.apply(<span class="keyword">lambda</span> y:<span class="number">80</span>&lt;=y&lt;=<span class="number">120</span>)]</span><br><span class="line">stu1</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu2=st.loc[st.语文.apply(<span class="keyword">lambda</span> x:x&gt;=<span class="number">90</span>)].loc[st.数学.apply(<span class="keyword">lambda</span> y:<span class="number">80</span>&lt;=y&lt;=<span class="number">120</span>)].loc[st.英语.apply(<span class="keyword">lambda</span> z:z&gt;<span class="number">60</span>)]</span><br><span class="line">stu2</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score_60</span>(<span class="params">c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> c&gt;<span class="number">90</span></span><br><span class="line">stu3=st.loc[st.英语.apply(score_60)]</span><br><span class="line">stu3</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> os </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span>(<span class="params">path</span>):</span></span><br><span class="line">  df=pd.read_excel(path,<span class="literal">None</span>)</span><br><span class="line">  print(df.keys())</span><br><span class="line">  <span class="comment"># for k,v in df.items():</span></span><br><span class="line">  <span class="comment">#   print(k)</span></span><br><span class="line">  <span class="comment">#   print(v)</span></span><br><span class="line">  <span class="comment">#   print(type(v))</span></span><br><span class="line">  <span class="keyword">return</span> df</span><br><span class="line">path = <span class="string">r&#x27;./stu.xlsx&#x27;</span></span><br><span class="line">read_excel(path)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel1</span>(<span class="params">path</span>):</span></span><br><span class="line">  data_xls = pd.ExcelFile(path)</span><br><span class="line">  print(data_xls.sheet_names)</span><br><span class="line">  data=&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> name <span class="keyword">in</span> data_xls.sheet_names:</span><br><span class="line">    df=data_xls.parse(sheetname=name,header=<span class="literal">None</span>)</span><br><span class="line">    data[name]=df</span><br><span class="line">    <span class="comment"># print(df)</span></span><br><span class="line">    <span class="comment"># print(name)</span></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">read_excel1(path)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>十個你必學的Pr快捷鍵，剪輯起來快速又方便</title>
    <url>/2021/03/06/%E5%8D%81%E5%80%8B%E4%BD%A0%E5%BF%85%E5%AD%B8%E7%9A%84Pr%E5%BF%AB%E6%8D%B7%E9%8D%B5%EF%BC%8C%E5%89%AA%E8%BC%AF%E8%B5%B7%E4%BE%86%E5%BF%AB%E9%80%9F%E5%8F%88%E6%96%B9%E4%BE%BF/</url>
    <content><![CDATA[<h2 id="十個你必學的-PR-快捷鍵，剪輯起來快速又方便"><a href="#十個你必學的-PR-快捷鍵，剪輯起來快速又方便" class="headerlink" title="十個你必學的 PR 快捷鍵，剪輯起來快速又方便"></a>十個你必學的 PR 快捷鍵，剪輯起來快速又方便</h2><p>1、快速对比调色前后差别( F2 键)</p>
<p>2、快速找到原素材影片( F 键)</p>
<p>3、快速选取片段(入点键 I / 出点键 O ) 按下快捷键( ; ) 选取影片则会删除，(如果不留下删除后的空白直接无缝接到上一个影片中，则要按下快捷键 “ )</p>
<p>4、快速汇入影片( , 直接插入影片 / . 直接把后面的影片都覆盖掉 )</p>
<p>5、快速切割工具(删除前段影片 Q / 删除后段影片 W )</p>
<p>6、音轨分离快捷键( Ctrl + L )</p>
<p>7、转场快捷键( Ctrl + D )</p>
<p>8、快速选取影片 ( Shitf + A )</p>
<p>9、快速缩放轨道长度 ( _ / = )</p>
<p>10、快速缩放轨道宽度 ( Ctrl +_ / = )</p>
]]></content>
      <categories>
        <category>视频工具使用</category>
      </categories>
      <tags>
        <tag>视频工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>合并文件夹内所有工作薄的所有工作表</title>
    <url>/2021/02/02/%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E8%96%84%E7%9A%84%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="这是第一个"><a href="#这是第一个" class="headerlink" title="这是第一个"></a>这是第一个</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这个是最完善的一个，值得借鉴</span><br><span class="line"># 导入库</span><br><span class="line">import pandas as pd</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.DataFrame()</span><br><span class="line">path_str &#x3D; r&#39;D:\jupyter notebook\test&#39;</span><br><span class="line"></span><br><span class="line">for excel_str in os.listdir(path_str):</span><br><span class="line">    print(&#39;需要合并的文件:&#39;, path_str + excel_str)</span><br><span class="line"></span><br><span class="line">    new_path &#x3D; os.path.join(path_str, excel_str)</span><br><span class="line">    if os.path.isfile(new_path):</span><br><span class="line">        excel &#x3D; pd.ExcelFile(new_path)</span><br><span class="line">        for sheet in excel.sheet_names:</span><br><span class="line"></span><br><span class="line">            sheet_excel &#x3D; excel.parse(sheet)</span><br><span class="line">            sheet_excel[&#39;test&#39;] &#x3D; excel_str.split(&#39;.&#39;)[0]  # 将原工作簿名作为合并后工作表的列</span><br><span class="line">            df &#x3D; pd.concat([df, sheet_excel])</span><br><span class="line"></span><br><span class="line"># 导出到原文件夹</span><br><span class="line"></span><br><span class="line"># if os.path.exists(new_str):</span><br><span class="line">#     os.remove(new_str)</span><br><span class="line">new_str &#x3D; os.path.join(path_str, &#39;合并文件.xlsx&#39;)</span><br><span class="line">df.to_excel(new_str, index&#x3D;False)</span><br><span class="line">print(&#39;合并后数据的大小:&#39;, df.shape)</span><br><span class="line">print(&#39;合并工作已完成，请到原文件夹内查看结果！&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="这是第二个"><a href="#这是第二个" class="headerlink" title="这是第二个"></a>这是第二个</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 合并同一文件夹下工作薄名相似的所有工作表，这是最完整的一个</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import datetime as dt</span><br><span class="line"></span><br><span class="line">import glob</span><br><span class="line">import os</span><br><span class="line"># runDir &#x3D; r&#39;D:\jupyter notebook\test\11.xlsx&#39;</span><br><span class="line"># if os.getcwd()!&#x3D;runDir:</span><br><span class="line">#     os.chdir(runDir)</span><br><span class="line">files &#x3D; glob.glob(&#39;11*.xlsx&#39;)</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.DataFrame()</span><br><span class="line"></span><br><span class="line">for each in files:</span><br><span class="line">    sheets &#x3D; pd.ExcelFile(each).sheet_names</span><br><span class="line"></span><br><span class="line">    for sheet in sheets:</span><br><span class="line">        df &#x3D; df.append(pd.read_excel(each, sheet, index_col&#x3D;0))</span><br><span class="line"></span><br><span class="line">df.to_excel(r&#39;D:\jupyter notebook\test\1111.xlsx&#39;, index&#x3D;False)</span><br><span class="line">print(&#39;数据大小为:&#39;, df.shape)</span><br></pre></td></tr></table></figure>
<h3 id="这是合并一个工作薄内的所有工作表"><a href="#这是合并一个工作薄内的所有工作表" class="headerlink" title="这是合并一个工作薄内的所有工作表"></a>这是合并一个工作薄内的所有工作表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.ExcelFile(&#39;your_file&#39;)</span><br><span class="line"></span><br><span class="line">df_new &#x3D; pd.DataFrame()</span><br><span class="line"></span><br><span class="line">for name in df.sheet_names:  # 获取每个Sheet的名称</span><br><span class="line">    # 循环读取每个Sheet表内容，同时设置某列为字符串，避免长数字文本被识别为数字</span><br><span class="line">    df_pre &#x3D; df.parse(sheet_name&#x3D;name, dtype&#x3D;&#123;&#39;columns_name&#39;: str&#125;)</span><br><span class="line">    df_new &#x3D; df_new.append(df_pre)</span><br><span class="line"></span><br><span class="line">df_new.to_excel(&#39;your_newfile&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="这是简单高效的方法"><a href="#这是简单高效的方法" class="headerlink" title="这是简单高效的方法"></a>这是简单高效的方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Folder_Path &#x3D; r&#39;D:\jupyter notebook\test&#39;</span><br><span class="line">file_list &#x3D; os.listdir(Folder_Path)</span><br><span class="line"></span><br><span class="line">dfs &#x3D; []</span><br><span class="line">for item in file_list:</span><br><span class="line">    print(&#39;需要合并的文件为:&#39;, Folder_Path+item)</span><br><span class="line">    dfs.append(pd.read_excel(Folder_Path + &#39;\\&#39; + item))</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.concat(dfs, sort&#x3D;False)</span><br><span class="line">df.to_excel(r&#39;D:\jupyter notebook\test\test.xlsx&#39;, index&#x3D;False)</span><br><span class="line">print(&#39;合并后的数据大小为:&#39;, df.shape)</span><br><span class="line">print(&#39;合并完成&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这个带进度表</span><br><span class="line"></span><br><span class="line">dir &#x3D; &#39;test&#x2F;&#39;</span><br><span class="line">filenames &#x3D; os.listdir(dir)</span><br><span class="line">index &#x3D; 0</span><br><span class="line">dfs &#x3D; []</span><br><span class="line">for name in filenames:</span><br><span class="line">    print(&#39;正在处理第&#39; + str(index+1) + &#39;个表格&#39;)</span><br><span class="line">    dfs.append(pd.read_excel(os.path.join(dir, name)))</span><br><span class="line">    index +&#x3D; 1</span><br><span class="line">df &#x3D; pd.concat(dfs)</span><br><span class="line">df.to_excel(&#39;test&#x2F;total.xlsx&#39;, index&#x3D;False)</span><br></pre></td></tr></table></figure>
<h3 id="这是一个更高级的用函数来写多功能的"><a href="#这是一个更高级的用函数来写多功能的" class="headerlink" title="这是一个更高级的用函数来写多功能的"></a>这是一个更高级的用函数来写多功能的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import xlrd</span><br><span class="line">import xlsxwriter</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_file_list(dir, file_type_list&#x3D;[&#39;txt&#39;, &#39;csv&#39;, &#39;xlsx&#39;, &#39;xls&#39;], file_list&#x3D;[]):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    获取指定文件夹下指定类型文件路径</span><br><span class="line">    :param dir: 文件夹路径</span><br><span class="line">    :param file_type_list: 文件类型</span><br><span class="line">    :param file_list: 文件列表</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    for root, _, files in os.walk(dir):</span><br><span class="line">        for file in files:</span><br><span class="line">            file_type &#x3D; file[file.rfind(&#39;.&#39;) + 1:]</span><br><span class="line">            if file_type in file_type_list:</span><br><span class="line">                file_list.append(os.path.join(root, file))</span><br><span class="line">    return file_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def merge_xlsx_files(file_dir_path, out_file_path,</span><br><span class="line">                     file_type_list&#x3D;[&#39;txt&#39;, &#39;csv&#39;, &#39;xlsx&#39;, &#39;xls&#39;],</span><br><span class="line">                     out_file_name&#x3D;&#39;result.xlsx&#39;):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    合并目录下指定类型的文件</span><br><span class="line">    :param file_dir_path: 文件夹路径</span><br><span class="line">    :param out_file_path:  输出文件夹路径</span><br><span class="line">    :param file_type_list: 需要合并的文件类型</span><br><span class="line">    :param out_file_name:  输出文件名称</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    file_paths &#x3D; get_file_list(file_dir_path, file_type_list)</span><br><span class="line">    if not os.path.exists(out_file_path):</span><br><span class="line">        os.makedirs(out_file_path)</span><br><span class="line">    dfs &#x3D; []</span><br><span class="line">    for file in file_paths:</span><br><span class="line">        print(f&#39;file&#x3D;&#123;file&#125;&#39;)</span><br><span class="line">        dfs.append(pd.read_excel(file))</span><br><span class="line">    df &#x3D; pd.concat(dfs)</span><br><span class="line">    df.to_excel(os.path.join(out_file_path, out_file_name), index&#x3D;False)</span><br><span class="line">    print(f&#39;out_file_path&#x3D;&#123;out_file_path&#125;&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    file_dir_path &#x3D; os.path.join(sys.path[0], r&#39;D:\jupyter notebook\test&#39;)</span><br><span class="line">    out_file_path &#x3D; os.path.join(sys.path[0], r&#39;D:\jupyter notebook\test&#39;)</span><br><span class="line">    merge_xlsx_files(file_dir_path, out_file_path, [&#39;xls&#39;])</span><br></pre></td></tr></table></figure>
<h3 id="这个是带用弹窗保存的"><a href="#这个是带用弹窗保存的" class="headerlink" title="这个是带用弹窗保存的"></a>这个是带用弹窗保存的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># python pandas合并多个excel(xls和xlsx)文件（弹窗选择文件夹和保存文件）</span><br><span class="line"></span><br><span class="line">import tkinter as tk</span><br><span class="line">from tkinter import filedialog</span><br><span class="line">import os</span><br><span class="line">import pandas as pd</span><br><span class="line">import glob</span><br><span class="line"></span><br><span class="line">root &#x3D; tk.Tk()</span><br><span class="line">root.withdraw()</span><br><span class="line"></span><br><span class="line"># 选择文件夹位置</span><br><span class="line">filelocation &#x3D; os.path.normpath(</span><br><span class="line">    filedialog.askdirectory(initialdir&#x3D;os.getcwd()))</span><br><span class="line">lst &#x3D; []</span><br><span class="line"></span><br><span class="line"># 读取文件夹下所有文件（xls和xlsx都读取）</span><br><span class="line">for i in glob.glob(filelocation + &quot;\\\\&quot; + &quot;*.*&quot;):</span><br><span class="line">    if os.path.splitext(i)[1] in [&quot;.xls&quot;, &quot;.xlsx&quot;]:</span><br><span class="line">        lst.append(pd.read_excel(i))</span><br><span class="line"></span><br><span class="line"># 保存合并后的excel文件</span><br><span class="line">writer &#x3D; pd.ExcelWriter(filedialog.asksaveasfilename(title&#x3D;&quot;保存&quot;, initialdir&#x3D;filelocation,</span><br><span class="line">                                                     defaultextension&#x3D;&quot;xlsx&quot;, filetypes&#x3D;[(&quot;Excel 工作簿&quot;, &quot;*.xlsx&quot;), (&quot;Excel 97-2003 工作簿&quot;, &quot;*.xls&quot;)]))</span><br><span class="line">pd.concat(lst).to_excel(writer, &#39;all&#39;, index&#x3D;False)</span><br><span class="line">writer.save()</span><br><span class="line"></span><br><span class="line">print(&#39;\n%d个文件已经合并成功！&#39; % len(lst))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>在Pandas中更改列的数据类型方法总结</title>
    <url>/2021/08/22/%E5%9C%A8Pandas%E4%B8%AD%E6%9B%B4%E6%94%B9%E5%88%97%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"></span><br><span class="line">a = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;1.2&#x27;</span>, <span class="string">&#x27;4.2&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;0.03&#x27;</span>], [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;0&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">df= pd.DataFrame(a)</span><br><span class="line">df.dtypes</span><br></pre></td></tr></table></figure>



<pre><code>0    object
1    object
2    object
dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame (a, dtype=<span class="string">&#x27;float&#x27;</span>) <span class="comment">#示例 1</span></span><br><span class="line">df.dtypes</span><br></pre></td></tr></table></figure>



<pre><code>0     object
1    float64
2    float64
dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame (data=a, dtype=np.int8) <span class="comment">#示例 2</span></span><br><span class="line">df.dtypes</span><br></pre></td></tr></table></figure>
<pre><code>0    object
1    object
2    object
dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面是一个字符串 Seriess 的例子，它的 dtype 为 object：</span></span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;4.7&#x27;</span>, <span class="string">&#x27;pandas&#x27;</span>, <span class="string">&#x27;10&#x27;</span>])</span><br><span class="line">s</span><br></pre></td></tr></table></figure>



<pre><code>0         1
1         2
2       4.7
3    pandas
4        10
dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 to_numeric 转为数值。默认情况下，它不能处理字母型的字符串 &#x27;pandas&#x27;：</span></span><br><span class="line"><span class="comment"># 如果遇到无效值，第三个选项就是忽略该操作：</span></span><br><span class="line">pd.to_numeric(s,errors=<span class="string">&#x27;coerce&#x27;</span>)</span><br></pre></td></tr></table></figure>



<pre><code>0     1.0
1     2.0
2     4.7
3     NaN
4    10.0
dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.to_numeric(s, errors=<span class="string">&#x27;ignore&#x27;</span>)<span class="comment">#the original Series is returned untouched</span></span><br></pre></td></tr></table></figure>



<pre><code>0         1
1         2
2       4.7
3    pandas
4        10
dtype: object
</code></pre>
<p>对于多列或者整个 DataFrame</p>
<p>如果想要将这个操作应用到多个列，依次处理每一列是非常繁琐的，所以可以使用 DataFrame.apply 处理每一列。</p>
<p>对于某个 DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;1.2&#x27;</span>, <span class="string">&#x27;4.2&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;0.03&#x27;</span>], [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;0&#x27;</span>]]</span><br><span class="line">df = pd.DataFrame(a, columns=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
      <th>col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>1.2</td>
      <td>4.2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>70</td>
      <td>0.03</td>
    </tr>
    <tr>
      <th>2</th>
      <td>x</td>
      <td>5</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dtypes</span><br></pre></td></tr></table></figure>



<pre><code>col1    object
col2    object
col3    object
dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>]]=df[[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>]].apply(pd.to_numeric)</span><br><span class="line">df.dtypes</span><br></pre></td></tr></table></figure>



<pre><code>col1     object
col2    float64
col3    float64
dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
      <th>col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>1.2</td>
      <td>4.20</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>70.0</td>
      <td>0.03</td>
    </tr>
    <tr>
      <th>2</th>
      <td>x</td>
      <td>5.0</td>
      <td>0.00</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 但是，可能不知道哪些列可以可靠地转换为数字类型。在这种情况下，设置参数：</span></span><br><span class="line"></span><br><span class="line">df.apply(pd.to_numeric, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后该函数将被应用于整个 DataFrame，可以转换为数字类型的列将被转换，而不能 (例如，它们包含非数字字符串或日期) 的列将被单独保留。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外 pd.to_datetime 和 pd.to_timedelta 可将数据转换为日期和时间戳。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
      <th>col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>1.2</td>
      <td>4.20</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>70.0</td>
      <td>0.03</td>
    </tr>
    <tr>
      <th>2</th>
      <td>x</td>
      <td>5.0</td>
      <td>0.00</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 软转换 —— 类型自动推断</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本 0.21.0 引入了 infer_objects () 方法，用于将具有对象数据类型的 DataFrame 的列转换为更具体的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如，用两列对象类型创建一个 DataFrame，其中一个保存整数，另一个保存整数的字符串：</span></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>]&#125;, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">df.dtypes</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<pre><code>a    object
b    object
dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 然后使用 infer_objects ()，可以将列 &#x27;a&#x27; 的类型更改为 int64：</span></span><br><span class="line"></span><br><span class="line">df =df.infer_objects()</span><br><span class="line">df.dtypes</span><br></pre></td></tr></table></figure>



<pre><code>a     int64
b    object
dtype: object
</code></pre>
<p>astype 强制转换</p>
<p>如果试图强制将两列转换为整数类型，可以使用 df.astype (int)。</p>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;1.2&#x27;</span>, <span class="string">&#x27;4.2&#x27;</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;0.03&#x27;</span>], [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;0&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">df= pd.DataFrame(a, columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line"></span><br><span class="line">df</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>1.2</td>
      <td>4.2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>70</td>
      <td>0.03</td>
    </tr>
    <tr>
      <th>2</th>
      <td>x</td>
      <td>5</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dtypes</span><br></pre></td></tr></table></figure>



<pre><code>one      object
two      object
three    object
dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[[<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>]]=df[[<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>]].astype(<span class="built_in">float</span>)</span><br><span class="line">df.dtypes</span><br></pre></td></tr></table></figure>



<pre><code>one       object
two      float64
three    float64
dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>多工作表保存至一个工作薄内问题</title>
    <url>/2021/07/06/%E5%A4%9A%E5%B7%A5%E4%BD%9C%E8%A1%A8%E4%BF%9D%E5%AD%98%E8%87%B3%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E8%96%84%E5%86%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="pandas-将多个-dataframe-以多个-sheet-的形式保存到一个-excel-文件中"><a href="#pandas-将多个-dataframe-以多个-sheet-的形式保存到一个-excel-文件中" class="headerlink" title="pandas 将多个 dataframe 以多个 sheet 的形式保存到一个 excel 文件中"></a>pandas 将多个 dataframe 以多个 sheet 的形式保存到一个 excel 文件中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">writer &#x3D; pd.ExcelWriter(&#39;test.xlsx&#39;)</span><br><span class="line">data1.to_excel(writer,sheet_name&#x3D;&#39;sheet1&#39;)</span><br><span class="line">data2.to_excel(writer,sheet_name&#x3D;&#39;sheet2&#39;)</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>
<h3 id="上面的方法会将原来的-excel-文件覆盖掉，假如想要对已经存在的-excel-文件进行修改，可以使用开源工具包（anaconda-已附带）openpyxl"><a href="#上面的方法会将原来的-excel-文件覆盖掉，假如想要对已经存在的-excel-文件进行修改，可以使用开源工具包（anaconda-已附带）openpyxl" class="headerlink" title="上面的方法会将原来的 excel 文件覆盖掉，假如想要对已经存在的 excel 文件进行修改，可以使用开源工具包（anaconda 已附带）openpyxl"></a>上面的方法会将原来的 excel 文件覆盖掉，假如想要对已经存在的 excel 文件进行修改，可以使用开源工具包（anaconda 已附带）openpyxl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from openpyxl import load_workbook  # 这一句必须写</span><br><span class="line"> </span><br><span class="line">writer &#x3D; pd.ExcelWriter(&#39;test.xlsx&#39;,engin&#x3D;&#39;openpyxl&#39;)</span><br><span class="line">book &#x3D; load_workbook(writer.path)</span><br><span class="line">writer.book &#x3D; book</span><br><span class="line">dataframe.to_excel(excel_writer&#x3D;writer,sheet_name&#x3D;&quot;info5&quot;)</span><br><span class="line">writer.save()</span><br><span class="line">writer.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="另一种高效的写法"><a href="#另一种高效的写法" class="headerlink" title="另一种高效的写法"></a>另一种高效的写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with pd.ExcelWriter(r&quot;D:\test1\result.xlsx&quot;, engine&#x3D;&#39;openpyxl&#39;) as writer:  # 这是一种高效的写法 from openpyxl import load_workbook 这一句必须写</span><br><span class="line">    book &#x3D; load_workbook(writer.path)</span><br><span class="line">    writer.book &#x3D; book</span><br><span class="line">    data1.to_excel(writer,sheet_name&#x3D;&#39;sheet1&#39;)</span><br><span class="line">    data2.to_excel(writer,sheet_name&#x3D;&#39;sheet2&#39;)</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import os</span><br><span class="line">from openpyxl import load_workbook  # 必须导入的模块</span><br><span class="line"></span><br><span class="line">path &#x3D; r&quot;D:\test1\file_folder&quot;</span><br><span class="line">listing &#x3D; os.listdir(path)</span><br><span class="line">data_list &#x3D; [f for f in listing if f[-5:] &#x3D;&#x3D; &#39;.xlsx&#39;]  # 为了排除不是.xlsx的文件，避免程序报错</span><br><span class="line"></span><br><span class="line">with pd.ExcelWriter(r&quot;D:\test1\result.xlsx&quot;, engine&#x3D;&#39;openpyxl&#39;) as writer:  # 这是一种高效的写法</span><br><span class="line">    for i in data_list:</span><br><span class="line">        name &#x3D; i.split(&#39;.&#39;)[0]</span><br><span class="line">        df1 &#x3D; pd.read_excel(os.path.join(path, i))</span><br><span class="line">        df1.to_excel(writer, sheet_name&#x3D;name, index&#x3D;False)  # 程序的逻辑</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="获取工作薄所有工作表列表"><a href="#获取工作薄所有工作表列表" class="headerlink" title="获取工作薄所有工作表列表"></a>获取工作薄所有工作表列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.read_excel(path, sheet_name&#x3D;None)</span><br><span class="line">for i in df.keys():</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">方法二:</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.read_excel(path, sheet_name&#x3D;None)</span><br><span class="line">sheet_name_list &#x3D; list(df)</span><br><span class="line">print(sheet_name_list)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 另一种写法</span><br><span class="line"></span><br><span class="line">writer &#x3D; pd.ExcelWriter(r&#39;result.xlsx&#39;)</span><br><span class="line"></span><br><span class="line">for i in os.listdir(r&#39;.&#x2F;file_folder&#39;):</span><br><span class="line">    name &#x3D; i.split(&#39;.&#39;)[0]</span><br><span class="line">    df1 &#x3D; pd.read_excel(os.path.join(r&#39;.&#x2F;file_folder&#39;, i))</span><br><span class="line">    df1.to_excel(writer, sheet_name&#x3D;name, index&#x3D;False)</span><br><span class="line">writer.save()  # 这2个操作不能忘记，否则文件只在缓存里，看不到直接的操作结果</span><br><span class="line">writer.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Python-pandas-如何向-excel-添加数据"><a href="#Python-pandas-如何向-excel-添加数据" class="headerlink" title="Python pandas 如何向 excel 添加数据"></a>Python pandas 如何向 excel 添加数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个空的excel文件</span><br><span class="line">nan_excle &#x3D; pd.DataFrame()</span><br><span class="line">nan_excel.to_excel(path + filename)</span><br><span class="line"></span><br><span class="line"># 打开excel</span><br><span class="line">writer &#x3D; pd.ExcelWriter(path + filename)</span><br><span class="line">#sheets是要写入的excel工作簿名称列表</span><br><span class="line">for sheet in sheets:</span><br><span class="line">　　output.to_excel(writer, sheet_name&#x3D;sheet)</span><br><span class="line"></span><br><span class="line"># 保存writer中的数据至excel</span><br><span class="line"># 如果省略该语句，则数据不会写入到上边创建的excel文件中</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>
<h2 id="不同方法读取-excel-中的多个不同-sheet-表格性能比较"><a href="#不同方法读取-excel-中的多个不同-sheet-表格性能比较" class="headerlink" title="不同方法读取 excel 中的多个不同 sheet 表格性能比较"></a>不同方法读取 excel 中的多个不同 sheet 表格性能比较</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方法1</span><br><span class="line">def read_excel(path):</span><br><span class="line">  df&#x3D;pd.read_excel(path,None)</span><br><span class="line">  print(df.keys())</span><br><span class="line">  # for k,v in df.items():</span><br><span class="line">  #   print(k)</span><br><span class="line">  #   print(v)</span><br><span class="line">  #   print(type(v))</span><br><span class="line">  return df</span><br><span class="line"> </span><br><span class="line"># 方法2</span><br><span class="line">def read_excel1(path):</span><br><span class="line">  data_xls &#x3D; pd.ExcelFile(path)</span><br><span class="line">  print(data_xls.sheet_names)</span><br><span class="line">  data&#x3D;&#123;&#125;</span><br><span class="line">  for name in data_xls.sheet_names:</span><br><span class="line">    df&#x3D;data_xls.parse(sheetname&#x3D;name,header&#x3D;None)</span><br><span class="line">    data[name]&#x3D;df</span><br><span class="line">    # print(df)</span><br><span class="line">    # print(name)</span><br><span class="line">  return data</span><br><span class="line"> </span><br><span class="line"># 方法3</span><br><span class="line">def read_excel2(path):</span><br><span class="line">  data_xls &#x3D; pd.io.excel.ExcelFile(path)</span><br><span class="line">  data&#x3D;&#123;&#125;</span><br><span class="line">  print(data_xls.sheet_names)</span><br><span class="line">  for name in data_xls.sheet_names:</span><br><span class="line">    df&#x3D;pd.read_excel(data_xls,sheetname&#x3D;name,header&#x3D;None)</span><br><span class="line">    data[name]&#x3D;df</span><br><span class="line">  return data</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="结论：若读取多个-sheet-表格时，方法-2-和方法-3-相对于方法-1-的效率较高。"><a href="#结论：若读取多个-sheet-表格时，方法-2-和方法-3-相对于方法-1-的效率较高。" class="headerlink" title="结论：若读取多个 sheet 表格时，方法 2 和方法 3 相对于方法 1 的效率较高。"></a>结论：若读取多个 sheet 表格时，方法 2 和方法 3 相对于方法 1 的效率较高。</h3><p>一、简介</p>
<p>　　pandas 中的 ExcelFile () 和 ExcelWriter ()，是 pandas 中对 excel 表格文件进行读写相关操作非常方便快捷的类，尤其是在对含有多个 sheet 的 excel 文件进行操控时非常方便，本文就将针对这两个类的使用方法展开介绍；</p>
<p>二、ExcelFile ()</p>
<p>　　在使用 ExcelFile () 时需要传入目标 excel 文件所在路径及文件名称，下面是示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">demo_excel &#x3D; pd.ExcelFile(r&#39;D:\demo.xlsx&#39;)</span><br></pre></td></tr></table></figure>
<p>接下来可以使用 ExcelFile () 中的方法来获取目标表格文件的相关信息：</p>
<p>1、sheet_names</p>
<p>使用 sheet_names 来查看当前表格中包含的所有 sheet 名称（按顺序）：</p>
<p><code>print(demo_excel.sheet_names)</code></p>
<p>　2、parse()</p>
<p>　　使用 parse () 可以根据传入的 sheet 名称来提取对应的表格信息，下面是一个简单的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table1 &#x3D; demo_excel.parse(sheet_name&#x3D;demo_excel.sheet_names[0])</span><br><span class="line"></span><br><span class="line">table2 &#x3D; demo_excel.parse(sheet_name&#x3D;demo_excel.sheet_names[1])</span><br><span class="line"></span><br><span class="line">table3 &#x3D; demo_excel.parse(sheet_name&#x3D;demo_excel.sheet_names[2])</span><br><span class="line"></span><br><span class="line">print(table1)</span><br><span class="line">print(table2)</span><br><span class="line">print(table3)</span><br></pre></td></tr></table></figure>
<p>基于已创建的 writer 对象，可以利用 to_excel () 方法将不同的数据框及其对应的 sheet 名称写入该 writer 对象中，并在全部表格写入完成之后，使用 save () 方法来执行 writer 中内容向对应实体 excel 文件写入数据的过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39;&#39;创建数据框1&#39;&#39;&#39;</span><br><span class="line">df1 &#x3D; pd.DataFrame(&#123;&#39;V1&#39;:np.random.rand(100),</span><br><span class="line">          &#39;V2 &#39;:np.random.rand(100),</span><br><span class="line">          &#39;V3&#39;:np.random.rand(100)&#125;)</span><br><span class="line">df1.to_excel(writer,sheet_name&#x3D;&#39;sheet1&#39;,index&#x3D;False)</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;创建数据框2&#39;&#39;&#39;</span><br><span class="line">df2 &#x3D; pd.DataFrame(&#123;&#39;V1&#39;:np.random.rand(100),</span><br><span class="line">          &#39;V2 &#39;:np.random.rand(100),</span><br><span class="line">          &#39;V3&#39;:np.random.rand(100)&#125;)</span><br><span class="line">df2.to_excel(writer,sheet_name&#x3D;&#39;sheet2&#39;,index&#x3D;False)</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;创建数据框3&#39;&#39;&#39;</span><br><span class="line">df3 &#x3D; pd.DataFrame(&#123;&#39;V1&#39;:np.random.rand(100),</span><br><span class="line">          &#39;V2 &#39;:np.random.rand(100),</span><br><span class="line">          &#39;V3&#39;:np.random.rand(100)&#125;)</span><br><span class="line">df3.to_excel(writer,sheet_name&#x3D;&#39;sheet3&#39;,index&#x3D;False)</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;数据写出到excel文件中&#39;&#39;&#39;</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>好的学习方法和习惯</title>
    <url>/2021/03/06/%E5%A5%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%92%8C%E4%B9%A0%E6%83%AF/</url>
    <content><![CDATA[<p>能在考试中胜出的人分为两种：一种是策略正确的人，一种是真正刻苦的人。</p>
<p>人和人之间最大的差距是什么</p>
<p>网络上有句成功学鸡汤这样说：「经营企业，经营的是与那些成功企业之间的差距；经营人生，经营的是与成功人士之间的差距。干掉这个差距，你也可以很牛 ×。」</p>
<p>可是，差距是什么？在哪里？怎么干掉？</p>
<p>我考过不少试了，中高考、考研、司考、托福，接下来还想考 CPA（注册会计师），甚至想去尝试一下考博。</p>
<p>考试难吗？</p>
<a id="more"></a>

<p>任何靠自己就能做到的事情，都不能叫作难事。</p>
<p>那些在上学时讨厌考试、觉得复习太累的人，到后来就会知道，如果什么都不用理会，仅凭自己的认真勤奋就能做好一件事，这是多大的幸福和幸运。</p>
<p>能在考试中胜出的人，分为两种。</p>
<p>一种是策略正确的人，轻轻松松学习，效果极佳。</p>
<p>我们经常看到那种考上清华、北大的人说自己根本没怎么努力就考上了，他们不一定是天才、智商高，但最起码能够理性地看待考试，寻找规律，摸索途径，在正确的方向上努力，自然可以少费力气就能取得佳绩。</p>
<p>一种是真正刻苦的人。</p>
<p>这种人未必拥有极佳的学习方法，要背诵就傻傻背诵，要做题就拼命做题，一个知识点被他在一百道题里练习过，再笨也会了。</p>
<p>最好的做法当然是在正确的策略下，投入足够多的学习时间。</p>
<p>学习时间是指真正在学习的时间，不是昏昏欲睡地熬通宵复习，也不是三心二意地翻翻书，如果没有集中注意力，那根本不叫学习时间。</p>
<p>基于我们在注意力上的差距，你可以学一个小时，顶别人学五个小时。不能专心的话，去图书馆待再长的时间也不过是自欺欺人而已。</p>
<p>在学习[1]这件事情上，人和人之间最大的差距之一就是专注力。</p>
<p>如何长时间地专注学习？</p>
<p>我们把专注学习的方法分为三个板块。</p>
<p>1.学习前的准备</p>
<p>在每天开始学习前，明确本次学习的任务和结束时间。</p>
<p>问自己三个问题：</p>
<p>我为什么要学这些东西？</p>
<p>我今天要解决什么问题？</p>
<p>我预估多久可以学完这些东西？</p>
<p>让两个人做同样的十道题。一个人知道自己做这十道题的目的是强化自己容易搞错的几个知识点，他带着解决问题的心态投入学习，必然比另一个只给自己规划定量任务的人学习要专注。</p>
<p>让两个人同样记忆一章节的内容。</p>
<p>一个人清楚地知道必须在下午六点前结束任务，另一个人只是模糊地知道在下午要把这些内容背完，则前者集中注意力的紧迫性更强。在后者的心里，下午可以是六点结束，也可以是七点结束，当结束时间有弹性的时候，就会下意识认为还有很长的学习时间，也就更难集中注意力。</p>
<p>如果你在为一场考试做准备，就一定要清楚「怎么样学习才能达到目标」，这样更能帮助你去抵制诱惑，专注于任务。</p>
<p>这个问题包括三个要素：</p>
<p>A.要达到什么样的目标。考什么学校？这个学校要多少分数？单科目标分数是多少？</p>
<p>B.要做什么事情。都需要学习哪些知识点？这些知识点在哪些书上？都要做哪些题，做几遍？背哪些东西？</p>
<p>C.这些事情要做多久。总共的复习时间是几个月？给每一个任务分配多长时间？</p>
<p>如果对上面的问题有答案的话，那么，每一个你灯下学习的晚上，每一个迎着晨光背诵的早晨，你都知道自己在做什么，为什么这么做。即便不是一个热爱学习的人，带着明确的目的去做，与模模糊糊、只是知道应该这么做，专注度也会有差别。</p>
<p>特别为学习准备一个干净整洁的环境。</p>
<p>把工作和学习环境布置得舒适愉悦、极尽方便，所有要干的活都在早上坐下后一一安排好，把有助于提高注意力的东西都放在眼前，比如，想考上的学校的照片。</p>
<p>这样长期下来，就会给自己的脑袋里装置这样一个开关：只要进入这个环境，学习就可以开始了。</p>
<p>尽量不在早晨或者是学习开始之前收拾桌子，这样很容易控制不好时间，导致耗费时间过长。</p>
<p>人天性里更喜欢简单直接的、不动脑的、眼前的事情，相比学习，整理房间显然是更令人愉悦的。</p>
<p>利用环境来给自己暗示，这是我过去一直忽略的一个技巧。</p>
<p>读高中时我不愿意在整理内务或者打扮自己上多花一丁点时间，那时候我对于学习有一种变态的专注，完全不在意自己在什么地方学习。</p>
<p>但是那种极端专注是可遇不可求的，持续性也比较差。</p>
<p>我发现环境对学习有影响是因为一次搬家。</p>
<p>我以前住的房子是一个钢铁公司的家属楼，年代有点久远，屋子装修陈旧，怎么打扫都弄不干净，这直接导致我收拾房间的欲望不强，在乱糟糟的环境里，我的学习状态一直都不怎么好，回到家就提不起劲来。</p>
<p>事情的有趣之处就在于，当我身处其中的时候，并不能发现环境与自身状态之间的关系，一直到我后来搬家住进一个日式装修风格的精美房子里，才发现自己的不同。</p>
<p>晚上回家，一开门进去就觉得很幸福，愿意静坐其中，桌椅板凳、书本台灯、被褥衣服，都摆放得整齐有序，这种整洁的环境会增加人对自己控制力的信心，由外而内地使自己产生一种「不可乱」的心情。</p>
<p>「一切都在我的控制之中，学习也是。」</p>
<p>大概是这种心情。</p>
<p>我学习的桌子上放着植物界的励志之星仙人掌，桌角贴着我的奋斗目标，台灯是朋友送的，小米品牌的，外表简洁漂亮，暖光，我超级喜欢，看到它就有幸福感，这样就直接减少了对「结束玩乐开始工作」的排斥，精神很容易收拢到眼前的工作上来。</p>
<p>关于学习环境还有几点要注意。</p>
<p>到底应该去图书馆学习，还是留在寝室就好了？</p>
<p>我的建议是最好不要在寝室，一定要把学习环境和休息娱乐的地方分开，这样更能强化自己脑袋里的学习和娱乐开关。</p>
<p>我连吃饭、娱乐和工作都不用同一张桌子。</p>
<p>如果在一个地方，学习状态始终不好，也可以考虑换一个环境，调整状态，只是不要去太陌生太极端的环境中，最好是去自己本来就熟悉和习惯的地点。期末考试的时候有朋友叫我一起去校外咖啡馆学习，但实际上效率极低，咖啡馆与图书馆相比声音杂，总有人来来往往，桌子太小，光调整心情就需要很长时间。</p>
<p>珍惜不会被打扰的时间段。</p>
<p>以前上学的时候，学校把一节课的时间设定成四十五分钟，所有人都必须遵守这个安排，把自己学习的节奏调整成四十五分钟一休息。</p>
<p>上学这么多年，我对这个制度始终没有习惯。</p>
<p>刚刚感觉自己沉静下来了，找到了状态，很快就到了下课时间，忍不住盼望下课，毕竟老师讲课也不是那么好听。</p>
<p>到了大学，没有自习课，学习变成一件很自由的事情。</p>
<p>这也就意味着，你可以随时学习，也要准备随时被打扰。</p>
<p>所以要珍惜那些不被打扰的、安静的学习时间，也要多多寻找这样的时间。</p>
<p>例如早起后的清晨，不要安排那些杂七杂八的事情，就坐在那里学习一段时间。</p>
<p>番茄时间管理法现在很火，很多人都说这个方法好用。</p>
<p>一个番茄时间共三十分钟，包括二十五分钟的工作时间和五分钟的休息时间。</p>
<p>我总觉得二十五分钟学习时间太短，适合那些精神完全没办法集中的人用作早期训练，或者适用于已经上了班的人，他们往往需要同时处理很多事情，又随时可能被打断。</p>
<p>不过这个方法帮助我养成了一种习惯：设定好的学习时间，绝对不中断，也不可以被打扰，反正接下来有休息的时间。</p>
<p>脑中一定要有这样的概念：学习时间绝对不可以中断，就算是无法集中注意力，也不要放弃为集中注意力而努力。</p>
<p>2.在学习的过程中</p>
<p>排除干扰。</p>
<p>据说，人的每个神经元都和一万个神经元交流，就好比一万个人无时无刻不在打电话找你，所以大脑必然是很容易分神的。</p>
<p>我把干扰分为四种。</p>
<p>第一种，杂念。</p>
<p>明明看着数学题，莫名其妙地就想起来朋友要过生日了，该给她买个礼物，反正这件事是必须要做的，干脆现在就买，于是就放下手上的题，开始刷淘宝。</p>
<p>一旦发现自己脑袋中闪现了这种小念头，就拿张便笺纸写下来，每天设置一个专属时间段来集中处理此类小事，让自己把这些事情安心地放下。</p>
<p>第二种，烦恼。</p>
<p>烦恼是代指那些最近在困扰或影响自己情绪的事情，例如，跟室友闹矛盾，上一次考试失败等，这种事情尽快解决最好。</p>
<p>小事不要与朋友计较，你还有更重要的事情要做，该道歉的道歉，该视而不见的就视而不见。</p>
<p>如果这件事始终在脑海里盘桓放不下，就拿出一张纸，把自己对这件事情的解决思路写下来。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures20210301150030.png" alt="20210301150030"></p>
</div>

<p>你可以按照自己的情况，把分析情况和解决思路写得更详细。</p>
<p>每次想到这件令人烦恼的事情，都看一眼这个解决思路，然后就能安心下来。</p>
<p>保持情绪的稳定是一个人重要的能力之一，如果总被乱七八糟的情绪困扰，就要反思自己是不是一个心胸不够开阔的人。</p>
<p>敏感、多疑、易怒，都是严重的能量自耗。</p>
<p>第三种，手机。</p>
<p>如果控制不住自己玩手机，最好的办法就是远离手机！没什么更高级的方法！就是隔绝，见不到，摸不着。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Python必须要养成的几个习惯</title>
    <url>/2021/02/19/%E5%AD%A6%E4%B9%A0Python%E5%BF%85%E9%A1%BB%E8%A6%81%E5%85%BB%E6%88%90%E7%9A%84%E5%87%A0%E4%B8%AA%E4%B9%A0%E6%83%AF/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/296731634">源自知乎</a>感谢作者，以此来鞭策及督促自己学习。</p>
<p>首先，我就是从零基础开始学的 Python，在学习 Python 前，首先你要具备以下条件。</p>
<p>1、能够坚持学下去的精神<br>2、一台电脑</p>
<p>没错，就只要这两点，就可以学会 Python，因为 Python 本身设计的目的就是简单易上手，换句话来说，学会 Python，有手就行。</p>
<a id="more"></a>

<p>对于小白来说，有个人引导会比自学要高效的多，尤其容易坚持不下去的小伙伴。</p>
<p>但有句话也说的好，师傅领进门，修行看个人。学习 Python 是需要一个 “师傅” 带你入门的。Python 的初步学习十分简单。</p>
<p>在学习完这些 Python 的基础课程之后，你已经对编程的世界有了初步的认识，不过在你进一步向更深处学习 Python 之前，你需要再审视一下你的学习之路，想想你能把 Python 用在生活中的哪里。</p>
<blockquote>
<p>你或许可以通过新学的 Python 去完成一些重复性的任务。<br>你或许可以靠 Python 提高工作效率。<br>你或许可以用 Python 赚点外快。<br>你又或许可以直接转行成为一名程序员。<br>如果你一时间想不到 Python 的用武之地，你不妨先放下 Python，等到生活中需要 Python 去解决一些问题的时候在重新回来学习 Python。<br>如果你打算继续深入，先做到以下两点。<br>找到一个适合自己的 IDE。好的 IDE，可以帮助你很快完成任务。<br>明确方向。这决定你会在 Python 这条路上走多远。</p>
</blockquote>
<p>最后，努力学习，学以致用。生活中可以用到 Python 的位置远比你想象的多得多，等到你学会 Python 之后你会发现生活中有很多的问题都是可以通过 Python 来帮助你快速解决的。</p>
<p>学编程最需要的就是耐心！现在大家想学编程太方便了，跟着教程满天飞。刚开始入门的时候有高手带，往往能有事半功倍的效果，尤其是自己不知道怎么找资料，怎么去配置编程环境什么的时候。有人手把手教的话，入门就高效很多了。</p>
<p>还是想先泼点冷水！不要被市面上的各种 Python 培训广告冲昏了头脑：</p>
<p>① 学完 Python，并不能立马拿一两万的工资，甚至可能找不到工作！</p>
<p>②Python 也没有那么简单，不是有手就行！</p>
<p>③别想着 1 个月、2 个月就能学会，你至少得腾出半年时间全职学习！</p>
<p>如果你还是执意要学 Python，那么好，接下来我们看看怎么学。Python 作为一门脚本语言，难度上相较于其他语言略微简单点。但对于没有计算机基础的人来说，可能最开始配置 Python 编译环境都能让他望而却步。这里推荐一个无需安装配置的在线编程平台（新手可以先在线写一段时间的代码，适应下）</p>
<p>1、Python 学习路线图</p>
<p>学习一定不是盲目的，只有先明确了要学哪些东西，怎么学，才能更高效地去学 Python。</p>
<p>这是 Python 的整个知识体系图谱，对于新手来说，没必要学那么多。先把 Python 基础和进阶知识吃透，才是入门的关键。后续你是往前端开发深造，还是去新潮时髦的大数据、人工智能，就全凭自己的兴趣。但我相信这时候的你，应该不会像现在这么迷茫。</p>
<p>2、关于如何学 Python</p>
<p>其实网上的 Python 课程很多，都是比较有体系的。学 Python 入门和进阶的知识，用网课完全足够。但 Python 本质上是对一门语言工具的运用，实战比理论更重要。</p>
<p>我们在学习的时候一定要多敲、多练、多思考！！！</p>
<p>写代码不只是跟着视频课或者照着书本写完就行的，我们要理清每行代码的逻辑。刚开始学，最好对每一句代码都加以注释，帮助我们理清逻辑，加深印象。</p>
<p>同时，学完一个知识点后应该多去找对应的案例来练习，做到理论与实战的深度结合。</p>
<p>3、Python 学习资源</p>
<p>Python 书籍：</p>
<p>《零基础入门学习Python》</p>
<p>《Think Python 2e 中译版》</p>
<p>《Python+Cookbook》第三版中文v3.0.0</p>
<p>《Python数据科学手册》</p>
<p>《Python知识手册-v2.2》</p>
<p>学习网站：</p>
<p><a href="http://www.pythontutor.com/visualize.html#mode=edit">在线工具Python代码运行原理过程演示</a></p>
<p>最后，自学 Python 最重要的就是心态。我们在学习过程中必然会遇到很多难题，可能自己想破脑袋都无法解决。这都是正常的，千万别急着否定自己，怀疑自己。找一个靠谱点的师兄，没事知乎一下，其实这些难题也就迎刃而解了。</p>
<p>在学习 Python 的过程中需要养成几个好习惯。</p>
<p>下面我给大家分享几条：</p>
<blockquote>
<p>缩进</p>
</blockquote>
<p>由于跟其他编程语言的区别性，缩进在 python 编程中显得十分重要；在 Python 的代码块中必须使用相同数目的行首缩进空格数，否则会造成脚本运行错误，提示你格式不正确之类的信息。因此，在使用 python 语言写脚本的时候，保证缩进的一致性相当重要。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211018.png" alt="20210218211018"></p>
</div>

<blockquote>
<p>空格</p>
</blockquote>
<p>虽然在 python 编程过程中，空行并不是 Python 语法的必需部分，但是，保持函数之间或类的方法之间用空行分隔，可以使得代码看起来更加清晰明了，也有利于后期的代码维护或重构。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211111.png" alt="20210218211111"></p>
</div>

<blockquote>
<p>注释</p>
</blockquote>
<p>注释相对经常使用编程语言的人来说应该不是很陌生吧，主要因为注释不仅使得阅读代码的人容易理解，也让代码作者更好地定位代码函数等。python 跟其它语言一样，注释在一些该注释的地方，可以让效率事半功倍。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211352.png" alt="20210218211352"></p>
</div>

<blockquote>
<p>源代码</p>
</blockquote>
<p>python 作为完全开源的语言，代码对于任何人都可以随意浏览。这种方式可以更好地帮助人们发现有利精简扼要的代码，在很多方面可以省去不必要的时间，因为觉得合适可以直接拿过来使用或者简单修改。经常看一下好的源代码，不仅会让你学习别人的编程方式，还在另一方面大大的帮助你更好地学习。</p>
<blockquote>
<p>编程思想</p>
</blockquote>
<p>使用任何一门编程语言，都需要保持很好的编程思想，对 python 来说也是一样的。学会创造使用适合自己的编程思想是至关重要的，因此，去多读一些讲解编程思想之类的书籍来充实自己吧。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211449.png" alt="20210218211449"></p>
</div>

<blockquote>
<p>多实践</p>
</blockquote>
<p>学习任何一门编程语言都需要多做多写多看，通过不同的项目，来让自己得到更好的锻炼，相信是一件很棒的事情。在业余时间，经常的去敲写一些代码，也是很有意思的。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211542.png" alt="20210218211542"></p>
</div>

<p>兴趣<br>兴趣是成功的一半，兴趣促使你更好地去使用学习编程语言，而不单单为了忙碌的工作。很多创造出编程语言的人来说，正时因为兴趣的使然，才成就了如此好的一些编程语言。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211606.png" alt="20210218211606"></p>
</div>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>学习是没有尽头的差不多就行了</title>
    <url>/2021/08/24/%E5%AD%A6%E4%B9%A0%E6%98%AF%E6%B2%A1%E6%9C%89%E5%B0%BD%E5%A4%B4%E7%9A%84%E5%B7%AE%E4%B8%8D%E5%A4%9A%E5%B0%B1%E8%A1%8C%E4%BA%86/</url>
    <content><![CDATA[<p>大部分人咨询我的都是跟创业相关的问题，但是偶尔也有人咨询我考研、考公务员的问题。</p>
<p>关于考研，我是这样看的，考研的人，至少有一半的人是为了逃避现实。但是，现实是逃避不了的。</p>
<p>今天你不想面对，三年后你还是得面对。</p>
<p>有的人是因为本科就业不乐观，轻松而且高工资的职位太少，所以就选择继续留在学校，考研考博。</p>
<p>如果你没有一个清晰的规划，只是一味去学习，去考证，会学傻的，最终也会跟社会脱轨的。</p>
<p>除非，你天赋异禀能考进名校，或者去知名大学留学，能接触到某个领域最尖端的技术或者大师，而且你对于学术、研究真的非常感兴趣。</p>
<p>还有一种情况，就是你的家里已经给你铺好路了，你研究生一毕业他们就会给你安排一个铁饭碗，一个萝卜坑。</p>
<p>因为有些正规单位，人家招人的起步条件就是211硕士，还要通过笔试、面试，这些都是明面的要求。</p>
<p>当然，这些单位可能还会有看不见的要求：你的亲爹或者亲妈得是那个单位的元老。</p>
<p>除了这两种情况之外，大部分读研的人，都是非常盲目的。三年宝贵青春搭上了，最终换来了的是，起步工资比本科生高几百元。</p>
<p>但是，对于那些没有家庭支持、需要自己买车买房的人来说，多这几百元屁用都没有。还不如利用三年时间去探索各种赚钱的可能性。</p>
<p>即使进入社会之后，很多人也喜欢学习，考各种证书，参加各种学习培训班。</p>
<p>这些可能也会起到一定作用，但是你一定要搞清楚，人生的目的不是学习，而是创造并且享受物质财富和精神财富。</p>
<p>学习是永无止境的，差不多就行了。</p>
<p>知识太多，很可能会成为你前行路上的包袱。</p>
<p>因为你学习的时间多了，实践的机会就少了。</p>
<p>人的时间和精力是极其有限的，我在VIP群也经常讲“积极性”这个词语，比如你的帖子火了，或者你的收入有明显提升了，你会非常兴奋的，积极性能充分调动起来，然后你会更加热情地投身到自己的事业上去，成长飞快。</p>
<p>小成功是大成功之母。</p>
<p>而这一切都是实践出来的结果，不是学习出来的结果。</p>
<p>有针对性的学习，确实能给人指明方向，比如我在群里教大家玩知乎、蹭热点的几个要点，以及引流量和变现的几个手段。这些都是非常宝贵的经验。</p>
<p>但是呢，这些顶多能贡献1%的力量，剩下的99%得靠你的实践，你得去做，去执行才可以。</p>
<p>最底层的人，没有思维、没有方法也没有执行力，只能浑浑噩噩地给别人打工，没有任何主动性；</p>
<p>中层的人，每天花费大量时间去学习方法和思维，但是执行力如果跟不上，也是白搭。</p>
<p>牛逼的人，一定是执行力超强的。他在学到那关键性的1%的信息之后，会立刻去实践，99%的时间和精力都用于执行了。</p>
<p>而自信心、激情、先进的思维、好点子、金钱、合作伙伴，都是在执行中产生的。</p>
<p>最后，我再说点狠的东西，适合白手起家的男性老板。</p>
<p>如果一个知识，或者一条新闻，它不能给你带来金钱，你就不要去学，不要去看。</p>
<p>比如看各类无营养的短视频，看汽车类型的文章，看历史、军事类的文章，看王S聪跟女网红撕逼，看哪里又发生灾难了……</p>
<p>这些垃圾信息通通不要去接触，看一眼都不行。</p>
<p>你只接触那些能让自己赚到更多钱的信息。</p>
<p>比如怎么通过知乎引流量，怎么通过公众号收钱，怎么通过抖音直播卖货，怎么通过朋友圈招更多代理……总之，你必须把精力放到学习能赚到钱的知识上，然后就是每天投入大量时间去实践，去试错。</p>
<p>另外，所有不能给你带来钱、带来业务的人，都不要接触，能拉黑尽量全部拉黑，包括亲戚和同学。</p>
<p>否则，今天穷鬼同学跟你聊“往日情谊”，明天穷鬼亲戚向你借钱，后天穷鬼同事叫你去参加婚礼……结果就是，你很重感情，但是你的宝贵时间和为数不多的试错资金，都被这些恶鬼榨干了。</p>
<p>你之所以痛苦，就是因为你干的事情跟赚钱无关。</p>
<p>这句话杀伤力非常大，大家可以细品。</p>
<p>人之所以会痛苦，就是因为他干的事情没有价值，跟赚钱无关。</p>
<p>赚不到钱，那么他就会从心底产生“浪费生命”的感觉。</p>
<p>所有的负面情绪，都跟“此时此刻自己没有在赚钱”这件事有关。</p>
<p>而当你全身心投入到赚钱上之后，你会发觉时间过得飞快，生活很有味道，浑身充满能量。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>学霸的学习方法</title>
    <url>/2021/03/06/%E5%AD%A6%E9%9C%B8%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>如果你有这种情况，那这篇回答就是为你准备的。答应我，耐心花 3 分钟把本文看完，然后去实践，你会遇到一个学霸一样的自己。</p>
<p>下面，我将从预习、听讲、课后提问、做题、考前复习以及参加比赛等多方面，详细讲解我的学习方法。</p>
<p>考前复习方法，无论是高考、考研还是平时的考试，都可以用到。</p>
<a id="more"></a>

<h2 id="一、预习"><a href="#一、预习" class="headerlink" title="一、预习"></a>一、预习</h2><p>在小学和中学时，老师就强调预习。然而，在大学里，能做到课前预习的同学非常少。他们不这么做的原因，大概是：花费很多时间，老师上课也会讲到。</p>
<p>我的实践证明，时间绝对花得值。预习一遍后听课跟直接听课，其心态是截然不同的。预习后听课，感觉一切尽在掌握之中，而不会手忙脚乱，否则一会听老师讲，一会又自己看书，慌乱中抓不住重点。</p>
<p>那么，我是如何预习的呢？</p>
<p>我会把上课要讲的章节，通读一遍。在通读一遍的过程中，会把重点概念和方法标出来，把不明白的地方标出来。如果课本上有例题，也会简单看一遍。但课本上的习题不必做。</p>
<p>重要的是，在预习中明白，这节课要学习什么，哪些是重点，哪些自己不太明白，从而形成对学习内容的宏观把握。</p>
<p>这个把握很重要，是后面学习的基础。</p>
<h2 id="二、听老师讲课"><a href="#二、听老师讲课" class="headerlink" title="二、听老师讲课"></a>二、听老师讲课</h2><p>经过预习，我就很明白上课的重点在哪里。就是解决预习时不太明白的问题。如此，上课的效率贼高。</p>
<p>通常，老师在讲课的过程中，会顺带把我的疑问讲明白。</p>
<p>你可能会有疑问，在老师讲其他内容的时候，我在干什么呢？</p>
<p>我也在听啊。只不过，这时候的我成了一个坐在台下的评委，审视着老师的讲课内容。他/她是怎么理解这个概念的，跟我理解的有没有出入？他/她又是怎么解题的，思路对不对，有没有更好的解法？身份的转变，真的是一时试一时爽，一直试一直爽。</p>
<h2 id="三、课后提问"><a href="#三、课后提问" class="headerlink" title="三、课后提问"></a>三、课后提问</h2><p>难免有几个问题，预习时没有搞明白，上课时老师也没有讲到。</p>
<p>如果有这种情况出现，一定要抓住刚下课的老师，别让他/她跑了！</p>
<p>干嘛？问他/她问题。</p>
<p>千万不要害羞。就我一个人向老师提问，不就暴露了吗？不要有这种想法啊。你向没提问的同学提问，可能他/她也答不上来。至于他们为什么不提问，原因之一是他们没有问题（没有细致地思考）。</p>
<p>提问的时候，要虚心向老师请教。把自己不明白的地方，跟老师详细地说明，以求得他/她的解答或建议。</p>
<p>做完这 3 步，就已经把所有的知识点过了一遍，而且没有盲区了。能看到这里的同学，都是有学霸潜力的 重磅的还在后面，我们继续。</p>
<h2 id="四、做题"><a href="#四、做题" class="headerlink" title="四、做题"></a>四、做题</h2><p>大部分人对做题是有偏见的。通常，我们认为它是任务，甚至认为它就是学习中最大的绊脚石。</p>
<p>实际上，它的作用非常大。做题可以让你知道什么是你知道的，什么是你不知道的。通过做题，你可以快速而客观地发现知识漏洞。</p>
<p>我是怎么做题的呢？</p>
<p>老师布置的作业是肯定要做的。<br>如果你够细心，你会发现，有时老师布置的作业不会覆盖所有知识点。这时，我会在书上的课后习题中找相关题目来做。<br>对于课后习题中的其他题目，我通常会过一遍。这个过一遍，就是做一遍并给出结果，但是形式可能很简单。比如写个公式再加个结果，而不是长篇大论。<br>做题的过程中不要翻书找答案。自己努力去想如何解决，有什么方法能用上。做完题目后，再去翻书找答案，并确定自己的知识盲区。</p>
<p>关于做题，我要强调一点，一定要把解题重点和结果落到纸上，而不是简单地判断自己会还是不会。自己脑袋中想的跟实际能到做的，有时真的是差了十万八千里。</p>
<h2 id="五、考前复习"><a href="#五、考前复习" class="headerlink" title="五、考前复习"></a>五、考前复习</h2><p>我的复习办法比较「非主流」。我不会把一本书反复读好几遍，但我的复习办法成效显著。</p>
<p>我把它分为 4 个小步骤。</p>
<ol>
<li><p>回忆<br>我会把一本书放在旁边。努力回忆这门课程的内容，能回忆多少是多少，把它们简单地记在纸上。这个过程不会花很多时间，最多一个小时就能搞定。</p>
</li>
<li><p>看一遍书<br>然后，我会从头看一遍书。这次看书的目的有三个：一是确认自己能回忆起来的知识点是否正确无误；二是摸清楚自己记不起来的知识点是哪些；三是做一个索引。这个索引用处非常大，以至于它成了我复习方法的核心。</p>
</li>
<li><p>做索引<br>拿一张新纸。对于每个知识点，无论是否记得起来，都用关键词简单地记下。然后，在每个关键词的后面标注页码。标注页码有什么用呢？我后面说。</p>
</li>
</ol>
<p>标注完页码后，就是下面这个样子。大学里的书已经不知去向，只能用我最近读的书说明一下。</p>
<p>我看谁敢说我字丑，哼！</p>
<p>太难了，被说字丑，还不止一个人…这有打印版的，呐<br>之后，用不同的记号，把记得起来的知识点和记不起来的都标记出来。</p>
<ol start="4">
<li>多次回忆<br>对着关键词回忆知识点，至少回忆两次，特别是那些没记住的。如果某个知识点在两次中都能回忆起来，那么可以说是记住了。如果任何一次记不起来，那么，快去根据页码查书并理解记忆，直至连续两次都能回忆起来。</li>
</ol>
<p>至此，你已经掌握我复习方法的精髓！</p>
<p>还有一点需要说明的是，回忆过程必须过夜。就是说，两次回忆中间要有一次睡眠。别问我是怎么知道的。</p>
<p>到这里，就真正地把书上内容学到手了，老师怎么出题都不怕！</p>
<h2 id="六、参加比赛"><a href="#六、参加比赛" class="headerlink" title="六、参加比赛"></a>六、参加比赛</h2><p>如果只是看书和做题，学习未免枯燥了些。在看书和做题之余，我还会参加各种学科竞赛。我参加过的比赛有：大学生物理竞赛、学校组织的数学竞赛（关于高数）、结构设计比赛（估计你要猜到我的专业了）等。</p>
<p>在这些比赛中，不仅活学活用了学到的知识，还能认识一些朋友，但我更看重比赛对知识的应用。</p>
<p>最实际的收获是，因为物理竞赛得奖，那学期的大学物理课程得了满分。对了，另一个学期的大学物理课程需要考试，得了 99。</p>
<h2 id="七、饮食和运动"><a href="#七、饮食和运动" class="headerlink" title="七、饮食和运动"></a>七、饮食和运动</h2><p>有一些同学通过私信或者评论咨询我，你这个学霸平时吃的什么，肯定很讲究吧？你平时锻炼吗，有什么锻炼方法可以推荐下？</p>
<p>好吧，你们确实问到了重要问题。毕竟，「人是铁，饭是钢」，「身体是革命的本钱」。不吃好，不搞好身体，怎么有精力去专心学习呢？</p>
<p>通常，食堂提供的饭菜已经够我们的基本需要，所以我一般就去食堂，点外卖的情况比较少。但是，在食堂不是一直开着，有时候饿了却不在饭点，特别是下午四点左右，晚上 11 点左右，真是难受。我在另一篇如何进入状态的文章里有写到，饥肠辘辘会阻碍我们专注的状态。</p>
<p>所以，这个时候我会吃一点零食，特别是五谷杂粮。我吃的比较多的是这个黑芝麻核桃粉，毕竟学霸也担心自己的发际线。</p>
<p>​<br>便宜实在，一大罐能喝一个月，平均一天两块钱左右，价钱对我们学生党是 OK 的。关键是，黑芝麻含量比较高，而且不含蔗糖，热量低，比较适合我这个爱健身的人。</p>
<p>对于健身，我的想法可能跟你不同。大二大三那会，我开始去健身房，希望借助器械，增长自己的肌肉。不可否认，肌肉线条确实越来越明显。但是每天去健身房 1-2 小时，时间上是来不了的，而且健身房会员卡费用也不低。</p>
<p>又想锻炼身体，增加一点肌肉线条，又想不花费那么多时间和费用，怎么办？好在，我找到一个比较好的健身方法，无器械健身。每天跟着书里的步骤练习深蹲、俯卧撑、倒立撑、腿举等，现在小有成效，六块腹肌隐约可见（让我嘚瑟一会儿）。关键是，随时随地可以练起来，不用器械，每次花半个小时就好。如果你也想试试，推荐保罗的《囚徒健身》。这是保罗在监狱中学会的一套古老健身法，所以有「囚徒」两个字。</p>
<p>​</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>读到这里，你会发现，我好像也没用什么奇技淫巧。确实，我不过是把别人不屑于用的方法和技巧用到极致，并加点创新。（哎？脸呢）</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures20210301150618.png" alt="20210301150618"></p>
</div>

<p>电影《无双》剧照<br>所以，相信你自己，你一样也可以做到。你所缺的可能只是，静下心，开始做。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>实例38_Python调用人工智能识别表格</title>
    <url>/2022/01/04/%E5%AE%9E%E4%BE%8B38-Python%E8%B0%83%E7%94%A8%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%86%E5%88%AB%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests  # 用于HTTP请求</span><br><span class="line">import time  # 时间模块</span><br><span class="line">from aip import AipOcr  # 导入AipOcr模块，用于做文字识别</span><br><span class="line">import os</span><br><span class="line">work_path &#x3D; r&quot;D:\BaiduNetdiskDownload\PythonOffice\实例38_Python调用人工智能识别表格\图片&quot;</span><br><span class="line">pictures &#x3D; []  # 存储文件夹内所有文件的路径（包括子目录内的文件）</span><br><span class="line">for root, dirs, files in os.walk(work_path):</span><br><span class="line">    path &#x3D; [os.path.join(root, name) for name in files]</span><br><span class="line">    pictures.extend(path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">APP_ID &#x3D; &#39;24608598&#39;</span><br><span class="line">API_KEY &#x3D; &#39;kAHxRGWszGl95maX0GgIKpGC&#39;</span><br><span class="line">SECRET_KEY &#x3D; &#39;NA1or974XAPSCgo7SlmMoYBzzZKhgoGM&#39;</span><br><span class="line">client &#x3D; AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"># 提交识别请求，并储存所有请求ID</span><br><span class="line">for picture in pictures:</span><br><span class="line">    pic &#x3D; open(picture, &#39;rb&#39;)  # 以二进制方式打开图片</span><br><span class="line">    img &#x3D; pic.read()  # 读取</span><br><span class="line">    table &#x3D; client.tableRecognitionAsync(img)  # 调用表格识别模块</span><br><span class="line">    request_id &#x3D; table[&#39;result&#39;][0][&#39;request_id&#39;]</span><br><span class="line"></span><br><span class="line">    # 判断识别是否完成，直到完成才根据请求ID获取Excel下载路径</span><br><span class="line">    result &#x3D; client.getTableRecognitionResult(request_id)  # 通过ID获取识别结果</span><br><span class="line">    while result[&#39;result&#39;][&#39;ret_msg&#39;] !&#x3D; &#39;已完成&#39;:  # 如果状态是“已完成”，才能获取下载地址</span><br><span class="line">        time.sleep(2)  # 暂停2秒再刷新</span><br><span class="line">        result &#x3D; client.getTableRecognitionResult(request_id)  # 持续刷新，直到满足条件</span><br><span class="line"></span><br><span class="line">    download_path &#x3D; result[&#39;result&#39;][&#39;result_data&#39;]</span><br><span class="line"></span><br><span class="line">    # 下载并将Excel文件名设为图片名</span><br><span class="line">    excel_name &#x3D; picture.split(&quot;.&quot;)[0] + &quot;.xls&quot;  # 让excel文件的名字与图片相同</span><br><span class="line">    excel &#x3D; requests.get(download_path)  # 抓取下载链接</span><br><span class="line">    file &#x3D; open(excel_name, &#39;wb&#39;)  # 新建excel文件</span><br><span class="line">    file.write(excel.content)  # 写入excel文件并保存</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>将本地项目上传到Github</title>
    <url>/2021/02/14/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u014135752/article/details/79951802">本文来源</a></p>
<p>首先你需要一个 github 账号，所有还没有的话先去注册吧！</p>
<p><a href="https://github.com/">https://github.com/</a></p>
<p>我们使用 git 需要先安装 git 工具，这里给出下载地址，下载后一路直接安装即可：</p>
<p><a href="https://git-for-windows.github.io/">https://git-for-windows.github.io/</a></p>
<ol>
<li>进入 Github 首页，点击 New repository 新建一个项目</li>
</ol>
<a id="more"></a>

<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160444.png" alt="20210213160444"></p>
</div>

<ol start="2">
<li>填写相应信息后点击 create 即可 </li>
</ol>
<p>Repository name: 仓库名称</p>
<p>Description (可选): 仓库描述介绍</p>
<p>Public, Private : 仓库权限（公开共享，私有或指定合作者）</p>
<p>Initialize this repository with a README: 添加一个 README.md</p>
<p>gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore</p>
<p>license: 证书类型，对应生成文件 LICENSE</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160533.png" alt="20210213160533"></p>
</div>

<ol start="3">
<li>点击 Clone or dowload 会出现一个地址，copy 这个地址备用。</li>
</ol>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160640.png" alt="20210213160640"></p>
</div>

<ol start="4">
<li>接下来就到本地操作了，首先右键你的项目，如果你之前安装 git 成功的话，右键会出现两个新选项，分别为 Git Gui Here,Git Bash Here, 这里我们选择 Git Bash Here，进入如下界面，Test_Bluetooth 即为我的项目名。</li>
</ol>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160729.png" alt="20210213160729"></p>
</div>

<ol start="5">
<li>接下来输入如下代码（关键步骤），把 github 上面的仓库克隆到本地</li>
</ol>
<p>git clone <a href="https://github.com/CKTim/BlueTooth.git%EF%BC%88https://github.com/CKTim/BlueTooth.git">https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git</a> 替换成你之前复制的地址）</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160753.png" alt="20210213160753"></p>
</div>

<ol start="6">
<li>这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你 github 上面的项目名，如图我多出了个 Test 文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下</li>
</ol>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160827.png" alt="20210213160827"></p>
</div>

<ol start="7">
<li>接着继续输入命令 cd Test，进入 Test 文件夹</li>
</ol>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160852.png" alt="20210213160852"></p>
</div>

<ol start="8">
<li>接下来依次输入以下代码即可完成其他剩余操作：</li>
</ol>
<p>git add .        （注：别忘记后面的.，此操作是把 Test 文件夹下面的文件都添加进来）</p>
<p>git commit  -m  ” 提交信息”  （注：“提交信息” 里面换成你需要，如 “first commit”）</p>
<p>git push -u origin master   （注：此操作目的是把本地仓库 push 到 github 上面，此步骤需要你输入帐号和密码）</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213161016.png" alt="20210213161016"></p>
</div>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>打开文本文件后读取方式及行后显示控制</title>
    <url>/2021/08/29/%E6%89%93%E5%BC%80%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%90%8E%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F%E5%8F%8A%E8%A1%8C%E5%90%8E%E6%98%BE%E7%A4%BA%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="python-逐行读取文件内容的三种方法"><a href="#python-逐行读取文件内容的三种方法" class="headerlink" title="python 逐行读取文件内容的三种方法"></a>python 逐行读取文件内容的三种方法</h2><p>一、使用 open 打开文件后一定要记得调用文件对象的 close () 方法。比如可以用 try/finally 语句来确保最后能关闭文件。</p>
<p>二、需要导入 import os</p>
<p>三、下面是逐行读取文件内容的三种方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、第一种方法：</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\test.txt&quot;</span>)               <span class="comment"># 返回一个文件对象 </span></span><br><span class="line">line = f.readline()               <span class="comment"># 调用文件的 readline()方法    </span></span><br><span class="line"><span class="keyword">while</span> line:</span><br><span class="line">    print(line,end=<span class="string">&#x27;&#x27;</span>)      <span class="comment"># 后面跟 &#x27;,&#x27; 将忽略换行符</span></span><br><span class="line">    line=f.readlines()</span><br><span class="line">    print(line)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<pre><code>每晚陪伴你
[&#39;時光再慢\n&#39;, &#39;相聚再久\n&#39;, &#39;總得散\n&#39;, &#39;幾十年後\n&#39;, &#39;當我離開人間\n&#39;, &#39;塵歸塵\n&#39;, &#39;土歸土&#39;]
[&#39;時光再慢\n&#39;, &#39;相聚再久\n&#39;, &#39;總得散\n&#39;, &#39;幾十年後\n&#39;, &#39;當我離開人間\n&#39;, &#39;塵歸塵\n&#39;, &#39;土歸土&#39;][]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、第二种方法：</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\test.txt&quot;</span>): </span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>
<pre><code>每晚陪伴你

時光再慢

相聚再久

總得散

幾十年後

當我離開人間

塵歸塵

土歸土
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3、第三种方法：</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) </span><br><span class="line">lines = f.readlines()      <span class="comment">#读取全部内容 ，并以列表方式返回</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    print(line)  </span><br></pre></td></tr></table></figure>
<pre><code>每晚陪伴你

時光再慢

相聚再久

總得散

幾十年後

當我離開人間

塵歸塵

土歸土
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 四、一次性读取整个文件内容：</span></span><br><span class="line">file_object = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    all_the_text = file_object.read()</span><br><span class="line">    print(all_the_text)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    file_object.close()</span><br></pre></td></tr></table></figure>
<pre><code>每晚陪伴你
時光再慢
相聚再久
總得散
幾十年後
當我離開人間
塵歸塵
土歸土
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python 读取文件，如何去掉换行符 &quot;\n&quot;_</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\test.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\test.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read().splitlines()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\win\Desktop\test.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        line=line.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure>
<pre><code>[&#39;每晚陪伴你\n&#39;, &#39;時光再慢\n&#39;, &#39;相聚再久\n&#39;, &#39;總得散\n&#39;, &#39;幾十年後\n&#39;, &#39;當我離開人間\n&#39;, &#39;塵歸塵\n&#39;, &#39;土歸土&#39;]
[&#39;每晚陪伴你&#39;, &#39;時光再慢&#39;, &#39;相聚再久&#39;, &#39;總得散&#39;, &#39;幾十年後&#39;, &#39;當我離開人間&#39;, &#39;塵歸塵&#39;, &#39;土歸土&#39;]
每晚陪伴你
時光再慢
相聚再久
總得散
幾十年後
當我離開人間
塵歸塵
土歸土
</code></pre>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>放空自己，好运就会成为常态</title>
    <url>/2021/08/24/%E6%94%BE%E7%A9%BA%E8%87%AA%E5%B7%B1%EF%BC%8C%E5%A5%BD%E8%BF%90%E5%B0%B1%E4%BC%9A%E6%88%90%E4%B8%BA%E5%B8%B8%E6%80%81/</url>
    <content><![CDATA[<p>我的回答是，我每天必须睡够7-8小时，而且下午会锻炼半小时，然后每天至少也会写作1小时。</p>
<p>当然，想要输出1000字的文章，还需要摄入10000字的信息。</p>
<p>其余的时间，要么在搞流量，要么在收钱，要么就是在组织合作伙伴写作、搞流量和收钱。</p>
<p>至于看新闻、看综艺、刷朋友圈、跟朋友圈聚会、社交之类的事情，我早就不参与了，因为实在是提不起兴趣。</p>
<p>然后有人说，这样会没有感情，没有朋友的。</p>
<p>我想说，我的几个朋友都是十年以上的老朋友，一起x过x、一起x过x那种。其余的所有人我都看做是利益关系，不掺杂感情，我也不结交新朋友。</p>
<p>另外，我从来不羡慕朋友多的人。</p>
<p>在这个烟换烟、茶换茶的社会，如果你还觉得你朋友非常多，那说明你这个人对“朋友”二字多少有点误解。</p>
<p>至于感情，无论男人怎么嘴上说的多么好听，品德多么高尚，他本质上需要的是食物和性。</p>
<p>因为雄性动物的本能就是，在时间和空间维度，把jing子传播的越广越好。</p>
<p>从10岁到100岁，他一直是蠢蠢欲动的，看到年轻漂亮的女人就会有感觉，有需求。</p>
<p>但是女性不一样，很多人到25、30岁才能真正品味到xxx的美妙，而大部分女性到49岁就绝经了。</p>
<p>所以，男人和女人对于感情的理解自然不一样，也没法一起讨论。</p>
<p>另外，没钱的男人也根本没资格谈感情，没钱连狗都不理你，何况女人。</p>
<p>我之前说过，男人天生就是比女人贱的，比如同样是成年人，出去办事，你如果是女人的话，别人看你挺不容易的，还有点姿色，都会照顾一下。</p>
<p>如果是个男人，开的车也破，穿的也寒酸，根本没人正眼看你，被呼来喝去的概率倒是很大。</p>
<p>所以说，男人没有任何退路，只有奋斗搞钱这一条出路。</p>
<p>千万不要相信那些蠢货说的：不要只顾着赚钱，你看人家那个网红照样拒绝了王S聪，有钱就了不起啊？</p>
<p>但是，大家没看到的是，还有999个女网红没有拒绝王S聪。这才是大概率事件。</p>
<p>当然，我不是让大家通过赚钱去买感情和性，而是说，你没钱的话，压根就别考虑这件事了。故事都是他们的，你就做个旁观者也挺好的。</p>
<p>关于赚钱，很多人经常跟我说，自己时而相信这个，时而相信那个，特别迷茫。浑浑噩噩到了30岁，仍然一事无成。</p>
<p>对于这种人，他们身上有两个致命的问题：</p>
<p>①该做的事你不做，天天想着你喜欢做的事。但是喜欢做的事又养不活你。比如女人追剧和综艺，男人刷美女视频和汽车视频。</p>
<p>②找不到你擅长做的事，一辈子做着得过且过的事。比如不想做这份工作，但是有房贷车贷，没办法辞职，更加不敢做新的尝试。（有一部分傻逼是因为自己的试错资金被垃圾朋友和父母榨干了）</p>
<p>其实这些人都是在挥霍自己宝贵的财富，挥霍自己的时间和金钱。</p>
<p>时间就是生命，如果你的时间和注意力被垃圾人掠夺了，他就是在变相谋杀你，你的健康、财运、幸福感，都会越来越差。</p>
<p>而金钱，如果你给了错的人，却没有索要等价的回报，那么等别人把你金钱掠夺光了，人家转身就跑了。</p>
<p>想要不被掠夺，想要拥有独立思考的能力，你需要做到两点：放空和聚焦。</p>
<p>有穷鬼同事请你吃饭，不要去，把时间空出来。</p>
<p>有穷鬼朋友找你聊天，别搭理他，因为他在占用你的时间和思维。</p>
<p>有人送你垃圾礼物，不要收，因为它会占用你房子的空间。你抬眼看到它，潜意识里就会想到这个东西和背后的人，心里也会一直装着这个东西和关联的人。</p>
<p>有人诱导你看文章，刷短视频，不要去看，不要去刷，否则你的大脑会被他们所掌控。</p>
<p>如果你来者不拒，碰到东西就往家里带，碰到吸引人的文章就要点开看，碰到朋友来掠夺你的时间你就把时间拱手相让，那么你的家里、心里、大脑里、人生时空里，都被别人装满了垃圾。</p>
<p>有的人一开口我就知道他的脑子里已经塞满了大粪，无可救药。</p>
<p>一旦你的时间、空间、大脑全部放空之后，你就可以开始专注做事情了。</p>
<p>专注的好处，就是你花很小的精力就可以弄懂常识。</p>
<p>再多花一点精力，就会发现规律。</p>
<p>如果能坚持每天都专注两小时的话，那么好运将会成为你的常态。</p>
<p>比如，有些人经常会问我，为什么人家的知乎回答能上热门，人家的抖音直播时有几万人观看？</p>
<p>我说，你先去调查一下，人家每天要写多少字，发多少条短视频，直播在线几小时。这样的工作他们重复几年了。</p>
<p>最后你会发现，所有的好运，其实都是创造出来的，都是打拼出来的，都是修炼出来的，都是放空出来的，都是专注出来的。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析之pandas</title>
    <url>/2021/01/28/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas/</url>
    <content><![CDATA[<p>&emsp;&emsp;最近开始学习使用Python的Pandas库处理工作中的一些重复性劳动，发现它真是个好东西，用起来真是太高效了。由于一直都处于零散的学习状态，现在对这些知识进行一个简单的总结，以便于形成知识体系。个人认为知识只有形成了体系才能灵活的应用。</p>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>series 类似一维数组，他由一组数据及数据对应的标签组成。说是类似数组，但其实和数组是有区别的，主要是由于 Series 的索引的存在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pandas import Series, DataFrame</span><br><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure>
<p><code>obj = Series([1,2,3,4])# 创建一个Series对象，如果不声明索引，则默认的索引是0到N-1(N是数据的长度)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj.index 代表Series对象的索引，我们可以手动声明索引</span><br><span class="line">obj.values 代表Series对象的值，此时才相当于数组，即为python中的list</span><br></pre></td></tr></table></figure>
<p>我们可以手动声明 series 的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj2&#x3D; Series([1,2,3,4], index&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line">obj2[&#39;c&#39;]#通过索引获取元素的值</span><br></pre></td></tr></table></figure>
<p>判断是否缺失数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj2.isnull() #使用series对象的方法，返回series，值为True或False</span><br><span class="line">pd.isnull(obj2) # 使用pandas的方法</span><br><span class="line">pd.notnull(obj2)</span><br></pre></td></tr></table></figure>
<p>series 对象本身及其索引都有一个 name 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdata &#x3D; &#123;&#39;ohino&#39;: 3500, &#39;texas&#39;: 7100, &#39;utah&#39;: 500&#125;</span><br><span class="line">obj &#x3D; Series(sdata)</span><br><span class="line">obj.name &#x3D; &#39;population&#39;</span><br><span class="line">obj.index.name &#x3D; &#39;state&#39;</span><br></pre></td></tr></table></figure>
<h2 id="Series-总结"><a href="#Series-总结" class="headerlink" title="Series 总结"></a>Series 总结</h2><p>Series 可以看成是一个定长的有序字典，可以认为字典的 key 值即为对应的 Series 的值的索引。</p>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>Dataframe 是一种表格型的数据结构，可以看成 Series 组成的字典，最常用的构建方法是传入一个由登场列表或者 numpy 数组组成的字典。DataFrame 会自动加上索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#x3D; &#123;‘state’: [&#39;ohio&#39;,&#39;ohio&#39;,&#39;ohio&#39;], &#39;year&#39;: [2001, 2002, 2003], &#39;pop&#39;: [1.5, 1.6, 1.7]&#125;</span><br><span class="line">frame &#x3D; DataFrame(data, columns&#x3D;[&#39;year&#39;, &#39;state&#39;,&#39;pop&#39;])</span><br></pre></td></tr></table></figure>
<p>获取元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame[&#39;state&#39;]#获取Series，返回的Series与原来的DataFrame有相同的索引。而且其name属性已经被设置为该columns的值，即为state</span><br><span class="line">frame.state # 也可以使用属性的方式获取series</span><br></pre></td></tr></table></figure>
<p>当需要获取一行元素时，使用位置或者名称的方式进行获取。<br><code>frame.ix[2] #获取第三行数据，此时仍为series，只是columns的值变成了索引</code></p>
<p>另一种常见的数据形式是嵌套字典，外层的字典的键作为列，内层字典的键作为行索引，内层字典的键会被合并，排序，形成最终的索引，也可以指定索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame.values #以二维数组的方式返回DataFrame中的数据</span><br><span class="line">frame.index.name #设置索引的名字</span><br><span class="line">frame.columns.name #设置columns的名字</span><br></pre></td></tr></table></figure>
<h2 id="DataFrame-切片"><a href="#DataFrame-切片" class="headerlink" title="DataFrame 切片"></a>DataFrame 切片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj[val]# 选取DataFrame的单个列或者一组列</span><br><span class="line">obj.ix[val] # 选取DataFrame的单个行或者一组行</span><br><span class="line">obj.ix[:,val] #选取单个列或者列子集</span><br><span class="line">obj.ix[val1, val2] #同时选取行和列</span><br></pre></td></tr></table></figure>
<h2 id="DataFrame-和-Series-之间的运算"><a href="#DataFrame-和-Series-之间的运算" class="headerlink" title="DataFrame 和 Series 之间的运算"></a>DataFrame 和 Series 之间的运算</h2><p>默认情况下，DataFrame 和 Series 之间的算术运算会将 Series 的索引匹配到 DataFrame 的列，然后沿着行一直向下传播</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame &#x3D; DataFrame(np.arange(12.).reshape((4,3)), columns&#x3D;list(&#39;bde&#39;), index&#x3D;[&#39;Utah&#39;, &#39;Ohio&#39;, &#39;Texas&#39;, &#39;Oregon&#39;])</span><br><span class="line">series &#x3D; frame.ix[0]</span><br></pre></td></tr></table></figure>
<p><code>frame - series = DataFrame(&#123;&#39;b&#39;:[0,3,6,9],&#39;d&#39;:[0,3,6,9],&#39;e&#39;:[0,3,6,9]&#125;, index=[&#39;Utah&#39;, &#39;Ohio&#39;, &#39;Texas&#39;, &#39;Oregon&#39;])</code></p>
<p>是因为逐行传播的原因，frame 每一行的元素都会减去 series 的对应值。</p>
<p>如果某个索引值在 DataFrame 的列或者 Series 的索引中找不到，则参与运算的两个对象就会被重新索引形成并集</p>
<p><a href="http://www.airghc.top/2017/04/27/python/">转自</a></p>
<p>这位兄弟的总结太好了，谢谢。我只是来学习的，学习用Markdown语法写作，真是太好了。</p>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理之anaconda介绍</title>
    <url>/2021/03/06/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8Banaconda%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="1-Jupyter-notebook-是什么？"><a href="#1-Jupyter-notebook-是什么？" class="headerlink" title="1.Jupyter notebook 是什么？"></a>1.Jupyter notebook 是什么？</h3><p>&emsp;&emsp;在没有 notebook 之前，在 IT 领域工作的我都是这样工作的：在普通的 Python shell 或者在 IDE（集成开发环境）如 Pycharm 中写代码，然后在 word 中写文档来说明你的项目。这个过程很反锁，通常是写完代码，再写文档的时候我还的重头回顾一遍代码。最蛋疼的地方在于，有些数据分析的中间结果，我还的重新跑代码，然后把结果弄到文档里给客户看。有了 notebook 之后，我的世界突然美好了许多，因为 notebook 可以直接在代码旁写出叙述性文档，而不是另外编写单独的文档。也就是它可以能将代码、文档等这一切集中到一处，让用户一目了然。</p>
<a id="more"></a>

<blockquote>
<p>Jupyter notebook（<a href="http://jupyter.org/%EF%BC%89">http://jupyter.org/）</a> 是一种 Web 应用，能让用户将说明文本、数学方程、代码和可视化内容全部组合到一个易于共享的文档中。</p>
</blockquote>
<p>Jupyter Notebook 已迅速成为数据分析，机器学习的必备工具。因为它可以让数据分析师集中精力向用户解释整个分析过程。</p>
<p>Jupyter 这个名字是它要服务的三种语言的缩写：Julia，PYThon 和 R，这个名字与“木星（jupiter）”谐音。</p>
<p>前面说过 Anaconda 是一个 python 数据科学百宝箱，所以它的作用就是燃爆数据科学，让小白也可以轻松玩数据。</p>
<p>你可以利用 Anaconda 研究数据处理、数据建模、机器学习、神经网络、自然语言处理、可视化展示、教学等等。既能一人独秀，也可以团队作战。</p>
<p>当然这些都是依托于 python 的，首先你得会撸代码。</p>
<p>PS：对于小白来说自学也不是件容易的事，需要花相当的时间去适应 python 的语法逻辑，而且要坚持亲手敲代码，不断练习。</p>
<p>如果对自己没有自信，也可以考虑看编程课程，跟着老师的节奏去学习，能比较快地掌握 python 语法体系，也能得到充分的案例练习。</p>
<p>神奇的 conda<br>说说 conda，这是 Anaconda 的杀手锏。</p>
<p>Conda 是一个开源、跨平台和语言无关的软件包管理和系统管理系统，通过 Conda 可安装、升级和升级软件包依赖。Conda 为 Python 程序创造，但是它可以打包、分发任意语言编写的软件（例如 R 语言）和包含多语言的项目。<br>conda 和 pip 都可以管理 python 库，但最大的不同在于 conda 是跨平台且不限语言的，而且可以独自创建虚拟环境。因为 conda 立足于数据科学生态，不像 pip 可以安装几乎所有的 python 库（来自 pypl），conda 只能安装 anaconda 里支持的数据科学库（600 多个）。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures20210304100654.png" alt="20210304100654"></p>
</div>

<p>主要的数据科学内置库包括 pandas、numpy、matplotlib、jupyter、scipy、ipython、nltk、notebook、sikit-learn、seaborn、xlrd、xlwt……</p>
<p>一般把这些数据科学库分为四大类：基础库（jupyter、pandas、numpy、scipy），机器学习库（keras、tensorflow、pytorch、sikit-learn、nltk），可视化库（matplotlib、seaborn、plotly）、拓展计算库（numba、dask、pyspark）</p>
<p>Anaconda 的缺点</p>
<p>Anaconda 的优点也是它的缺点，功能太齐全就显得很臃肿，一个安装包快 500M，所以不少人去拥抱 miniconda 了。但无论如何，Anaconda 都是 python 数据科学最好的伙伴。</p>
<p>首先，作为一个 Python 初学者，你主要想分析下自己学习 Python 目标，比如你想学习 Python 的网络编程和 Web 编程， 下载 Anaconda 没什么用，Anaconda 可能唯一对你有用的，就是它自带了一个 Juypter notebook，让你可以在上面尝试敲一些 Python 代码。</p>
<p>当然，如果你想学习数据分析和机器学习，下载 Anaconda 就是一个不错的选择，因为它会帮你把数据科学和机器学习常用库都安装好，也不用看到一堆各种各样的库吓到了，Anaconda 的库也就那么几大类：</p>
<p>提供脚本开发编辑环境，Jupyter/Jupyterlab/….等等<br>提供数据分析的库 Numpy/pandas/Scipy/Numbia/DasK<br>提供数据图表展示的，Bokeh,matplotlib 等等<br>提供机器学习方面的，比如 sktlearn,theano,TensorFloww..等等</p>
<p>基本覆盖数据科学和机器学习方方面面，没必要一开始贪全贪多，全部都学习。一开始，不要被数据分析数据科学这样大名词吓到，实际上拿 EXCEL 统计销售额，做销售曲线图，也是“数据分析”，Python 相比 EXCEL 的优势, 也只是可以分析更大量的数据,有更多可用的统计函数,有更多可用图表(相比 EXCEL 自带的图表）而已，所以完全不要觉得恐惧。</p>
<p>Anaconda 的学习，建议先用 Jupyter 来入门 pandas 库，pandas 你可以理解为 Python 版本的 excel, excel 里的操作，Python 都有对应的代码相对应，一开始就专心学会如何 pandas 把你在 excel 会的操作都练一遍。</p>
<p>Pandas 的官方的 10 分钟教程作为入门就可以，仔细跟着这 10 分钟教程把 Pandas 基本操作练习下，</p>
<p>学习的过程中，要想想每一行代码，对应 excel 的操作是啥，这样就好理解了。比如 EXCEL 常见操作：</p>
<p>增加/删除一列<br>增加/删除一行<br>更新某个列行的值<br>过滤<br>根据某一列排序<br>建一个透视图<br>给 EXCEL 一个饼图/Bar 图<br>两个 EXCEL 表格关联<br>给 EXCEL 某一列求和/平均数/中位数等等</p>
<p>这个在 Jupyter notebook 反复练习下，不要贪快，慢慢练，多练几遍，练到完全熟记为止，可以随便那一个 EXCEL 来操练，用 EXCEL 做增改删关联绘图，加透视等等全部操作一遍，然后将其一步步的对应的 Pandas 用法也来一遍。逐步练到，别人做一个 EXCEL 操作，立刻就能关联到对应的 Pandas 操作，练到这种程度，数据分析基本就入门了。总之有不理解的地方，多和 EXCEL 的行，列，表格相关联，就比较容易理解，这块主要靠多练，练到行程肌肉记忆，敲 pandas 不用花太多脑子，手熟而已。</p>
<p>有了这个基础，处理一些较复杂的分析，比如对 Pandas 的表格数据做下傅立叶变换，那就去看下 Scipy 的傅立叶变换，要做一些线性，逻辑回归等等，再看看 Skt-learn, 循序渐进，你会发现原来那么多库，那么多方法也不过如此，并不复杂。</p>
<p>搞这块不要恐惧一些名词，特别数据基础不好的话，不要太恐惧大名词，一个大名词后面，对应的东西，等你自己代码跑一次，其实也很简单明了。<br>你的回答不对，知道你卖数据分析课的，但如果是自己不熟悉的领域，例如编程，好为人师是错的，jupyter 只是个 Python 库，任何 py 环境都可以装，anaconda 是管理包括 py 在内解释器语言环境的，二者没有任何独特的彼此关系，使用 jupyter 并不需要安装 anaconda。不要误导别人。</p>
<p>简单，别用 anaconda，miniconda 也别用。老老实实装 Python 官方就环境得了。</p>
<p>笑看楼上楼下扯淡，anaconda 相对原生 py 环境的优势不过是 conda 的包管理和环境管理两个功能。</p>
<p>conda 的包都是编译过的一些 windows 系统下没装编译器装不上的包使用 conda 可以装上。但第一，现在的 Python 环境支持不是五年十年前了，现在的官方包支持很好，就算装不上的也可以用 whl 包下载安装，而且 conda 的包不全只有流行的包才有，所以基本没什么用了。</p>
<p>第二个 conda 的环境管理，可以建不同版本的 py 子环境。你都装 conda 了肯定是搞数据科学人工智能的，这行当的项目和软件开发不一样，不需要一个项目建一个 py 子环境，都是共用系统 py 环境的。如果是搞开发的，创建子环境都用 virtualenv(pycharm 默认)。</p>
<p>总之 conda 的两大功能要是在五年前可能还有些用处，在 Python 发展日新月异的今天基本鸡肋了。他还有几大缺点难以忍受。</p>
<p>第一是 conda 的包基本都是第三方支持维护，官方只会维护 Python 官方的包，conda 的出毛病不管。例如 tensorflow。</p>
<p>第二 anaconda 真的很大，安装后上 g 了(Python 官方环境才几十 m)，随便用俩月目录就超过 10g，里面自带那些东西 90％以上你这辈子都用不到。用啥装啥不香吗。</p>
<p>第三 anaconda 的官方网站是经常被封，逢年过节就封，官方软件源则根本打不开，就算你切换了国内的清华源也卡的基本啥都装不上。Python 的国内源，豆瓣的，阿里的，又多又快，谁用谁知道。</p>
<p>anaconda 再好不过是个第三个发行版软件，资源和系统兼容性是比不上 Python 官方的。虽然号称能帮使用者减轻环境配置负担，你用了就知道他用着可比官方麻烦多了，虽然有个界面甭提多慢了，再说你都学编程了就用命令行装包吧点鼠标太丢人了。</p>
<p>我学 Python 开始就用的 anaconda，后来改成乞丐版的 miniconda，现在干脆换回原生 Python 环境。劝你别折腾，官方的就是普世的，最好。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式练习</title>
    <url>/2021/06/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># author : BJxo</span><br><span class="line"># date : 2021&#x2F;04&#x2F;30</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"># phone_number_regex &#x3D; re.compile(r&#39;(\(\d&#123;3&#125;\)) (\d&#123;3&#125;-\d&#123;3&#125;)&#39;)</span><br><span class="line"># mo &#x3D; phone_number_regex.search(&#39;My number is (415) 555-4242.&#39;)</span><br><span class="line"># print(&#39;Phone number found: &#39; + mo.group(1))</span><br><span class="line"># print(mo.groups())</span><br><span class="line"></span><br><span class="line"># bat_regex &#x3D; re.compile(r&#39;Bat(man|mobile|bat|copter)&#39;)</span><br><span class="line"># mo &#x3D; bat_regex.search(&#39;Batmobile lost a wheel&#39;)</span><br><span class="line"># print(mo.group())</span><br><span class="line"># print(mo.group(1))</span><br><span class="line"></span><br><span class="line"># &#39;?&#39; 在正则表达式内表示匹配 0 或 1 次，换句话说就是可选匹配，有就匹配，没有就不匹配。而 &#39;*&#39; 则表示匹配 0 次 或多次。</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">bat_regex1 &#x3D; re.compile(r&#39;Bat(wo)?man&#39;)</span><br><span class="line">mo1 &#x3D; bat_regex1.search(&#39;The Adventures of Batman&#39;)</span><br><span class="line">print(mo1.group())</span><br><span class="line">mo2 &#x3D; bat_regex1.search(&#39;The Adventures of Batwoman&#39;)</span><br><span class="line">print(mo2.group())</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"># phone_regex &#x3D; re.compile(r&#39;(\d&#123;3&#125;-)?(\d&#123;3&#125;-\d&#123;4&#125;)&#39;)</span><br><span class="line"># mo1 &#x3D; phone_regex.search(&#39;My number is 415-555-4242&#39;)</span><br><span class="line"># print(mo1.group())</span><br><span class="line"># mo2 &#x3D; phone_regex.search(&#39;My number is 555-4242&#39;)</span><br><span class="line"># print(mo2.group())</span><br><span class="line"></span><br><span class="line"># 用星号匹配 0 次或 多次</span><br><span class="line"># bat_regex &#x3D; re.compile(r&#39;Bat(wo)*man&#39;)</span><br><span class="line"># mo1 &#x3D; bat_regex.search(&#39;The Adventures of Batman&#39;)</span><br><span class="line"># print(mo1.group())</span><br><span class="line"></span><br><span class="line"># mo2 &#x3D; bat_regex.search(&#39;The Adventures of Batwoman&#39;)</span><br><span class="line"># print(mo2.group())</span><br><span class="line"># mo3 &#x3D; bat_regex.search(&#39;The Adventures of Batwowowowoman&#39;)</span><br><span class="line"># print(mo3.group())</span><br><span class="line"></span><br><span class="line"># 用 &#39;+&#39; 号匹配 1 次或 多次</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">bat_regex &#x3D; re.compile(r&#39;Bat(wo)+man&#39;)</span><br><span class="line">mo1 &#x3D; bat_regex.search(&#39;The Adventures of Batman&#39;)</span><br><span class="line">print(mo1 &#x3D;&#x3D; None)</span><br><span class="line"></span><br><span class="line">mo2 &#x3D; bat_regex.search(&#39;The Adventures of Batwoman&#39;)</span><br><span class="line">print(mo2.group())</span><br><span class="line">mo3 &#x3D; bat_regex.search(&#39;The Adventures of Batwowowowoman&#39;)</span><br><span class="line">print(mo3.group())</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"># 贪心和非贪心匹配</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">greedy_ha_regex &#x3D; re.compile(r&#39;(ha)&#123;3,5&#125;&#39;)</span><br><span class="line">mo1 &#x3D; greedy_ha_regex.search(&#39;hahahahahaha&#39;)</span><br><span class="line">print(mo1.group())</span><br><span class="line"></span><br><span class="line">greedy_ha_regex &#x3D; re.compile(r&#39;(ha)&#123;3,5&#125;?&#39;)</span><br><span class="line">mo2 &#x3D; greedy_ha_regex.search(&#39;hahahahahaha&#39;)</span><br><span class="line">print(mo2.group())</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"># findall() 方法 返回一组字符串，而 search 返回一个Match 对象，包含被查找字符串的‘第一次’匹配的文本</span><br><span class="line"></span><br><span class="line"># phone_number_regex &#x3D; re.compile(r&#39;\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;&#39;)</span><br><span class="line"># mo &#x3D; phone_number_regex.search(&#39;cell:415-555-9999 work:212-555-0000&#39;)</span><br><span class="line"># print(mo.group())  # 只返回‘第一次’匹配的文本</span><br><span class="line"></span><br><span class="line"># findall() 返回一个字符串列表</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">phone_number_regex &#x3D; re.compile(r&#39;\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;&#39;)  # has no groups</span><br><span class="line">mo &#x3D; phone_number_regex.findall(&#39;cell:415-555-9999 work:212-555-0000&#39;)</span><br><span class="line">print(mo)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"># phone_number_regex &#x3D; re.compile(r&#39;(\d&#123;3&#125;)-(\d&#123;3&#125;-\d&#123;4&#125;)&#39;)  # has groups</span><br><span class="line"># mo1 &#x3D; phone_number_regex.findall(&#39;cell:415-555-9999 work:212-555-0000&#39;)</span><br><span class="line"># print(mo1)</span><br><span class="line"></span><br><span class="line"># 建立自己的字符分类</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">vowel_regex &#x3D; re.compile(r&#39;[aeiouAEIOU]&#39;)</span><br><span class="line">print(vowel_regex.findall(&#39;Robocop eats baby food.ABY FOOD.&#39;))</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"># ^ 加在左方括号后 表示将得到‘非字符类’，即不在这个字符类中的所有字符</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">vowel_regex &#x3D; re.compile(r&#39;[^aeiouAEIOU]&#39;)</span><br><span class="line">print(vowel_regex.findall(&#39;Robocop eats baby food.ABY FOOD.&#39;))</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"># 插入字符和美元字符</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">begins_with_hello &#x3D; re.compile(r&#39;^hello&#39;)</span><br><span class="line">he &#x3D; begins_with_hello.search(&#39;hello world!&#39;)</span><br><span class="line">print(he)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"># begins_with_hello &#x3D; re.compile(r&#39;^hello&#39;)</span><br><span class="line"># he &#x3D; begins_with_hello.search(&#39;hello world!&#39;)</span><br><span class="line"># print(begins_with_hello.search(&#39;he said hello&#39;) &#x3D;&#x3D; None)</span><br><span class="line"></span><br><span class="line"># 正则表达式 r&#39;\d$&#39; 匹配以数字 0 到 9 结束的字符串</span><br><span class="line"></span><br><span class="line"># endwith_number &#x3D; re.compile(r&#39;\d$&#39;)</span><br><span class="line"># num &#x3D; endwith_number.search(&#39;Your number is 43&#39;)</span><br><span class="line"></span><br><span class="line"># print(num)</span><br><span class="line"></span><br><span class="line"># 正则表达式 r&#39;^\d$&#39; 匹配从开始到结束都是数字的字符串</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">whole_string_isnum &#x3D; re.compile(r&#39;^\d+$&#39;)</span><br><span class="line">print(whole_string_isnum.search(&#39;12345670&#39;))</span><br><span class="line">print(whole_string_isnum.search(&#39;1234xy5670&#39;) &#x3D;&#x3D; None)</span><br><span class="line">print(whole_string_isnum.search(&#39;12 345670&#39;) &#x3D;&#x3D; None)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line"># 通配符(.) 这个历害了，它匹配除了换行之外的所有字符</span><br><span class="line"></span><br><span class="line"># at_regex &#x3D; re.compile(r&#39;.at&#39;)</span><br><span class="line"># print(at_regex.findall(&#39;The cat in thd hat sat on the flat at.&#39;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 用 (.*) 匹配所有字符</span><br><span class="line"></span><br><span class="line">name_regex &#x3D; re.compile(r&#39;First Name:(.*) Last Name:(.*)&#39;)</span><br><span class="line">mo &#x3D; name_regex.search(&#39;First Name:Al Last Name:Sweigart&#39;)</span><br><span class="line">print(mo.group(1))</span><br><span class="line">print(mo.group(2))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>比较两个excel表格的不同</title>
    <url>/2022/01/04/%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAexcel%E8%A1%A8%E6%A0%BC%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import openpyxl</span><br><span class="line">from openpyxl.styles import PatternFill</span><br><span class="line">from openpyxl.styles import colors</span><br><span class="line">from openpyxl.styles import Font, Color</span><br><span class="line">import copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 读取excel文件</span><br><span class="line"># 括号中的字符串为你要比较的两个excel的路径，注意用“&#x2F;”</span><br><span class="line">wb_a &#x3D; openpyxl.load_workbook(r&quot;C:\Users\d\Desktop\1.xlsx&quot;)</span><br><span class="line">wb_b &#x3D; openpyxl.load_workbook(r&quot;C:\Users\d\Desktop\2.xlsx&quot;)</span><br><span class="line"># 定义一个方法来获取表格中某一列的内容，返回一个列表</span><br><span class="line"># 将每一列输出为一个列表（temp表示列的名字）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getIP(wb, temp):</span><br><span class="line">    sheet &#x3D; wb.active</span><br><span class="line">    ip &#x3D; []</span><br><span class="line">    for cellobj in sheet[temp]:</span><br><span class="line">        ip.append(cellobj.value)</span><br><span class="line">    return ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 想比较哪几列就输入那几列的名称</span><br><span class="line">list1 &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]</span><br><span class="line">list2 &#x3D; []  # 用于存每列不同的值</span><br><span class="line">differ1 &#x3D; &#123;&#125;  # 第一个文件中每列不同的列表组成字典</span><br><span class="line">differ2 &#x3D; &#123;&#125;  # 第二个文件中每列不同的列表组成字典</span><br><span class="line">for temp1 in list1:</span><br><span class="line">    # 获得ip列表</span><br><span class="line">    ip_a &#x3D; getIP(wb_a, temp1)</span><br><span class="line">    ip_b &#x3D; getIP(wb_b, temp1)</span><br><span class="line">    # 将两个列表转换成集合</span><br><span class="line">    aa &#x3D; set(ip_a)</span><br><span class="line">    bb &#x3D; set(ip_b)</span><br><span class="line">    # 找出两个列表的不同行，并转换成列表</span><br><span class="line">    difference &#x3D; list(aa ^ bb)</span><br><span class="line">    # 打印出列表中的元素</span><br><span class="line">    # 到这一步，两个表格中不同的数据已经被找出来了</span><br><span class="line">    # for i in difference:</span><br><span class="line">    #     print (i)</span><br><span class="line"></span><br><span class="line">    # 将不同行高亮显示</span><br><span class="line">    #print (&quot;开始第一张表&quot; + &quot;----&quot; *10)</span><br><span class="line">    del list2[0:]</span><br><span class="line">    a &#x3D; wb_a.active[temp1]</span><br><span class="line">    for cellobj in a:</span><br><span class="line">        if cellobj.value in difference:</span><br><span class="line">            #print (cellobj.value)</span><br><span class="line">            cellobj.font &#x3D; Font(color&#x3D;colors.BLACK, italic&#x3D;True, bold&#x3D;True)</span><br><span class="line">            cellobj.fill &#x3D; PatternFill(&quot;solid&quot;, fgColor&#x3D;&quot;DDDDDD&quot;)</span><br><span class="line">            list2.append(cellobj.value)</span><br><span class="line">    if list2 !&#x3D; []:</span><br><span class="line">        differ1[temp1] &#x3D; copy.deepcopy(list2)</span><br><span class="line">    #print (&quot;开始第二张表&quot; + &quot;----&quot; *10)</span><br><span class="line">    del list2[0:]</span><br><span class="line">    b &#x3D; wb_b.active[temp1]</span><br><span class="line">    for cellobj in b:</span><br><span class="line">        if cellobj.value in difference:</span><br><span class="line">            #print (cellobj.value)</span><br><span class="line">            cellobj.font &#x3D; Font(color&#x3D;colors.BLACK, italic&#x3D;True, bold&#x3D;True)</span><br><span class="line">            cellobj.fill &#x3D; PatternFill(&quot;solid&quot;, fgColor&#x3D;&quot;DDDDDD&quot;)</span><br><span class="line">            list2.append(cellobj.value)</span><br><span class="line">    if list2 !&#x3D; []:</span><br><span class="line">        differ2[temp1] &#x3D; copy.deepcopy(list2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(differ1.items())</span><br><span class="line">print(differ2.items())</span><br><span class="line">wb_a.save(r&quot;C:\Users\win\Desktop\a.xlsx&quot;)</span><br><span class="line">wb_b.save(r&quot;C:\Users\win\Desktop\b.xlsx&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>没有痛苦你就一无所获</title>
    <url>/2021/01/30/%E6%B2%A1%E6%9C%89%E7%97%9B%E8%8B%A6%E4%BD%A0%E5%B0%B1%E4%B8%80%E6%97%A0%E6%89%80%E8%8E%B7/</url>
    <content><![CDATA[<p>&emsp;&emsp;痛苦是人生不可避免的现实，成功的关键是接受痛苦并从中成长。痛苦的反面是什么？十之八九的人会回答“快乐”。错，真正的反面是“不痛”，也就是舒适。而舒适虽然很好，却不是真正意义上的快乐。穷其一生追求舒适的人最终会感到非常失望，如果一生竭力避免痛苦，你也就避开了最深层次的快乐。虽然每个人都尽力把生活中的痛苦最小化，现实仍然是痛苦不可避免。</p>
<p>&emsp;&emsp;任何事情都有起伏利弊，我们如果想有生之年有所成就，关键是不要排斥痛苦，而要学会如何理解和接受痛苦。痛苦是我们为快乐支付的代价，我们生活中的所有快乐，家庭和睦、事业有成、人生意义的追求，都需要付出艰苦努力来换取。我们经常所说的“痛苦”是一种实际意义上的“努力”：为身体健康付出的努力是痛苦的，为思考付出的努力是痛苦的，为建立和维持友好关系而努力是痛苦的。由此看出，尽管努力是痛苦的，想实现人生目标却离不开它，任何想无风无浪平静度过一生的人，都无法品味到真正意义的快乐。</p>
<p>&emsp;&emsp;真正的快乐离不开痛苦，这里有个例子：什么是你父母的最大快乐？是的，你。父母的最大痛苦是什么？回答同样是：你。父母的最大快乐同时也是他们的最大痛苦并非巧合，快乐越大，努力所需要的痛苦也越大。此外，我们实现目标过程中经历的痛苦越多，我们感受的成功喜悦也越多，换句话说：我们付出越多，也就越要珍惜。</p>
<p>&emsp;&emsp;追求舒适被定义为“颓废堕落”，整个社会以此为主要目标的时候，它就危险了，罗马帝国的坍塌就是由于这个原因，他们太舒适了。西方当前的很低出生率也是当代颓废的一种表现，年轻人为了自己的舒适甚至不顾及国家的前途，整个社会早早晚晚会自食其果。经常的情况是对痛苦的恐惧比痛苦本身还可怕，扎一下疫苗只需几秒钟，对那份疼痛的预期和想象却持续几个小时。害怕痛苦是最大的限制条件，你如果害怕旅行就哪儿都去不成。同样，如果害怕身体和精神上的痛苦，你就不会成长并有所成就，更不用说找到真理。</p>
<p>&emsp;&emsp;我们每个人都面对同一个选择：或是痛苦着努力着，或是忍受痛苦认为自己是懦夫不敢尝试。举个例子，不敢求职，你就避免了被拒绝的痛苦，一生也就成了轻言放弃的懦夫，而且这样的情绪会经常萦绕纠缠着你，挥之不去。事实上，痛苦经常是跨过去进入快乐世界的门槛，一个很好的例子就是治疗牙齿：钻开、充填需要一个小时，疼痛持续两个小时，但修补却可以防止牙的进一步恶化，未来多年里给了你吃东西的快乐。</p>
<p>&emsp;&emsp;最大也是最需要克服的恐惧就是害怕面对现实，有些人宁可活在幻觉里也不愿清醒地正视它。为什么？因为现实总是与我们习惯了的情况有所不同，意味着现存的生活之路必须有所改变，这是很痛苦的。所以我们选择逃避，不肯付出为达到人生目标和雄心壮志而必须付出的努力。我们都想伟大，都想改变世界，关键是并不总是想着要付出相应的努力，所以我们常常分心，刻意回避我们应该成为什么样的人和想要取得什么样成就这样的问题。面对无法回避的现实时我们更加痛苦，特别是感到再也无力做任何事情改变它的时候。所以要经常自问：“我在回避什么样的痛苦？”要尽力准确找出害怕什么，说明理由，可能发生的最糟糕情况是什么。为此，先列出没有痛苦的情况下你想要达到的目标，然后在每个旁边写下要想达到这些目标不可避免的痛苦，再写下是什么使得这些目标拥有价值。现在把两个栏目加以比较，如果某个目标真有价值，你马上就可以看出对痛苦的恐惧是如何阻碍你实现这个目标的，这就可以清楚说明你是多么心甘情愿付出痛苦的代价达到想要取得的目标了。</p>
<p>&emsp;&emsp;重要的是要盯住目标，消除痛苦的最好办法之一就是将其忘记而只是盯住快乐。有人说痛苦和快乐似乎不可能同时发生，痛苦着就不会感到快乐。错！如果把注意力仅仅放在痛苦上，即使有快乐可言的时候你也会对其麻木不仁，转移了注意的重点也就改变了感觉。再举个例子：打棒球的时候，正常情况下你会奔跑、跳跃、投球、防卫，这一次不用球做一次！你想你能坚持玩多久？五分钟？没有球，也就没有了分散痛苦的快乐，每一步都似乎那么沉重。再把球拿上来，又可以玩上两个小时了。圣人说要把双眼盯在目标上，要达到人生目标，你必须学会有关生活的相应知识，这样你才能真正感受到努力带来的快乐。</p>
<p>&emsp;&emsp;想象某个男孩和伙伴玩耍时跌倒擦破了膝盖，开始哭泣，伙伴们冲他喊道：“哭吧，伙计，可劲儿哭！”他却立刻站起来重又加入游戏。回到家里，孩子给妈妈看受的伤，立刻又大哭起来。我们的生活享受与痛苦密切相关，很多人学会说“那又怎么样”，对痛苦毫不在意，而有的人则纠结于自怨自艾情绪，深陷痛苦不能自拔。很多人盯住自己的不能而不是能够，结果造成毫无意义的痛苦。每个人生来都有惊人的天赋和潜力，所以纠缠于自己的缺点就如同衣裳褴褛到高级饭店进餐一样愚蠢–漂亮的风景、精美雅致的餐具，为此你感到局促不安大声喊道：“没有盐！怎么回事？”原本很愉快的经历变成你和周围人的一场噩梦。取得伟大成就的是那些忍受最大痛苦的人，你会因为手指扎根刺就放弃革命吗？你会因为头痛就不再发挥聪明才智吗？有的人在冰水中游泳、在烧红的煤炭上行走，为的就是克服这样做所带来的恐惧，克服恐惧使我们能够感觉到自由意志，让我们能在多大程度上塑造自己的生活。学会专注痛苦中的好处吧，这样你才能发现生活所能给予的最大快乐。</p>
<p>&emsp;&emsp;说到他人的痛苦，那就是两回事了。看望住院朋友的时候，不要说教他应该“看到积极的一面”，同情和理解才能减轻痛苦。同样，也不要对人类的苦难视而不见，你的社区如果出现问题，问自己：“我能做些有助于问题解决的什么事情？”大多数人都能体会到今天人类的苦难：绝望、迫害、残缺的家园……而愿意全力以赴找到真正解决方法的人却凤毛麟角。伟大不仅仅在于比去年更多的捐献，而在于身体力行，把他人的痛苦当作自己的，这就是伟人的伟大之处，这里才是伟大最终得以展现出来之处。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>没有深度思考勤奋都是扯淡</title>
    <url>/2021/01/30/%E6%B2%A1%E6%9C%89%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E5%8B%A4%E5%A5%8B%E9%83%BD%E6%98%AF%E6%89%AF%E6%B7%A1/</url>
    <content><![CDATA[<p>&emsp;&emsp;在今天去看我们周遭的信息环境，不得不说移动互联网的普及让人对信息的摄取广度有了延展，却因此限制了我们摄取信息的深度。我们日常的视野中，总是充斥着碎片化信息之 “过” 的问题——即 99% 的东西，与我们一点关系都没有，或者说在 “浅尝辄止，浮于表面” 的思考模式下对我们没有任何价值。<br>&emsp;&emsp;麦克卢汉曾说：我们创造了工具，工具反过来塑造我们。放到现在来看，也是一样的：一旦你习惯了 “低成本、高回报” 的刺激，你就很难去做那些 “高投入” 的事情，因此成为“低效勤奋者”——看起来每天忙碌，到头来却一无所获。<br>&emsp;&emsp;为什么？因为战术上你很勤奋，实际上却刻意回避了真正困难却更有价值的部分——战略思维与战略决策。而这种 “战略思维懒惰” 的行为，最终会导致你战略决策失误，陷入了低成长的陷阱。<br>&emsp;&emsp;其实，人生最大的悲哀，莫过于将一辈子的聪明，都耗费在肢体的勤奋上。要想成为真正的 “高成长人群”，防止你与预期 “背道而驰”，就要学会并保持深度思考的能力。今天这篇文章，希望能对你有所启发。<br>&emsp;&emsp;许多人宁愿做 “低效勤奋者”也不愿意深度思考。以下这个故事，人们常常用来说明执行力的问题。其实是只知其一，不知其二。<br>&emsp;&emsp;张三和李四同时受雇于一家店铺，拿着同样的薪水。 一段时间后，张三升职加薪，李四却没有，于是李四找老板理论。老板对他说：“李四，你现在帮我到集市上去一下，看看今天早上有什么卖的。”不一会儿，李四从集市回来，向老板汇报：“只有一个农民拉了一车土豆在卖。” 老板问：“有多少？” 李四不知道，于是赶紧又跑到集市上，然后回来告诉老板：“一共 40 袋土豆。” 老板又问他：“价格呢？” 李四说：“您没有叫我打听价格啊。”<br>&emsp;&emsp;于是老板让李四先坐下休息，并把张三叫来，吩咐他说去做同一件事。 张三回来，向老板汇报：“今天集市上只有一个农民在卖土豆，一共 40 袋，价格是两毛五分钱一斤。我看了一下，这些土豆的质量不错，价格也便宜，根据我们以往的销量，40 袋土豆在一个星期左右就可以全部卖掉，一定能赚钱。”<br>&emsp;&emsp;此时老板转向了李四，说：“现在你知道为什么张三的薪水比你高了吧？”<br>&emsp;&emsp;从执行力角度看，是李四做事没有责任心；但再深入地分析，他的思维方式存在问题，他有两个方面不如张三：一是不愿多动脑筋深入思考，二是釆取低级思考方式，很多方面想不到。伯特兰 · 罗素说：“许多人宁愿死，也不愿思考，事实上他们也确实至死都没有思考。”观察我们身边不少看似勤奋的人，却混得不行，为什么？因为他们是 “低效勤奋者”。“低效勤奋者” 有两个特征：不愿深入思考，釆取低级思考。这就导致他们做事效率低，效能低，成长慢。“低效勤奋者” 之所以不愿深入思考与釆取低级思考，是因为这些人不会深度思考。学渣与学霸之间的差别就在于深度思考。普通员工与卓越员工之间的差别也在于深度思考。小老板与大老板之间的差别更在于深度思考。<br>&emsp;&emsp;从 “被动学习” 向“主动学习”升级深度思考，首先是从 “被动学习” 向“主动学习”升级。大多数人从学校开始，就习惯了被学校和老师的教学计划牵着鼻子走；到了工作单位后，被上级的指令与监督驱使着行动。这就是所谓的被动学习与被动思考。本文开头故事中的李四就是这么一个人。釆取这种被动的学习与工作方式的人，亦步亦趋，跟着别人的思维走，既没有偷着懒，一样的累得像狗；又做什么都做不好，做不到位，内心充满压力感。而主动学习不是这样的。我注意到那些学校中的一些学霸，他们有自己的学习计划与学习节奏，以自学为主。在他们眼里，学校统一的学习计划与老师，只是其中之一的辅助途径。我见过一位高中学霸，高一就学完了全部高中课程。我年轻时刚参加工作，就很纳闷：为什么我的上司文化程度不如我，但他批评我时，总能看到我看不到的问题，想出我想不到的办法。有同事解释说，因为领导比我经验丰富。我就不服这个邪，于是，我决定变被动为主动：首先，我强迫自己重视并安心本职工作。其次，在了解工作职责和部门目标的基础上制定自己的较高目标、专业能力体系化学习计划与工作计划。然后，自己找问题，并带着问题在部门內外、行业內外进行广泛的学习与专注思考。这个时候，关键是能够投入业余时间用在学习与工作上。这样一来，经过一段时间，我很快找到了感觉，看问题、想办法、做事情，都能踩到点子上了。在我负责的工作范围内，我所掌握的信息、知识与我的见解，都能走在领导的前面。这样不但使绩效明显提升，博得上司的赏识，而且自己也感到对工作有了发自内心的兴趣，还心情舒畅，不像过去一样有压力了。<br>&emsp;&emsp;人生最大的思想误区认为战略短板可以用战术的勤奋来弥补。<br>&emsp;&emsp;在前几年大众创业的热潮中，我认识的一位老乡，他三十来岁，也按奈不住心潮澎湃，说老子决定不打工了，创业当老板去。他拿出准备结婚买房的钱，加上找众多亲朋好友众筹的款子，共逾百万，开了一家餐馆。我是偶然去吃饭碰上他的。吃完之后，他问我，餐馆办得怎么样？我实话实说，你这个啊有两个战略上的问题：一个是地段偏僻了，另一个是菜品虽然有特色，口味也挺好，但根据我对周边人群的了解，你这定位有点不精准，高不成低不就。这老乡听了有点不高兴，跟我大谈什么工匠精神，要精益求精创一流莱品。最后他说，这地段偏是偏了点，但租金便宜，我可以把省下的资金，用来作广告，搞宣传，打响牌子，还是划算的。后来听说他在广告与促销上做了很大努力与很多动作，如微信宣传，店內有奖促销，优惠促销，派人在路口撒广告传单，到附近小区与写字楼贴广告。可以讲，凡营销教课书上提到的促销招术，他都几乎用了一遍。但最终还是无力回天，半年后便停业倒闭了。我发现，不少人有一个盲目的自信，以为战略上的短板，可以用正确的战术和增加战术资源投入，来弥补，来挽救。这实质上是在用战术上的勤奋，来掩盖战略上的懒惰。战术上你很勤奋，实际上却刻意回避了真正困难却更有价值的部分——战略思维与战略决策。而这种 “战略思维懒惰” 的行为，最终会导致你战略决策失误，结果可能是一失足成千古恨。前面所讲的选择 “低成长区” 还是选择“高成长区”，这都属于战术层面的思考，这些你选择对了，做对了，也还是不够的。比战术层面的深度思考更重要的，是战略层面的深度思考。你必须把决定事业全局与长久成败的战略决策视为头等大事，在战略上多学习，多动脑子，多花时间，多选择，多比较，不怕麻烦，力戒 “战略思维懒惰”。要能 “忍、等、准”，有耐心，时刻准备，创造机会，但勿因急躁而轻举妄动。如果你是公司老板，就须选择一个好的行业，好的商业模式，把握好机会，使机遇同自己的核心能力、关键资源、价值观相匹配。然后，制定公司的发展战略规划。<br>&emsp;&emsp;如果你是职场人士，在注重选好行业、公司平台时，更要选好职业，并且使这些选择与自己的专业、特质潜能、价值观相适合。然后，根据环境和公司未来发展趋势、未来机会制定自己的长远职业发展计划与新能力学习计划。<br>&emsp;&emsp;人生最大的悲伤，莫过于将一辈子的聪明都耗费在战术上。当你抬头一看，你精益求精的事情，它们所在的职业或行业己经衰落，或社会价值与个人价值都很低微，或前进的战略大方向错了。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>经典语句</title>
    <url>/2021/04/24/%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>《乡下人的悲歌》，是《纽约时报》和影响力颇大的《泰晤士报》力推的一本书，作者 J.D 万斯借自己真实的人生经历，讲述了一个普通家庭孩子要如何才能跨越阶层，为自己的人生谋得选择的权利。</p>
<p>万斯在序言中说：</p>
<p>我之所以写这本书，并不是因为我取得了什么不平凡的成就，而是因为我做的事虽然非常平凡，但大多数像我那样家庭的孩子都做不到。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2021/03/27/%E8%8E%B7%E5%8F%96%E6%A1%8C%E9%9D%A2%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%86%99%E6%88%90%E5%87%BD%E6%95%B0%E6%96%B9%E4%BE%BF%E8%B0%83%E7%94%A8%EF%BC%88%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%89/</url>
    <content><![CDATA[<h2 id="写成函数，需要时直接调用更方便"><a href="#写成函数，需要时直接调用更方便" class="headerlink" title="写成函数，需要时直接调用更方便"></a>写成函数，需要时直接调用更方便</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetDesktopPath</span>():</span></span><br><span class="line">    <span class="keyword">return</span> os.path.join(os.path.expanduser(<span class="string">&quot;~&quot;</span>), <span class="string">&#x27;Desktop\\111.txt&#x27;</span>)   <span class="comment">#存放在桌面上的文件在读取时，路径应加 \\ 表示转义</span></span><br><span class="line"></span><br><span class="line"> print(GetDesktopPath())</span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Readfiles</span>(<span class="params">b</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(b,encoding=<span class="string">&#x27;gbk&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f1:		  <span class="comment">#用 for 循环一行一行的读取，推荐这读法，不占用内存空间</span></span><br><span class="line">            line = line[:-<span class="number">1</span>]  <span class="comment">#去除每一行的换行符，即回车产生的空行，使输出时没有空格</span></span><br><span class="line">            print(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a=GetDesktopPath()		<span class="comment">#调用函数时，其返回值返回给函数本身，这时用一个变量 ‘a’ 接收，再把 a 传下一个函数使用</span></span><br><span class="line">    Readfiles(a)		<span class="comment">#传实参变量 a 给读取文件的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    first_number = <span class="built_in">input</span>(<span class="string">&#x27;\nFirst number:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> first_number.lower() == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    second_number = <span class="built_in">input</span>(<span class="string">&#x27;\nSecond number:&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        answer = <span class="built_in">int</span>(first_number) / <span class="built_in">int</span>(second_number)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        print(<span class="string">&quot;You can&#x27;t divide by 0!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(answer)</span><br></pre></td></tr></table></figure>
<h2 id="异常处理实例"><a href="#异常处理实例" class="headerlink" title="异常处理实例"></a>异常处理实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n=<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入一个数字：&#x27;</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">&#x27;输入错误&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    dn=n**<span class="number">2</span></span><br><span class="line">    print(<span class="string">&#x27;其平方为：&#x27;</span>,dn)</span><br><span class="line">    <span class="keyword">if</span> dn&lt;<span class="number">50</span>:</span><br><span class="line">        print(<span class="string">&#x27;平方小于50，退出&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>获取路径下所有文件全名路径判断是路径目录文件是否存在</title>
    <url>/2021/08/22/%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%85%A8%E5%90%8D%E8%B7%AF%E5%BE%84%E5%88%A4%E6%96%AD%E6%98%AF%E8%B7%AF%E5%BE%84%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_name</span>(<span class="params">file_dir</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(file_dir):</span><br><span class="line">        <span class="comment"># print(root)  # 当前目录路径</span></span><br><span class="line">        print(dirs)  <span class="comment"># 当前路径下所有子目录</span></span><br><span class="line">        print(files)  <span class="comment"># 当前路径下所有非目录子文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_name(<span class="string">r&quot;C:\Users\win\Desktop\ccc&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_name</span>(<span class="params">file_dir</span>):</span></span><br><span class="line">    L = []</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(file_dir):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(file)[<span class="number">1</span>] == <span class="string">&#x27;.png&#x27;</span>:  <span class="comment"># 想要保存的文件格式</span></span><br><span class="line">                L.append(os.path.join(root, file))</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line">file_name(<span class="string">r&quot;C:\Users\win\Desktop\ccc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#其中os.path.splitext()函数将路径拆分为文件名+扩展名</span></span><br></pre></td></tr></table></figure>



<pre><code>[&#39;C:\\Users\\win\\Desktop\\ccc\\20200706130733539 - 副本 (2).png&#39;,
 &#39;C:\\Users\\win\\Desktop\\ccc\\20200706130733539 - 副本.png&#39;,
 &#39;C:\\Users\\win\\Desktop\\ccc\\20200706130733539.png&#39;,
 &#39;C:\\Users\\win\\Desktop\\ccc\\modify\\20200706130733539 - 副本 (2).png&#39;,
 &#39;C:\\Users\\win\\Desktop\\ccc\\modify\\20200706130733539 - 副本.png&#39;,
 &#39;C:\\Users\\win\\Desktop\\ccc\\modify\\20200706130733539.png&#39;]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dirpath = <span class="string">r&#x27;D:\Premiere\1&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dirpath):</span><br><span class="line">	os.mksdir(dirpath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历指定目录，显示目录下的目录和文件名（分开显示）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printPath</span>(<span class="params">path</span>):</span></span><br><span class="line">    dirList = []</span><br><span class="line">    fileList = []</span><br><span class="line"></span><br><span class="line">    dirFiles = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> dirFile <span class="keyword">in</span> dirFiles:</span><br><span class="line">        curPath = path + <span class="string">&#x27;/&#x27;</span> + dirFile</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(curPath):</span><br><span class="line">            <span class="comment"># 排除隐藏文件</span></span><br><span class="line">            <span class="keyword">if</span> dirFile[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                dirList.append(curPath)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> os.path.isfile(curPath):</span><br><span class="line">            <span class="keyword">if</span> dirFile[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                fileList.append(curPath)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;dirlist里有啥？&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> dir_ <span class="keyword">in</span> dirList:</span><br><span class="line">        print(<span class="string">&#x27;t&#x27;</span>, dir_)</span><br><span class="line">    print(<span class="string">&#x27;filelist里有啥？&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> file_ <span class="keyword">in</span> fileList:</span><br><span class="line">        print(<span class="string">&#x27;t&#x27;</span>, file_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path = <span class="string">r&quot;C:\Users\win\Desktop\ccc&quot;</span></span><br><span class="line">printPath(path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历指定目录，显示目录下的文件名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eachFile</span>(<span class="params">filepath</span>):</span></span><br><span class="line">    pathDir = os.listdir(filepath)</span><br><span class="line">    print(<span class="string">&#x27;pathDir:&#x27;</span>, pathDir)</span><br><span class="line">    <span class="keyword">for</span> allDir <span class="keyword">in</span> pathDir:</span><br><span class="line">        child = os.path.join(filepath, allDir)</span><br><span class="line">        print(child)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eachFile(<span class="string">r&quot;C:\Users\win\Desktop\ccc&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归获取路径下所有文件名</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listdir</span>(<span class="params">path, list_name</span>):</span>  <span class="comment"># 传入存储的list</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        file_path = os.path.join(path, file)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(file_path):</span><br><span class="line">        	listdir(file_path, list_name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list_name.append(file_path)</span><br><span class="line">    <span class="keyword">return</span> list_name</span><br><span class="line">listdir(<span class="string">r&quot;C:\Users\win\Desktop\ccc&quot;</span>,list_name=[])</span><br></pre></td></tr></table></figure>



<pre><code>[&#39;C:\\Users\\win\\Desktop\\ccc\\20200706130733539 - 副本 (2).png&#39;,
 &#39;C:\\Users\\win\\Desktop\\ccc\\20200706130733539 - 副本.png&#39;,
 &#39;C:\\Users\\win\\Desktop\\ccc\\20200706130733539.png&#39;,
 &#39;C:\\Users\\win\\Desktop\\ccc\\modify\\20200706130733539 - 副本 (2).png&#39;,
 &#39;C:\\Users\\win\\Desktop\\ccc\\modify\\20200706130733539 - 副本.png&#39;,
 &#39;C:\\Users\\win\\Desktop\\ccc\\modify\\20200706130733539.png&#39;]
</code></pre>
<h2 id="怎样使用-Python-来判断一个路径是否存在判断一个路径是文件还是目录-判断一个路径是否存在"><a href="#怎样使用-Python-来判断一个路径是否存在判断一个路径是文件还是目录-判断一个路径是否存在" class="headerlink" title="怎样使用 Python 来判断一个路径是否存在判断一个路径是文件还是目录 判断一个路径是否存在"></a>怎样使用 Python 来判断一个路径是否存在判断一个路径是文件还是目录 判断一个路径是否存在</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.path.exists(path)     <span class="comment"># 判断一个路径是否存在，可以判断一个文件或目录（文件夹）是否存在</span></span><br><span class="line"></span><br><span class="line">os.path.isdir(path)      <span class="comment"># 判断一个目录（文件夹）是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断一个路径是文件还是目录（文件夹）</span></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"></span><br><span class="line">os.path.isdir(path)   <span class="comment"># 返回 True 表示是目录（文件夹）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"></span><br><span class="line">os.path.isfile(path)   <span class="comment"># 返回 True 表示是文件</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机存储单位</title>
    <url>/2021/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h2><p>存储单位是一种计量单位。指在某一领域以一个特定量，或标准做为一个记录（计数）点。再以此点的某个倍数再去定义另一个点，而这个点的代名词就是计数单位或存储单位。</p>
<a id="more"></a>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在计算机内部，信息都是釆用二进制的形式进行存储、运算、处理和传输的。信息存储单位有位、字节和字等几种。各种存储设备存储容量单位有 KB、MB、GB 和 TB 等几种。</p>
<h3 id="基本储存单元"><a href="#基本储存单元" class="headerlink" title="基本储存单元"></a>基本储存单元</h3><p>位（bit）：二进制数中的一个数位，可以是 0 或者 1，是计算机中数据的最小单位。</p>
<p>字节（Byte，B）：计算机中数据的基本单位，每 8 位组成一个字节。各种信息在计算机中存储、处理至少需要一个字节。例如，一个 ASCII 码用一个字节表示，一个汉字用两个字节表示。</p>
<p>字（Word）：两个字节称为一个字。汉字的存储单位都是一个字。</p>
<h3 id="扩展的存储单位"><a href="#扩展的存储单位" class="headerlink" title="扩展的存储单位"></a>扩展的存储单位</h3><p>在计算机各种存储介质（例如内存、硬盘、光盘等）的存储容量表示中，用户所接触到的存储单位不是位、字节和字，而是 KB、MB、GB 等，但这不是新的存储单位，而是基于字节换算的。</p>
<p>KB：早期用的软盘有 360KB 和 720KB 的，不过软盘已经很少使用。</p>
<p>MB：早期微型机的内存有 128MB、256MB、512MB，目前内存都是 1GB、2GB 甚至更大。</p>
<p>GB：早期微型机的硬盘有 60GB、80GB，目前都是 500GB、1TB 甚至更大。</p>
<p>TB：目前个人用的微型机存储容量也都能达到这个级别了，而作为服务器或者专门的计算机，不可缺少这么大的存储容量。</p>
<h3 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h3><p>换算率约等于 1000（1024），从大到小顺序为 T、GB、MB、KB、B 再小就是位了。</p>
<p>计算机存储单位一般用 bit、B、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB…… 来表示，它们之间的关系是：</p>
<p>1 Byte（B） = 8 bit<br>1 Kilo Byte（KB） = 1024B<br>1 Mega Byte（MB） = 1024 KB<br>1 Giga Byte （GB）= 1024 MB<br>1 Tera Byte（TB）= 1024 GB<br>1 Peta Byte（PB） = 1024 TB<br>1 Exa Byte（EB） = 1024 PB<br>1 Zetta Byte（ZB） = 1024 EB<br>1Yotta Byte（YB）= 1024 ZB<br>1 Bronto Byte（BB） = 1024 YB<br>1Nona Byte（NB）=1024 BB<br>1 Dogga Byte（DB）=1024 NB<br>1 Corydon Byte（CB）=1024DB</p>
<p>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，是最小的存储单位。</p>
<p>[英文缩写：b (固定小写)]</p>
<p>字节 byte：8 个二进制位为一个字节 (B)，计算机存储的基本单位。</p>
<p>字节又被译为 “字节”，即是在电脑内一个英文字所占的最基本单元，而一个中文字是占两个字节的。</p>
<p>至于硬盘容量，一般的制造商总是用十进制的计数。一般计算机的操作系统都是使用二进制的计数，所以你经常会发现计算机中看到的硬盘容量比硬盘上的实际可用容量要小，比如 20GB 的硬盘只显示有 18.6GB。</p>
<p>特别误导人是软盘的情况。720KB 的软盘是 720乘1024 个数位组的值经常用 2 个十六进制的数字（在信息科学中这样一个 16 进制的数字也称为一），而 1.44MB 的软盘则莫名奇妙的是 1.44 乘 1000 乘 1024 个数位组的值经常用两个十六进制的数字（在信息科学中这样一个 16 进制的数字也称为一），即不全是十进制也不全是二进制。</p>
<p>注：“兆” 为百万级数量单位。</p>
<h3 id="b（bit）与-B"><a href="#b（bit）与-B" class="headerlink" title="b（bit）与 B"></a>b（bit）与 B</h3><p>上面的换算相信大家已看过了，可说起存储容量单位，大家很自然的会想起自己的硬盘有多少 GB、内存有多少 MB，我们知道了字节（B）是电脑中表示信息含义的最小单位，通常情况下一个 ACSII 码就是一个字节的空间来存放。而事实上电脑中还有比字节更小的单位，因为一个字节是由八个二进制位组成的，换一句话说，每个二进制位所占的空间才是电脑中最小的单位，我们把它称为位，也称比特（bit）。由此可见，一个字节等于八位。人们之所以把字节称为电脑中表示信息含义的最小单位，是因为一位并不能表示我们现实生活中的一个相对完整的信息。<br>有的时候，为了简写，我们会把位的单位缩写成 b，这个时候大家一定会有疑问了，因为字节的单位我们用 B 表示，两者不就是一样了吗？其实，字节的表示单位 B 是 Byte 的缩写，位的表示单位 b 是 bit 的缩写，1b 与 1B 之间只要大小写不同，那么表示的含义也不同，因为 8b 才等于 1B。</p>
<p>一般来说，我们讲到存储设备时，都是按照字节进行换算，例如 <img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210215123629.png" alt="20210215123629">。但是在网络传输之中，数据传输则是按照位进行传输的。这就可以解释为什么自己家里的宽带 ADSL 是 1Mb 的带宽，但是下载数据却只能在 100KB 左右徘徊。因为1MB=1024KB，由于字节与位之间的关系是八倍，因此将 1024Kb 除以 8 就得到 128KB。由此可见，实现上网络传输带宽中的 1M 只等于电脑中的 128KB。这样加上信号的衰减，一般只能保持在 100KB 左右。<br>相同的道理，我们的网卡一般都是 100M 的，但是为什么传输速度达不到这么高呢？因为 100Mb，将其除以 8 得到 12.5MB，这就是我们网卡能够达到的最高速度了。</p>
<h3 id="换算进率"><a href="#换算进率" class="headerlink" title="换算进率"></a>换算进率</h3><p>计算机都是二进制的，让它们计算单位，只有 2 的整数幂时才能非常方便计算机计算，因为电脑内部的电路工作有高电平和低电平两种状态。所以就用二进制来表示信号，以便计算机识别。而人习惯于使用 10 进制，所以存储器厂商们使用 1000 作进率。这样导致的后果就是实际容量要比标称容量少，不过这是合法的。1024 是 2 的 10 次方，因为如果取大了，不接近 10 的整数次方，不方便人们计算；取小了，进率太低，单位要更多才能满足需求，所以取 2 的 10 次方正好。</p>
<p>计算实例：标称 100GB 的硬盘，其实际容量为：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210215123558.png" alt="20210215123558"></p>
</div>

<h3 id="带宽存储换算"><a href="#带宽存储换算" class="headerlink" title="带宽存储换算"></a>带宽存储换算</h3><p>在我们的记忆中，我们恐怕最熟悉的就是当初用 Modem 接入互联网时，接入的速度仅仅为 56Kbps。在这个单位中，bps 是 bit Per Second 的缩写，翻译成中文就是比特位每秒，也就是表示一秒钟传输多少位（bit）的意思。Kb 与 KB 之间的关系：我们在电脑原理中知道，电脑的最小存储单位是字节 Byte，一个字节，是由八位二进制位组成的。由此，我们可以这样认为，一个字节是由 8 个位组成的，或者说一个字节与八个位所占的空间是相同的。因为，当我们使用 100Mb 带宽的网络下载时，理论上的速度应该是 100 除以 8 等于 12.5MB。</p>
]]></content>
      <categories>
        <category>视频工具使用</category>
      </categories>
      <tags>
        <tag>视频工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>读书最基本的3件事</title>
    <url>/2021/02/16/%E8%AF%BB%E4%B9%A6%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%843%E4%BB%B6%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="读书最基本的-3-件事：一是学会做人，二是打破我执，三是洞察规律"><a href="#读书最基本的-3-件事：一是学会做人，二是打破我执，三是洞察规律" class="headerlink" title="读书最基本的 3 件事：一是学会做人，二是打破我执，三是洞察规律"></a>读书最基本的 3 件事：一是学会做人，二是打破我执，三是洞察规律</h3><p>之前听到一个人说：“我们人修行，就是与天争命。” 这个观点，甚有道理。</p>
<p>古人说，一命二运三风水，四积阴德五读书。对于绝大多数人而言，真正能改变命运的，只能靠读书。</p>
<p>有的人不以为然，说隔壁家老王的儿子，读完大学出来，赚到的钱，还不如人家不读书，自己做生意的多。</p>
<p>读书≠学历 读书≠知识 读书≠知道</p>
<p>这篇文章，给大家解读，如何通过真正的读书，来改变自己，逆袭命运。</p>
<a id="more"></a>

<h4 id="真正的读书，要打破我执。"><a href="#真正的读书，要打破我执。" class="headerlink" title="真正的读书，要打破我执。"></a>真正的读书，要打破我执。</h4><p>我自己工作 10 年后，泡在书城里，又读了 3 年书，读了多少书，自己没算过。很多人叫我推荐一些好书，我的观点是：开卷有益，任何一本书，都是好书。</p>
<p>正规的书籍出版，有对应的书号，审查是很严格的，能上市的书，都是好书，不好的书，根本就没资格出版。</p>
<p>每一个本书，都是一个看世界的窗口，不同的书，就是不同的窗口。</p>
<p>所以，读书，读到最后，要打破我执。</p>
<p>什么是我执？</p>
<p>一个人出生，成长，到成年，自然形成一套看待和评价人、事、物的观念，就是我执。</p>
<p>我执，本身不好，不坏，只是一种认知系统，是看世界的一个窗口。</p>
<p>很多人的毛病，就是只从自己的窗口，去看世界，并认为，自己就是对的，别人的观点和自己不一样，别人就是错的。</p>
<p>如果无法打破我执，一个人读再多的书，都没有用，因为他看世界的窗口，是固定的，是局部的，认知是有限的。</p>
<p>而打破我执的人，可以从任意一个窗口，去看世界。这样的人，认知是无限的。</p>
<h4 id="真正的读书，要洞察规律。"><a href="#真正的读书，要洞察规律。" class="headerlink" title="真正的读书，要洞察规律。"></a>真正的读书，要洞察规律。</h4><p>很多人买书，然后摆在书架上，不管看了多少，占有很多书，就感觉自己有文化了。其实，读书多少，不是关键，关键是，你能通过读书明理，来洞察世间万物的规律。</p>
<p>举个例子：</p>
<p>人逢喜事精神爽，有的人运气好时，就得意忘形，恨不过全世界的人都知道。而等到自己运气下跌时，又抱怨自己倒霉。</p>
<p>而能洞察规律的人，在自己运气好时，懂得谦虚、收敛，免得内心膨胀了，而导致“亢龙有悔”。在运气下跌时，因为前面有做好心理准备，所以也能顺利摆平。吉凶和福祸，都是互相依存，互相转化的，《易经》《老子》《庄子》等等，很多书中，都讲明这些道理。</p>
<p>高明的人，洞察规律，保持心醒；不高明的人，被规律牵着鼻子走。</p>
<p>所以，我们要走出读书的误区，不要认为受教育学历高就好，读书数量多就好，也不是知识渊博就好。</p>
<p>读书，最基本的就是要做好 3 件事：一是学会做人，二是打破我执，三是洞察规律。做到知行合一，就是读书的最高境界。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>读取多行为表头的方法</title>
    <url>/2021/08/22/%E8%AF%BB%E5%8F%96%E5%A4%9A%E8%A1%8C%E4%B8%BA%E8%A1%A8%E5%A4%B4%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure>
<h2 id="对于待合并的数据表格的表头不正规的情况，如表头由多行组成且行中有折分单元格的情况，这种情形下，如何强行合并可能得不到想要的效果，如何做，且看如下分解："><a href="#对于待合并的数据表格的表头不正规的情况，如表头由多行组成且行中有折分单元格的情况，这种情形下，如何强行合并可能得不到想要的效果，如何做，且看如下分解：" class="headerlink" title="对于待合并的数据表格的表头不正规的情况，如表头由多行组成且行中有折分单元格的情况，这种情形下，如何强行合并可能得不到想要的效果，如何做，且看如下分解："></a>对于待合并的数据表格的表头不正规的情况，如表头由多行组成且行中有折分单元格的情况，这种情形下，如何强行合并可能得不到想要的效果，如何做，且看如下分解：</h2><h3 id="第一步：先进行常规合并操作，得到不规整的合并后的的表，目得到的是内容齐全的在一个表格内的所有数据"><a href="#第一步：先进行常规合并操作，得到不规整的合并后的的表，目得到的是内容齐全的在一个表格内的所有数据" class="headerlink" title="第一步：先进行常规合并操作，得到不规整的合并后的的表，目得到的是内容齐全的在一个表格内的所有数据"></a>第一步：先进行常规合并操作，得到不规整的合并后的的表，目得到的是内容齐全的在一个表格内的所有数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">displaydir</span>(<span class="params">dir_path</span>):</span></span><br><span class="line">    file_list = []</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> filenames <span class="keyword">in</span> os.walk(dir_path):</span><br><span class="line">        <span class="keyword">for</span> table <span class="keyword">in</span> filenames[<span class="number">2</span>]:</span><br><span class="line">            path = filenames[<span class="number">0</span>] + <span class="string">&#x27;/&#x27;</span> + table</span><br><span class="line">            li = pd.read_excel(path,header=<span class="number">3</span>,dtype=<span class="built_in">str</span>)</span><br><span class="line">            li[<span class="string">&#x27;file_name&#x27;</span>] = os.path.splitext(table)[<span class="number">0</span>]</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            file_list.append(li)</span><br><span class="line">            print(<span class="string">&#x27; 第&#x27;</span> + <span class="built_in">str</span>(n) + <span class="string">&#x27; 个表格已合并&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;在该目录下有 %d 个 xlsx 文件&#x27;</span> % <span class="built_in">len</span>(file_list))</span><br><span class="line">    data_result = pd.concat(file_list, ignore_index=<span class="literal">True</span>)</span><br><span class="line">    data_result.to_excel(out_path + <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;result.xlsx&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dir_path = <span class="string">r&quot;D:\1 - 副本\新建文件夹&quot;</span></span><br><span class="line">    out_path = <span class="string">r&quot;C:\Users\win\Desktop\xlsx&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_path):</span><br><span class="line">        os.makedirs(out_path)</span><br><span class="line"></span><br><span class="line">    displaydir(dir_path)</span><br></pre></td></tr></table></figure>
<h3 id="第二步：根据需要，对表头的列进行重命名操作，并且删除数据行为全空数据的行。"><a href="#第二步：根据需要，对表头的列进行重命名操作，并且删除数据行为全空数据的行。" class="headerlink" title="第二步：根据需要，对表头的列进行重命名操作，并且删除数据行为全空数据的行。"></a>第二步：根据需要，对表头的列进行重命名操作，并且删除数据行为全空数据的行。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.read_excel(<span class="string">r&quot;C:\Users\win\Desktop\xlsx\result.xlsx&quot;</span>,dtype=<span class="built_in">str</span>)</span><br><span class="line">data.rename(columns=&#123;<span class="string">&#x27;Unnamed: 1&#x27;</span>:<span class="string">&#x27;学校&#x27;</span>,<span class="string">&#x27;Unnamed: 2&#x27;</span>:<span class="string">&#x27;姓名&#x27;</span>,<span class="string">&#x27;Unnamed: 3&#x27;</span>:<span class="string">&#x27;学生/教师&#x27;</span>,<span class="string">&#x27;Unnamed: 4&#x27;</span>:<span class="string">&#x27;性别&#x27;</span>,<span class="string">&#x27;Unnamed: 5&#x27;</span>:<span class="string">&#x27;身份证号&#x27;</span>,<span class="string">&#x27;Unnamed: 6&#x27;</span>:<span class="string">&#x27;手机号&#x27;</span>&#125;,inplace=<span class="literal">True</span>)</span><br><span class="line">data.dropna(axis=<span class="number">0</span>,how=<span class="string">&#x27;all&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>





<h2 id="reset-index-重置索引列"><a href="#reset-index-重置索引列" class="headerlink" title="reset_index () 重置索引列"></a>reset_index () 重置索引列</h2><p>pandas 中的 reset_index ()</p>
<p>数据清洗时，会将带空值的行删除，此时 DataFrame 或 Series 类型的数据不再是连续的索引，可以使用 reset_index () 重置索引</p>
<p>eg:<br>import pandas as pd</p>
<p>import numpy as np</p>
<p>df = pd.DataFrame(np.arange(20).reshape(5,4),index=[1,3,4,6,8])</p>
<p>print(df)</p>
<p>reset_index () 重置索引：</p>
<p>print(df.reset_index())</p>
<p>在获得新的 index，原来的 index 变成数据列，保留下来。</p>
<p>不想保留原来的 index，使用参数 drop=True，默认 False。</p>
<p>print(df.reset_index(drop=True))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.to_excel(<span class="string">r&#x27;D:\finall.xlsx&#x27;</span>,index=<span class="literal">False</span>)   <span class="comment"># 保存工作表</span></span><br></pre></td></tr></table></figure>
<h1 id="上述为一个处理的完整过程"><a href="#上述为一个处理的完整过程" class="headerlink" title="上述为一个处理的完整过程"></a>上述为一个处理的完整过程</h1><h1 id="以下为第一学习操作的过程："><a href="#以下为第一学习操作的过程：" class="headerlink" title="以下为第一学习操作的过程："></a>以下为第一学习操作的过程：</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file_path=<span class="string">r&quot;D:\1 - 副本\新建文件夹&quot;</span></span><br><span class="line">file_list=os.listdir(file_path)</span><br><span class="line"></span><br><span class="line">data_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_list:</span><br><span class="line">    full_path=os.path.join(file_path,i)</span><br><span class="line">    data=pd.read_excel(full_path,header=<span class="number">3</span>,dtype=<span class="built_in">str</span>)</span><br><span class="line">    data_list.append(data)</span><br><span class="line">    df_all=pd.concat(data_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># df_all.to_excel(r&#x27;D:\result1.xlsx&#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_all.rename(columns=&#123;<span class="string">&#x27;Unnamed: 0&#x27;</span>:<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;Unnamed: 1&#x27;</span>:<span class="string">&#x27;学校&#x27;</span>,<span class="string">&#x27;Unnamed: 2&#x27;</span>:<span class="string">&#x27;姓名&#x27;</span>,<span class="string">&#x27;Unnamed: 3&#x27;</span>:<span class="string">&#x27;学生家长&#x27;</span>,<span class="string">&#x27;Unnamed: 4&#x27;</span>:<span class="string">&#x27;性别&#x27;</span>,<span class="string">&#x27;Unnamed: 5&#x27;</span>:<span class="string">&#x27;身份证号&#x27;</span>,<span class="string">&#x27;Unnamed: 6&#x27;</span>:<span class="string">&#x27;手机号&#x27;</span>&#125;,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># df_all.head(20)</span></span><br><span class="line"><span class="comment"># df_all.drop(columns=[&#x27;id&#x27;], inplace=True)</span></span><br><span class="line">df_all.head(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_all.dropna(axis=<span class="number">0</span>, how=<span class="string">&#x27;all&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.shape</span><br></pre></td></tr></table></figure>
<pre><code>(39, 15)
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.reset_index(drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.to_excel(<span class="string">r&#x27;D:\finall.xlsx&#x27;</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_all.rename(columns=&#123;<span class="string">&#x27;学生家长&#x27;</span>:<span class="string">&#x27;学生/教师&#x27;</span>&#125;,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_all</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_all.dropna(axis=<span class="number">0</span>,how=<span class="string">&#x27;all&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">df_all</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>超强的学习能力是怎样练就的_精练型</title>
    <url>/2021/03/08/%E8%B6%85%E5%BC%BA%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%83%E5%B0%B1%E7%9A%84-%E7%B2%BE%E7%BB%83%E5%9E%8B/</url>
    <content><![CDATA[<p>藤校本科，稍微说一下我的经验。</p>
<ol>
<li>学习开始前的准备：心态</li>
</ol>
<p>我认为世界上没有 “困难” 的内容，只有 “简单但是不完整” 的内容。</p>
<p>爱因斯坦说：“如果你不能让一个五岁小孩理解你的概念，那就意味着你对这个概念不够了解。”</p>
<p>这句话的含义很丰富。首先，为什么一个五岁小孩具备可以理解所有概念的能力？</p>
<p>因为所有概念本质上都是一个逻辑链条，一环接一环。只要把每一个环节的逻辑理解了，那你对这个概念本身就理解透了。</p>
<p>这个逻辑链条上的每一环都不困难，所以一个五岁小孩都能理解。</p>
<p>理解一个概念最困难的地方在于填补一个断裂的逻辑链条。</p>
<p>很多时候，教科书里会说：“因为 A，所以 C。” 然而那个概念其实是 “因为 A，所以 B，所以 C。”</p>
<p>在这个时候我们就会头大：看不懂 A 和 C 之间的联系啊，难道是因为 A 所以 D 所以 C？还是因为 A 所以 E 所以 C？</p>
<p>困难就是在这个过程中出现的。</p>
<p>我们都曾有过这个经历：自己苦苦思索了许久的难题，在别人一两句话的点拨下就豁然开朗。</p>
<p>这种经历的本质就是对方告诉了你：“A 和 C 之间缺失的那个部分是 B。”</p>
<p>从 A 到 B 到 C 的逻辑不难，难的是修补 A 和 C 之间断裂的逻辑链条。</p>
<p>因此，我再次重复：世界上没有 “困难” 的内容，只有 “简单但是不完整” 的内容。</p>
<p>当你在学习上感到气馁时，记住上面这句话，它将会给你继续探索的信心和勇气。</p>
<ol start="2">
<li>痴迷（obsession）</li>
</ol>
<p>“痴迷” 是我用过的最有效的方法。当我学到一个新概念时，如果我不能马上理解它，我就会一整天反复在脑中思索这个概念：走路时、吃饭时、坐车时都在思考。其实就是把别人看手机的时间拿来思考概念了。</p>
<p>但是 “痴迷” 和常见的 “利用碎片时间” 有一个根本性的不同。利用碎片时间是被动的，是 “因为我有这些时间，所以我要利用好它”；而痴迷是主动的，是 “我对这个内容很好奇，所以我要弄懂它。” 换句话说， 利用碎片时间的重点在于 “利用时间”，而痴迷的重点在于 “你很好奇”。</p>
<p>当你用 “痴迷” 的方法想通一个概念时，你就会把这个概念记得特别牢固，因为 1）你花了很多时间反复思考它，这本身就是一个记忆的过程；2）你对这个概念会有自己的理解，知其然并知其所以然，而不是单纯把教科书背了下来。“知其然并知其所以然” 意味着当你对这个概念的记忆变得模糊时，你脑里将有更多关于这个概念的内容来 “提示” 你将其记起来。</p>
<ol start="3">
<li>有效率的学习策略</li>
</ol>
<p>当你遇到一道数学难题时，你会怎么做？</p>
<p>查答案？自己苦苦思索？开始玩手机逃避？</p>
<p>我的做法是在有答案的情况下先查答案，不浪费时间在解题过程上，而是把时间都花在理解概念上。这样才可以把时间的效用最大化，因为难题都是树的叶子，而题目考察的概念是树的主干。</p>
<p>一棵树只有一个主干，但是可以有茫茫多的叶子。如果你每个难题都自己思索的话，你大概率得学到猴年马月了。因此，应对难题最好的方法不是硬刚，而是找答案。</p>
<p>当然，对于主干的概念来讲，建议用前面的方法把它摸透。</p>
<h3 id="比喻型"><a href="#比喻型" class="headerlink" title="比喻型"></a>比喻型</h3><p>超强的学习能力，本质是超强的思维能力。</p>
<p>举个例子。玩狼人杀的时候。每一局都有海量的信息。如何从新手成长到大神，就看懂不懂快速的处理信息。</p>
<p>基本上，每一个狼人杀大神都有固定的思维方式。比如，先排除掉无用的信息，然后从表情，发言的正确性，发言的动机筛选出，自己需要的信息。</p>
<p>新手如果只记住套路，而不形成处理信息的思维，很难有实质性的成长。</p>
<p>现实里，很多人学不好数学，就是只背诵教科书上的知识。而数学除了知识点，更是一种思维方式。如果用文科的方法，而没有培养数学思维，是学不好数学的。</p>
<p>网上有一个段子，每次只喝一半的酒，那酒就永远喝不完。这种规律总结，也算是一种抽象的思维。运用这种思维解决问题，我们可以得出酒喝不完的结论。</p>
<p>按照这个规律，我们可以一反三得出。路程也应该永远走不完。因为我们走到路程中心的时候，剩下的路程会出来一个新的中心点。所以，我们永远不可能到达目的地。</p>
<p>上述的过程，便是通过规律总结，把一个未知的问题，转化为一个已知的问题。把一个未知的事物，剖析出已知的规律。</p>
<p>当然，酒喝不完，目的地永远到不了。这都是错误结论。如果我们学过级数，我们就可以轻易的说出，这类芝诺悖论的荒谬之处。</p>
<p>对于小学生来说，他们可以总结出酒喝不完的结论。而一个修过高等数学的大学生，能通过级数，证明出前者错误。两种就区别于知识结构的不同。</p>
<p>前者只有简单的数学思维，最多能发现一些表层的现象。后者，有极限、导数、微积分等抽象工具，可以总结出事物深层次的规律。</p>
<p>超强的学习能力，不仅是增多知识，更是建立知识的体系的能力。让我们从事物表层规律，进入到深层规律。</p>
<p>举一个金庸老爷子的例子。</p>
<p>笑傲江湖里面，风清扬教令狐冲学剑，里面有一招华山剑法，叫小狗洗澡。是用剑尖去戳别人喉咙。令狐冲之前学这一招，都是从下路向上戳。结果与风清扬练剑的时候，还没俯身，剑被打掉了。令狐冲直接呆立当场。</p>
<p>风清扬当时就怒了，大骂蠢材。你剑没了，就不能用手指去戳别人吗？不能俯身用小狗洗澡，你就不能变招为爱居牛笔，打别人上路吗？</p>
<p>令狐冲听完又傻了，之前岳不群教剑法的时候，不仅招式顺序不能改动。连剑抬高一公分都会被纠正回来。而风清扬这番话，眼界瞬间开拓起来。</p>
<p>风清扬后来叹道，五岳剑法就是太注重招式。最后被魔教的人，破的干干净净。我有一套剑法，里面没有招式，但无招胜有招。因为任何招式，都要遵守一定内在规律。而我这套剑法，就是破别人内在规律的。</p>
<p>剑法叫独孤九剑。里面破剑式，可以破天下剑法。破掌式，可以破天下掌法。无论未来新出什么剑法掌法招式，你都可以一剑破之。</p>
<p>同样的，当代信息爆炸，招式的更新特别快。但无论怎么变，这些招式都是从一些核心的规律变化而来的。</p>
<p>信息量增长再快，招式的新老交替再快，规律却很少变化。</p>
<p>所以，超强的学习能力，一是要高效的吸收信息，二，是能通过整理知识点，把握事情的内在规律，形成新的思维方式。</p>
<p>而死读书的人，虽然有大量的知识。但并没有处理知识的能力。就好象男生学了一大堆撩妹套路，结果从头尬聊到尾。</p>
<p>我自创了一个词，叫 “知识型结构处理器。” 便是指，能解决问题的知识体系。</p>
<p>独孤九剑就是一个巨大的处理器，天下的武功输入进去，输出的都是破解方法。</p>
<p>而每一个学科的处理器都是不一样的。</p>
<p>将汉字输入，文院学生的处理器，会出来五言律诗。</p>
<p>将杯子的颜色、花纹、材质，输入历史学生的处理器，会出来杯子的朝代，使用者的地位。</p>
<p>将生活的事物，输入商院学生的处理器，会出来各种资源调配的方法。</p>
<p>当然，越体系化的知识，这个处理器就越强大。同理，越专业的问题，越需要强大的处理器。</p>
<p>独孤九剑可以破尽天下武功，但仅仅是冷兵器学科的处理器。你用原子弹炸它，它就处理不了。</p>
<p>那我们如何分辨，自己只是记忆知识点，还是在理解知识点，建立处理器。</p>
<p>很明显的一点，就是知识是不是块状的。</p>
<p>举个例子</p>
<p>我还在学校的时候，基本上跟各种大神级辩手都见过。结果很多被吹捧为神的辩手。打比赛更多的靠运气。</p>
<p>why？你如果去问他几个问题。</p>
<p>辩论的定义是什么？ 回答：不知道。</p>
<p>辩论与吵架，有什么区别？ 回答：不知道</p>
<p>（吵架：遇到冲突时，双方不企图解决问题。而是尽力言语伤害的过程。</p>
<p>辩论：遇到冲突时，两方没有能力解决问题，只有第三方拥有解决问题的权利。二者选其一情况下，双方说服第三方的过程。）</p>
<p>那反驳逻辑的方法呢？回答：不知道</p>
<p>（逻辑学的三种基本反驳法）</p>
<p>辩题有几种类型？回答：不知道</p>
<p>（事实之辩，政策之辩，价值之辩）</p>
<p>这三个问题，是辩论中最基础的问题。决定着，打辩论的目的，打辩论的方法，准备比赛的整体结构。许多人打了四年辩论，从来没有思考过这个问题。甚至，都没有意识到基本的问题。</p>
<p>最后导致四年的收获。可能仅仅能用在辩论上。无法反哺其他领域。</p>
<p>就好象，你用辩论的技巧去应付吵架，就是大灾难。</p>
<p>如果连基本的逻辑反驳都不知道，逻辑的地基根本没建立。打再多比赛也没用。</p>
<p>所以学习的本质，就是建立一个思维处理器。处理器的系统，越具有解释力，越能处理生活的信息，就越是一个好系统。</p>
<p>查理芒格说自己一生有 100 个思维模式，其实就是说有一百个系统结构的处理器，来帮助他日常的决策。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历目录下的所有文件及文件里的sheet</title>
    <url>/2021/02/02/%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E9%87%8C%E7%9A%84sheet/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"># 遍历某目录下的Excel文件名字，加入列表</span><br><span class="line">list1 &#x3D; []</span><br><span class="line">for file in os.listdir(document_path):</span><br><span class="line">        if file.endswith(&quot;xlsx&quot;) or file.endswith(&quot;xls&quot;):</span><br><span class="line">            list1.append(file)</span><br></pre></td></tr></table></figure>
<h4 id="list1-列表大概是这样-‘a-xlsx’-‘b-xlsx’-‘c-xls’…-接下来可以用相对路径或绝对路径读取"><a href="#list1-列表大概是这样-‘a-xlsx’-‘b-xlsx’-‘c-xls’…-接下来可以用相对路径或绝对路径读取" class="headerlink" title="list1 列表大概是这样 [‘a.xlsx’,‘b.xlsx’,‘c.xls’…], 接下来可以用相对路径或绝对路径读取"></a>list1 列表大概是这样 [‘a.xlsx’,‘b.xlsx’,‘c.xls’…], 接下来可以用相对路径或绝对路径读取</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 相对路径读取,即代码与文件同目录才可以</span><br><span class="line">for i in list1:</span><br><span class="line">	pd.read_excel(i）</span><br><span class="line"># 绝对路径读取</span><br><span class="line">for i in list1:</span><br><span class="line">	excel_path &#x3D; os.path.join(document_path,i)</span><br><span class="line">	pd.read_excel(excel_path)</span><br></pre></td></tr></table></figure>
<h3 id="pandas-读取-Excel-文件下的-sheet"><a href="#pandas-读取-Excel-文件下的-sheet" class="headerlink" title="pandas 读取 Excel 文件下的 sheet"></a>pandas 读取 Excel 文件下的 sheet</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">writer &#x3D; pd.ExcelFile(&#39;.&#x2F;a.xlsx&#39;)</span><br><span class="line">sheet_len &#x3D; len(writer.sheet_names)</span><br><span class="line"># 指定下标读取</span><br><span class="line">for i in range(0,sheet_len):</span><br><span class="line">    df &#x3D; pd.read_excel(writer,sheetname&#x3D;i)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的高级数据结构详解</title>
    <url>/2021/02/07/Python%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>数据结构</p>
<p>&emsp;&emsp;数据结构的概念很好理解，就是用来将数据组织在一起的结构。换句话说，数据结构是用来存储一系列关联数据的东西。在 Python 中有四种内建的数据结构，分别是 List、Tuple、Dictionary 以及 Set。大部分的应用程序不需要其他类型的数据结构，但若是真需要也有很多高级数据结构可供选择，例如 Collection、Array、Heapq、Bisect、Weakref、Copy 以及 Pprint。本文将介绍这些数据结构的用法，看看它们是如何帮助我们的应用程序的。</p>
<a id="more"></a>

<p>&emsp;&emsp;关于四种内建数据结构的使用方法很简单，并且网上有很多参考资料，因此本文将不会讨论它们。</p>
<ol>
<li>Collections</li>
</ol>
<p>&emsp;&emsp;collections 模块包含了内建类型之外的一些有用的工具，例如 Counter、defaultdict、OrderedDict、deque 以及 nametuple。其中 Counter、deque 以及 defaultdict 是最常用的类。</p>
<p>1.1 Counter()</p>
<p>&emsp;&emsp;如果你想统计一个单词在给定的序列中一共出现了多少次，诸如此类的操作就可以用到 Counter。来看看如何统计一个 list 中出现的 item 次数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">li &#x3D; [&quot;Dog&quot;, &quot;Cat&quot;, &quot;Mouse&quot;, 42, &quot;Dog&quot;, 42, &quot;Cat&quot;, &quot;Dog&quot;]</span><br><span class="line"></span><br><span class="line">a &#x3D; Counter(li)</span><br><span class="line"></span><br><span class="line">print a # Counter(&#123;&#39;Dog&#39;: 3, 42: 2, &#39;Cat&#39;: 2, &#39;Mouse&#39;: 1&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若要统计一个 list 中不同单词的数目，可以这么用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">li &#x3D; [&quot;Dog&quot;, &quot;Cat&quot;, &quot;Mouse&quot;, 42, &quot;Dog&quot;, 42, &quot;Cat&quot;, &quot;Dog&quot;]</span><br><span class="line"></span><br><span class="line">a &#x3D; Counter(li)</span><br><span class="line"></span><br><span class="line">print a # Counter(&#123;&#39;Dog&#39;: 3, 42: 2, &#39;Cat&#39;: 2, &#39;Mouse&#39;: 1&#125;)</span><br><span class="line"></span><br><span class="line">print len(set(li)) # 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果需要对结果进行分组，可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">li &#x3D; [&quot;Dog&quot;, &quot;Cat&quot;, &quot;Mouse&quot;,&quot;Dog&quot;,&quot;Cat&quot;, &quot;Dog&quot;]</span><br><span class="line"></span><br><span class="line">a &#x3D; Counter(li)</span><br><span class="line"></span><br><span class="line">print a # Counter(&#123;&#39;Dog&#39;: 3, &#39;Cat&#39;: 2, &#39;Mouse&#39;: 1&#125;)</span><br><span class="line"></span><br><span class="line">print &quot;&#123;0&#125; : &#123;1&#125;&quot;.format(a.values(),a.keys())  # [1, 3, 2] : [&#39;Mouse&#39;, &#39;Dog&#39;, &#39;Cat&#39;]</span><br><span class="line"></span><br><span class="line">print(a.most_common(3)) # [(&#39;Dog&#39;, 3), (&#39;Cat&#39;, 2), (&#39;Mouse&#39;, 1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下的代码片段找出一个字符串中出现频率最高的单词，并打印其出现次数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">string &#x3D; &quot;&quot;&quot;   Lorem ipsum dolor sit amet, consectetur</span><br><span class="line"></span><br><span class="line">    adipiscing elit. Nunc ut elit id mi ultricies</span><br><span class="line"></span><br><span class="line">    adipiscing. Nulla facilisi. Praesent pulvinar,</span><br><span class="line"></span><br><span class="line">    sapien vel feugiat vestibulum, nulla dui pretium orci,</span><br><span class="line"></span><br><span class="line">    non ultricies elit lacus quis ante. Lorem ipsum dolor</span><br><span class="line"></span><br><span class="line">    sit amet, consectetur adipiscing elit. Aliquam</span><br><span class="line"></span><br><span class="line">    pretium ullamcorper urna quis iaculis. Etiam ac massa</span><br><span class="line"></span><br><span class="line">    sed turpis tempor luctus. Curabitur sed nibh eu elit</span><br><span class="line"></span><br><span class="line">    mollis congue. Praesent ipsum diam, consectetur vitae</span><br><span class="line"></span><br><span class="line">    ornare a, aliquam a nunc. In id magna pellentesque</span><br><span class="line"></span><br><span class="line">    tellus posuere adipiscing. Sed non mi metus, at lacinia</span><br><span class="line"></span><br><span class="line">    augue. Sed magna nisi, ornare in mollis in, mollis</span><br><span class="line"></span><br><span class="line">    sed nunc. Etiam at justo in leo congue mollis.</span><br><span class="line"></span><br><span class="line">    Nullam in neque eget metus hendrerit scelerisque</span><br><span class="line"></span><br><span class="line">    eu non enim. Ut malesuada lacus eu nulla bibendum</span><br><span class="line"></span><br><span class="line">    id euismod urna sodales.  &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">words &#x3D; re.findall(r&#39;\w+&#39;, string) #This finds words in the document</span><br><span class="line"></span><br><span class="line">lower_words &#x3D; [word.lower() for word in words] #lower all the words</span><br><span class="line"></span><br><span class="line">word_counts &#x3D; Counter(lower_words) #counts the number each time a word appears</span><br><span class="line"></span><br><span class="line">print word_counts</span><br><span class="line"></span><br><span class="line"># Counter(&#123;&#39;elit&#39;: 5, &#39;sed&#39;: 5, &#39;in&#39;: 5, &#39;adipiscing&#39;: 4, &#39;mollis&#39;: 4, &#39;eu&#39;: 3, </span><br><span class="line"></span><br><span class="line"># &#39;id&#39;: 3, &#39;nunc&#39;: 3, &#39;consectetur&#39;: 3, &#39;non&#39;: 3, &#39;ipsum&#39;: 3, &#39;nulla&#39;: 3, &#39;pretium&#39;:</span><br><span class="line"></span><br><span class="line"># 2, &#39;lacus&#39;: 2, &#39;ornare&#39;: 2, &#39;at&#39;: 2, &#39;praesent&#39;: 2, &#39;quis&#39;: 2, &#39;sit&#39;: 2, &#39;congue&#39;: 2, &#39;amet&#39;: 2, </span><br><span class="line"></span><br><span class="line"># &#39;etiam&#39;: 2, &#39;urna&#39;: 2, &#39;a&#39;: 2, &#39;magna&#39;: 2, &#39;lorem&#39;: 2, &#39;aliquam&#39;: 2, &#39;ut&#39;: 2, &#39;ultricies&#39;: 2, &#39;mi&#39;: 2, </span><br><span class="line"></span><br><span class="line"># &#39;dolor&#39;: 2, &#39;metus&#39;: 2, &#39;ac&#39;: 1, &#39;bibendum&#39;: 1, &#39;posuere&#39;: 1, &#39;enim&#39;: 1, &#39;ante&#39;: 1, &#39;sodales&#39;: 1, &#39;tellus&#39;: 1,</span><br><span class="line"></span><br><span class="line"># &#39;vitae&#39;: 1, &#39;dui&#39;: 1, &#39;diam&#39;: 1, &#39;pellentesque&#39;: 1, &#39;massa&#39;: 1, &#39;vel&#39;: 1, &#39;nullam&#39;: 1, &#39;feugiat&#39;: 1, &#39;luctus&#39;: 1, </span><br><span class="line"></span><br><span class="line"># &#39;pulvinar&#39;: 1, &#39;iaculis&#39;: 1, &#39;hendrerit&#39;: 1, &#39;orci&#39;: 1, &#39;turpis&#39;: 1, &#39;nibh&#39;: 1, &#39;scelerisque&#39;: 1, &#39;ullamcorper&#39;: 1,</span><br><span class="line"></span><br><span class="line"># &#39;eget&#39;: 1, &#39;neque&#39;: 1, &#39;euismod&#39;: 1, &#39;curabitur&#39;: 1, &#39;leo&#39;: 1, &#39;sapien&#39;: 1, &#39;facilisi&#39;: 1, &#39;vestibulum&#39;: 1, &#39;nisi&#39;: 1, </span><br><span class="line"></span><br><span class="line"># &#39;justo&#39;: 1, &#39;augue&#39;: 1, &#39;tempor&#39;: 1, &#39;lacinia&#39;: 1, &#39;malesuada&#39;: 1&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1.2 Deque</p>
<p>　　Deque 是一种由队列结构扩展而来的双端队列 (double-ended queue)，队列元素能够在队列两端添加或删除。因此它还被称为头尾连接列表 (head-tail linked list)，尽管叫这个名字的还有另一个特殊的数据结构实现。</p>
<p>　　Deque 支持线程安全的，经过优化的 append 和 pop 操作，在队列两端的相关操作都能够达到近乎 O (1) 的时间复杂度。虽然 list 也支持类似的操作，但是它是对定长列表的操作表现很不错，而当遇到 pop (0) 和 insert (0, v) 这样既改变了列表的长度又改变其元素位置的操作时，其复杂度就变为 O (n) 了。</p>
<p>　　来看看相关的比较结果：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">from collections import deque</span><br><span class="line"> </span><br><span class="line">num &#x3D; 100000</span><br><span class="line"> </span><br><span class="line">def append(c):</span><br><span class="line">    for i in range(num):</span><br><span class="line">        c.append(i)</span><br><span class="line"> </span><br><span class="line">def appendleft(c):</span><br><span class="line">    if isinstance(c, deque):</span><br><span class="line">        for i in range(num):</span><br><span class="line">            c.appendleft(i)</span><br><span class="line">    else:</span><br><span class="line">        for i in range(num):</span><br><span class="line">            c.insert(0, i)</span><br><span class="line">def pop(c):</span><br><span class="line">    for i in range(num):</span><br><span class="line">        c.pop()</span><br><span class="line"> </span><br><span class="line">def popleft(c):</span><br><span class="line">    if isinstance(c, deque):</span><br><span class="line">        for i in range(num):</span><br><span class="line">            c.popleft()</span><br><span class="line">    else:</span><br><span class="line">        for i in range(num):</span><br><span class="line">            c.pop(0)</span><br><span class="line"> </span><br><span class="line">for container in [deque, list]:</span><br><span class="line">    for operation in [append, appendleft, pop, popleft]:</span><br><span class="line">        c &#x3D; container(range(num))</span><br><span class="line">        start &#x3D; time.time()</span><br><span class="line">        operation(c)</span><br><span class="line">        elapsed &#x3D; time.time() - start</span><br><span class="line">        print &quot;Completed &#123;0&#125;&#x2F;&#123;1&#125; in &#123;2&#125; seconds: &#123;3&#125; ops&#x2F;sec&quot;.format(</span><br><span class="line">              container.__name__, operation.__name__, elapsed, num &#x2F; elapsed)</span><br><span class="line"> </span><br><span class="line"># Completed deque&#x2F;append in 0.0250000953674 seconds: 3999984.74127 ops&#x2F;sec</span><br><span class="line"># Completed deque&#x2F;appendleft in 0.0199999809265 seconds: 5000004.76838 ops&#x2F;sec</span><br><span class="line"># Completed deque&#x2F;pop in 0.0209999084473 seconds: 4761925.52225 ops&#x2F;sec</span><br><span class="line"># Completed deque&#x2F;popleft in 0.0199999809265 seconds: 5000004.76838 ops&#x2F;sec</span><br><span class="line"># Completed list&#x2F;append in 0.0220000743866 seconds: 4545439.17637 ops&#x2F;sec</span><br><span class="line"># Completed list&#x2F;appendleft in 21.3209998608 seconds: 4690.21155917 ops&#x2F;sec</span><br><span class="line"># Completed list&#x2F;pop in 0.0240001678467 seconds: 4166637.52682 ops&#x2F;sec</span><br><span class="line"># Completed list&#x2F;popleft in 4.01799988747 seconds: 24888.0046791 ops&#x2F;sec</span><br></pre></td></tr></table></figure>
<p>另一个例子是执行基本的队列操作：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">q &#x3D; deque(range(5))</span><br><span class="line">q.append(5)</span><br><span class="line">q.appendleft(6)</span><br><span class="line">print q</span><br><span class="line">print q.pop()</span><br><span class="line">print q.popleft()</span><br><span class="line">print q.rotate(3)</span><br><span class="line">print q</span><br><span class="line">print q.rotate(-1)</span><br><span class="line">print q</span><br><span class="line"> </span><br><span class="line"># deque([6, 0, 1, 2, 3, 4, 5])</span><br><span class="line"># 5</span><br><span class="line"># 6</span><br><span class="line"># None</span><br><span class="line"># deque([2, 3, 4, 0, 1])</span><br><span class="line"># None</span><br><span class="line"># deque([3, 4, 0, 1, 2])</span><br></pre></td></tr></table></figure>
<p>译者注:rotate 是队列的旋转操作，Right rotate (正参数) 是将右端的元素移动到左端，而 Left rotate (负参数) 则相反。</p>
<p>1.3 Defaultdict</p>
<p>　　这个类型除了在处理不存在的键的操作之外与普通的字典完全相同。当查找一个不存在的键操作发生时，它的 default_factory 会被调用，提供一个默认的值，并且将这对键值存储下来。其他的参数同普通的字典方法 dict () 一致，一个 defaultdict 的实例同内建 dict 一样拥有同样地操作。</p>
<p>　　defaultdict 对象在当你希望使用它存放追踪数据的时候很有用。举个例子，假定你希望追踪一个单词在字符串中的位置，那么你可以这么做：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"> </span><br><span class="line">s &#x3D; &quot;the quick brown fox jumps over the lazy dog&quot;</span><br><span class="line"> </span><br><span class="line">words &#x3D; s.split()</span><br><span class="line">location &#x3D; defaultdict(list)</span><br><span class="line">for m, n in enumerate(words):</span><br><span class="line">    location[n].append(m)</span><br><span class="line"> </span><br><span class="line">print location</span><br><span class="line"> </span><br><span class="line"># defaultdict(&lt;type &#39;list&#39;&gt;, &#123;&#39;brown&#39;: [2], &#39;lazy&#39;: [7], &#39;over&#39;: [5], &#39;fox&#39;: [3],</span><br><span class="line"># &#39;dog&#39;: [8], &#39;quick&#39;: [1], &#39;the&#39;: [0, 6], &#39;jumps&#39;: [4]&#125;)</span><br></pre></td></tr></table></figure>
<p>是选择 lists 或 sets 与 defaultdict 搭配取决于你的目的，使用 list 能够保存你插入元素的顺序，而使用 set 则不关心元素插入顺序，它会帮助消除重复元素。<br>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"> </span><br><span class="line">s &#x3D; &quot;the quick brown fox jumps over the lazy dog&quot;</span><br><span class="line"> </span><br><span class="line">words &#x3D; s.split()</span><br><span class="line">location &#x3D; defaultdict(set)</span><br><span class="line">for m, n in enumerate(words):</span><br><span class="line">    location[n].add(m)</span><br><span class="line"> </span><br><span class="line">print location</span><br><span class="line"> </span><br><span class="line"># defaultdict(&lt;type &#39;set&#39;&gt;, &#123;&#39;brown&#39;: set([2]), &#39;lazy&#39;: set([7]),</span><br><span class="line"># &#39;over&#39;: set([5]), &#39;fox&#39;: set([3]), &#39;dog&#39;: set([8]), &#39;quick&#39;: set([1]),</span><br><span class="line"># &#39;the&#39;: set([0, 6]), &#39;jumps&#39;: set([4])&#125;)</span><br></pre></td></tr></table></figure>
<p>另一种创建 multidict 的方法：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;the quick brown fox jumps over the lazy dog&quot;</span><br><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">words &#x3D; s.split()</span><br><span class="line"> </span><br><span class="line">for key, value in enumerate(words):</span><br><span class="line">    d.setdefault(key, []).append(value)</span><br><span class="line">print d</span><br><span class="line"> </span><br><span class="line"># &#123;0: [&#39;the&#39;], 1: [&#39;quick&#39;], 2: [&#39;brown&#39;], 3: [&#39;fox&#39;], 4: [&#39;jumps&#39;], 5: [&#39;over&#39;], 6: [&#39;the&#39;], 7: [&#39;lazy&#39;], 8: [&#39;dog&#39;]&#125;</span><br></pre></td></tr></table></figure>
<p>一个更复杂的例子：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example(dict):</span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        try:</span><br><span class="line">            return dict.__getitem__(self, item)</span><br><span class="line">        except KeyError:</span><br><span class="line">            value &#x3D; self[item] &#x3D; type(self)()</span><br><span class="line">            return value</span><br><span class="line"> </span><br><span class="line">a &#x3D; Example()</span><br><span class="line"> </span><br><span class="line">a[1][2][3] &#x3D; 4</span><br><span class="line">a[1][3][3] &#x3D; 5</span><br><span class="line">a[1][2][&#39;test&#39;] &#x3D; 6</span><br><span class="line"> </span><br><span class="line">print a # &#123;1: &#123;2: &#123;&#39;test&#39;: 6, 3: 4&#125;, 3: &#123;3: 5&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Array<br>　　array 模块定义了一个很像 list 的新对象类型，不同之处在于它限定了这个类型只能装一种类型的元素。array 元素的类型是在创建并使用的时候确定的。</li>
</ol>
<p>　　如果你的程序需要优化内存的使用，并且你确定你希望在 list 中存储的数据都是同样类型的，那么使用 array 模块很合适。举个例子，如果需要存储一千万个整数，如果用 list，那么你至少需要 160MB 的存储空间，然而如果使用 array，你只需要 40MB。但虽然说能够节省空间，array 上几乎没有什么基本操作能够比在 list 上更快。</p>
<p>　　在使用 array 进行计算的时候，需要特别注意那些创建 list 的操作。例如，使用列表推导式 (list comprehension) 的时候，会将 array 整个转换为 list，使得存储空间膨胀。一个可行的替代方案是使用生成器表达式创建新的 array。看代码：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import array</span><br><span class="line"> </span><br><span class="line">a &#x3D; array.array(&quot;i&quot;, [1,2,3,4,5])</span><br><span class="line">b &#x3D; array.array(a.typecode, (2*x for x in a))</span><br></pre></td></tr></table></figure>
<p>　　因为使用 array 是为了节省空间，所以更倾向于使用 in-place 操作。一种更高效的方法是使用 enumerate：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import array</span><br><span class="line"> </span><br><span class="line">a &#x3D; array.array(&quot;i&quot;, [1,2,3,4,5])</span><br><span class="line">for i, x in enumerate(a):</span><br><span class="line">    a[i] &#x3D; 2*x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　对于较大的 array，这种 in-place 修改能够比用生成器创建一个新的 array 至少提升 15% 的速度。</p>
<p>　　那么什么时候使用 array 呢？是当你在考虑计算的因素之外，还需要得到一个像 C 语言里一样统一元素类型的数组时。</p>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import array</span><br><span class="line">from timeit import Timer</span><br><span class="line"> </span><br><span class="line">def arraytest():</span><br><span class="line">    a &#x3D; array.array(&quot;i&quot;, [1, 2, 3, 4, 5])</span><br><span class="line">    b &#x3D; array.array(a.typecode, (2 * x for x in a))</span><br><span class="line"> </span><br><span class="line">def enumeratetest():</span><br><span class="line">    a &#x3D; array.array(&quot;i&quot;, [1, 2, 3, 4, 5])</span><br><span class="line">    for i, x in enumerate(a):</span><br><span class="line">        a[i] &#x3D; 2 * x</span><br><span class="line"> </span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    m &#x3D; Timer(&quot;arraytest()&quot;, &quot;from __main__ import arraytest&quot;)</span><br><span class="line">    n &#x3D; Timer(&quot;enumeratetest()&quot;, &quot;from __main__ import enumeratetest&quot;)</span><br><span class="line"> </span><br><span class="line">    print m.timeit() # 5.22479210582</span><br><span class="line">    print n.timeit() # 4.34367196717</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.Heapq</p>
<p>　　heapq 模块使用一个用堆实现的优先级队列。堆是一种简单的有序列表，并且置入了堆的相关规则。</p>
<p>　　堆是一种树形的数据结构，树上的子节点与父节点之间存在顺序关系。二叉堆 (binary heap) 能够用一个经过组织的列表或数组结构来标识，在这种结构中，元素 N 的子节点的序号为 2<em>N+1 和 2</em>N+2 (下标始于 0)。简单来说，这个模块中的所有函数都假设序列是有序的，所以序列中的第一个元素 (seq [0]) 是最小的，序列的其他部分构成一个二叉树，并且 seq [i] 节点的子节点分别为 seq [2<em>i+1] 以及 seq [2</em>i+2]。当对序列进行修改时，相关函数总是确保子节点大于等于父节点。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"> </span><br><span class="line">heap &#x3D; []</span><br><span class="line"> </span><br><span class="line">for value in [20, 10, 30, 50, 40]:</span><br><span class="line">    heapq.heappush(heap, value)</span><br><span class="line"> </span><br><span class="line">while heap:</span><br><span class="line">    print heapq.heappop(heap)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　heapq 模块有两个函数 nlargest () 和 nsmallest ()，顾名思义，让我们来看看它们的用法。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"> </span><br><span class="line">nums &#x3D; [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]</span><br><span class="line">print(heapq.nlargest(3, nums)) # Prints [42, 37, 23]</span><br><span class="line">print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]</span><br></pre></td></tr></table></figure>
<p>两个函数也能够通过一个键参数使用更为复杂的数据结构，例如：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"> </span><br><span class="line">portfolio &#x3D; [</span><br><span class="line">&#123;&#39;name&#39;: &#39;IBM&#39;, &#39;shares&#39;: 100, &#39;price&#39;: 91.1&#125;,</span><br><span class="line">&#123;&#39;name&#39;: &#39;AAPL&#39;, &#39;shares&#39;: 50, &#39;price&#39;: 543.22&#125;,</span><br><span class="line">&#123;&#39;name&#39;: &#39;FB&#39;, &#39;shares&#39;: 200, &#39;price&#39;: 21.09&#125;,</span><br><span class="line">&#123;&#39;name&#39;: &#39;HPQ&#39;, &#39;shares&#39;: 35, &#39;price&#39;: 31.75&#125;,</span><br><span class="line">&#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 45, &#39;price&#39;: 16.35&#125;,</span><br><span class="line">&#123;&#39;name&#39;: &#39;ACME&#39;, &#39;shares&#39;: 75, &#39;price&#39;: 115.65&#125;</span><br><span class="line">]</span><br><span class="line">cheap &#x3D; heapq.nsmallest(3, portfolio, key&#x3D;lambda s: s[&#39;price&#39;])</span><br><span class="line">expensive &#x3D; heapq.nlargest(3, portfolio, key&#x3D;lambda s: s[&#39;price&#39;])</span><br><span class="line"> </span><br><span class="line">print cheap</span><br><span class="line"> </span><br><span class="line"># [&#123;&#39;price&#39;: 16.35, &#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 45&#125;,</span><br><span class="line"># &#123;&#39;price&#39;: 21.09, &#39;name&#39;: &#39;FB&#39;, &#39;shares&#39;: 200&#125;, &#123;&#39;price&#39;: 31.75, &#39;name&#39;: &#39;HPQ&#39;, &#39;shares&#39;: 35&#125;]</span><br><span class="line"> </span><br><span class="line">print expensive</span><br><span class="line"> </span><br><span class="line"># [&#123;&#39;price&#39;: 543.22, &#39;name&#39;: &#39;AAPL&#39;, &#39;shares&#39;: 50&#125;, &#123;&#39;price&#39;: 115.65, &#39;name&#39;: &#39;ACME&#39;,</span><br><span class="line"># &#39;shares&#39;: 75&#125;, &#123;&#39;price&#39;: 91.1, &#39;name&#39;: &#39;IBM&#39;, &#39;shares&#39;: 100&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　来看看如何实现一个根据给定优先级进行排序，并且每次 pop 操作都返回优先级最高的元素的队列例子。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"> </span><br><span class="line">class Item:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"> </span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#39;Item(&#123;!r&#125;)&#39;.format(self.name)</span><br><span class="line"> </span><br><span class="line">class PriorityQueue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._queue &#x3D; []</span><br><span class="line">        self._index &#x3D; 0</span><br><span class="line"> </span><br><span class="line">    def push(self, item, priority):</span><br><span class="line">        heapq.heappush(self._queue, (-priority, self._index, item))</span><br><span class="line">        self._index +&#x3D; 1</span><br><span class="line"> </span><br><span class="line">    def pop(self):</span><br><span class="line">        return heapq.heappop(self._queue)[-1]</span><br><span class="line"> </span><br><span class="line">q &#x3D; PriorityQueue()</span><br><span class="line">q.push(Item(&#39;foo&#39;), 1)</span><br><span class="line">q.push(Item(&#39;bar&#39;), 5)</span><br><span class="line">q.push(Item(&#39;spam&#39;), 4)</span><br><span class="line">q.push(Item(&#39;grok&#39;), 1)</span><br><span class="line"> </span><br><span class="line">print q.pop() # Item(&#39;bar&#39;)</span><br><span class="line">print q.pop() # Item(&#39;spam&#39;)</span><br><span class="line">print q.pop() # Item(&#39;foo&#39;)</span><br><span class="line">print q.pop() # Item(&#39;grok&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Bisect</li>
</ol>
<p>　　bisect 模块能够提供保持 list 元素序列的支持。它使用了二分法完成大部分的工作。它在向一个 list 插入元素的同时维持 list 是有序的。在某些情况下，这比重复的对一个 list 进行排序更为高效，并且对于一个较大的 list 来说，对每步操作维持其有序也比对其排序要高效。</p>
<p>　　假设你有一个 range 集合：</p>
<p>复制代码代码如下:</p>
<p><code>a = [(0, 100), (150, 220), (500, 1000)]</code></p>
<p>　　如果我想添加一个 range (250, 400)，我可能会这么做：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import bisect</span><br><span class="line"> </span><br><span class="line">a &#x3D; [(0, 100), (150, 220), (500, 1000)]</span><br><span class="line"> </span><br><span class="line">bisect.insort_right(a, (250,400))</span><br><span class="line"> </span><br><span class="line">print a # [(0, 100), (150, 220), (250, 400), (500, 1000)]</span><br></pre></td></tr></table></figure>
<p>　　我们可以使用 bisect () 函数来寻找插入点：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import bisect</span><br><span class="line"> </span><br><span class="line">a &#x3D; [(0, 100), (150, 220), (500, 1000)]</span><br><span class="line"> </span><br><span class="line">bisect.insort_right(a, (250,400))</span><br><span class="line">bisect.insort_right(a, (399, 450))</span><br><span class="line">print a # [(0, 100), (150, 220), (250, 400), (500, 1000)]</span><br><span class="line"> </span><br><span class="line">print bisect.bisect(a, (550, 1200)) # 5</span><br></pre></td></tr></table></figure>
<p>　　<code>bisect (sequence, item) =&gt; index 返回元素应该的插入点，但序列并不被修改。</code></p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import bisect</span><br><span class="line"> </span><br><span class="line">a &#x3D; [(0, 100), (150, 220), (500, 1000)]</span><br><span class="line"> </span><br><span class="line">bisect.insort_right(a, (250,400))</span><br><span class="line">bisect.insort_right(a, (399, 450))</span><br><span class="line">print a # [(0, 100), (150, 220), (250, 400), (500, 1000)]</span><br><span class="line"> </span><br><span class="line">print bisect.bisect(a, (550, 1200)) # 5</span><br><span class="line">bisect.insort_right(a, (550, 1200))</span><br><span class="line">print a # [(0, 100), (150, 220), (250, 400), (399, 450), (500, 1000), (550, 1200)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新元素被插入到第 5 的位置。</p>
<ol start="5">
<li>Weakref</li>
</ol>
<p>　　weakref 模块能够帮助我们创建 Python 引用，却不会阻止对象的销毁操作。这一节包含了 weak reference 的基本用法，并且引入一个代理类。</p>
<p>　　在开始之前，我们需要明白什么是 strong reference。strong reference 是一个对对象的引用次数、生命周期以及销毁时机产生影响的指针。strong reference 如你所见，就是当你将一个对象赋值给一个变量的时候产生的：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a</span><br></pre></td></tr></table></figure>
<p>　　在这种情况下，这个列表有两个 strong reference，分别是 a 和 b。在这两个引用都被释放之前，这个 list 不会被销毁。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.obj &#x3D; None</span><br><span class="line">        print &#39;created&#39;</span><br><span class="line"> </span><br><span class="line">    def __del__(self):</span><br><span class="line">        print &#39;destroyed&#39;</span><br><span class="line"> </span><br><span class="line">    def show(self):</span><br><span class="line">        print self.obj</span><br><span class="line"> </span><br><span class="line">    def store(self, obj):</span><br><span class="line">        self.obj &#x3D; obj</span><br><span class="line"> </span><br><span class="line">a &#x3D; Foo() # created</span><br><span class="line">b &#x3D; a</span><br><span class="line">del a</span><br><span class="line">del b # destroyed</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　Weak reference 则是对对象的引用计数器不会产生影响。当一个对象存在 weak reference 时，并不会影响对象的撤销。这就说，如果一个对象仅剩下 weak reference，那么它将会被销毁。</p>
<p>　　你可以使用 weakref.ref 函数来创建对象的 weak reference。这个函数调用需要将一个 strong reference 作为第一个参数传给函数，并且返回一个 weak reference。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import weakref</span><br><span class="line">&gt;&gt;&gt; a &#x3D; Foo()</span><br><span class="line">created</span><br><span class="line">&gt;&gt;&gt; b &#x3D; weakref.ref(a)</span><br><span class="line">&gt;&gt;&gt; b</span><br></pre></td></tr></table></figure>
<p>　　一个临时的 strong reference 可以从 weak reference 中创建，即是下例中的 b ()：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b().show()</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>　　请注意当我们删除 strong reference 的时候，对象将立即被销毁。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; del a</span><br><span class="line">destroyed</span><br></pre></td></tr></table></figure>
<p>　　如果试图在对象被摧毁之后通过 weak reference 使用对象，则会返回 None：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b() is None</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>若是使用 weakref.proxy，就能提供相对于 weakref.ref 更透明的可选操作。同样是使用一个 strong reference 作为第一个参数并且返回一个 weak reference，proxy 更像是一个 strong reference，但当对象不存在时会抛出异常。<br>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; Foo()</span><br><span class="line">created</span><br><span class="line">&gt;&gt;&gt; b &#x3D; weakref.proxy(a)</span><br><span class="line">&gt;&gt;&gt; b.store(&#39;fish&#39;)</span><br><span class="line">&gt;&gt;&gt; b.show()</span><br><span class="line">fish</span><br><span class="line">&gt;&gt;&gt; del a</span><br><span class="line">destroyed</span><br><span class="line">&gt;&gt;&gt; b.show()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&quot;, line 1, in ?</span><br><span class="line">ReferenceError: weakly-referenced object no longer exists</span><br></pre></td></tr></table></figure>
<p>完整的例子：<br>　　引用计数器是由 Python 的垃圾回收器使用的，当一个对象的应用计数器变为 0，则其将会被垃圾回收器回收。</p>
<p>　　最好将 weak reference 用于开销较大的对象，或避免循环引用 (虽然垃圾回收器经常干这种事情)。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import weakref</span><br><span class="line">import gc</span><br><span class="line"> </span><br><span class="line">class MyObject(object):</span><br><span class="line">    def my_method(self):</span><br><span class="line">        print &#39;my_method was called!&#39;</span><br><span class="line"> </span><br><span class="line">obj &#x3D; MyObject()</span><br><span class="line">r &#x3D; weakref.ref(obj)</span><br><span class="line"> </span><br><span class="line">gc.collect()</span><br><span class="line">assert r() is obj #r() allows you to access the object referenced: it&#39;s there.</span><br><span class="line"> </span><br><span class="line">obj &#x3D; 1 #Let&#39;s change what obj references to</span><br><span class="line">gc.collect()</span><br><span class="line">assert r() is None #There is no object left: it was gc&#39;ed.</span><br></pre></td></tr></table></figure>
<p>　　提示：只有 library 模块中定义的 class instances、functions、methods、sets、frozen sets、files、generators、type objects 和 certain object types (例如 sockets、arrays 和 regular expression patterns) 支持 weakref。内建函数以及大部分内建类型如 lists、dictionaries、strings 和 numbers 则不支持。</p>
<ol start="6">
<li>Copy()</li>
</ol>
<p>　　通过 shallow 或 deep copy 语法提供复制对象的函数操作。</p>
<p>　　shallow 和 deep copying 的不同之处在于对于混合型对象的操作 (混合对象是包含了其他类型对象的对象，例如 list 或其他类实例)。</p>
<ol>
<li>对于 shallow copy 而言，它创建一个新的混合对象，并且将原对象中其他对象的引用插入新对象。</li>
<li>对于 deep copy 而言，它创建一个新的对象，并且递归地复制源对象中的其他对象并插入新的对象中。</li>
</ol>
<p>　　普通的赋值操作知识简单的将心变量指向源对象。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"> </span><br><span class="line">a &#x3D; [1,2,3]</span><br><span class="line">b &#x3D; [4,5]</span><br><span class="line"> </span><br><span class="line">c &#x3D; [a,b]</span><br><span class="line"> </span><br><span class="line"># Normal Assignment</span><br><span class="line">d &#x3D; c</span><br><span class="line"> </span><br><span class="line">print id(c) &#x3D;&#x3D; id(d)          # True - d is the same object as c</span><br><span class="line">print id(c[0]) &#x3D;&#x3D; id(d[0])    # True - d[0] is the same object as c[0]</span><br><span class="line"> </span><br><span class="line"># Shallow Copy</span><br><span class="line">d &#x3D; copy.copy(c)</span><br><span class="line"> </span><br><span class="line">print id(c) &#x3D;&#x3D; id(d)          # False - d is now a new object</span><br><span class="line">print id(c[0]) &#x3D;&#x3D; id(d[0])    # True - d[0] is the same object as c[0]</span><br><span class="line"> </span><br><span class="line"># Deep Copy</span><br><span class="line">d &#x3D; copy.deepcopy(c)</span><br><span class="line"> </span><br><span class="line">print id(c) &#x3D;&#x3D; id(d)          # False - d is now a new object</span><br><span class="line">print id(c[0]) &#x3D;&#x3D; id(d[0])    # False - d[0] is now a new object</span><br></pre></td></tr></table></figure>
<p>shallow copy (copy ()) 操作创建一个新的容器，其包含的引用指向原对象中的对象。</p>
<p>deep copy (deepcopy ()) 创建的对象包含的引用指向复制出来的新对象。</p>
<p>　　复杂的例子：</p>
<p>　　假定我有两个类，名为 Manager 和 Graph，每个 Graph 包含了一个指向其 manager 的引用，而每个 Manager 有一个指向其管理的 Graph 的集合，现在我们有两个任务需要完成：</p>
<p>　　1) 复制一个 graph 实例，使用 deepcopy，但其 manager 指向为原 graph 的 manager。</p>
<p>　　2) 复制一个 manager，完全创建新 manager，但拷贝原有的所有 graph。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import weakref, copy</span><br><span class="line"> </span><br><span class="line">class Graph(object):</span><br><span class="line">    def __init__(self, manager&#x3D;None):</span><br><span class="line">        self.manager &#x3D; None if manager is None else weakref.ref(manager)</span><br><span class="line">    def __deepcopy__(self, memodict):</span><br><span class="line">        manager &#x3D; self.manager()</span><br><span class="line">        return Graph(memodict.get(id(manager), manager))</span><br><span class="line"> </span><br><span class="line">class Manager(object):</span><br><span class="line">    def __init__(self, graphs&#x3D;[]):</span><br><span class="line">        self.graphs &#x3D; graphs</span><br><span class="line">        for g in self.graphs:</span><br><span class="line">            g.manager &#x3D; weakref.ref(self)</span><br><span class="line"> </span><br><span class="line">a &#x3D; Manager([Graph(), Graph()])</span><br><span class="line">b &#x3D; copy.deepcopy(a)</span><br><span class="line"> </span><br><span class="line">if [g.manager() is b for g in b.graphs]:</span><br><span class="line">    print True # True</span><br><span class="line"> </span><br><span class="line">if copy.deepcopy(a.graphs[0]).manager() is a:</span><br><span class="line">    print True # True</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>Pprint()</li>
</ol>
<p>Pprint 模块能够提供比较优雅的数据结构打印方式，如果你需要打印一个结构较为复杂，层次较深的字典或是 JSON 对象时，使用 Pprint 能够提供较好的打印结果。</p>
<p>假定你需要打印一个矩阵，当使用普通的 print 时，你只能打印出普通的列表，不过如果使用 pprint，你就能打出漂亮的矩阵结构</p>
<p>如果</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pprint</span><br><span class="line"> </span><br><span class="line">matrix &#x3D; [ [1,2,3], [4,5,6], [7,8,9] ]</span><br><span class="line">a &#x3D; pprint.PrettyPrinter(width&#x3D;20)</span><br><span class="line">a.pprint(matrix)</span><br><span class="line"> </span><br><span class="line"># [[1, 2, 3],</span><br><span class="line">#  [4, 5, 6],</span><br><span class="line">#  [7, 8, 9]]</span><br></pre></td></tr></table></figure>
<p>额外的知识</p>
<p>一些基本的数据结构</p>
<ol>
<li>单链链表</li>
</ol>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data &#x3D; None</span><br><span class="line">        self.nextNode &#x3D; None</span><br><span class="line"> </span><br><span class="line">    def set_and_return_Next(self):</span><br><span class="line">        self.nextNode &#x3D; Node()</span><br><span class="line">        return self.nextNode</span><br><span class="line"> </span><br><span class="line">    def getNext(self):</span><br><span class="line">        return self.nextNode</span><br><span class="line"> </span><br><span class="line">    def getData(self):</span><br><span class="line">        return self.data</span><br><span class="line"> </span><br><span class="line">    def setData(self, d):</span><br><span class="line">        self.data &#x3D; d</span><br><span class="line"> </span><br><span class="line">class LinkedList:</span><br><span class="line">    def buildList(self, array):</span><br><span class="line">        self.head &#x3D; Node()</span><br><span class="line">        self.head.setData(array[0])</span><br><span class="line">        self.temp &#x3D; self.head</span><br><span class="line">        for i in array[1:]:</span><br><span class="line">            self.temp &#x3D; self.temp.set_and_return_Next()</span><br><span class="line">            self.temp.setData(i)</span><br><span class="line">            self.tail &#x3D; self.temp</span><br><span class="line">        return self.head</span><br><span class="line">    def printList(self):</span><br><span class="line">        tempNode &#x3D; self.head</span><br><span class="line">        while(tempNode!&#x3D;self.tail):</span><br><span class="line">            print(tempNode.getData())</span><br><span class="line">            tempNode &#x3D; tempNode.getNext()</span><br><span class="line">        print(self.tail.getData())</span><br><span class="line">myArray &#x3D; [3, 5, 4, 6, 2, 6, 7, 8, 9, 10, 21]</span><br><span class="line"> </span><br><span class="line">myList &#x3D; LinkedList()</span><br><span class="line">myList.buildList(myArray)</span><br><span class="line">myList.printList()</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用 Python 实现的普林姆算法</li>
</ol>
<p>　　译者注：普林姆算法 (Prims Algorithm) 是图论中，在加权连通图中搜索最小生成树的算法。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">from heapq import heapify, heappop, heappush</span><br><span class="line"> </span><br><span class="line">def prim( nodes, edges ):</span><br><span class="line">    conn &#x3D; defaultdict( list )</span><br><span class="line">    for n1,n2,c in edges:</span><br><span class="line">        conn[ n1 ].append( (c, n1, n2) )</span><br><span class="line">        conn[ n2 ].append( (c, n2, n1) )</span><br><span class="line"> </span><br><span class="line">    mst &#x3D; []</span><br><span class="line">    used &#x3D; set( nodes[ 0 ] )</span><br><span class="line">    usable_edges &#x3D; conn[ nodes[0] ][:]</span><br><span class="line">    heapify( usable_edges )</span><br><span class="line"> </span><br><span class="line">    while usable_edges:</span><br><span class="line">        cost, n1, n2 &#x3D; heappop( usable_edges )</span><br><span class="line">        if n2 not in used:</span><br><span class="line">            used.add( n2 )</span><br><span class="line">            mst.append( ( n1, n2, cost ) )</span><br><span class="line"> </span><br><span class="line">            for e in conn[ n2 ]:</span><br><span class="line">                if e[ 2 ] not in used:</span><br><span class="line">                    heappush( usable_edges, e )</span><br><span class="line">    return mst</span><br><span class="line"> </span><br><span class="line">#test</span><br><span class="line">nodes &#x3D; list(&quot;ABCDEFG&quot;)</span><br><span class="line">edges &#x3D; [ (&quot;A&quot;, &quot;B&quot;, 7), (&quot;A&quot;, &quot;D&quot;, 5),</span><br><span class="line">          (&quot;B&quot;, &quot;C&quot;, 8), (&quot;B&quot;, &quot;D&quot;, 9), (&quot;B&quot;, &quot;E&quot;, 7),</span><br><span class="line">      (&quot;C&quot;, &quot;E&quot;, 5),</span><br><span class="line">      (&quot;D&quot;, &quot;E&quot;, 15), (&quot;D&quot;, &quot;F&quot;, 6),</span><br><span class="line">      (&quot;E&quot;, &quot;F&quot;, 8), (&quot;E&quot;, &quot;G&quot;, 9),</span><br><span class="line">      (&quot;F&quot;, &quot;G&quot;, 11)]</span><br><span class="line"> </span><br><span class="line">print &quot;prim:&quot;, prim( nodes, edges )</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>如何克服紧张情绪</title>
    <url>/2021/01/28/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E7%B4%A7%E5%BC%A0%E6%83%85%E7%BB%AA/</url>
    <content><![CDATA[<p>&emsp;&emsp;紧张情绪总是伴随着我们的成长，并随着成长逐渐增加，我们会发现以前会逃避的东西，现在逃不掉了。所以这个问题急需解决，有一篇不错，搬了过来，准备随时学习用。</p>
<p><a href="http://www.360doc.com/content/10/0731/17/601194_42756242.shtml">转自</a></p>
<p>&emsp;&emsp;《抓住让人瞩目的机会：当众讲话让掌声响起》作者为北京卡耐基学校校长黄久凌先生十年潜心研究语言魅力的成果，是符合中国社会语境的当众讲话艺术结晶。本文系我从该书中节选，通过自己在文字和文章结构上重新修改编排整理而就，使之更具针对性和操作性。标题系自己提的。</p>
<p>&emsp;&emsp;当众讲话总是伴随着一个人的职业发展悄悄地来到人们面前。因为当众讲话是与我们职业发展联系最密切的一种讲话形式。职场中，很多场合都需要当众讲话：求职面试、竞聘职位、工作述职、汇报说明、总结报告、发表意见、主持活动、商务谈判、宣传产品、激励员工、接受采访、会议发言等。当众讲话是一个人在职场上必备的基本技能，也是管理者对人管理的必要工具。英国前首相邱吉尔曾说过一句经典的话：“你能对着多少人当众讲话，你的事业就会有多大！” 可见，当众讲话是一门不可不学的一课。学习当众讲话对表达能力的提高、个性的改善、社交能力的提升都有很大作用。可是，绝大多数人对于当众讲话都感到紧张恐怖。看来，紧张是绝大部分讲话者面对听众时首先遇到的最大障碍。所以，我们一定要突破当众讲话让我们感觉到紧张的心理障碍.</p>
<p>&emsp;&emsp;美国成人教育家戴尔・卡耐基先生毕生都在训练成人有效地说话。他认为，成人学习当众讲话，最大的障碍便是紧张。他说：“我一生几乎都在致力于帮助人们克服登台的恐惧，增强勇气和自信。”。<br>&emsp;&emsp;何谓紧张？紧张首先是人应对恶劣环境的一种本能反应。人的身体向来就会对外在的刺激保持警觉，一旦感到不利于自己的情况发生，就会出现紧张反应，比如肌肉绷紧、心跳加快、手心出汗等，这些反应不用大脑思考，是人的本能，表明人体的紧急预案已经启动，它会让人大脑兴奋、精神集中、创新能力增强，使人的潜能发挥有了可能，所以，许多专家认为紧张、压力是激发潜能的有利因素.  而紧张不见得是件坏事，适度紧张不但无害，还会起到积极的作用。对于当众讲话来说，适度紧张会让我们重视听众，重视我们的表达方式，不会懈怠。只要你在乎听众，想给听众留下好印象，自然就会重视你的讲话，不会完全放松。我们前面提到的很多演讲家终身没有消除演讲的紧张也是这个道理，这样反而会增强表达的效果 。<br>&emsp;&emsp;很多人不了解这个事实，往往以为别人讲话都不紧张，而天底下只有自己讲话紧张，当众讲话也会紧张，远不止我们这些普通人。只有 “紧张” 和 “过度紧张” 才是我们真正要调整和突破的。因此我们没有必要去担心轻微、适度的紧张，只有过分紧张造成了思维停滞言辞不畅，我们才需要把它降低到一定程度，让它成为一种助力而不是阻力。</p>
<p>&emsp;&emsp;下面列出人们在讲话时怀有不同程度的紧张度及其表现：</p>
<table>
<thead>
<tr>
<th align="left">表现紧张程度</th>
<th align="center">心理状态</th>
<th align="center">身体表现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">不紧张</td>
<td align="center">毫不在乎</td>
<td align="center">松懈</td>
</tr>
<tr>
<td align="left">适度紧张</td>
<td align="center">感到压力不够轻松</td>
<td align="center">重视，会经常思考</td>
</tr>
<tr>
<td align="left">紧张</td>
<td align="center">畏惧担心</td>
<td align="center">惴惴不安 过分关注，心神不宁，睡不好觉，上台时心跳加快、脸红、出汗、表情僵硬</td>
</tr>
<tr>
<td align="left">过度紧张</td>
<td align="center">恐惧害怕</td>
<td align="center">做恶梦、头痛、胃不舒服、胸闷、呼吸困难、当场晕倒等</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;从而，我们可以更清楚地看出，只有 “紧张” 和 “过度紧张” 才是我们真正要调整和突破的。因此我们没有必要去担心轻微、适度的紧张，只有过分紧张造成了思维停滞言辞不畅，我们才需要把它降低到一定程度，让它成为一种助力而不是阻力。</p>
<p>&emsp;&emsp;那么，当众讲话紧张的根源在哪里？既然紧张是人的一种反应式行为，那这种紧张到底是对什么做出的反应呢？有很多学者提出了自己的看法，以下是两位专家的观点。</p>
<p>&emsp;&emsp;一位是美国魅力学校校长都兰博士，他认为，产生怯场紧张的原因主要有以下几个方面：</p>
<pre><code>    1.害怕做得没有想得那么好。

    2.准备得不太充分。

    3.害怕人们 (听众) 反应不佳。

    4.早期有失败的经历。

    5.没有充分进入角色 (可能是由于 1，2，3 或 4)。
</code></pre>
<p>&emsp;&emsp;谈到紧张怯场的原因时，都是由于出现了害怕的感觉，让人产生了紧张。无外乎就是害怕 “自我形象不好”，“怕出丑”、“怕丢脸”、“怕没面子”。有了这种害怕心理，才会导致紧张出现。人类害怕的原理，明确地讲，我把它归结为 6 个字 “有需求，没把握”。很多人经历过高考，高考的时候一般都会特别紧张害怕，为什么呢？首先看这个人有没有需求。有啊，想考上大学，有的人还想考上好大学。但有把握吗？一般来讲都不会有十足的把握，万一发挥失常，万一考试那天发烧拉肚子，万一题目超出了自己复习的范围…… 很多偶然情况可能出现。这样，人就没有把握了。人一旦感觉到对事情没有把握，不安全感就会产生，所以大部分人高考会紧张。但也有人高考不紧张，什么人呢？一类是学习特别好的，保送都不去，一定要自己考，非清华、北大这样的学校不上。这样的学生有需求，但他们把握性很大，因此考试不会紧张。还有一类人是学习特别差的，知道自己怎么也考不上，“是妈妈让我考的”，不得不参加。这是连需求都没有的人，还紧张什么呢？  所以心理学上有一句话 “压力总是伴随着需要而产生”。无欲则刚啊，没有需求了，人还有什么担心和害怕的？<br>我们再看看当众讲话紧张是不是也因为 “有需求，没把握”?</p>
<p>&emsp;&emsp;我们私下讲话的时候很放松，可一旦站起来对一群人讲话，就不一样了，心理发生了变化，产生了展示自己的需要。私下讲话的时候，这种需求不能说没有，但非常小。而一站起来，给别人看的心理就产生了，想要表现得好，想要说得好，想让大家特别是领导认可，谁都会有这样的心理，很正常。但你有没有把握表现好呢？有些人讲话机会多，成功的经验多，把握比较大，但好多人在当众讲话方面缺乏锻炼，没有经验，没有充分的把握好好表现，出现紧张自然就不奇怪了。</p>
<p>&emsp;&emsp;所以，我说当众讲话的紧张就是源于 “有需求，没把握” 而产生的害怕心理。因此，克服当众讲话的紧张就要从这两个方面来解决。</p>
<p>&emsp;&emsp;事情有那么重大吗？　首先我们谈一谈需求，看看能不能把人的需求给降下来。需求没了，人就不紧张了，需求低了，紧张程度就小了。有人说不可能，谁站起来不想展示自己啊，这种需求是正常的，不可能降低。但我说可以，这个需求还是可以降低的。我通过 6 个方法来帮大家试着把需求降下来。</p>
<p>&emsp;&emsp;第 1 个方法：看轻结果。美国有一个著名的高空走钢索表演者叫瓦伦达，他走钢索以距离长、离地面高而出名，是美国观众公认的一流杂技表演艺术家。他走钢索非常有经验，一生做过很多次出色表演，但在最后一次重要演出中，他意外地从 70 米高空坠落身亡。事故发生后记者去采访瓦伦达妻子，没想到瓦伦达的妻子说：“我就觉得他这次要出事，因为他在表演前不停地对我说：‘这次表演实在太重要了，一定不能有一丁点儿失误，更不可以失败。’而这之前的任何一次表演，他根本不紧张，只是一心想着走钢丝的每一个技术细节，从不在意结果。” 后来，心理学家把不专注于事情本身，而是一再考虑做这件事情可能会带来的后果、患得患失的心态，叫做 “瓦伦达心态”。</p>
<p>&emsp;&emsp;在一次重要的国际田径比赛中，一名国内跳高运动员面临着冲击金牌的最后一跳。教练对她说：“好好跳，只要跳过这两厘米，你的房子就到手了。” 结果她硬是没跳过那 “两厘米”，“房子” 也泡了汤。在洛杉矶奥运会上，受了伤的跳水王子洛加尼斯也面临着争夺金牌的最后一跳，但他的教练只轻松地对他说：：“你妈妈在家里等着你呢，跳完这一轮，你就可以回家吃她做的小甜饼了。” 洛加尼斯微微一笑，从容跳入水中。他以自己优美的姿态征服了所有裁判及在场的观众，赢得了久久的掌声。他最终获得了金牌，既回家和妈妈一道品尝了小甜饼，也得到了政府奖励。中外两个教练，同样是用语言去激励运动员，因为 “说法” 不同而导致截然不同的结局。</p>
<p>&emsp;&emsp;让人考虑后果、患得患失的 “瓦伦达心态” 只会让人紧张加剧。我们目前的文化非常在乎事情结果，总是以结果论成败，以成败论英雄。其后果是越想得到就越不容易得到，越怕失败就越容易失败。结果需要我们去关注，但关注过度了，就会把结果看得太重，做事就会受到影响。</p>
<p>&emsp;&emsp;一次我给中关村一家知名企业做产品发布指导。该公司召开产品发布会，由市场部杨经理来介绍产品。她紧张得不得了：“我们研发部门花了半年的心血研究的产品，要是我给介绍砸了就全完了，怎么对得起他们呀。” 我说，我先了解一下你们是怎么发布新产品的吧。</p>
<p>&emsp;&emsp;我了解后知道了他们的新产品是制作电视节目用的非线性编辑系统，是用电脑编辑节目的一套工具，产品发布就是现场演示用这套系统编辑好的一组节目，杨经理在中间要穿插做一些补充介绍。我知道了这些情况之后，对杨经理说：“杨经理，你知道你在产品发布中充当什么角色吗？你充当的角色不是主讲人，而是解说员。解说是什么性质呢？就像赵忠祥老师主持《动物世界》，他是在屏幕后面的人，根本不需要出现，《动物世界》里有哪一集赵老师会露脸？他的工作只是大家在看不懂的时候说上一两句，让大家看得懂，大家能看懂的时候，赵老师还不能说话，否则会影响观众看节目。你所做的事性质和赵老师做的一样，发布会上应该是产品当主角，充分表现，当客户看不明白的时候，才需要你说上几句，而客户能看明白时，你就不用说话。所以，有产品自身的演示作为保证，你不用把你讲话的作用看得太重了。反倒是你表现得过分了，客户都看你而不看产品，才是你介绍的失败呢。其实你们的产品到底符合不符合客户的要求，到底能不能对客户的工作发挥作用，这才是能否成功的根本，不会因为你说了几句动听的话客户就抢着买。所以，你的讲话跟发布会的效果有关系，但不是百分之百，也就只占 5%~10% 吧”。杨经理听我这么一说，松了一口气：“黄老师，那我就轻松多了。</p>
<p>&emsp;&emsp;我们经常听到一句话叫 “这件事具有重大的现实意义和深远的历史意义”，形容我们做的事有很重要的意义。我国的 “嫦娥” 卫星发回第一张月球照片时，我看电视报道时就听到了这句话，评论嫦娥工程意义重大而深远。这件事确实意义重大，但我们的发言、讲话有那么大意义吗？  往往很多情况只是走个过场和有个形式。所以，下次你觉得你讲话的意义非常重大时，和 “嫦娥” 工程比一比，想想你的讲话有那么大的现实意义和深远的历史意义吗？因此，第一点，要客观评价你讲话的作用与意义，把结果看轻而不是盲目放大。</p>
<p>&emsp;&emsp;第 2 个方法：放下自我。　中国有一位音乐家叫陈其钢，他说自己是个内向的人，不太习惯在公众面前讲话。2002 年北京第 5 届国际音乐节上他要展现音乐作品《蝶恋花》，这次展现的方式与以往不同，采用 “音乐会现场解说” 的特殊表现形式，由他自己亲自登台讲解。演奏是他的长项，但对着观众讲话陈其钢心里就打鼓了，感觉很紧张。但他意外想到了一个方法立刻调整了紧张的心情，是什么方法呢？</p>
<p>他说：“有时候我想，音乐会台上有一百多位音乐家在拉琴，好像是一百多只猴子在那里搞表演，台下有一千多名观众，也就是一千多只猴子在看表演，这些猴子在看的时候还会鼓掌。这次更特别的是，还有两只猴子在说话。猴子们在一起玩，所以没必要那么认真。” 咦，你看，大家都不是人了，还有必要那么一本正经吗？<br>&emsp;&emsp;王朔被称为最有风格的作家之一，他有一句名言：“我是流氓我怕谁？” 我称陈其钢、王朔这种调整心态的方法就是不把自己当人的方法。当然，我们普通人谁也不能像陈其钢那样把自己当猴子，像王朔那样把自己比喻成流氓，但很多时候，我们做人确实太过认真了。我们现在的教育只有一种不变的方式，即只教大家做人要认真。其实，要知道任何事物没有变化就是死的东西，没有变化的做人方式也迟早会出问题。我们很多的紧张是由于 “太认真” 才出现的，人在很多时候会孔雀开屏 —— 自作多情，太把自己当回事了。其实，做人应持有 “既认真， 又不认真” 的心态，是最重要的。在这里，我们先需要了解的是放下自我，不要太把自己当回事。</p>
<p>&emsp;&emsp;第 3 个方法：允许犯错。要允许自己犯错误，因为，我们不是学校里专职的老师，更不是职业演讲家，又不是天天以讲话为职业，话讲不好是正常的。讲话中遇到讲错话，不要觉得沮丧。因为我们每个人都要允许自己有一个成长的过程，要学会随时随地给自己一个恰当的定位，任何事物的发展都是从小到大、由弱变强的，要允许自己在缺少经验和技能生疏的情况下讲不好，允许自己犯错误，这是再正常不过的事情了。</p>
<p>&emsp;&emsp;第 4 个方法：允许失败，这又是非常重要的一点。“一定要成功，绝不能失败”，我们经常听到这句振奋人心的话。但大家想一想，这句话现实吗？成功和失败是一对孪生子，任何事情的结果可能成功也可能失败，概率差不多，基本上是各占一半，这是天地运行的自然法则决定的。就像地球不管怎么转，我们这一半现在是白天，地球另一半就绝对是黑夜。既然知道事物有两面性，为什么一到事情的成败上，我们就要求只能成功，不能失败？运动员是不是也要懂得这一点？</p>
<p>&emsp;&emsp;刘翔连续创造了 4 年的辉煌，对于对抗激烈、新人层出不穷的世界短跑赛场，有这样的骄人战绩真让人惊叹不已。我发现，刘翔的成功首先是做人的成功，印证了 “做事先做人” 的道理。他取得的惊人成绩与他拥有良好的心态、极高的心理素质是有关系的。请看：</p>
<p>&emsp;&emsp;在 2007 年 8 月第 11 届世界田径锦标赛上，刘翔凭实力是有机会夺得金牌的，而且他的世界级金牌就差世锦赛这一块，得到了就享有 “大满贯” 的称号。他很想得到这个冠军，全国人民也很希望他得到，压力来了。但刘翔在赛前新闻发布会上却说：“我尽力去跑，但跑出什么成绩现在还不好说，要看当时的状态，拿不到冠军，能拿到第二名、第三名也是不错的。” 我看出他不是嘴上说说而已，是发自真心这么说，是从心里对结果有一个现实的期待，也让全国人民对结果有了一个现实的期待。在这样的心态下，人才会真的放下负担，才会把更多的精力用在做事上。最后的结果刘翔不是第二名、第三名，他拿到了冠军，实现了大满贯的愿望。中国人民的自豪感又被狠狠地激发了一次。而在 2008 年北京奥运会上，刘翔又被全国人民寄予了很大的希望要卫冕奥运会冠军。但刘翔经过努力之后最终因伤退赛。我觉得这又表现了他良好的心理素质。一件事经过尝试之后要允许自己勇于放弃，要允许自己失败，说起来，这不仅不是失败，而是一个人智慧的表现，不把这样的事看成失败，人就不会失落沮丧。</p>
<p>&emsp;&emsp;第 5 个方法：允许丢脸。 大家熟知的香港凤凰卫视的节目主持人窦文涛，有 “名嘴”、“铁嘴” 之雅号，嘴巴着实厉害。但是窦文涛小时候嘴巴并不灵巧，虽然爱说话，但是说不好，结结巴巴，有点口吃。上初中的时候有一次老师跟他说：“窦文涛，学校组织演讲比赛，我看你挺爱说的，你来参加吧。”“哟，演讲怎么讲？”“就像写作文一样，你写篇稿子，上台背出来就行了。”“那好吧。” 窦文涛犹犹豫豫地答应了。回去开始写演讲稿，接着就开始背。背的时候自己还发明了一套方法，把每个自然段的第一个字作为关键字记住，一想到这个字这一段就倒背如流地背下来了，效率很高。他让妈妈考他，妈妈只要任意提其中一个关键字，他就可以把这段背下来。演讲会那天，窦文涛一上台，哎，怎么感觉跟家里不一样？家里没人，但这里台下一千多人黑压压的一大片。他当时有点慌，赶紧背第一段吧。第一段背完之后就想第二段的第一个字，想起来了，第二段也背下来了，还挺顺利。这时就想第三段的第一个字，麻烦了，这第三段的第一个字是什么呢？想不出来了，也没有妈妈在旁边提字。一紧张，整个脑袋空白，什么都没有了。再一看，台下开始交头接耳，开始议论上了。窦文涛站在台上足足半分钟，一句话也没有说，他越来越害怕，最后突然感觉裤子湿了：“坏了，尿裤子了。” 结果全校师生看着窦文涛尿湿了裤子跑下台。第二天窦文涛来上学，也觉得挺难为情，好像全校女生都在看他。老师来找他：“窦文涛，你昨天虽然没朗诵完，但是前面两段朗诵得还是不错的，能背下来一定能拿个名次。你知道吗？这一次我们学校的演讲比赛是为区里的演讲比赛做选拔的，根据你昨天的表现，我们决定让你到区里参加演讲比赛。” 窦文涛还会答应吗？没想到他竟答应得很痛快。为什么呢？在窦文涛的回忆里，他说：“我昨天当众尿了裤子，丢人已经丢到家了，还能有比这个更丢脸的事情吗？自己觉得无所谓了，所以答应得很痛快：“去！” 这一去还真拿了个名次回来” 他说：“从此之后我就有点变化了，反正已经不要脸了，还有什么所谓呢？  卸下这个包袱之后，我觉得自己还行，也能经常在这种场合露露脸。 中国人传统上都比较内向，大家一起听你说话的机会很难得，要珍惜每一次当众说话、当众表演的机会，就让自己积累挫折、积累出丑的经验，这样才能放下自我。这次出丑了吧，你们笑话我吧，我就不要脸了一分；下次又出丑了。我就不要脸了二分；等我全不要脸了，我就进入自由王国、无我的状态。所谓的‘自我’就是脸面、自尊心、虚荣心等诸如此类的东西构成的，当这些东西全被摧毁的时候，你突然发现你获得了一切。”  面子是怎么挣来的？面子是通过丢面子挣来的。你能说窦文涛今天成名不要感谢那次当众尿裤子吗？窦文涛从尿裤子慢慢地练成了主持人，现在他说起小时候尿裤子的事情不仅不觉得没有面子，还觉得是件有面子的事。小时候多笨啊，而现在他是名嘴、铁嘴，主持的节目谁都爱看，多有面子啊。所以丢面子本来就是一件正常的事，是走向成功必须付出的代价，是挣面子的开始啊。所以，要发自内心地接受自己也会有没面子的时候。</p>
<p>&emsp;&emsp;第 6 个方法：允许紧张。要接受紧张而不是控制紧张。紧张的表现本来就是正常的，是应该的，要正确对待它。可是我们很多人认为紧张不正常，为了不想让人看出自己紧张，就拼命掩饰，刻意控制，故作镇定，结果不仅紧张控制不住，反而因为掩饰紧张加重了心理负担，变得更加紧张了。不要跟紧张对抗，它就是身体对外在环境的一种应急反应，说明你的身体正常。如果上台紧张了，不妨在讲话前跟听众坦然承认：“今天看到这么多专家、领导在座，我真的感觉有点紧张。” 这样说，放弃了掩饰的心理，接下来你的表现反倒自然了。一旦我们允许紧张出现，最大的好处就是人会变得真实。因为人人都会紧张，你紧张了大家认为你很真实，但要是刻意控制，听众就会感觉你好像故意在隐藏着什么而让人不踏实，不安全。听众觉得不安全了就会防备你，而展示了最真实的自我，听众就容易接受你，而刻意掩饰就会做作虚假。所以，不要想着去控制紧张，紧张就随它去吧。以上是我谈的如何克服紧张。哦，现在似乎不能叫 “克服” 了，而应该叫 “调适”。调适紧张的第一个方面就是降低需求，有 6 个方法，我们一起总结一下：</p>
<p>　　1.看轻结果</p>
<p>　　2.放下自我</p>
<p>　　3.允许犯错</p>
<p>　　4.允许失败</p>
<p>　　5.允许丢脸</p>
<p>　　6.允许紧张</p>
<p>&emsp;&emsp;附注：我推荐此文，缘于一位名叫 chsdyt 的馆友对此文的评论，它使我很感动，也使我很钦佩这位馆友能学以致用。但愿更多人能受惠。下面是这位馆友的评论：</p>
<p>&emsp;&emsp;“非常感谢此篇文章的分享者！通过阅读到它，让我跨出克服当众发言紧张的第一步。真的如它所说，心中有了那 6 个方法，顿感心理轻松不少。就是，何必呢？何必把事情、把自己看的那么重？- 看轻结果、放下自我。犯点错怕啥呢？不是不会吗？就是会的人也难免犯错。紧张那是必然的。紧张就紧张吧。失败就失败吧。一开始就成功它也不可能啊。是不是？丢点脸怕啥，就怕连丢脸的勇气都没有。所以呢，允许自己犯错、允许自己失败、允许自己丢脸、允许自己紧张。当对自己宽容些了以后呢？发现自己的心里竟是前所未有的轻松。敢去做（当众发言）这件事情了！<br>&emsp;&emsp;终于跨出这一步了！<br>&emsp;&emsp;现在的我当众发言已经不紧张、不害怕了。从容不迫！连自己也没想到呢。呵呵。真好！”</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>如何看待父亲发文怒斥网游</title>
    <url>/2021/02/16/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E7%88%B6%E4%BA%B2%E5%8F%91%E6%96%87%E6%80%92%E6%96%A5%E7%BD%91%E6%B8%B8/</url>
    <content><![CDATA[<p>[转载知乎网文，写得太好了，感谢]</p>
<p>最近，浙江一家长发表在《新华每日电讯》的文章《被网游毁掉的孩子》引热议。他说，儿子沉迷网游，荒废了学业，高考失利。其努力10年才帮儿子从网游中走出。文章全文如下图：</p>
<a id="more"></a>

<p>这孩子天生是个军迷，如果他的成长过程中，从没接触过更高级的爱好，一直玩《穿越火线》这种低门槛、强瘾性的十八线射击游戏，他能沉迷多少年我都不奇怪。</p>
<p>所以，建议这位父亲除了打骂，禁足，送去当兵之外，不如试试我这招：</p>
<p>《使命召唤》和《战地》让他玩玩看？《欧陆风云》和《全面战争》让他玩玩看？我保证他马上忘掉《穿越火线》这玩意。</p>
<p>兴趣需要引导到高处，而不是扼杀在摇篮。</p>
<p>下一步，想买《使命召唤：二战》吗？想换一台 PS4 pro 吗？全战又出 DLC了吗？好好学习去吧，完成了学习目标，爹给你买。</p>
<p>死都不想学习吗？也行，那就跟爹出去玩实弹射击，去军事博物馆，去野外生存，去欧洲旅游，看看当年盟军打突出部之役的地方。</p>
<p>总之就是，用游戏作为奖励，根据孩子的兴趣，让他接触游戏以外的爱好。</p>
<p>其实很多中国孩子之所以沉迷游戏，是因为他们不像西方世界的孩子们一样，有那么多选择。</p>
<p>妞也不能泡，乐队也不让组，不能出去 gapyear，也不能在车库里鼓捣机械。最后最后，连游戏也不让我玩了！？那老子肯定跟你死磕到底喽。</p>
<p>洪水宜疏不宜堵。老祖宗传了几千年的道理，现在都被忘得差不多了。</p>
<p>退一万步讲，就算这位父亲的一篇文章，真的带来权威媒体的批判和游戏发行商的保护，这就真的可以让小孩子们不玩游戏了吗？</p>
<p>前段时间的人民网素质三连，加上大陆游戏用了十几年的所谓什么“防沉迷系统”，这些有让玩《王者荣耀》的小孩子变少吗？并没有。</p>
<p>相反，越来越多的小孩子开始玩游戏了。因为这是社会潮流、科技潮流、也是文化潮流，没人能阻止。</p>
<p>游戏就跟 A片一样，是人类的天性。粗暴一刀切，一点意义都没有。别把孩子们当傻子，只要他们有欲望，你再怎么压制也只会适得其反。</p>
<p>不信的话，不妨去搜搜 “王者荣耀 + 防沉迷”，结果绝对发人深省……</p>
<p>“哪里有压迫，哪里就有反抗”，这句话咱们中国人当成信仰说了一百年，真的到了教育自己后代的时候，却变成了“哪里有反抗，哪里就有压迫”。</p>
<p>这几年来，跟题主截图类似的诸如“优等生沉迷网游成绩一落千丈”、“父亲不让玩游戏导致孩子跳楼”、“母亲怒摔两部手机，以防女儿玩《王者荣耀》”，这样的报道，少吗？</p>
<p>至于孩子 “沉迷” 游戏的解决办法，网络上的信息和评论更是让我笑掉大牙。不妨再去搜搜 “孩子沉迷游戏怎么办”，结果肯定吓得你赶紧去预约一个脑部 CT：</p>
<p>掌握中国话语权的媒体尚且如此，更何况普通父母？</p>
<p>在中国，游戏这顶 “鸦片” 的帽子实在是戴得太久了，太冤了。</p>
<p>心情复杂，有感而发。威廉今天就要说一说这个被 “专家教授”们呕心沥血研究了十几年的问题：</p>
<p>我们到底为什么 “沉迷” 打游戏？游戏真的能害孩子吗？</p>
<p>请不要摔手机、砸电脑、关禁闭、抽嘴巴，让我们理性地来探讨这个问题。</p>
<p>正所谓以史鉴今，要说解释人类的行为，威廉觉得历史就是最好的参考书。</p>
<p>自人类诞生以来，任何一种形式的艺术作品——绘画、雕刻、建筑、音乐、文学、舞蹈、戏剧、电影，它们的终极诉求其实大同小异。艺术家们通过作品来刺激观众的感官，以此来向观众表达自我、建立沟通、继而引发共鸣。</p>
<p>艺术家们表达这种诉求的方式日新月异——从洞穴里的史前壁画到今天的 VR头盔，艺术形式的进步永远跟随着科技的进步。</p>
<p>一如文字催生文学、胶片催生电影，上世纪末，随着人类的科技发展，一种融合了视觉、听觉、触觉的新艺术形式出现了。</p>
<p>电子游戏之所以被称为 “第九艺术”，也正是因为如此。</p>
<p>这个新生儿注定将比电影更加受欢迎，因为观众不再是坐在座椅上冷眼旁观，而是通过触觉设备加入到电影之中，成为电影的主角。</p>
<p>对于那些像我一样大的 80、90后来说，我们的成长就见证了电子游戏产业的从无到有、发展壮大，我们见证了这种艺术形式真正地在普罗大众之间流传开来。我们是真正玩着游戏长大的一群人。</p>
<p>如果雷神杨永信教授读到这里，估计要摩拳擦掌、蓄力大招，准备电一下我这个执迷不悟、大放厥词的网瘾老少年了。</p>
<p>可就算要被杨教授一套带走，威廉也依然坚持自己的观点——其实我们玩游戏的原因很简单：</p>
<p>我们就像是第一次看到裸体雕塑的希腊人、第一次走进漆黑的电影院的美国人一样——我们是“电子游戏” 这种最新艺术形式的第一批观众。</p>
<p>而裸体的石头人、伸手不见五指的放映厅、光怪陆离的液晶屏幕，都会让第一次见到的人害怕。所以，任何一种艺术形式，它们都需要一个媒介，来帮助它们慢慢从少数走向多数。</p>
<p>雕塑的媒介是神庙，电影的媒介是电影院。而对于游戏来讲，这个媒介是家庭游戏主机。</p>
<p>但是，2000年光明日报一篇《电子海洛因》的文章，带来了文化部的一纸游戏机禁令。所以在中国，这个媒介的普及，我们比西方晚了十几年。</p>
<p>而晚了十几年的代价，就是当中国人突然面对以电脑和网络为依托，野蛮生长的电子游戏的时候，就像日本武士面对工业革命带来的现代枪炮——上一代缺乏认知，下一代疯狂滥用。</p>
<p>在世纪之交的中国，那时大哥大还不能打王者荣耀，小霸王还是学习机，而家用电脑普及率极低。所以电子游戏的启蒙仪式，大多数中国人是在烟雾缭绕的网吧中完成的。</p>
<p>启蒙过后，由于跟琴棋书画相比，诞生于时代尖端的电子游戏有着异常真实的画面和极为刺激的交互，所以它开始随着互联网和网吧在中国迅速传播——也让中国的小孩子迅速沉迷。</p>
<p>这些中国的孩子们大部分没见过 XBOX、PS2、NGC，对游戏的认知还停留在 FC 时代的《超级玛丽》和《魂斗罗》。有一天，他们突然就在网吧玩到了《梦幻西游》和《魔兽世界》，那情景就好像一个吃糠咽菜好几年的人，突然发现了一家豪华自助餐，2块钱随便吃，他要是能愿意出来就有鬼了。</p>
<p>这些游戏对小孩子致命的吸引力，将涉世未深的他们吸引到鱼龙混杂又无人监管的网吧，导致学校和家庭对他们再无吸引力可言。所以，家长老师们就觉得：是游戏传播了网吧，而不是网吧传播了游戏。只要没有游戏，天下太平。</p>
<p>于是他们对 “游戏”二字畏之如虎，一味封锁打压、明令禁止，导致孩子们想玩到游戏的方式就只有继续偷偷跑去网吧。</p>
<p>如此一来二去的恶性循环，其实直到今天依然在上演，只是角色不同罢了——《梦幻西游》、《魔兽世界》换成了《穿越火线》、《王者荣耀》，网吧、游戏房换成了手机、iPad。</p>
<p>十几年来，电子游戏变成了利欲熏心的商人、教子无方的父母、疏于职守的老师们最完美的替罪羊——电子游戏是海洛因，我也没办法啊。</p>
<p>沉迷游戏四个字，变成了无药可救的近义词。这个千古奇冤的骂名，直到两亿中国人都在玩着王者荣耀的今天，竟仍然被人不断提起。</p>
<p>难道现在的家长们真的不能感同身受，其实这样的 “沉迷” 无可厚非吗？就像 70 后沉迷武侠小说、80后沉迷日本漫画一样，每一个小孩子——尤其是男孩子——心中都有一个降妖伏魔、惩奸除恶的英雄梦。</p>
<p>而在游戏世界里，你不必再去崇拜、向往那些盖世的英雄。因为你就是英雄，你可以亲手击败那些让你恨得咬牙切齿的坏蛋。</p>
<p>对于 90后来讲，他们也许是代表圣光的骑士、是永不为奴的兽人，起身反抗邪恶的天灾，击败荼毒世间的巫妖王。</p>
<p>而对于那些玩着《王者荣耀》的 00后孩子们来讲，他们就是一骑当千的赵云、就是百步穿杨的黄忠。手指轻轻滑动，就可以破阵杀敌、天下无双。</p>
<p>你能怪他们沉迷吗？《王者荣耀》也好，《穿越火线》也好，这些快餐游戏的设计初衷就是瞄准那些不懂游戏的人，孩子能比企鹅的游戏设计师还聪明吗？</p>
<p>一味的抗拒、声讨、咒骂是没用的。我请全中国的家长们尝试把游戏看作爱好，把《穿越火线》和《王者荣耀》当成敲门砖，把你们的孩子引向更具艺术性、知识性、创造性的好游戏。</p>
<p>你们会发现，游戏是一个多么棒的启蒙工具。</p>
<p>写到这里，我不得不感谢我开明而睿智的父母。在我还是小孩子的时候，他们给了我一个加设密码的家用电脑，让我可以在干净卫生的环境里玩游戏的同时又得到了必要的限制和监督。同时他们也鼓励我接触游戏以外的兴趣爱好，并积极参与。</p>
<p>他们的谆谆教导让威廉今天可以用自己做成反例，来说明一个 “沉迷游戏”的少年非但没有被游戏摧毁，反而被游戏升华：</p>
<p>大概是 10岁的时候，我爸托人在家中电脑里装了一个当时如日中天的游戏《金庸群侠传》——于是我只用了一秒钟就“沉迷” 了。</p>
<p>游戏里自由奔放的叙事手法和极为形象的武功招式激起了我对武侠小说的巨大兴趣。于是我一边玩游戏，一边开始如饥似渴地拜读金庸老师的全部著作。</p>
<p>我妈很支持我，经常陪我阅读，给我解释那些我不认识的词。</p>
<p>之后我一发而不可收拾，“金古梁温黄”一部部读过去之后，我发现，我开始 “沉迷”读小说。中文的武侠小说读完之后，时值我 “沉迷” 于龙与地下城规则的美式 RPG 游戏《冰风谷》和《博德之门》。</p>
<p>于是我便开始去读西方人的“武侠”——同龄人还在看《还珠格格》和《情深深雨濛濛》的时候，我开始“沉迷”《魔戒》、《冰与火之歌》。那一年还没有最强美剧《权力的游戏》，《冰与火之歌》的中文译本很难买，但我老爸还是想办法帮我买到了。</p>
<p>再之后，我又开始读历史题材、侦探题材、科幻题材、悬疑题材的小说。直到 17、8岁的某一个午后，我发现，我想当一个作家。</p>
<p>而我有了这个想法后，第一部尝试写的小说，改编自我玩了无数遍、严重 “沉迷”的汉堂经典 RPG 系列《天地劫》。</p>
<p>我的第一个读者，就是我妈。</p>
<p>还有，我小时候不喜欢运动，但因为《实况足球》而 “沉迷”看球踢球，时至今日仍是阿森纳的忠实厂工；</p>
<p>我的英语启蒙读物是一款叫《弥赛亚》的英文游戏，之后的人生中，我的英文积累有一半来自我“沉迷” 的那些英文游戏，因为不懂那些英文我就没有办法破关；我因为《文明》系列游戏而 “沉迷”历史和地理，历史课是我唯一一门考过全校第一的科目。</p>
<p>同样的例子在威廉的生命里俯拾皆是，不胜枚举。可以说，正是游戏造就了今天的我，一个更好的我，我就是活生生的“游戏鸦片论” 反例。</p>
<p>这虽然是一个关于我的故事，但这个故事的主角其实不是我，而是我的父母。</p>
<p>因为长大之后我才知道，在那个盗版还未猖獗的年代，一台电脑和那些动辄 7、80元的正版游戏光盘，对于并不富有的我爸我妈来说，意味着什么。</p>
<p>因为长大之后我才知道，为什么班里那么多同学都冒着挨揍的风险也要撒谎、逃课，跑去网吧玩《热血传奇》，而我虽然也去过几次，却提不起多大兴趣——因为我在家里写完作业就能玩，而且我玩的游戏可比《热血传奇》高级多了。</p>
<p>所以，如果没有我爸妈对我 “沉迷游戏”的理解、支持，我可能今天就不会在这里写字。是他们的引导，左右了我所接触到的一切；是他们的鼓励，让我的天赋不仅仅停留在兴趣。</p>
<p>在威廉看来，无论是中国的 “限制” 规则，还是西方的 “分级”制度，都不是给孩子们设定的，而是给孩子们的家长设定的。</p>
<p>威廉身边有两个身为人父的朋友，我们称他们为 G 和 C 好了。</p>
<p>G也是一个资深玩家，从孩子还未懂事的时候他就给孩子的设备加了家长锁。他的儿子从小就只能玩到他精挑细选的游戏。《王者荣耀》推出后，他儿子全班同学都在玩，但他的儿子的手机卡并没有上网流量，所以他的儿子并不能在学校里发微信或打游戏。</p>
<p>但他会每晚亲自带着老婆儿子玩王者荣耀，排位上分，并不失时机地给儿子讲解游戏里面每一个历史人物的故事。每每看到他朋友圈分享那些寓教于乐的游戏故事，威廉总觉得为人父、为人夫，莫过于此。</p>
<p>而我的另外一个朋友C，倒是乐得将自己的账号和设备都丢给孩子，随便他玩。因为这样小孩子就会一整天都变得安静听话，大人也落得逍遥自在。</p>
<p>简简单单的两个父亲的故事，恶魔全都藏在细节里。</p>
<p>我猜，过度溺爱孩子要什么给什么的、发现孩子打游戏就把孩子胖揍一顿的，这样的父母，在中国也不是少数。所以，才有了“母亲怒摔两部手机，以防女儿玩王者荣耀”“网游害了一个年代的孩子”这样的文章，见诸报端。</p>
<p>无知是愤怒的源头，而愤怒不能解决问题，只会招致更多问题。</p>
<p>小小的游戏不能决定你孩子的未来，父母才能。错不在电脑，不在手机，不在网络，不在游戏，而在父母的教育方式。</p>
<p>我们为什么玩游戏？因为天生好奇的我们人类，这辈子注定要 “沉迷” 一些事物。</p>
<p>这种沉迷能让一个人攀上巅峰，也能让一个人跌下深渊。而决定我们走向哪条路的明灯，有两个名字：一个叫爸爸，一个叫妈妈。</p>
<p>孩子们不需要《成长守护平台》，也不需要《健康游戏公告》。他们需要的东西再简单不过：陪伴，理解，沟通。</p>
<p>2.9更新：感谢大家的肯定和支持，一直觉得这个话题在当今中国算是一大社会难题，身边的很多父母都缺乏对待游戏的正确态度和开放观念，也不懂如何积极地把游戏作为一个强化物引导孩子的成长。希望我码了这么多字，可以给看到的父母们做一个参考。</p>
<p>同时作为一个玩家，我也希望中国的玩家群体终有一天不会被人放在边缘地带冷眼看待，游戏也是艺术，也是文化，值得被公正地审视和对待。</p>
<p>可这样的待遇，光靠对那些不理解游戏的老一辈人们冷嘲热讽、挖苦臆测，是得不来的。就像父母对待孩子一样，那些苦于父母反对的孩子们，也请多多努力，去陪伴、去理解、去沟通吧。</p>
<p>但愿我们的儿子，都能在爸爸的陪伴下一起打游戏。</p>
<p>2.17更新：除了一部分不懂游戏的脑残和杠精之外，我非常高兴绝大部分知乎用户都跟威廉抱持着一样的想法和态度，同时也积极地给予我支持和转发。我也会像大家一样，利用自己手上的资源把我这篇回答转出知乎，让更多的家长看到。</p>
<p>这几天忙着过年，抱歉实在没时间一一回复网友的评论，今天最后一更，回复一些主流评论的同时，就当是对我这篇啰啰嗦嗦的长文做个总结，没时间细看的朋友可以直接看这里了：</p>
<ol>
<li><p>所有的艺术都分三六九等，这是事实，游戏也不例外。不信就先去看看《泰坦尼克号》，再去看看《纯洁心灵：逐梦演艺圈》，然后再告诉我艺术到底有没有高低。在我的眼中，免费网游处处都是利用心理学和行为学设计的沉迷陷阱，没有任何具有启发性的内容，只是一遍遍地重复毫无意义的感官刺激；而优质的付费游戏就像是一本好书、一部好电影，是非常好的用于学习、思考、激发兴趣的工具。所以，对于孩子们来说，《穿越火线》就是低级的，《文明6》就是高级的，我坚信不疑。</p>
</li>
<li><p>说我何不食肉糜的朋友，我想说我不是从小养尊处优的晋惠帝，我的家庭和其他普通家庭的孩子没有两样，只不过我的爸妈并不认为“电脑就是个游戏机，为什么要买？”。至于那些在讨论钱的朋友，要知道 STEAM上一个游戏才几十块，去一趟比利时也就几千块，如果连这个钱都没有的话，那这就是一个生育决策问题了。我的个人意见是，对大部分中国父母来说，这件事问题还是出在观念上，不是物质上。</p>
</li>
<li><p>这篇文章并不是在讨论 “从沉迷一个游戏到沉迷一堆游戏”，而是“从沉迷一个爱好到沉迷一堆爱好”。就像我说的，堵不如疏，一个精神生活无比丰富的人，不论是大人还是孩子，是不太会一直沉迷同一件事情无法自拔的。如果孩子真的就是除了游戏之外没有任何其他爱好，我觉得哪怕能让他喜欢上许许多多不同类型、不同节奏的游戏，也远比被一个劣质网游牢牢捆住强得多。</p>
</li>
<li><p>至于到底该怎么疏引、怎么管理、怎么激发孩子的兴趣，威廉只能说我不是一个教育家，才学有限，没办法根据极度有限的信息给到你们每一个人因材施教的规划。诚惶诚恐，希望我这一篇关于游戏母题的文章能稍微帮到你们：<a href="https://zhuanlan.zhihu.com/p/33439754">如何确定自己喜欢的游戏类型？</a></p>
</li>
<li><p>我在评论区看到了很多朋友，不幸拥有跟问题中所引用的父亲一样无知无能的父母；但我更多看到的是一些玩着游戏长大的，愿意去陪伴、理解、沟通的父母，和一些将来注定成为优秀父母的年轻人。如果你问我，我从我爸妈的身上学到了什么？我的答案就是——代沟是永远存在的，所以一颗懂得开放和包容的心，还有一颗保持思考和学习的头脑，才是成为一对优秀父母的关键。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>真正决定你人生高度的，是深度学习能力</title>
    <url>/2021/02/16/%E7%9C%9F%E6%AD%A3%E5%86%B3%E5%AE%9A%E4%BD%A0%E4%BA%BA%E7%94%9F%E9%AB%98%E5%BA%A6%E7%9A%84%E6%98%AF%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[<h3 id="主动学习和被动学习的差异"><a href="#主动学习和被动学习的差异" class="headerlink" title="主动学习和被动学习的差异"></a>主动学习和被动学习的差异</h3><p>作者 | 周岭</p>
<p>来源 | 清脑</p>
<p>胡适的英语老师、民国时期自学成才的出版家王云五先生在年轻的时候是这样自学英语写作的：</p>
<p>找到一篇英文的名家佳作，熟读几次以后，把它翻译成中文，等过了一星期之后，再依据中文反过来翻译成英文，这个期间绝不查阅英语原文。</p>
<p>翻译后再与原文比对，找出自己翻译的错误、失误和不够精良之处。</p>
<a id="more"></a>

<p>如此反复练习，王云五先生练就了扎实的英文功底，为日后的英语教学和出版事业打下了坚实的基础。</p>
<p>在那个科技、信息远不如今天发达的年代，有限的学习条件迫使人们静下心来转向这种深度学习。</p>
<p>时间拨到百年之后，我们的社会发生了巨变，人类进入了前所未有的物质和信息丰富时代，新奇有趣、轻简浓缩的知识随处可见。</p>
<p><strong>人们担忧的不再是无知识可学，而是学不完的知识。</strong></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/b4e134f319d7acc658af8eb1cd3702f9.jpeg" alt="b4e134f319d7acc658af8eb1cd3702f9"></p>
</div>

<p>时至今日，恐怕很少有人能像王云五先生这样主动静下心来深度学习了，甚至很多人认为，现今时代的学习已经不必如此「费尽艰辛」。</p>
<p>人们有太多的方式可以让自己轻松地获取知识，比如每天听一本书、参加牛人的线上课、订阅名家专栏或参加某某学习群……<br>轻松高效，干货满满，只要自已持之以恒，就定能有所成就。</p>
<p>可惜的是，这种认知注定是一个错觉，因为科技和信息虽然在我们这一代发生了巨变，但人类的学习机能并未随之快速变化，我们的大脑运作模式几乎和百年前一模一样。</p>
<p>更坏的消息是，<strong>「丰富的信息和多元的方式」在带来便捷的同时，也深深地损耗着人们「深度学习」的能力，并且这种倾向越来越明显。</strong></p>
<p>三个月前，罗振宇在 2017 跨年演讲中提到这样一个事实：</p>
<p>用钞票和用微信 / 支付宝支付，有什么区别？</p>
<p>表面是更快更方便；实质上，用钞票支付，是在理性决策；用手机支付，是在冲动消费。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/9fa7915cc746cd153e36b9552b367458.jpeg" alt="9fa7915cc746cd153e36b9552b367458"></p>
</div>

<p>购物，越来越不是理性的决策行为，用户用本能花钱，追求的是快感。</p>
<p>种种迹象表明，快速、简便、轻松的方式使得人们低层次的「原始脑」功能得到进一步强化，高层次的「现代脑」功能则进一步弱化，而深度学习能力几乎全部依赖高层次的「现代脑」（大脑皮层）。</p>
<p>商家已经看清了这一点，于是想方设法推出各种代读、领读、听读的产品，让人们瞬间体验到轻松获取知识的快感，并且产生勤奋的感觉。</p>
<p>而现实的情况是：<strong>人们越学越焦虑、越学越浮躁，懂得很多道理，却依旧过不好现在（别说是一生了）。</strong></p>
<p>我隐隐约约看到这个世界正朝着两极发展：</p>
<p>一小部分知识精英依旧直面核心困难，努力地深度钻研，生产内容；绝大部分信息受众享受轻度学习，消费内容。</p>
<p>知识阶层在逐渐固化。如果长期陷于错误的认知或习惯于轻度学习，一旦丧失深度学习能力，将很难打破知识阶层的限制，被困在认知低层。</p>
<p>深度学习的能力已经变得越来越稀缺。</p>
<p>如果我们真的希望在时代潮流中占据一席之地，那就应该尽早抛弃轻松学习的幻想，锤炼深度学习能力，逆流而上，成为稀缺，否则人生之道路势必会越来越窄。</p>
<p>01</p>
<p><strong>什么是深度学习？</strong></p>
<p>1946 年，美国学者埃德加. 戴尔（Edgar Dale）提出了「学习金字塔」（Cone of<br>Learning）的理论，之后美国缅因州国家训练实验室也做了相同的实验，并发布了「学习金字塔」报告。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/18bd6131eb8a4888e1c294e69338697f.jpeg" alt="18bd6131eb8a4888e1c294e69338697f"></p>
</div>

<p>报告称：人的学习分为「被动学习」和「主动学习」两个层次。</p>
<p>被动学习：如听讲、阅读、试听、演示，学习内容的平均留存率为 5%、10%、20%、30%。</p>
<p>主动学习：如通过讨论、实践、教授给他人，能将原来被动学习的内容留存率，从<br>5%，提升到 50%、75% 和 90%。</p>
<p>这个模型很好地展示了不同学习深度和层次之间的对比。</p>
<p>反观自身的学习，我们同样可以清晰地划分出不同的层次。</p>
<p>以阅读为例，从浅到深依次为：</p>
<p>听书</p>
<p>自己读书</p>
<p>自己读书 + 摘抄金句</p>
<p>自己读书 + 思维导图 / 读书笔记</p>
<p>自己读书 + 践行操练</p>
<p>自己读书 + 践行操练 + 输出教授</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/9fb0480ad30916a18ecfac90a73eb6bf.jpeg" alt="9fb0480ad30916a18ecfac90a73eb6bf"></p>
</div>

<p>当前有很多听书产品，读书达人用十几分钟解读一本书，一天听一本，一年下来就三百多本，这种便捷新颖、浓缩干货的学习看似轻松高效，实则处于被动学习的最浅层。</p>
<p>好一点的情况是自己读原书，但读完之后却不回顾或少有提炼总结，只满足于输入的过程，这类学习的知识留存率很低。卿不见几天之后就想不起来自己读了什么了吗？</p>
<p>更糟的是，这种努力会导致盲目追求阅读的速度和数量，让人产生勤奋的感觉，实际上这是低水平的勤奋，投入越多，损失越大。</p>
<p>初级阅读者不可避免会踩入这两个坑，而另一类浅层次学习的人数也不少，这类人能够自己阅读，也做读书笔记或思维导图，但遗憾的是，读书笔记的内容往往是把书中的内容梳理罗列了一番，看起来更像是一个大纲。</p>
<p>很多人醉心于此，似乎自己对全书的知识了若于胸，殊不知自己只是「农夫山泉」而已——「我们不生产知识，我们只是知识的搬运工！」</p>
<p>虽然这种做法一定程度上属于主动学习，但它仅仅是简单「知识陈述」，与高级别的「知识转换」有很大的不同。</p>
<p>更深一层的是，读书之后能去实践书中的道理，哪怕有那么一两点让生活发生改变，也是很了不起的，因为从这一刻开始，知识得到了转化。</p>
<p>从知道到做到是一个巨大的进步，然而自己知道或做到是一回事，让别人知道或做到又是另外一回事。</p>
<p>不信试着将自己知道的东西向别人清晰地讲出来，你会发现这并不容易，心里想得挺明白，讲的时候就开始语无伦次了，如果再让你把知道的东西写下来呢？你可能根本无从下笔。</p>
<p>请注意，这种困难才是真正深度学习的开始。</p>
<p>因为这必须动用原先所有的已有知识去解释新知识，当你能够把新学的知识解释清楚时，就意味着把它纳入了自己的知识体系，同时达到了教授他人的水平，并可能创造出新的知识。</p>
<p>罗振宇在 60 秒语音中曾提到他是这样学习的：</p>
<p>我每天要求自己写够五篇阅读心得，不用长篇大论，短短几个词就行。</p>
<p>因为真正的学习就像是缝扣子，把新知识缝接到原有的知识结构中，每天写五篇阅读心得就是逼迫自己原来的知识结构对新知识做出反应，然后把这个反应用文字固化下来，缝接的过程就完成了。</p>
<p>「缝合」是深度学习的关键，而大多数人只完成了「获取知识」，却忽略了「缝合知识」这一步，学习过程是不完整的。</p>
<p>另一些人有了一定的缝合，但缝合得不够深入，没有高质量的产出，也使得学习深度大打折扣。</p>
<p>浅层学习满足输入，深度学习注重输出。</p>
<p>从想法到语言再到文字，即网状的思维变成树状的结构再变成线性的文字，相当于把思想从气态变成液态再变成固态——那些固态的东西才真正属于自己。</p>
<p>毕竟任何知识都不可避免地会损耗，并且这种损耗一直存在，如果不想办法让自己学到的东西固化下来，时间一长就会烟消云散，留不下多少痕迹。</p>
<p>有了自己的东西，便一定要「教授」出去，「教授」和「缝合」会相互形成巩固和循环。</p>
<p>《暗时间》的作者刘未鹏说：「教」是最好的「学」，如果一件事情你不能讲清楚，十有八九你还没有完全理解。当然，「教」的最高境界是能用最简洁的话让一个外行人也能明白你讲的东西。</p>
<p>可见，逼迫自己通过「获取高质量知识」+「深度缝合新知识」，再用自己的语言或文字去教授他人，是为深度学习之道。</p>
<p>这是我目前能够觉知到最高层次的深度学习了，也许还有更高级的，但对绝大多数人来讲，能做到并做好这一点已经足够了。</p>
<p>02</p>
<p><strong>如何深度学习？</strong></p>
<p>如上，深度学习有三个要素：</p>
<p>1、获取高质量知识；</p>
<p>2、深度缝合新知识；</p>
<p>3、输出成果去教授。</p>
<p>这样的学习必然要放弃「快学」、「多学」的安全感，同时要耗费更多的时间，面临更难的处境，甚至还会「备受煎熬」。</p>
<p>但请一定相信：正确的行动往往是反直觉的，一开始舒服和容易的事往往得不到好结果，而一开始难受和困难的事才能让人真正产生收获。</p>
<p>所以，我们需要逐步改进。</p>
<p><strong>一. 尽可能地获取并亲自啃读一手知识</strong></p>
<p>从读书角度讲，就是读经典、读原著，甚至是学术论文。经典的一手知识已经经过时间的沉淀，价值深度已被证明，值得精耕细读。</p>
<p>把精力集中到符合自己需求的一手知识上，放弃那些「几分钟读完……」「每天一本……」「十堂……<br>课」的干货幻念，虽然那些也能带来一些启示，但终究是支离破碎、被人咀嚼过的。</p>
<p>亲自啃读虽然更艰辛，但唯有亲历过才能感受到深度理解或认知产生的真正快感，比吸收二手知识不知道要爽多少倍。</p>
<p>读书这事最好不要请人代替，从长远看，终归是要自己获得挖矿的能力的，这样才能走得更远。</p>
<p><strong>二. 尽可量用自己的话把所学知识写出来</strong></p>
<p>每读一本有价值的好书，就用写作的方式把作者的思想用自己的语言重构出来，尽力结合自身的经历、学识、角度去解释、延伸，而不是简单地把书本的要点进行罗列。</p>
<p>简单的「知识陈述」无法达到深度缝合的效果，只有做到「知识转换」才能用旧知识体系对新知识进行深度缝合，所以在重构时只取最需要的观点就好了，其它无关的观点可以放弃，即使它们很有理。</p>
<p>真正深度的好文往往与原书没有太大的关系，只是原书触发了思考，引用了案例，最后看来，读书笔记往往是一篇全新的文章，甚至创造了新的知识。</p>
<p>这个过程是渐近的，虽然刚开始说的好像都是别人的观点，但逐渐地就会衍生出自己的观点，虽然起初会有些吃力，但只要持续练习，能关联的经历、观点、案例就会越来越多，对一个主题的思考也会越来越深入。</p>
<p>所以无需求快、求多。如有必要，可以花足够长的时间去打磨一个主题或观点。当一个趋近你当前最好水平的作品打动了别人，所产生的影响力和收获远比每天写但缺乏深度的思考要强得多。</p>
<p>我鼓励大家写作，是因为一旦能写清楚了，就必定能讲清楚，而且文章具有复利效应，可以随时被他人读到，这样也间接地达到了讨论交流和教授他人的目的。</p>
<p><strong>三. 反思生活</strong></p>
<p>学习不止读书，生活经历同样可以被深度学习。</p>
<p>生活中每天发生的事情如水流一样经过我们，不会停留，如不留心，很难留下痕迹，就像最浅层的被动学习，留存率很低，缺少反思的生活难以产生深度。</p>
<p>《好好学习》的作者成甲就非常注重反思，他每天早上大约要花两个小时左右的时间进行复盘反思，而且要求自己的员工也这样做。</p>
<p>他在书中花了大量笔墨阐述了反思的方法和好处，他说：人与人之间的差距不是来自年龄，甚至不是来自经验，而是来自经验总结、反思和升华的能力。</p>
<p>受这个理念的影响，我从去年 2<br>月份开始，持续每天反思总结，有时几句话，有时上千字。</p>
<p>通过反思，我发现很多没想明白的事情在反思的时候想清楚了，很多模糊的概念在反思的时候变清晰了，很多看似并不关联的事情居然找到了底层的联通……</p>
<p>持续反思让我对生活细节的感知能力变得越来越强，生活给我留下来的东西也越来越多，或许这篇文章的立意与构思有很多要素也来自平日的反思。</p>
<p>如果让我推荐一个不可或缺的习惯，我必推反思。</p>
<p>03</p>
<p><strong>深度学习的好处</strong></p>
<p>深度学习除了能让我们放弃浮躁，磨练理智，还能带来诸多好处，比如跨界能力。</p>
<p>古典在《你的生命有什么可能》一书中说到，人的能力分为「知识、技能和才干」三个层次：</p>
<p>知识是最没有迁移能力的，你读到医科博士，也照样不会做麻婆豆腐；</p>
<p>技能通常由 70% 的通用技能和 30% 的专业技能组成，迁移性要好一些；</p>
<p>而到了才干层面，职业之间的界限就完全被打破了。</p>
<p>这就解释了为什么那些牛人能够轻易地在不同领域之间进行跨界，因为他们已经通过深度学习达到了某一领域的才干层面；</p>
<p>而这些才干在其它领域同样适用，所以只需要花少量的时间熟悉知识与技能就能玩得转。</p>
<p>但反过来，如果你在一个领域从未达到过才干层面，当换到其它行业时，只能从底层的知识和技能重新开始，这就非常吃力了。</p>
<p>深度学习能够帮助人们跨界，这毋庸置疑，同时它还能帮人产生灵感。</p>
<p>我们都知道爱因斯坦是在去专利局上班的路上，看到伯尼尔钟楼时，脑中突然冒出了一个假设：「如果公交车以光速移动，那么从车上看钟楼的指针会不会是静止的呢？」</p>
<p>这个假设使得 20 世界最伟大的发现——狭义相对论从此走入人们的视野。</p>
<p>而另一个德国化学家凯库勒，是在非常疲劳的情况下做了个白日梦，梦到一条首尾相咬的蛇，这条蛇成了他发现了苯分子结构的线索。</p>
<p>人们都惊叹科学家们的直觉和灵感，但假设爱因斯坦是一名理发师，凯库勒是一名管道工，他们就不会获得这些直觉和灵感。</p>
<p>因为只有他们在自己的领域探索得足够深入时，灵感才可能在潜意识的帮助下显现出来，这些原理在现代脑科学研究中都得到了应证。</p>
<p>虽然我们不是科学家，但深度学习依然能让人更大概率地收获意外的惊喜。</p>
<p>与此同时，深度学习能让我们在高处俯视，看到一般事物的更多关联，产生洞见，并且积累得越多，反应速度越快。</p>
<p>比如当我深度解读《超越感觉》，知晓正确思考的核心是让自己的主观认知尽量与客观世界保持一致后，我突然对「解放思想、实事求是」这八个字就有了全新的认识。</p>
<p>再看看祖国近年的发展，如此大的事实证明了这个真理是极其正确并重要的——而换作之前的我，肯定是看不到这个关联的。</p>
<p>不仅如此，如果自己在一些领域的认知深度积累得足够多，那么即便是面对影视节目、娱乐八卦、新闻热点这些「腐蚀」人们注意力的事物时，也同样能调动高级认知，把它们与有益的思考关联起来，产生比众人更深刻更独特的见解。</p>
<p>比如前两天我带女儿去看电影《西游记之女儿国》，剧中女儿国国王与唐僧经历生死之后对他说：「我做了一个梦，多年以后，你蓄满长发，和我一起慢慢变老，但是，你并不开心！」</p>
<p>我立即感慨到，这就是「未来视角」啊，国王用未来视角俯视现在，然后做出了理智的决定，克制了自己的感情放唐僧西行。</p>
<p>换作以前，我肯定是对此无感的，而在女儿眼里，能看到的只是国王好漂亮，猴子好搞笑……</p>
<p>据我所知，很多严肃的成长者同样喜欢娱乐消遣，比如李笑来喜欢看电影，师北宸喜欢看综艺……<br>我敢说，他们身处娱乐时，依旧是「现代脑」在主导，不断地在关联认知，而非单纯地满足「原始脑」的直接需求。</p>
<p>再延伸了说，热点娱乐并非没有价值，浮浅知识也同样具有意义，但前提是：你需要先有足够的认知深度——深度之下的广度才是有效的。</p>
<p>04</p>
<p>专注深度学习</p>
<p><strong>同时对浅学习保持开放</strong></p>
<p>说了这么多深度学习，那像罗辑思维推出的那些专栏、精品课、听书等产品应该如何对待呢？彻底拒绝或远离吗？</p>
<p>我觉得并不需要，因为深度学习与浅学习其实并不冲突，浅学习也有其价值。</p>
<p>重要的是不要搞反权重关系，我们可以把它作为了解新信息的入口，但不能把成长的过程全部寄托于此。</p>
<p>更合理的态度是：专注深度学习，同时对浅学习保持开放。</p>
<p>选择一些值得关注的人，通过这些平台和他们保持连接。</p>
<p>他们释放的一些有价值的信息会引领我们走向更广阔的世界，但无论如何，最终要自己去读、自己去想、自己去做。</p>
<p>就像这篇文章，如果触动了你，也仅仅是为你开启了一个新的视角，<strong>最终能否获取深度学习能力只能靠你自己去行动，没有人能够替代。</strong></p>
<p>学会深度学习，你的人生才会有更多可能。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>视频有关概念及文件大小计算方法</title>
    <url>/2021/02/15/%E8%A7%86%E9%A2%91%E6%9C%89%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>编码率 / 比特率直接与文件体积有关。且编码率与编码格式配合是否合适，直接关系到视频文件是否清晰。 </p>
<p>在视频编码领域，比特率常翻译为编码率，单位是 Kbps，例如 800Kbps </p>
<p>其中， 1K=1024 1M=1024K </p>
<p>b 为 比特（bit） 这个就是电脑文件大小的计量单位，1KB=8Kb，区分大小写，B 代表字节 (Byte) s 为 秒（second） p 为 每（per） </p>
<a id="more"></a>

<p>以 800kbps 来编码表示经过编码后的数据每秒钟需要用 800K 比特来表示。 </p>
<p>1MB=8Mb=1024KB=8192Kb </p>
<p>Windows 系统文件大小经常用 B (字节) 为单位表示，但网络运营商则用 b (比特)，也就是为什么 2Mb 速度宽带在电脑上显示速度最快只有约 256KB 的原因，网络运营商宣传网速的时候省略了计量单位。  </p>
<p>视频文件体积：(音频码率 + 视频码率) x 时长 / 8</p>
<p>or</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210215115042.png" alt="20210215115042"></p>
</div>

<p>例：有一个 1.5 小时（5400 秒）的影片，希望转换后文件大小刚好为 700M </p>
<p>计算方法如下： </p>
<blockquote>
<p>700×8÷5400×1024≈1061Kbps </p>
</blockquote>
<p>当然不经过压缩文件的计算公式又不同：</p>
<p>声音为，数据量（位 / 秒）= (采样频率（Hz）* 采样位数（bit）* 声道数)</p>
<p>其中，单声道的声道数为 1，立体声的声道数为 2。</p>
<p>数据量 * 时间 / 8＝文件总字节</p>
<p>例如:  </p>
<p>CD 即为未经压缩的音频文件，采样 44.1k,16 位，双声道。</p>
<p>数据量＝44.1<em>16</em>2=1411kb/1024=1.38Mb, 一般的 MP3 压缩后为 128kbps</p>
<p>如果以一张 CD 放一个小时计算的话，CD 总量＝1.38*3600/8=621MB, 当然 CD 大约放 1 小时多点，顶多也就 700MB。</p>
<p>图象应该是，数据量（位 / 秒）= (画面尺寸 * 彩色位数（bit）* 帧数)</p>
<blockquote>
<p>数据量 * 时间 / 8＝文件总字节 </p>
</blockquote>
<p>例如 :<br>2 分钟，25 帧 / 秒，640×480 分辨率，24 位真彩色数字视频的不压缩的数据量约为，数据量<br>＝640x480x24*25=184320Kb=180Mb, 而 VCD、MKV 标准编码率 (加上音频) 分别为 1152Kbps 和 30Mbps (1080p 高清)</p>
<p>2 分钟文件字节＝180Mbx120/8=2700000KB=2636.71875MB＝2.57GB，而压缩后一部 90 分钟高质量 DVD 电影可以达到 9GB。 </p>
<h2 id="像素及显示问题"><a href="#像素及显示问题" class="headerlink" title="像素及显示问题"></a>像素及显示问题</h2><p>大概主要牵扯到 3 个概念：像素、分辨率、密度。</p>
<h4 id="一、像素"><a href="#一、像素" class="headerlink" title="一、像素"></a>一、像素</h4><p>我们常说的像素，一般就是指图像含有多少个像素点。我们就以 720P、1080P 为例：</p>
<p>1080P 的实际像素是 1920*1280, 相乘结果是 2073600，即有 2073600 个像素点， 也就是常说的 1080P 为 200 万像素</p>
<p>720P 实际像素是 1280×720， 相乘结果 921600，即有 921600 个像素点，也就是常说的 720P 为 100 万像素</p>
<p>图像占用空间大小计算公式：</p>
<p>图像像素 * 图像位深 / 8 = 占用字节</p>
<p>如果一张图片像素为 1024*1024， 位深 32 位，则图片占用空间大小为：</p>
<blockquote>
<p>1024<em>1024</em>32/8 = 4194304 byte = 4096KB.</p>
</blockquote>
<h4 id="二、分辨率"><a href="#二、分辨率" class="headerlink" title="二、分辨率"></a>二、分辨率</h4><p>分辨率常指的是设备输出分辨率或叫屏幕分辨率，即屏幕上横竖有多少个容器点，每个容器点用于容纳一个像素。</p>
<p>例如 iPhone 5s, 它的分辨率为 1136<em>640，用它看 1080P, 其实只能看到 1136</em>640 多个像素点，不能发挥 1080P 的优势，</p>
<p>很多细节被忽略。</p>
<h4 id="三-密度"><a href="#三-密度" class="headerlink" title="三  密度"></a>三  密度</h4><p>每英寸包括多少个像素点，单位 PPI (Pixels Per Inch)。屏幕 PPI 计算方式：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210215120502.png" alt="20210215120502"></p>
</div>
比如 iPhone 5s 屏幕分辨率为: 1136*640,  尺寸为 4 英寸，则 PPI 为 (1136*1136+640*640)/4, 开根号，大概就是 325。

<p>PPI 超过 300 就可以算是视网模屏了，肉眼已经分辨不出像素点来。</p>
<p>假设我有 A、B 两部手机，两者屏幕的宽度分辨率都是 320*640，但 A 的尺寸为 3.5 英寸，B 的宽度为 7 英寸，那么显然是 A 手机的密度大，</p>
<p>所有 A 的图像看起来更清晰，而 B 的看起来要模糊些，图像也要大些。</p>
<h2 id="码率（Bitrate）、帧率（FPS）、分辨率和清晰度的联系与区别"><a href="#码率（Bitrate）、帧率（FPS）、分辨率和清晰度的联系与区别" class="headerlink" title="码率（Bitrate）、帧率（FPS）、分辨率和清晰度的联系与区别"></a>码率（Bitrate）、帧率（FPS）、分辨率和清晰度的联系与区别</h2><p><a href="https://blog.csdn.net/pc9319/article/details/79621352?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">转自</a></p>
<h4 id="视频码率、帧率和分辨率到底哪一个影响电影的清晰度"><a href="#视频码率、帧率和分辨率到底哪一个影响电影的清晰度" class="headerlink" title="视频码率、帧率和分辨率到底哪一个影响电影的清晰度"></a>视频码率、帧率和分辨率到底哪一个影响电影的清晰度</h4><p>码率：影响体积，与体积成正比：码率越大，体积越大；码率越小，体积越小。</p>
<p>码率就是数据传输时单位时间传送的数据位数 , 一般我们用的单位是 kbps 即千位每秒。也就是取样率（并不等同与采样率，采样率的单位是 Hz，表示每秒采样的次数），单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真，围绕这个核心衍生出来 cbr（固定码率）与 vbr（可变码率）， “码率” 就是失真度，码率越高越清晰，反之则画面粗糙而多马赛克。</p>
<p>下面是通过一个 wav 文件的采样率来计算码率和文件大小，通过 MediaInfo 工具显示的文件信息如下：</p>
<p>概要</p>
<p>完整名称                            :audio\wav\adele-rolling_in_the_deep.wav</p>
<p>文件格式                            : Wave</p>
<p>文件大小                            : 38.3 MiB</p>
<p>长度                                   : 3 分 47 秒</p>
<p>平均混合码率                    : 1 411 Kbps</p>
<p>音频</p>
<p>ID                                        : 0</p>
<p>文件格式                            : PCM</p>
<p>格式设置 ,Endianness      : Little</p>
<p>编码设置 ID                         : 1</p>
<p>编码设置 ID/ 提示信息        : Microsoft</p>
<p>长度                                     : 3 分 47 秒</p>
<p>码率                                     : 1 411.2 Kbps</p>
<p>声道                                    : 2 声道</p>
<p>采样率                                : 44.1 KHz</p>
<p>位深度                                : 16 位</p>
<p>大小                                    : 38.3 MiB (100%)</p>
<h5 id="1-码率计算公式："><a href="#1-码率计算公式：" class="headerlink" title="1. 码率计算公式："></a>1. 码率计算公式：</h5><p>码率 = 采样率 x 位深度 x 声道</p>
<p>所以，上面文件的码率 = 44.1Khz x 16 位 x 2 声道 = 1411.2 Kbps</p>
<h5 id="2-文件大小-码率-x-时长-1411-2-Kbps-x-3-x-60-47-s-1411-2Kbps-x-227s-38102-4Kb"><a href="#2-文件大小-码率-x-时长-1411-2-Kbps-x-3-x-60-47-s-1411-2Kbps-x-227s-38102-4Kb" class="headerlink" title="2. 文件大小 = 码率 x 时长 = 1411.2 Kbps x (3 x 60 + 47 )s = 1411.2Kbps x 227s =38102.4Kb"></a>2. 文件大小 = 码率 x 时长 = 1411.2 Kbps x (3 x 60 + 47 )s = 1411.2Kbps x 227s =38102.4Kb</h5><p>38102.4 Kb /1024 Kb/M = 37.2M</p>
<p>近似等于 mediainfo 工具显示的文件大小 38.3M。</p>
<p>注：此计算公式对未压缩的 wav 格式文件有效，不适用于 mp3 等被压缩的文件。</p>
<p>通常来说，一个视频文件包括了画面及声音，例如一个 RMVB 的视频文件，里面包含了视频信息和音频信息，音频及视频都有各自不同的采样方式和比特率，也就是说，同一个视频文件音频和视频的比特率并不是一样的。而我们所说的一个视频文件码流率大小，一般是指视频文件中音频及视频信息码流率的总和。</p>
<p>以国内最流行，大家最熟悉的 RMVB 视频文件为例，RMVB 中的 VB，指的是 VBR，即 Variable BitRate 的缩写，中文含义是可变比特率，它表示 RMVB 采用的是动态编码的方式，把较高的采样率用于复杂的动态画面 (歌舞、飞车、战争、动作等)，而把较低的采样率用于静态画面，合理利用资源，达到画质与体积可兼得的效果。</p>
<p>帧率（FPS） ：影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。如果码率为变量，则帧率也会影响体积，帧率越高，每秒钟经过的画面越多，需要的码率也越高，体积也越大。<br>帧率就是在 1 秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。每秒显示的图片数影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。由于人类眼睛的特殊生理结构，如果所看画面之帧率高于 16 的时候，就会认为是连贯的，此现象称之为视觉暂留。并且当帧速达到一定数值后，再增长的话，人眼也不容易察觉到有明显的流畅度提升了。</p>
<p>分辨率：影响图像大小，与图像大小成正比：分辨率越高，图像越大；分辨率越低，图像越小。</p>
<h4 id="带宽、帧率（FPS）"><a href="#带宽、帧率（FPS）" class="headerlink" title="带宽、帧率（FPS）"></a>带宽、帧率（FPS）</h4><p>例如在 ADSL 线路上传输图像，上行带宽只有 512Kbps，但要传输 4 路 CIF 分辨率的图像。按照常规，CIF 分辨率建议码率是 512Kbps，那么照此计算就只能传一路，降低码率势必会影响图像质量。那么为了确保图像质量，就必须降低帧率，这样一来，即便降低码率也不会影响图像质量，但在图像的连贯性上会有影响。</p>
<h4 id="GOP（Group-of-picture）"><a href="#GOP（Group-of-picture）" class="headerlink" title="GOP（Group of picture）"></a>GOP（Group of picture）</h4><p>关键帧的周期，也就是两个 IDR 帧之间的距离，一个帧组的最大帧数，一般而言，每一秒视频至少需要使用 1 个关键帧。增加关键帧个数可改善质量，但是同时增加带宽和网络负载。</p>
<p>需要说明的是，通过提高 GOP 值来提高图像质量是有限度的，在遇到场景切换的情况时，H.264 编码器会自动强制插入一个 I 帧，此时实际的 GOP 值被缩短了。另一方面，在一个 GOP 中，P、B 帧是由 I 帧预测得到的，当 I 帧的图像质量比较差时，会影响到一个 GOP 中后续 P、B 帧的图像质量，直到下一个 GOP 开始才有可能得以恢复，所以 GOP 值也不宜设置过大。</p>
<p>同时，由于 P、B 帧的复杂度大于 I 帧，所以过多的 P、B 帧会影响编码效率，使编码效率降低。另外，过长的 GOP 还会影响 Seek 操作的响应速度，由于 P、B 帧是由前面的 I 或 P 帧预测得到的，所以 Seek 操作需要直接定位，解码某一个 P 或 B 帧时，需要先解码得到本 GOP 内的 I 帧及之前的 N 个预测帧才可以，GOP 值越长，需要解码的预测帧就越多，seek 响应的时间也越长。</p>
<h4 id="常见编码模式："><a href="#常见编码模式：" class="headerlink" title="常见编码模式："></a>常见编码模式：</h4><p>VBR（Variable Bitrate）动态比特率也就是没有固定的比特率，压缩软件在压缩时根据音频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式，推荐编码模式；</p>
<p>ABR（Average Bitrate）平均比特率是 VBR 的一种插值参数。LAME 针对 CBR 不佳的文件体积比和 VBR 生成文件大小不定的特点独创了这种编码模式。ABR 在指定的文件大小内，以每 50 帧（30 帧约 1 秒）为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量，可以做为 VBR 和 CBR 的一种折衷选择。</p>
<p>CBR（Constant Bitrate）常数比特率指文件从头到尾都是一种位速率。相对于 VBR 和 ABR 来讲，它压缩出来的文件体积很大，而且音质相对于 VBR 和 ABR 不会有明显的提高。</p>
<h4 id="高清视频"><a href="#高清视频" class="headerlink" title="高清视频"></a>高清视频</h4><p>目前的 720P 以及 1080P 采用了很多种编码，例如主流的 MPEG2，VC-1 以及 H.264，还有 Divx 以及 Xvid，至于封装格式更多到令人发指，ts、mkv、wmv 以及蓝光专用等等。</p>
<p>720 和 1080 代表视频流的分辨率，前者 1280<em>720，后者 1920</em>1080，不同的编码需要不同的系统资源，大概可以认为是 H.264&gt;VC-1&gt;MPEG2。</p>
<p>VC-1 是最后被认可的高清编码格式，不过因为有微软的后台，所以这种编码格式不能小窥。相对于 MPEG2，VC-1 的压缩比更高，但相对于 H.264 而言，编码解码的计算则要稍小一些，目前来看，VC-1 可能是一个比较好的平衡，辅以微软的支持，应该是一只不可忽视的力量。一般来说，VC-1 多为 “.wmv” 后缀，但这都不是绝对的，具体的编码格式还是要通过软件来查询。</p>
<p>总的来说，从压缩比上来看，H.264 的压缩比率更高一些，也就是同样的视频，通过 H.264 编码算法压出来的视频容量要比 VC-1 的更小，但是 VC-1 格式的视频在解码计算方面则更小一些，一般通过高性能的 CPU 就可以很流畅的观看高清视频。相信这也是目前 NVIDIA Geforce 8 系列显卡不能完全解码 VC-1 视频的主要原因。</p>
<p>PS&amp;TS 是两种视频或影片封装格式，常用于高清片。扩展名分别为 VOB/EVO 和 TS 等；其文件编码一般用 MPEG2/VC-1/H.264</p>
<p>高清，英文为 “High Definition”，即指 “高分辨率”。高清电视 (HDTV)，是由美国电影电视工程师协会确定的高清晰度电视标准格式。现在的大屏幕液晶电视机，一般都支持 1080i 和 720P，而一些俗称的 “全高清”(Full HD)，则是指支持 1080P 输出的电视机。</p>
<p>目前的高清视频编码格式主要有 H.264、VC-1、MPEG-2、MPEG-4、DivX、XviD、WMA-HD 以及 X264。事实上，现在网络上流传的高清视频主要以两类文件的方式存在：一类是经过 MPEG-2 标准压缩，以 tp 和 ts 为后缀的视频流文件 ; 一类是经过 WMV-HD(WindowsMedia Video HighDefinition) 标准压缩过的 wmv 文件，还有少数文件后缀为 avi 或 mpg，其性质与 wmv 是一样的。真正效果好的高清视频更多地以 H.264 与 VC-1 这两种主流的编码格式流传。</p>
<p>一般来说，H.264 格式以 “.avi”、“.mkv” 以及 “.ts” 封装比较常见。</p>
<h4 id="清晰度"><a href="#清晰度" class="headerlink" title="清晰度"></a>清晰度</h4><p>在码率一定的情况下，分辨率与清晰度成反比关系：分辨率越高，图像越不清晰，分辨率越低，图像越清晰。</p>
<p>在分辨率一定的情况下，码率与清晰度成正比关系，码率越高，图像越清晰；码率越低，图像越不清晰。</p>
<p>在码率一定的情况下，分辨率在一定范围内取值都将是清晰的；同样地，在分辨率一定的情况下，码率在一定范围内取值都将是清晰的。</p>
<p>在视频压缩的过程中， I 帧是帧内图像数据压缩，是独立帧。而 P 帧则是参考 I 帧进行帧间图像数据压缩，不是独立帧。在压缩后的视频中绝大多数都是 P 帧，故视频质量主要由 P 帧表现出来。由于 P 帧不是独立帧，而只是保存了与邻近的 I 帧的差值，故实际上并不存在分辨率的概念，应该看成一个二进制差值序列。而该二进制序列在使用熵编码压缩技术时会使用量化参数进行有损压缩，视频的质量直接由量化参数决定，而量化参数会直接影响到压缩比和码率。</p>
<p>视频质量可以通过主观和客观方式来表现，主观方式就是通常人们提到的视频清晰度，而客观参数则是量化参数或者压缩比或者码率。在视频源一样，压缩算法也一样的前提下比较，量化参数，压缩比和码率之间是有直接的比例关系的。</p>
<p>分辨率的变化又称为重新采样。由高分辨率变成低分辨率称为下采样，由于采样前数据充足，只需要尽量保留更多的信息量，一般可以获得相对较好的结果。而由低分辨率变成高分辨率称为上采样，由于需要插值等方法来补充（猜测）缺少的像素点，故必然会带有失真，这就是一种视频质量（清晰度）的损失。</p>
<h4 id="关于一个视频流的数据量："><a href="#关于一个视频流的数据量：" class="headerlink" title="关于一个视频流的数据量："></a>关于一个视频流的数据量：</h4><p>码率如果为 10Mb/s，代表 1 秒钟有 10M bit 的视频数据，对于 YUV422 格式的 1080P 视频而言，一帧图像是 1920x1080x2x8/1024/1024 = 31.64Mbit，1 秒钟 30 帧图像的话，则有 949.2Mb/s，可见其数据量之大，不压缩根本无法网上传播，所以一定要经过视频压缩处理，不要以为 1080P 的视频就一定是高清的，清晰度还跟视频码率密切相关，对于 1080P 的视频而言，蓝光视频的码率是 20Mb/s，一般下载的视频码率大都是 10Mb/s，一些 IPCamera/ 无人机的码率是 2～8Mb/s，而很多视频网站的码率甚至低于 5M/s，其实有时还不如高码率的 720P 清晰。</p>
<h3 id="好的画质是分辨率、帧率和码率三者之间的平衡："><a href="#好的画质是分辨率、帧率和码率三者之间的平衡：" class="headerlink" title="好的画质是分辨率、帧率和码率三者之间的平衡："></a>好的画质是分辨率、帧率和码率三者之间的平衡：</h3><p>码率不是越大越好</p>
<p>如果不做码率大小上的限制，那么分辨率越高，画质越细腻；帧率越高，视频也越流畅，但相应的码率也会很大，因为每秒钟需要用更多的数据来承载较高的清晰度和流畅度。这对云服务厂商而言这是好事（收入跟流量呈正比），但对您可能意味着更多的费用开支。</p>
<p>帧率不要超过 24</p>
<p>如果限定一个码率，比如 800kbps，那么帧率越高，编码器就必须加大对单帧画面的压缩比，也就是通过降低画质来承载足够多的帧数。如果视频源来自摄像头，24FPS 已经是肉眼极限，所以一般 20 帧的 FPS 就已经可以达到很好的用户体验了。</p>
<p>有些玩过 3D 游戏的朋友可能会说，游戏的帧率越高越流畅。这里要注意一定不要混淆场景：游戏追求高帧率的目的是为了尽可能让 3D 模型渲染出来的运动效果更加接近真实运动轨迹，所以帧率越高越好。但对摄像头而言，它要采集的目标是真实世界的物体，真实世界本来就没有刷新率的说法，所以这个理论不适用。</p>
<p>分辨率不盲目攀高</p>
<p>如果限定一个码率，比如 800kbps，那么分辨率越高就会让编码器越 “为难 “ ，可以想象，它必须拆东墙补西墙，通过减少色彩信息或者引入马赛克这种 “鱼目混珠” 的手段来承载足够多的像素点。所以，同样的是 2G 的一个电影文件，1080p 画质的版本可能不如 720p 画质的版本看起来更清晰。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>帧率：FPS（每秒钟要多少帧画面）；   以及 Gop（表示多少秒一个 I 帧）</p>
<p> 码率：编码器每秒编出的数据大小，单位是 kbps，比如 800kbps 代表编码器每秒产生 800kb（或 100KB）的数据。</p>
<p> 分辨率：单位英寸中所包含的像素点数； VGA：Video Graphics Array（视频图像分辨率）</p>
<p> 三者的对应直播质量的影响因素：</p>
<p> 帧率：影响</p>
<p> 画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。如果码率为变量，则帧率也会影响体积，帧率越高，每秒钟经过的画面越多，需要的码率也越高，体积也越大。帧率就是在 1 秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。</p>
<p> 分辨率：影响图像大小，与图像大小成正比：分辨率越高，图像越大；分辨率越低，图像越小。</p>
<p> 清晰度</p>
<p> 在码率一定的情况下，分辨率与清晰度成反比关系：分辨率越高，图像越不清晰，分辨率越低，图像越清晰。</p>
<p> 在分辨率一定的情况下，码率与清晰度成正比关系，码率越高，图像越清晰；码率越低，图像越不清晰。</p>
]]></content>
      <categories>
        <category>视频工具使用</category>
      </categories>
      <tags>
        <tag>视频工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>超强的学习能力是怎样练就的0</title>
    <url>/2021/03/08/%E8%B6%85%E5%BC%BA%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%83%E5%B0%B1%E7%9A%840/</url>
    <content><![CDATA[<p>学习并不是一味的努力，我们需要具备以下几个特质：</p>
<ul>
<li>1、匹配合适的目标；</li>
<li>2、学会深度学习；</li>
<li>3、建立自己的的认知体系；</li>
<li>4、及时正向反馈；</li>
<li>5、合理安排休息。</li>
</ul>
<a id="more"></a>

<h4 id="第一节-匹配：舒适区边缘，适用于万物的方法论"><a href="#第一节-匹配：舒适区边缘，适用于万物的方法论" class="headerlink" title="第一节　匹配：舒适区边缘，适用于万物的方法论"></a>第一节　匹配：舒适区边缘，适用于万物的方法论</h4><p>我在前一章描述的深度沉浸其实并非刻意练习的真正核心，其真正核心在于难易匹配上。</p>
<p>「匹配」这个关键词很可能被大众忽略了，但稍加研究我们就会发现，只要掌握了匹配原则，我们就可以掌握一个适用于万物的方法论。这么说还真不是夸张，因为匹配原则的适用范围实在太广了。</p>
<p>好的成长是始终游走在「舒适区边缘」</p>
<p>就在我写这部分内容的时候，碰巧读者「Amy 曹」跟我分享了她的几点体会，我一看内容就会心地笑了，因为她的体会正好印证了「匹配」这个关键词，所以我们不妨从她的故事开始。</p>
<p>第一件事说的是跑步，她说：「之前我要求自己每天跑步 1 小时，靠意志力，我坚持了蛮长一段时间，但是最后还是中断了。最近我调整了跑步的时间，改为每次 30 分钟，最好不要少于一周 4 次。调整以后发现，我可以不用太靠意志力去做这件事，而且会主动想办法坚持，并且跑完后会很放松，不像之前那样连续跑 1 小时会很累、很难受。我真的能感觉到现在这种『主动做』和原先那种『靠意志力做』完全不一样。」</p>
<p>第二件事说的是学英语，她说：「原来每天学习 1 小时我会烦躁，但现在改为每天学习 30 分钟，时间一到就不学了。这样，我反而可以坚持每天学，不厌倦。」</p>
<p>最后她总结道：「找一个自己能坚持做下去的方式，比单纯按照标准化的时间和方式做更重要。以前一直以为多花时间才能学好、才能达到效果，其实那是因为自己急于求成，想要快速见效，这样反而不容易坚持。现在降低了难度和标准，自己的行动力反而能持续增强，虽然达到目标所需的时间可能会变长，但是我相信这样的坚持最终可以产生复利效应。」</p>
<p>不知道你看了「Amy 曹」的故事后有何感想？在我看来，她最可贵的地方在于能够主动降低学习的强度和难度，使自己处在最佳承受范围，既保留了学习的成就感，也保证了学习的挑战性。</p>
<p>但是对大多数人来说，这种做法是反直觉的，因为我们想要做成一件事的时候，通常都会告诉自己要很努力、很拼，会给自己设定一个很高的标准，还会经常给自己「打鸡血」，告诉自己坚持就是胜利。这是我们默认的思考模式，只是默认的不代表就是科学的。那么科学的模式是什么呢？</p>
<p>回忆图 1-4 的内容，它告诉我们，最佳的学习区域在拉伸区内、舒适区边缘，在这个区域，我们既有成就又有挑战，进步最快。事实上，它就是难易匹配的意思：既不要太难，也不要太容易，难易适中的地带才是学习的心流通道。</p>
<p>「Amy 曹」一开始就处在困难区。由于想快速看到改变，她制订了远超自身水平的学习、训练计划，结果因体验太痛苦而中途放弃，这非常像我们常见的激励模式。很多缺少经历的年轻人都是这样的，总想同时实现太多、太大的目标，还希望在很短的时间内实现，于是不自觉地把自己推到了困难区内。他们总是兴冲冲地开始，热火朝天地做上几天，然后很快就没劲了 —— 做事情半途而废就是这个原因。</p>
<p>当然，匹配原则不只适用于学习这一领域，在我能观察到的任何领域，几乎都遵循这个规律。</p>
<p>比如健身，我们每次推举受力的时候其实都是肌肉撕裂的过程，这种轻微的撕裂会让人产生酸痛感但不会造成伤害，经过休息和营养补充，肌肉就会开始修复，修复过后会变得更强壮，所以每次教练让我们再坚持一下，做到力竭，就是在逼迫我们走出肌肉的舒适区到拉伸区。</p>
<p>其他运动也是如此，比如很多人都想通过跑步来减肥，但有的人很刻苦，上来就猛冲，以为那种痛苦感就是努力的证据，其实不然，专业教练给出的方法看上去更像是一种偷懒的做法。比如教练会建议你先慢跑，到稍微气喘的时候就改为快走，等气匀了再改为慢跑，如此反复，运动半个小时。因为就减肥而言，有氧运动前 20 分钟消耗的主要是身体里的糖，30 分钟之后消耗脂肪的比例才会有较大幅度的上升。所以我们只需每次到舒适区的边缘坚持一下，然后回到舒适区停留一下，调整好了再到舒适区边缘…… 如此反复。在接下来的 10~15 分钟，如果体力允许，就尽量快跑，或者强度至少比前 30 分钟再大一点，以便消耗更多的脂肪，因为此时身体已经适应了一定的强度，可以离舒适区边缘再远一些。</p>
<p>再说阅读。很多人喜欢向能人索要书单，认为能人们推荐的书肯定很好。他们按照书单兴冲冲地买一大堆回家，读的时候才发现那些书根本没能人们说的那么好，有些书晦涩、难懂、根本读不下去，没过几天，他们的兴趣就消失了。这是因为每个人的知识背景不同，同样一本书，能人们读起来可能刚好在拉伸区，但我们读起来则在困难区。所以，这个时候，不妨先把这本书放一放，去看那些自己感兴趣、又刚好能读懂的书，让兴趣、难度、需求同时匹配到舒适区边缘，这样的书肯定会让你读得津津有味。</p>
<p>再说说学习。成绩不好的同学想要奋起直追，想到的第一件事往往是努力比拼，于是他们也和成绩好的同学一样去做那些比较难的题目，结果人家学得挺轻松，自己却学得很痛苦，差距越拉越大。因为学习同样的内容，成绩好的同学可能刚好在拉伸区，但自己可能在困难区。此时，正确的做法应该是先沉住气，主动降低学习难度。</p>
<p>知道了这个原理以后，我们就应该花大量的时间去梳理哪些内容处在自己的拉伸区，即梳理那些「会做但特别容易错或不会做但稍微努力就能懂」的内容，然后在这个区域内努力。如果你已经为人父母，那就应该花大量的时间探寻孩子的拉伸区，然后指导他们在舒适区的边缘努力，而不是看到孩子考不好就一味冲着他们发脾气，说别人家的孩子如何如何，对标优等生，给孩子加学习量、加难度，这样做往往会适得其反。</p>
<p>另外，很多人说自己学习时经常分心走神、不够专注，其实原因也是一样的，因为他们可能并没有刻意关注自己学习内容的难易程度、调整学习的快慢节奏。我的朋友宋鼎华是一名高级工程师，平日里大家都叫他「宋兄」，他的孩子正在读高中，学习成绩始终名列前茅，可贵的是孩子从来不上课外兴趣班，学习之余还有不少玩游戏的时间，是名副其实的「学霸」。在一次聚会中，我正好与宋兄临座，于是试探地问：「你在孩子的学习上有没有采取什么特别的方法？」没想到他干脆地说：「有的！」我竖起耳朵继续听，他说：「就两条，一是像对待考试一样对待家庭作业；二是有问题只找主观原因。」</p>
<p>我听后有些发懵，心想：这就是所谓学霸的秘密吗？尤其是第一条，我竟然抓不到要领。后来才明白，「像对待考试一样对待家庭作业」就是让孩子保持合适的学习节奏。因为大多数孩子在家里写作业的时候都会因缺少限制而漫不经心，一会儿上厕所，一会儿喝水，遇到不会的就卡在原地发呆或马上求助，这种状态看起来像一直在学习，实际上是在舒适区内磨洋工，不仅效率低，还特别容易出错。而要求像考试一样，他们就必须逼迫自己集中注意力，在最短的时间内做最多的题，并且还要做正确，于是他们不自觉地把自己推到了舒适区的边缘。在这种状态下，孩子必然会极度专注，学习效率和成绩自然会提升。</p>
<p>距离太远的，我们都把握不住</p>
<p>面对上述需要努力的事情，我们需要游走在舒适区边缘，那么，面对那些不需要努力，甚至是令人享受的事物时，我们又该如何呢？比如突然有了大量的时间和金钱。我想很多人肯定希望时间和金钱越多越好，不过我劝你一定要谨慎，因为距离我们太远的事物，我们通常无法把握，无论它们是令人痛苦的还是令人享受的。</p>
<p>2019 年暑假，一位年轻的老师在向我提问的时候说：「别人羡慕我有寒暑假，但我一点也不喜欢，因为自己根本没有能力掌控这些大量的空余时间。不仅计划一个没实现，连作息时间也乱作一团。可以说，我对假期简直一点控制力都没有。」</p>
<p>很多学生也经常给我留言，说上了大学之后，一下子没有了高三时的那种紧张感，虽然刚开学的时候还算自律，但很快就开始变得懒散，宅在寝室里打游戏、刷抖音，无法专心学习，尤其是独处、时间由自己支配的时候，总是不自觉地选择最舒适的娱乐活动。这其实就是自由时间超出了自己的掌控 —— 他们失控了。</p>
<p>千万不要认为没有管束的生活很美好，一旦进入完全自由的时间，虽然开始会很舒服，但很快，我们就会迷失在众多选项中 —— 做这个也行，做那个也行。做选择是一件极为耗能的事情，如果没有与之匹配的清醒和定力，绝大多数人最终都会被强大的天性支配，去选择娱乐消遣。在有约束的环境下我们反而效率更高，生活更充实。</p>
<p>至于突然获得巨额财富这种事，估计大多数人都很难有这样的运气，不过我们可以看看别人的经历。2002 年，英国男子卡罗尔中了 970 万英镑奖金，一夜之间从垃圾工成了超级富翁，然后他开始买豪宅、买名车、吸毒、赌博，7 年后，其财富被挥霍一空，妻子离他而去，他不得不重做苦力，靠救济金生活；2006 年，英国女子温迪・格雷厄姆中了 100 万英镑奖金，结果奖金在一年内被花光，该女子沦为穷光蛋。据统计，在美国，每年彩票中奖者的破产率高达 75%。以此为戒，我们一定要保持清醒，认真审视自己控制欲望的能力，不要让悲剧发生。</p>
<p>理想的状态是持续获取与自己当前能力相匹配的财富或自由。这一点，做父母的应该有所启示：我们要关注孩子当前对自由、财富的掌控程度，在适当的时候适当放权或鼓励，这样的父母才是真正明智的。那些溺爱孩子的父母，往往在孩子很小的时候就给他们很大的决策权，让他们自己决定吃什么、玩什么、做什么，但孩子根本没有相应的掌控能力，最后变成了自以为是、自私自利的人，造成这些后果的原因正是我们缺少对匹配这个概念的认识。</p>
<p>人们常说底层概念、底层规律，那到底什么是底层呢？在我眼中，能解释的现象越多，这个概念就越底层。所以你掌握了匹配原则之后，就可以自己解释其他事情了，比如有人问你：「练习写作是日更好还是周更好？」你可以这样回答：「不管采用哪种方式，关键是你有没有让自己处在舒适区的边缘进行练习。如果输出的东西都是在舒适区随便写写的，那写再多也没用。」这样的回答既能给出开放的答案，又能抓住问题的本质。</p>
<p>从这个底层概念中我们可以得到这样一个结论：不管做什么，不管当前做得怎么样，只要让自己处在舒适区的边缘持续练习，你的舒适区就会不断扩大，拉伸区也就会不断扩展，原先的困难区也会慢慢变成拉伸区，甚至是舒适区，所以成长是必然的。</p>
<p>同时，我们也可以肯定：速成是不可能的。因为能力圈只能一点一点扩大，所以只要我们遵循匹配规律，不断在舒适区边缘拓展自己，同时愿意和时间做朋友，那么我们注定可以持续成长，重塑自己。</p>
<p>一切为了匹配</p>
<p>刻意练习的四要素看上去各自独立，实际上环环相扣、互连互通，而且它们最终都指向匹配。</p>
<p>先说第一个要素「目标」，它能帮我们解决行动力中的大问题。比如，我们每次行动遇阻时都会一筹莫展，但只要细想就能发现，不管你遇到的是什么问题，其根源都是一样的，那就是：这个问题太大、太模糊。</p>
<p>所以，你只要拆解目标 —— 把大目标拆分为小目标，任务就会立即从困难区转移到拉伸区，这样你就愿意行动了。不信的话，你可以细心观察一下，几乎所有的行动达人都是拆解任务的高手。</p>
<p>掌握了这个原理，我们就能推导出从舒适区到拉伸区的策略：提炼目标。在舒适区内行动最大的特点就是不动脑筋地重复，这种状态下，人们凭习惯和感觉做事，没有特别需要关注的东西，所以学习的时候分心走神，跑步的时候分心走神，睡觉的时候也分心走神，这样，做什么事都不会有太大的长进。</p>
<p>在拉伸区练习的一大特点就是要有关注点。</p>
<h3 id="这个回答最好"><a href="#这个回答最好" class="headerlink" title="这个回答最好"></a>这个回答最好</h3><p>老规矩，绝不只答题，必须先审题，先破题。</p>
<p>本答案中心思想：超强的学习能力，不是练就的，而是把那些阻碍一个人发挥潜力的东西清理掉，而呈现出来的。所以这个答案的中心思想是 “减”，而不是 “加”。</p>
<p>1、真正的学霸显然会给人一种，游刃有余，浑然天成的感觉。不是那种苦哈哈紧绷绷学习的人，而是做任何事情，轻松随意，却又条理分明，十分漂亮的人。这里就形成了一个悖论 —— 如果你在看这个问题及答案的时候，基本模式仍然是，我要更用力一点，我要更努力一点，学到某些东西，做到某些东西，不妨先暂停下来，反思一下这个十分明显的矛盾。</p>
<p>2、我会把这个问题反过来问，大部分人在小时候都聪明过，而且都有过一切轻松明了的经验，但我们真正的成长过程是 —— 慢慢的就越变越笨了。少部分没有被变笨的人，自然地变成了更会学习的，那么我们不妨来问，人是如何慢慢变笨的呢？</p>
<p>3、心思一多，人就变笨。凡是利弊得失考虑的多了，心思不纯，思前想后，人就变得蠢笨了。人开始考虑投机取巧，开始想老师怎么看我，同学怎么看我，开始聚集在一起讲讲八卦聊聊闲天的人，只要沾染了这些习惯，那种简单干净朴素的心境就全然不再。面对一个课题，一个知识的时候，也就无法再简单纯粹地客观处理它。</p>
<p>4、随着年岁的增长，社会化的程度越来越多，人的心思越来越散乱，我们每个人都可以再自己身上观察到这样一些东西：常常处在千头万绪，心思涣散的过程中。总在看，怎么评价谁谁，如何关注某个事件。还在悄悄咪咪地想，别人看不看得起我。哎呀，我好看不起那个人之类的事情。真正全心全意用来 “学习” 的时间，高纯度的注意力，都越来越少。</p>
<p>5、到了一定年龄，哪怕工作后，都仍然保持着超强学习能力的人，都会让人感觉他们还很像小孩子。生活简朴，心思也非常简单。说话办事，给人的感觉就是两个字 ——“干净”。他们不会想太多，就是很淳朴的，该学习了，我便学习了。该做的事，那么我就踏踏实实地做好，做完。也不多说什么，也不和谁讨论什么，抱怨什么，也不需要考虑那么多利弊得失。因为这些人一路以来就这样过下来，他 / 她考虑得很少，得到的却很多。这个正向循环，就让他们心思越来越纯粹，事情也做的越来越好。</p>
<p>6、如果你认为，“超强的学习能力”，就意味着，我会有光明的未来，名利丰收，别人也会看得起我。那么，你几乎不会拥有超强的学习能力。因为，你喜欢的只是结果，不是这个过程。你在内心里没有对学习，对这个事本身的尊重和虔诚，只是把它当做一个垫脚石，那么，它也并不会给予你足够的尊重和虔诚。世间道理千千万，学习、工作、金钱也好，都只是一面镜子，它们对我的态度，恰是我对它们的态度，分毫不差。</p>
<p>7、说到底，“汝欲学诗，功夫在诗外。” 真正喜欢骏马的人，会懂得欣赏骏马，得到骏马。真正喜欢学习的人，会懂得欣赏学习本身，也就会被学习和成绩所善待。奇技淫巧，文过饰非，不如真诚面对自己每时每刻的态度。仅此而已。</p>
<h3 id="高冷冷-的回答（最佳）"><a href="#高冷冷-的回答（最佳）" class="headerlink" title="高冷冷 的回答（最佳）"></a>高冷冷 的回答（最佳）</h3><p>[转自知乎高冷冷的回答，感谢]</p>
<p>手把手教你：如何练就超强的学习能力、如何做到「特别会考试」</p>
<p>本答案共计 2612 字，预计花费你 5 分钟，但会给你的学习方法带来极大的改变。请耐心阅读。</p>
<p>大家应该见过这样的同学，甚至自己也有类似的经历，就是<strong>平时学习感觉基本上都会，知识点也都记住了、书也都看懂了，但是一做题、一考试，就没法真正地发挥出来。</strong></p>
<p>这不是很奇怪吗？</p>
<h4 id="【一】你要用考试（或者说「测试」）的思维，去决定如何看书、如何学习。"><a href="#【一】你要用考试（或者说「测试」）的思维，去决定如何看书、如何学习。" class="headerlink" title="【一】你要用考试（或者说「测试」）的思维，去决定如何看书、如何学习。"></a>【一】你要用考试（或者说「测试」）的思维，去决定如何看书、如何学习。</h4><p>其实是这样的，我们从小的学习模式，都是先埋头苦读，然后再去考试。我们的习惯思维是，只要掌握得滚瓜烂熟，那么考场上自然什么题目都会做。</p>
<p>我今天要唱一下反调，这是非常低效的学习方式。那么什么是高效的？</p>
<p>—— 是用考试的思维去学习。</p>
<p>看书时候，非常重要的一点是，你要明确你的目的。</p>
<p>这个目的不是所谓的看懂公式、记住概念等比较宽泛模糊的东西，而是非常明确的：</p>
<p>你要回答什么问题？最直接的，就是课后习题，或者考试真题。</p>
<p>你是否要据此写一篇论文 / 文章？这意味着，你需要在掌握知识的基础上，有自己的思考，并且经过整合，进行输出。</p>
<p>也就是说，你要用考试（或者说「测试」）的思维，去决定如何看书、如何学习。</p>
<h4 id="【二】考试不是阅读，而是提问。我们是为了考试，而不是为了学习-知道-记住。"><a href="#【二】考试不是阅读，而是提问。我们是为了考试，而不是为了学习-知道-记住。" class="headerlink" title="【二】考试不是阅读，而是提问。我们是为了考试，而不是为了学习 / 知道 / 记住。"></a>【二】考试不是阅读，而是提问。我们是为了考试，而不是为了学习 / 知道 / 记住。</h4><p><strong>考试不是阅读，而是提问。</strong>不是一个被动地逐字逐句、照单全收的过程，这是事倍功半的，而且你总会觉得都要去记要去学；考试，最重要的是输出。</p>
<p>你体会一下这句话：<strong>我们是为了考试，而不是为了学习 / 知道 / 记住。</strong></p>
<p>这是两个完全不同，甚至相反的路径。</p>
<p>我们常把大量的高密度的「输入」（也就是接收信息、学习知识）放在首位，觉得「输入」之后自然会有「输出」（也就是把知识点用在考试之中）。</p>
<p>我们甚至会有这种错觉：我把中文系 / 历史系 / 哲学系前辈们列出的这 30 本书看完，学会并且记住其中的知识，我就会做题了。如果还不会，那就再看 20 本。</p>
<p>不是这样的。<strong>考试意味着主动去回想知识点，是把知识点从脑袋里调取出来。</strong></p>
<h4 id="【三】即用即学，是一个根据问题寻找答案的过程。"><a href="#【三】即用即学，是一个根据问题寻找答案的过程。" class="headerlink" title="【三】即用即学，是一个根据问题寻找答案的过程。"></a>【三】即用即学，是一个根据问题寻找答案的过程。</h4><p>发现了吗？<strong>学习和考试，是完全不同的事情。只有去以考试为明确的目的，你才知道看书的时候，如何看、如何思考、如何记忆。</strong></p>
<p>去研究考试题，包括它的出题范围和出题思路；去分析考试时，题目要求你怎样回忆知识点、怎样运用知识点？在学习的时候，就按照这种思路去学习。</p>
<p>大家知道，<strong>如果你刚掌握的知识点，就立刻应用，你就能掌握得非常牢固。这叫做即学即用。</strong></p>
<p>我想教大家的是，其实 <strong>「即用即学」，是另一种非常高效的学习方式。</strong>但掌握这个思路的人，并不多。</p>
<p>「即用即学」，也就是我刚才说的考试思维：<strong>总结出来考试时候怎么考，来决定学习时候如何学。先看看你要怎么用，再去学。</strong></p>
<p>以考研为例，同样也适用于考试、以及输出文章等，你先去找你最终要面对的真题。</p>
<p>真题为何重要？它给了你具体的目标，它是你所需要解决的具体的问题。</p>
<p>而且，最好能找到答案。如此你才能知道，你要对此问题了解、回答到何种程度，才是达到标准的。</p>
<p>这种反馈，才是明确的、有效的，方便你进行自我调整的。</p>
<p>所谓即用即学，是一个根据问题寻找答案的过程。不是为了学习，而是为了考试。</p>
<p>如果看到这里，觉得这篇答案对你有帮助，还请点个赞（不点也行，哈哈，不强求）。接下来还有一个重要的学习思维，我们继续说，大家加油，耐心看完。会对你有所帮助的。：）</p>
<h4 id="【四】「测试」比被动输入更加高效，也记得更牢。正是感觉到学习更吃力时，记忆才更为长久、牢固。"><a href="#【四】「测试」比被动输入更加高效，也记得更牢。正是感觉到学习更吃力时，记忆才更为长久、牢固。" class="headerlink" title="【四】「测试」比被动输入更加高效，也记得更牢。正是感觉到学习更吃力时，记忆才更为长久、牢固。"></a>【四】「测试」比被动输入更加高效，也记得更牢。正是感觉到学习更吃力时，记忆才更为长久、牢固。</h4><p>大脑中架构太多的空中楼阁是没有用处的，你要做的不是囤积各式精美的砖头，以及各类建筑的设计图，而是在有了一些主要的砖头之后，就试图踏踏实实地盖房子；并且在盖房子的过程中，发现哪块砖头可以怎么用，哪块砖头掌握得不好，还缺哪些砖头。</p>
<p>这就叫即用即学。</p>
<p>就像是学习英语单词，更好的方法是结合文章学习，在阅读理解中学习，而不是单独地背单词。这也是一个「即用即学」的过程。</p>
<p>单独地背单词，只是一个被动灌输的过程，并没有使用考试的思维进行调取，没有一个「测试」的过程。「测试」比被动输入更加高效，也记得更牢。</p>
<p>我们平时学习是怎样的？基本上是，把书和笔记拿过来，一遍又一遍地温习；如果想不起来，会直接去看原文，很少留给自己苦苦思索的时间。</p>
<blockquote>
<p>而研究表明，你越是愿意在那里耗着，花时间和精力去回想，哪怕最后想不起来，这个艰苦卓绝的过程，也能帮助你更好地记忆并理解知识点。（S.H.Kang 等人的研究，转引自彼得・布朗《认知天性》）</p>
</blockquote>
<p>「重复阅读」带来的熟练感，只是自以为掌握而已。</p>
<blockquote>
<p>与反复阅读这种复习方法相比，回想事实、概念或事件会更有效。这种方法被称为检索式练习。（《认知天性》）<br>在你回想时，如果很难想起来，或者磕磕巴巴，只能想起片段，别急于苛责自己。这是熟练地掌握知识点，必须经历的过程。</p>
</blockquote>
<p>正是感觉到学习更吃力时，记忆才更为长久、牢固。</p>
<h4 id="【五】学习最重要的，就是即用即学和即学即用，两个途径互为表里、互相推进，无法分割。"><a href="#【五】学习最重要的，就是即用即学和即学即用，两个途径互为表里、互相推进，无法分割。" class="headerlink" title="【五】学习最重要的，就是即用即学和即学即用，两个途径互为表里、互相推进，无法分割。"></a>【五】学习最重要的，就是即用即学和即学即用，两个途径互为表里、互相推进，无法分割。</h4><p>分享一个，与前文一脉相承，但让我耳目一新的观点，学习就是一个输入和输出的过程。我们平常的重心放在了输入，但实际上：</p>
<blockquote>
<p>要让知识和经验产生链接，也就是学以致用，最好保持输入和输出的平衡，但不是绝对的相等，输出要更多一些。（《奇特的一生》）<br>输出要更多一些。</p>
</blockquote>
<p>一些专业课的书，无论是人文社科还是理工科，可以先对某章节大致过一遍，对知识点和公式大致理解即可，不要去反复复习和背诵，而是立刻着手做题，在用的过程中，让自己去彻底理解和巩固记忆。</p>
<p><strong>学习最重要的，就是即用即学和即学即用，两个途径互为表里、互相推进，无法分割。</strong></p>
<p>然后在这一过程中获得反馈，这个反馈不是你背会了多少东西（囤积了多少砖头），而是对所必须面对的问题进行测试，并且以相对标准的答案进行反馈。</p>
<p>语文课代表冷冷的例行总结：</p>
<p>1、平时学习感觉基本上都会，知识点也都记住了、书也都看懂了，但是一做题、一考试，就没法真正地发挥出来。</p>
<p>2、学习不是目的，考试（测试）才是目的。你要用考试（或者说「测试」）的思维，去决定如何学习。</p>
<p>3、学习和考试，是完全不同的事情。只有去以考试为明确的目的，你才知道看书的时候，如何看、如何思考、如何记忆。</p>
<p>4、考试不是阅读，而是提问。考试意味着主动去回想知识点，是把知识点从脑袋里调取出来。</p>
<p>5、你先去找你最终要面对的真题。最好能找到答案。如此你才能知道，你要对此问题了解、回答到何种程度，才是达到标准的。总结出来考试时候怎么考，来决定学习时候如何学。</p>
<p>6、「测试」比被动输入更加高效，也记得更牢。「检索式练习」才是最有效的学习方法。</p>
<p>按照我所说的根本思维和具体方法，基本上每个人都可以大幅度提高学习能力。大家加油。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>删除缺少值、空值的行列数据</title>
    <url>/2021/08/29/%E5%88%A0%E9%99%A4%E7%BC%BA%E5%B0%91%E5%80%BC%E3%80%81%E7%A9%BA%E5%80%BC%E7%9A%84%E8%A1%8C%E5%88%97%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_dict=&#123;<span class="string">&#x27;name&#x27;</span>:[<span class="string">&#x27;mike&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;suzzi&#x27;</span>,<span class="string">&#x27;chang&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>],<span class="string">&#x27;place&#x27;</span>:[<span class="string">&#x27;china&#x27;</span>,<span class="string">&#x27;ireland&#x27;</span>,<span class="string">&#x27;japan&#x27;</span>,<span class="string">&#x27;china&#x27;</span>,</span><br><span class="line">                                                            <span class="string">&#x27;australia&#x27;</span>,<span class="string">&#x27;india&#x27;</span>],<span class="string">&#x27;phonenum&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]&#125;</span><br><span class="line">data_dict</span><br></pre></td></tr></table></figure>



<pre><code>&#123;&#39;name&#39;: [&#39;mike&#39;, &#39;&#39;, &#39;suzzi&#39;, &#39;chang&#39;, &#39;&#39;, &#39;&#39;],
 &#39;place&#39;: [&#39;china&#39;, &#39;ireland&#39;, &#39;japan&#39;, &#39;china&#39;, &#39;australia&#39;, &#39;india&#39;],
 &#39;phonenum&#39;: [1, 2, 3, 4, 5, 6]&#125;
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"></span><br><span class="line">df=pd.DataFrame(data_dict)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>place</th>
      <th>phonenum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>mike</td>
      <td>china</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td></td>
      <td>ireland</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>suzzi</td>
      <td>japan</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>chang</td>
      <td>china</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td></td>
      <td>australia</td>
      <td>5</td>
    </tr>
    <tr>
      <th>5</th>
      <td></td>
      <td>india</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1=df.copy()</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>place</th>
      <th>phonenum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>mike</td>
      <td>china</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td></td>
      <td>ireland</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>suzzi</td>
      <td>japan</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>chang</td>
      <td>china</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td></td>
      <td>australia</td>
      <td>5</td>
    </tr>
    <tr>
      <th>5</th>
      <td></td>
      <td>india</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df2=df1[df1.name==<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>place</th>
      <th>phonenum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td></td>
      <td>ireland</td>
      <td>2</td>
    </tr>
    <tr>
      <th>4</th>
      <td></td>
      <td>australia</td>
      <td>5</td>
    </tr>
    <tr>
      <th>5</th>
      <td></td>
      <td>india</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df2</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>place</th>
      <th>phonenum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td></td>
      <td>ireland</td>
      <td>2</td>
    </tr>
    <tr>
      <th>4</th>
      <td></td>
      <td>australia</td>
      <td>5</td>
    </tr>
    <tr>
      <th>5</th>
      <td></td>
      <td>india</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3=df1[df1.name!=<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">df3</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>place</th>
      <th>phonenum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>mike</td>
      <td>china</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>suzzi</td>
      <td>japan</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>chang</td>
      <td>china</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



<p>如果在第一列中是 NaNs，请使用 ^{} 和指定要检查的列：</p>
<p>df1 = df.dropna(subset=[‘Name’]) 删除 name 列中含有空值的整行，只保留全部没有空值的行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data_dict=&#123;<span class="string">&#x27;name&#x27;</span>:[<span class="string">&#x27;mike&#x27;</span>,np.nan,<span class="string">&#x27;suzzi&#x27;</span>,<span class="string">&#x27;chang&#x27;</span>,np.nan,np.nan],<span class="string">&#x27;place&#x27;</span>:[<span class="string">&#x27;china&#x27;</span>,<span class="string">&#x27;ireland&#x27;</span>,<span class="string">&#x27;japan&#x27;</span>,<span class="string">&#x27;china&#x27;</span>,</span><br><span class="line">                                                            <span class="string">&#x27;australia&#x27;</span>,<span class="string">&#x27;india&#x27;</span>],<span class="string">&#x27;phonenum&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]&#125;</span><br><span class="line">data_dict</span><br></pre></td></tr></table></figure>



<pre><code>&#123;&#39;name&#39;: [&#39;mike&#39;, nan, &#39;suzzi&#39;, &#39;chang&#39;, nan, nan],
 &#39;place&#39;: [&#39;china&#39;, &#39;ireland&#39;, &#39;japan&#39;, &#39;china&#39;, &#39;australia&#39;, &#39;india&#39;],
 &#39;phonenum&#39;: [1, 2, 3, 4, 5, 6]&#125;
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dff=pd.DataFrame(data_dict)</span><br><span class="line">dff</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>place</th>
      <th>phonenum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>mike</td>
      <td>china</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>NaN</td>
      <td>ireland</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>suzzi</td>
      <td>japan</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>chang</td>
      <td>china</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>NaN</td>
      <td>australia</td>
      <td>5</td>
    </tr>
    <tr>
      <th>5</th>
      <td>NaN</td>
      <td>india</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dff1=dff.dropna(subset=[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">dff1</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>place</th>
      <th>phonenum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>mike</td>
      <td>china</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>suzzi</td>
      <td>japan</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>chang</td>
      <td>china</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果行中缺少任何值，DataFrame dropna（）方法将删除整行。 df1 = df.dropna()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data_dict=&#123;<span class="string">&#x27;name&#x27;</span>:[<span class="string">&#x27;mike&#x27;</span>,np.nan,<span class="string">&#x27;suzzi&#x27;</span>,<span class="string">&#x27;chang&#x27;</span>,np.nan,np.nan],<span class="string">&#x27;place&#x27;</span>:[<span class="string">&#x27;china&#x27;</span>,np.nan,<span class="string">&#x27;japan&#x27;</span>,<span class="string">&#x27;china&#x27;</span>,</span><br><span class="line">                                                            <span class="string">&#x27;australia&#x27;</span>,<span class="string">&#x27;india&#x27;</span>],<span class="string">&#x27;phonenum&#x27;</span>:[<span class="number">1</span>,np.nan,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]&#125;</span><br><span class="line">data_dict</span><br></pre></td></tr></table></figure>



<pre><code>&#123;&#39;name&#39;: [&#39;mike&#39;, nan, &#39;suzzi&#39;, &#39;chang&#39;, nan, nan],
 &#39;place&#39;: [&#39;china&#39;, nan, &#39;japan&#39;, &#39;china&#39;, &#39;australia&#39;, &#39;india&#39;],
 &#39;phonenum&#39;: [1, nan, 3, 4, 5, 6]&#125;
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dk=pd.DataFrame(data_dict)</span><br><span class="line">dk</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>place</th>
      <th>phonenum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>mike</td>
      <td>china</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>suzzi</td>
      <td>japan</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>chang</td>
      <td>china</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>NaN</td>
      <td>australia</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>NaN</td>
      <td>india</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dfk=dk.dropna()</span><br><span class="line">dfk</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>place</th>
      <th>phonenum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>mike</td>
      <td>china</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>suzzi</td>
      <td>japan</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>chang</td>
      <td>china</td>
      <td>4.0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pandas 删除空数据行及列 dropna ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除含有空数据的全部行</span></span><br><span class="line"></span><br><span class="line">df4 = pd.read_csv(<span class="string">&#x27;4.csv&#x27;</span>,  encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df4 = df4.dropna()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过 axis 参数来删除含有空数据的全部列</span></span><br><span class="line"></span><br><span class="line">df4 = df4.dropna(axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过 subset 参数来删除在 age 和 sex 中含有空数据的全部行</span></span><br><span class="line"></span><br><span class="line">df4 = df4.dropna(subset=[<span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>])</span><br><span class="line"></span><br><span class="line">print(df4)</span><br><span class="line"></span><br><span class="line">df4 = df4.dropna(subset=[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;body&#x27;</span>,<span class="string">&#x27;home.dest&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于 DataFrame:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data.dropna (how = &#x27;all&#x27;)    # 传入这个参数后将只丢弃全为缺失值的那些行</span></span><br><span class="line"><span class="comment"># data.dropna (axis = 1)       # 丢弃有缺失值的列（一般不会这么做，这样会删掉一个特征）</span></span><br><span class="line"><span class="comment"># data.dropna (axis=1,how=&quot;all&quot;)   # 丢弃全为缺失值的那些列</span></span><br><span class="line"><span class="comment"># data.dropna (axis=0,subset = [&quot;Age&quot;, &quot;Sex&quot;])   # 丢弃‘Age’和‘Sex’这两列中有缺失值的行  </span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 DataFrame 样例数据</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, np.nan,<span class="number">7</span>, <span class="number">9</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, np.nan, np.nan, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], <span class="string">&#x27;c&#x27;</span>: [np.nan, <span class="number">0</span>, <span class="number">4</span>, np.nan, np.nan, <span class="number">5</span>], <span class="string">&#x27;d&#x27;</span>: [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan]&#125;)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.0</td>
      <td>a</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2.0</td>
      <td>b</td>
      <td>0.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.0</td>
      <td>NaN</td>
      <td>4.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.0</td>
      <td>d</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>9.0</td>
      <td>e</td>
      <td>5.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.dropna(axis=<span class="number">0</span>,how=<span class="string">&#x27;all&#x27;</span>)  <span class="comment"># 删除 NaN 所在行</span></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.0</td>
      <td>a</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2.0</td>
      <td>b</td>
      <td>0.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.0</td>
      <td>NaN</td>
      <td>4.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.0</td>
      <td>d</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>9.0</td>
      <td>e</td>
      <td>5.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.dropna(axis=<span class="number">0</span>,how=<span class="string">&#x27;any&#x27;</span>)  <span class="comment"># 删除表中含有任何 NaN 的行</span></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.dropna(axis=<span class="number">1</span>, how=<span class="string">&#x27;all&#x27;</span>)<span class="comment"># 删除表中全部为 NaN 的列</span></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.0</td>
      <td>a</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2.0</td>
      <td>b</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.0</td>
      <td>NaN</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.0</td>
      <td>d</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>9.0</td>
      <td>e</td>
      <td>5.0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.dropna(axis=<span class="number">1</span>, how=<span class="string">&#x27;any&#x27;</span>) <span class="comment"># 删除表中含有任何 NaN 的列</span></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
    </tr>
    <tr>
      <th>1</th>
    </tr>
    <tr>
      <th>2</th>
    </tr>
    <tr>
      <th>3</th>
    </tr>
    <tr>
      <th>4</th>
    </tr>
    <tr>
      <th>5</th>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pandas 中单元格数据处理之分割单元格信息</span></span><br><span class="line"><span class="comment"># 两总方法，一种是新建一个 dataframe，加上列标签，在用 concat 合并到一起。方法二比较简单，直接索引取数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">把一个“<span class="number">2000</span>-<span class="number">5000</span>”类型的数，分割为<span class="number">2000</span>与<span class="number">5000</span>两个，并分开显示</span><br><span class="line">s_min, s_max = df_clean.loc[: , <span class="string">&#x27;zwyx&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>).<span class="built_in">str</span></span><br><span class="line"><span class="comment">#split的参数1，则分割为两部分</span></span><br><span class="line">df_min = pd.DataFrame(s_min)</span><br><span class="line">df_min.columns = [<span class="string">&#x27;zwyx_min&#x27;</span>]</span><br><span class="line">df_max = pd.DataFrame(s_max)</span><br><span class="line">df_max.columns = [<span class="string">&#x27;zwyx_max&#x27;</span>]</span><br><span class="line"></span><br><span class="line">df_clean_concat = pd.concat([df_clean, df_min, df_max], axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># df_clean[&#x27;zwyx_min&#x27;].astype(int)</span></span><br><span class="line">df_clean_concat[<span class="string">&#x27;zwyx_min&#x27;</span>] = pd.to_numeric(df_clean_concat[<span class="string">&#x27;zwyx_min&#x27;</span>])</span><br><span class="line">df_clean_concat[<span class="string">&#x27;zwyx_max&#x27;</span>] = pd.to_numeric(df_clean_concat[<span class="string">&#x27;zwyx_max&#x27;</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>:[<span class="string">&#x27;a,b,c&#x27;</span>,<span class="string">&#x27;1,2,3&#x27;</span>,[<span class="string">&#x27;a,,,c&#x27;</span>],np.nan]&#125;)</span><br><span class="line">df[<span class="string">&#x27;v1&#x27;</span>] = df[<span class="string">&#x27;key&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;,&#x27;</span>).<span class="built_in">str</span>[<span class="number">0</span>]</span><br><span class="line">df[<span class="string">&#x27;v2&#x27;</span>] = df[<span class="string">&#x27;key&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;,&#x27;</span>).<span class="built_in">str</span>[<span class="number">1</span>]</span><br><span class="line">df[<span class="string">&#x27;v3&#x27;</span>] = df[<span class="string">&#x27;key&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;,&#x27;</span>).<span class="built_in">str</span>[<span class="number">2</span>]</span><br><span class="line">df</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>v1</th>
      <th>v2</th>
      <th>v3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a,b,c</td>
      <td>a</td>
      <td>b</td>
      <td>c</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1,2,3</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>[a,,,c]</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pandas 小技巧 —— 如何删除行或者列、根据条件删除指定行或者列</span></span><br><span class="line"><span class="comment"># 使用 df.drop</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=‘raise’)</span></span><br><span class="line"><span class="string">1、labels：要删除的标签，一个或者多个 (以 list 形式)；</span></span><br><span class="line"><span class="string">2、axis：指定哪一个轴，=0 删除行，=1 删除列；</span></span><br><span class="line"><span class="string">3、columns：指定某一列或者多列 (以 list 形式)；</span></span><br><span class="line"><span class="string">4、level：索引等级，针对多重索引的情况；</span></span><br><span class="line"><span class="string">5、inplaces：是否替换原来的 dataframe，=True 代表直接替换原始 df，=False 代表不替换原始 df</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 1、直接删除指定行 / 列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除列名为C的列，并替换原始df</span></span><br><span class="line">df.drop(columns=[<span class="string">&#x27;C&#x27;</span>], inplace=<span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、根据条件删除指定行</span></span><br><span class="line"><span class="comment"># 删除符合条件的指定行，并替换原始df</span></span><br><span class="line">df.drop(df[(df.score &lt; <span class="number">50</span>) &amp; (df.score &gt; <span class="number">20</span>)].index， inplace=<span class="literal">True</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dropna () 方法过滤任何含有缺失值的行</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pandas.DataFrame 里，如果一行数据有任意值为空，则过滤掉整行，这时候使用 dropna() 方法是合适的。下面的案例，任意列只要有一个为空数据，则整行都干掉。但是我们常常遇到的情况，是根据一个指标（一列）数据的情况，去过滤行数据，</span></span><br><span class="line"><span class="string">类似 Excel 里面的过滤漏斗，怎么办？</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.DataFrame([[<span class="number">1.</span>,<span class="number">6.5</span>,<span class="number">3.</span>],[<span class="number">1.</span>],[],[<span class="number">6.5</span>,<span class="number">3.</span>]],index=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>),columns=<span class="built_in">list</span>(<span class="string">&#x27;def&#x27;</span>))</span><br><span class="line">data</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>6.5</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>d</th>
      <td>6.5</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.dropna()</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>6.5</td>
      <td>3.0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一：dropna () 其他参数解析</span></span><br><span class="line"><span class="comment"># DataFrame.dropna(axis=0, how=&#x27;any&#x27;, thresh=None, subset=None, inplace=False)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">参数说明：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">axis:</span></span><br><span class="line"><span class="string">axis=0: 删除包含缺失值的行</span></span><br><span class="line"><span class="string">axis=1: 删除包含缺失值的列</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">how: 与 axis 配合使用</span></span><br><span class="line"><span class="string">how=‘any’ : 只要有缺失值出现，就删除该行货列</span></span><br><span class="line"><span class="string">how=‘all’: 所有的值都缺失，才删除行或列</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">thresh： axis 中至少有 thresh 个非缺失值，否则删除。比如 axis=0，thresh=10：标识如果该行中非缺失值的数量小于 10，将删除改行</span></span><br><span class="line"><span class="string">subset: list，在哪些列中查看是否有缺失值</span></span><br><span class="line"><span class="string">inplace: 是否在原数据上操作。如果为真，返回 None 否则返回新的 copy，去掉了缺失值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.dropna(axis=<span class="number">0</span>,subset=[<span class="string">&#x27;e&#x27;</span>]) <span class="comment">#axis=0,删除行，subset的列选择</span></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>6.5</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>6.5</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">方法二：替换并删除，Python pandas 如果某列值为空，过滤删除所在行数据</span></span><br><span class="line"><span class="string">如上面的 data 数据，如果希望 “e” 列数值为空 NaN 时，删除对应行也就是 “b、c” 行数据，保留其他行，用 dropna() 似乎比较麻烦。 这个时候的思路是：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fillna() 给空值填充一个数值（如 999999）</span></span><br><span class="line"><span class="string">index.tolist() 找出值为填充值所在行的索引</span></span><br><span class="line"><span class="string">drop 根据索引干掉对应的行</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">data[<span class="string">&#x27;e&#x27;</span>]=data[<span class="string">&#x27;e&#x27;</span>].fillna(<span class="number">999999</span>)</span><br><span class="line">find_index=data[(data.e==<span class="number">999999</span>)].index.tolist()</span><br><span class="line">find_index</span><br></pre></td></tr></table></figure>



<pre><code>[&#39;b&#39;, &#39;c&#39;]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop(find_index)</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>6.5</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>6.5</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pandas 缺失值与空值处理</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1. 相关函数</span></span><br><span class="line"><span class="string">df.dropna()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">df.fillna()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">df.isnull()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">df.isna()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 相关概念</span></span><br><span class="line"><span class="string">空值：在 pandas 中的空值是 &quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">缺失值：在 dataframe 中为 nan 或者 naT（缺失时间），在 series 中为 none 或者 nan 即可</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. 函数具体解释</span></span><br><span class="line"><span class="string">DataFrame.dropna(axis=0, how=&#x27;any&#x27;, thresh=None, subset=None, inplace=False)</span></span><br><span class="line"><span class="string">函数作用：删除含有空值的行或列</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">axis: 维度，axis=0 表示 index 行，axis=1 表示 columns 列，默认为 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">how:&quot;all&quot; 表示这一行或列中的元素全部缺失（为 nan）才删除这一行或列，&quot;any&quot; 表示这一行或列中只要有元素缺失，就删除这一行或列</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">thresh: 一行或一列中至少出现了 thresh 个才删除。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">subset：在某些列的子集中选择出现了缺失值的列删除，不在子集中的含有缺失值得列或行不会删除（有 axis 决定是行还是列）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inplace：刷选过缺失值得新数据是存为副本还是直接在原数据上进行修改。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">例子：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Alfred&#x27;</span>, <span class="string">&#x27;Batman&#x27;</span>, <span class="string">&#x27;Catwoman&#x27;</span>],</span><br><span class="line">                <span class="string">&quot;toy&quot;</span>: [np.nan, <span class="string">&#x27;Batmobile&#x27;</span>, <span class="string">&#x27;Bullwhip&#x27;</span>],</span><br><span class="line">                  <span class="string">&quot;born&quot;</span>: [pd.NaT, pd.Timestamp(<span class="string">&quot;1940-04-25&quot;</span>),pd.NaT]&#125;)</span><br><span class="line"> </span><br><span class="line">df</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>toy</th>
      <th>born</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Alfred</td>
      <td>NaN</td>
      <td>NaT</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Batman</td>
      <td>Batmobile</td>
      <td>1940-04-25</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Catwoman</td>
      <td>Bullwhip</td>
      <td>NaT</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;-----------------------------------------&#x27;</span>)</span><br><span class="line">print(df.dropna())</span><br></pre></td></tr></table></figure>
<pre><code>       name        toy       born
0    Alfred        NaN        NaT
1    Batman  Batmobile 1940-04-25
2  Catwoman   Bullwhip        NaT
-----------------------------------------
     name        toy       born
1  Batman  Batmobile 1940-04-25
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;delete colums&#x27;</span>)</span><br><span class="line">print(df.dropna(axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<pre><code>delete colums
       name
0    Alfred
1    Batman
2  Catwoman
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;所有值全为缺失值才删除&quot;</span>)</span><br><span class="line">print(df.dropna(how=<span class="string">&#x27;all&#x27;</span>))</span><br></pre></td></tr></table></figure>
<pre><code>所有值全为缺失值才删除
       name        toy       born
0    Alfred        NaN        NaT
1    Batman  Batmobile 1940-04-25
2  Catwoman   Bullwhip        NaT
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;至少出现过两个缺失值才删除&quot;</span>)</span><br><span class="line">print(df.dropna(thresh=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>至少出现过两个缺失值才删除
       name        toy       born
1    Batman  Batmobile 1940-04-25
2  Catwoman   Bullwhip        NaT
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;删除这个subset中的含有缺失值的行或列&quot;</span>)</span><br><span class="line">print(df.dropna(subset=[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;born&#x27;</span>]))</span><br></pre></td></tr></table></figure>
<pre><code>删除这个subset中的含有缺失值的行或列
     name        toy       born
1  Batman  Batmobile 1940-04-25
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">DataFrame.fillna(value=None, method=None, axis=None, inplace=False, limit=None, downcast=None, **kwargs)</span></span><br><span class="line"><span class="string">函数作用：填充缺失值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">value: 需要用什么值去填充缺失值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">axis: 确定填充维度，从行开始或是从列开始</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">method：ffill: 用缺失值前面的一个值代替缺失值，如果 axis =1，那么就是横向的前面的值替换后面的缺失值，如果 axis=0，那么则是上面的值替换下面的缺失值。backfill/bfill，缺失值后面的一个值代替前面的缺失值。注意这个参数不能与 value 同时出现</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">limit: 确定填充的个数，如果 limit=2，则只填充两个缺失值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">df = pd.DataFrame([[np.nan, <span class="number">2</span>, np.nan, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">3</span>, <span class="number">4</span>, np.nan, <span class="number">1</span>],</span><br><span class="line">                 [np.nan, np.nan, np.nan, <span class="number">5</span>],</span><br><span class="line">                [np.nan, <span class="number">3</span>, np.nan, <span class="number">4</span>]],</span><br><span class="line">                 columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line"> </span><br><span class="line">print(df)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">&quot;横向用缺失值前面的值替换缺失值&quot;</span>)</span><br><span class="line">print(df.fillna(axis=<span class="number">1</span>,method=<span class="string">&#x27;ffill&#x27;</span>))</span><br><span class="line"> </span><br><span class="line">print(<span class="string">&quot;纵向用缺失值上面的值替换缺失值&quot;</span>)</span><br><span class="line">print(df.fillna(axis=<span class="number">0</span>,method=<span class="string">&#x27;ffill&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         A    B   C  D</span><br><span class="line">    <span class="number">0</span>  NaN  <span class="number">2.0</span> NaN  <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">3.0</span>  <span class="number">4.0</span> NaN  <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>  NaN  NaN NaN  <span class="number">5</span></span><br><span class="line">    <span class="number">3</span>  NaN  <span class="number">3.0</span> NaN  <span class="number">4</span></span><br><span class="line">    横向用缺失值前面的值替换缺失值</span><br><span class="line">         A    B    C    D</span><br><span class="line">    <span class="number">0</span>  NaN  <span class="number">2.0</span>  <span class="number">2.0</span>  <span class="number">0.0</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">3.0</span>  <span class="number">4.0</span>  <span class="number">4.0</span>  <span class="number">1.0</span></span><br><span class="line">    <span class="number">2</span>  NaN  NaN  NaN  <span class="number">5.0</span></span><br><span class="line">    <span class="number">3</span>  NaN  <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">4.0</span></span><br><span class="line">    纵向用缺失值上面的值替换缺失值</span><br><span class="line">         A    B   C  D</span><br><span class="line">    <span class="number">0</span>  NaN  <span class="number">2.0</span> NaN  <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">3.0</span>  <span class="number">4.0</span> NaN  <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">3.0</span>  <span class="number">4.0</span> NaN  <span class="number">5</span></span><br><span class="line">    <span class="number">3</span>  <span class="number">3.0</span>  <span class="number">3.0</span> NaN  <span class="number">4</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(df.fillna(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<pre><code>     A    B    C  D
0  0.0  2.0  0.0  0
1  3.0  4.0  0.0  1
2  0.0  0.0  0.0  5
3  0.0  3.0  0.0  4
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不同的列用不同的值填充：</span></span><br><span class="line"></span><br><span class="line">values=&#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">0</span>,<span class="string">&#x27;B&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;C&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;D&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">df.fillna(value=values)</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>2.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.0</td>
      <td>3.0</td>
      <td>2.0</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对每列出现的替换值有次数限制，此处限制为一次</span></span><br><span class="line">df.fillna(value=values,limit=<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DataFrame.isna()</span></span><br><span class="line"><span class="comment"># 判断是不是缺失值：</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[np.nan, <span class="number">2</span>, np.nan, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;&quot;</span>, <span class="number">1</span>],</span><br><span class="line">                 [np.nan, np.nan, np.nan, <span class="number">5</span>],</span><br><span class="line">                [np.nan, <span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">4</span>]],</span><br><span class="line">                 columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line"> </span><br><span class="line">df</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3.0</td>
      <td>4.0</td>
      <td></td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>3.0</td>
      <td></td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如上，缺失值是 NAN，空值是没有显示。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">替换空值代码：需要把含有空值的那一列提出来单独处理，然后在放进去就好。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">clean_z=df[<span class="string">&#x27;C&#x27;</span>].fillna(<span class="number">0</span>)</span><br><span class="line">clean_z[clean_z==<span class="string">&#x27;&#x27;</span>]=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>]=clean_z</span><br><span class="line">df</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>hello</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>3.0</td>
      <td>hello</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.isna()</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>True</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>3</th>
      <td>True</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="Pandas-对列进行重命名"><a href="#Pandas-对列进行重命名" class="headerlink" title="Pandas 对列进行重命名"></a>Pandas 对列进行重命名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pandas 对列进行重命名</span></span><br><span class="line"><span class="comment"># 在处理 DataFrame 数据的时候，经常需要对列进行重命名，我们现在看一下到底如何进行重命名操作。</span></span><br><span class="line"><span class="comment"># 首先生成一个 DataFrame。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">province=pd.DataFrame(&#123;<span class="string">&#x27;省份&#x27;</span>:[<span class="string">&#x27;广东&#x27;</span>,<span class="string">&#x27;广西&#x27;</span>,<span class="string">&#x27;福建&#x27;</span>,<span class="string">&#x27;福建省&#x27;</span>],</span><br><span class="line">                      <span class="string">&#x27;ID&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">                      <span class="string">&#x27;code&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]&#125;)</span><br><span class="line">province</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>省份</th>
      <th>ID</th>
      <th>code</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>广东</td>
      <td>1</td>
      <td>a</td>
    </tr>
    <tr>
      <th>1</th>
      <td>广西</td>
      <td>2</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2</th>
      <td>福建</td>
      <td>3</td>
      <td>c</td>
    </tr>
    <tr>
      <th>3</th>
      <td>福建省</td>
      <td>4</td>
      <td>d</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 然后把ID变成id，code变成编码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法 1</span></span><br><span class="line"><span class="comment"># rename 的方式。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">province.rename(columns=&#123;<span class="string">&#x27;ID&#x27;</span>:<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="string">&#x27;编码&#x27;</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>省份</th>
      <th>id</th>
      <th>编码</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>广东</td>
      <td>1</td>
      <td>a</td>
    </tr>
    <tr>
      <th>1</th>
      <td>广西</td>
      <td>2</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2</th>
      <td>福建</td>
      <td>3</td>
      <td>c</td>
    </tr>
    <tr>
      <th>3</th>
      <td>福建省</td>
      <td>4</td>
      <td>d</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法 2</span></span><br><span class="line"><span class="comment"># 直接改 DataFrame 的 columns</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_col=[<span class="string">&#x27;省份&#x27;</span>,<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;编码&#x27;</span>]</span><br><span class="line">province.columns=p_col</span><br><span class="line">province</span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>省份</th>
      <th>id</th>
      <th>编码</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>广东</td>
      <td>1</td>
      <td>a</td>
    </tr>
    <tr>
      <th>1</th>
      <td>广西</td>
      <td>2</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2</th>
      <td>福建</td>
      <td>3</td>
      <td>c</td>
    </tr>
    <tr>
      <th>3</th>
      <td>福建省</td>
      <td>4</td>
      <td>d</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法 3</span></span><br><span class="line"><span class="comment"># 重新生成一个新的列表，也可以用于在读取 Excel 或者 csv 的时候，进行列名更改</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_col=[<span class="string">&#x27;省份&#x27;</span>,<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;编码&#x27;</span>]</span><br><span class="line">province_new=pd.DataFrame(province,columns=p_col)</span><br><span class="line">province_new</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>省份</th>
      <th>id</th>
      <th>编码</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>广东</td>
      <td>1</td>
      <td>a</td>
    </tr>
    <tr>
      <th>1</th>
      <td>广西</td>
      <td>2</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2</th>
      <td>福建</td>
      <td>3</td>
      <td>c</td>
    </tr>
    <tr>
      <th>3</th>
      <td>福建省</td>
      <td>4</td>
      <td>d</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">comany = pd.read_csv(<span class="string">&#x27;../data/public/year_report_train_sum.csv&#x27;</span>)</span><br><span class="line">comany.rename(columns=&#123;<span class="string">&#x27;净纳税总额利润&#x27;</span>:<span class="string">&#x27;净利润&#x27;</span>&#125;,inplace = <span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
</search>
