<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pandas groupby 保存到 dataFrame</title>
    <url>/2021/02/01/00-Pandas%20groupby%20%E4%BF%9D%E5%AD%98%E5%88%B0%20dataFrame/</url>
    <content><![CDATA[<h3 id="直接使用-reset-index-方法删除原来索引"><a href="#直接使用-reset-index-方法删除原来索引" class="headerlink" title="直接使用 reset_index 方法删除原来索引"></a>直接使用 reset_index 方法删除原来索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test_df &#x3D; pd.DataFrame(&#123;&#39;a&#39;:[1,1,3,2],&#39;b&#39;:[1,4,6,9],&#39;c&#39;:[1,4,8,12]&#125;)</span><br><span class="line">g_df &#x3D;test_df[&#39;c&#39;].groupby([test_df[&#39;a&#39;], test_df[&#39;b&#39;]]).sum()</span><br><span class="line">c_df &#x3D; pd.DataFrame(g_df)</span><br><span class="line">c_df.reset_index(inplace&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>输入出结果：<br><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201105347.png" alt="20210201105347"></p>
<p>分组后的原生结果：<br><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201110100.png" alt="20210201110100"></p>
<p>分组后转换为DataFrame的结果：<br><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201110222.png" alt="20210201110222"></p>
<p>使用 reset_index 方法删除原来索引后的结果:<br><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201110629.png" alt="20210201110629"></p>
<h3 id="将由-DataFrame-组成的字典存储至-Excel-的不同-Sheet-中（不覆盖）—-以及将数据读取回原形式"><a href="#将由-DataFrame-组成的字典存储至-Excel-的不同-Sheet-中（不覆盖）—-以及将数据读取回原形式" class="headerlink" title="将由 DataFrame 组成的字典存储至 Excel 的不同 Sheet 中（不覆盖）— 以及将数据读取回原形式"></a>将由 DataFrame 组成的字典存储至 Excel 的不同 Sheet 中（不覆盖）— 以及将数据读取回原形式</h3><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>&emsp;&emsp;当在 Excel 中存储多个 Sheet 时，不可以直接遍历字典，循环 df.to_excel ()，这样做的话前一个 Sheet 会不断被后一个 Sheet 覆盖，最后只存下来最后一个 Sheet。</p>
<p>想要不被覆盖可以通过 pd.ExcelWriter () 进行如下操作，其中 dic 为存储 DataFrame 的字典，dic_key 对应每个 Sheet 名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with pd.ExcelWriter(&quot;excel_name.xlsx&quot;) as writer:</span><br><span class="line">    for dic_key in dic.keys():</span><br><span class="line">        print(&#39;Saving data of &#39; + str(detector))</span><br><span class="line">        dic[dic_key].to_excel(writer, sheet_name &#x3D; str(detector))</span><br><span class="line">        print(&#39;Done!&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>&emsp;&emsp;上一问题的对偶过程是将 Excel 各 Sheet 的数据读取成一个字典包含多个 DataFrame 的形式。可以先建立空字典（dic），读取 Excel 的 Sheet 名字（sheet_name）作为字典的键，再循环读取每个 Sheet 的数据。过程如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#125;</span><br><span class="line"># 读取excel的Sheet名</span><br><span class="line">sheet_names &#x3D; pd.ExcelFile(&#39;excel_name.xlsx&#39;).sheet_names</span><br><span class="line">for sheet_name in sheet_names:</span><br><span class="line">    print(&#39;Loading data of Sheet &#39; + sheet_name + &#39;...&#39;)</span><br><span class="line">    dds[sheet_name] &#x3D; pd.read_excel(&#39;excel_name.xlsx&#39;, sheet_name&#x3D;sheet_name, index_col&#x3D;0)</span><br><span class="line">    print(&#39;Done!&#39;)</span><br></pre></td></tr></table></figure>
<p>当然跟 open 文件一样，上面的 5 行代码也可以简写如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with pd.ExcelWriter(r&#39;C:\Users\数据\Desktop\data\test2.xls&#39;) as writer:</span><br><span class="line">    df1.to_excel(writer, sheet_name&#x3D;&#39;df1&#39;)</span><br><span class="line">    df2.to_excel(writer, sheet_name&#x3D;&#39;df2&#39;)</span><br></pre></td></tr></table></figure>
<p>简单高效，不需要再单独写 save 和 close，自动完成。</p>
<h2 id="将-groupby-之后的数据以及标签保存-excel"><a href="#将-groupby-之后的数据以及标签保存-excel" class="headerlink" title="将 groupby 之后的数据以及标签保存 excel"></a>将 groupby 之后的数据以及标签保存 excel</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 欢迎使用Markdown编辑器</span><br><span class="line">  packsort&#x3D;newpack.groupby([&#39;Stock&#39;, &#39;ReportPeriod&#39;])[&#39;EndShare&#39;].sum()</span><br><span class="line"></span><br><span class="line">  data &#x3D; pd.DataFrame()</span><br><span class="line"></span><br><span class="line">  data&#x3D;packsort.reset_index() ###记住reset</span><br><span class="line">  #print(data)</span><br><span class="line">  </span><br><span class="line">  data.to_csv(&quot;MPayHold.csv&quot;, index&#x3D;False, encoding&#x3D;&quot;utf_8_sig&quot;)</span><br></pre></td></tr></table></figure>
<p>需要用到 packsort.reset_index () 重置索引，再转化为 dataframe 写入 excel</p>
<h2 id="Dataframeg-groupby-分组统计结果转换成-Dataframe，再修改其索引"><a href="#Dataframeg-groupby-分组统计结果转换成-Dataframe，再修改其索引" class="headerlink" title="Dataframeg groupby 分组统计结果转换成 Dataframe，再修改其索引"></a>Dataframeg groupby 分组统计结果转换成 Dataframe，再修改其索引</h2><p>pandas 提供了 groupby 函数可以对数据集按一个键或多个键进行分组统计。</p>
<p>groupby 分组函数：返回一个重构的 dataframe，数据的原索引会保留，但数据的相对位置会发生变化。</p>
<p>下面以一组数据为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"># 创建dataframe</span><br><span class="line">data &#x3D; pd.DataFrame(&#123;&quot;key&quot;: list(&quot;abbcaabac&quot;),</span><br><span class="line">                     &quot;value&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;)</span><br><span class="line"></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206081228.png" alt="20210206081228"></p>
</div>

<p>下面按 key 进行分组:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 按key分组</span><br><span class="line">data_group &#x3D; data.groupby(data[&quot;key&quot;])</span><br><span class="line"># 分组后的结果不能直接输出</span><br><span class="line">print(data_group)    # 输出的是data_group的类型</span><br></pre></td></tr></table></figure>
<p>可以使用循环对分组后的结果进行遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for key, value in data_group:</span><br><span class="line">    print(key)</span><br><span class="line">    print(value)</span><br><span class="line">    print(type(value))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206081413.png" alt="20210206081413"></p>
</div>

<ul>
<li>分组后的组名分别是 a, b, c；直接用类型转换 data_group 转变成 dataframe 不太容易。每一个 value 都是 dataframe 类型，可以把每个 value 进行拼接形成新的 dataframe，列名与原数据相同。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_data &#x3D; pd.DataFrame(columns&#x3D;[&quot;key&quot;, &quot;value&quot;])</span><br><span class="line">print(new_data)</span><br></pre></td></tr></table></figure>
<p>通过循环，对 value 进行拼接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 循环拼接</span><br><span class="line">for key, value in data_group:</span><br><span class="line">    new_data &#x3D; pd.concat([new_data, value])</span><br><span class="line">print(new_data)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206081542.png" alt="20210206081542"></p>
</div>

<p>在原始数据上实现了分组，但是原索引得到了保留，可以通过以下代码改变索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_data.index &#x3D; np.arange(len(new_data.index))</span><br><span class="line">print(new_data)</span><br></pre></td></tr></table></figure>
<p>结果可以看到数据变为有序：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206081629.png" alt="20210206081629"></p>
</div>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>00.小白Python学习路线</title>
    <url>/2021/01/29/00-%E5%B0%8F%E7%99%BDPython%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>学前须知：Python 是一种解释型、面向对象、动态数据类型</p>
<ul>
<li>Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。</li>
</ul>
<ul>
<li><p>像 Perl 语言一样，Python 源代码同样遵循 GPL (GNU General Public License) 协议。</p>
</li>
<li><p>Python 是一种解释型语言： 这就说明开发过程中没有了编译这个环节。类似于 PHP 和 Perl 语言。</p>
</li>
<li><p>Python 是面向对象语言: 这就说明 Python 支持面向对象的风格或代码封装在对象的编程技术。</p>
</li>
<li><p>Python 是交互式语言： 这就说明你可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。</p>
</li>
<li><p>Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到浏览器再到游戏。</p>
</li>
</ul>
<p>准备：在学习之前，我们首先要思考一个问题，怎么写代码，用什么写？所以，初学者我推荐 Python3.6 版本，这是最成熟的版本之一，一些功能库基本上都会兼容。编译软件使用 Pycharm。</p>
<pre><code>0 基础小白怎么学 Python 呢？
</code></pre>
<h3 id="一、确定学习目标"><a href="#一、确定学习目标" class="headerlink" title="一、确定学习目标"></a>一、确定学习目标</h3><p>&emsp;&emsp;任何人，无论是学习一个新东西的时候，都首先要确定一个方向，不然就像无头苍蝇样，胡乱碰撞。只有确定了学习方向，才能一直朝着这个方向走，才能在学习中进步，才能体会 Python 给你带来的快乐。</p>
<div align =center>


</div>

<h3 id="二、Python-基础知识学习"><a href="#二、Python-基础知识学习" class="headerlink" title="二、Python 基础知识学习"></a>二、Python 基础知识学习</h3><ul>
<li><p>a. 首先了解 Python 是什么，它都能做些什么？</p>
</li>
<li><p>b. 需要知道什么是变量、算法、解释器</p>
</li>
<li><p>c Python 的基本数据类型</p>
</li>
<li><p>d 列表和元组的操作方法</p>
</li>
<li><p>e 字符串操作方法</p>
</li>
<li><p>f 基本的字典操作方法</p>
</li>
</ul>
<div align =center>


</div>


<h3 id="三、掌握-Python-的条件语句，判断、循环的相关执行语句"><a href="#三、掌握-Python-的条件语句，判断、循环的相关执行语句" class="headerlink" title="三、掌握 Python 的条件语句，判断、循环的相关执行语句"></a>三、掌握 Python 的条件语句，判断、循环的相关执行语句</h3><ul>
<li><p>条件、判断语句：if、else、elif</p>
</li>
<li><p>循环语句：while、for</p>
</li>
<li><p>判断结束语句：continue、break</p>
</li>
</ul>
<h3 id="四、面对对象知识"><a href="#四、面对对象知识" class="headerlink" title="四、面对对象知识"></a>四、面对对象知识</h3><ul>
<li><p>类 (Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>
</li>
<li><p>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p>
</li>
<li><p>数据成员：类变量或者实例变量，用于处理类及其实例对象的相关的数据。</p>
</li>
<li><p>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p>
</li>
<li><p>局部变量：定义在方法中的变量，只作用于当前实例的类。</p>
</li>
<li><p>实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。</p>
</li>
<li><p>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个 Dog 类型的对象派生自 Animal 类，这是模拟 “是一个（is-a）” 关系（例图，Dog 是一个 Animal）。</p>
</li>
<li><p>实例化：创建一个类的实例，类的具体对象。</p>
</li>
<li><p>方法：类中定义的函数。</p>
</li>
<li><p>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p>
</li>
</ul>
<div align =center>


</div>


<h3 id="五、实践"><a href="#五、实践" class="headerlink" title="五、实践"></a>五、实践</h3><p>&emsp;&emsp;学习到了这个阶段了，一定要多动手实践，学了不去用，不去实操，时间过去一个月、两个月或许还记得，但时间长了，也就慢慢的忘了。在项目实践过程中出现问题，查找和处理过程中遇到的错误和异常，遇到问题多上网搜索，也可以参考公众号内的一些文章，在成功的解决了这些问题之后，你就得到一种特别的满足，特别的开心，这也是你学习 Python 给你带来的动力。</p>
<div align =center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/%E4%BD%A0%E6%87%82%E6%88%91%E7%9A%84%E6%84%8F%E6%80%9D%E5%90%A7.png" alt="你懂我的意思吧"></p>
</div>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>01-pandas中利用groupby分组导入数据到excel中</title>
    <url>/2021/02/01/01-Pandas%E4%B8%AD%E5%88%A9%E7%94%A8groupby%E5%88%86%E7%BB%84%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%88%B0excel%E4%B8%AD/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.read_table(read_file, header&#x3D;0, dtype&#x3D;str, sep&#x3D;&#39;\t&#39;)</span><br><span class="line">res_file &#x3D; fileDir + r&#39;\filename.xlsx&#39;</span><br><span class="line">writer &#x3D; pd.ExcelWriter(res_file)</span><br><span class="line">groupby_df &#x3D; df.groupby([&#39;colname&#39;])</span><br><span class="line"></span><br><span class="line">for i in groupby_df:</span><br><span class="line">    i[1].to_excel(writer, index&#x3D;False, sheet_name&#x3D;i[0])</span><br><span class="line"></span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>
<h3 id="使用-pandas-dataframe-toexcel-groupby-ExcelWriter-拆分-Excel-总表到分表，按某列的值分类到分表的-Python-方法"><a href="#使用-pandas-dataframe-toexcel-groupby-ExcelWriter-拆分-Excel-总表到分表，按某列的值分类到分表的-Python-方法" class="headerlink" title="使用 pandas.dataframe.toexcel, groupby, ExcelWriter 拆分 Excel 总表到分表，按某列的值分类到分表的 Python 方法"></a>使用 pandas.dataframe.toexcel, groupby, ExcelWriter 拆分 Excel 总表到分表，按某列的值分类到分表的 Python 方法</h3><p>首先，我们先读取总表， 其中 dtype 可以指定某列读取的格式.</p>
<p>读取 2020-07-27 的格式日期时，输出到 Excel 文件日期会变为 2020-07-27  00:00:00 格式</p>
<p>我们可以使用 date_parse 参数指定处理函数， 如果格式复杂且有错误，这是一个好办法.</p>
<p>也可以使用 datetime 中的 strftime 和 strptime 来处理，</p>
<p>上诉两种办法都需要指定一个函数，也可以使用 lambda</p>
<p>我这里不想处理日期格式，选择用字符串类型来读取。想要了解的可以参考别的文章，或者我可能勤奋以后会写 (大概率不会)</p>
<p>dtype 参数可以指定某列使用你想要的类型来读取</p>
<p><code>data = pandas.read_excel(&quot;总表.xls&quot;, dtype=&#123;&quot;日期&quot;: str&#125;)</code></p>
<p>如果我们想要按照部门来分类,写入分表, 下面这种写法会覆盖原来的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_departments &#x3D; data.groupby(&quot;部门&quot;)</span><br><span class="line">for department, data_department in data_departments:</span><br><span class="line">    data_department.to_excel(&quot;分类后的表.xls&quot;, department)</span><br></pre></td></tr></table></figure>
<p>要想达到分表的效果且不会覆盖， 我们可以使用 pandas.ExcelWriter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_departments&#x3D; data.groupby(&quot;部门&quot;)</span><br><span class="line"> </span><br><span class="line">writer1 &#x3D; pandas.ExcelWriter(&quot;分类后的表.xls&quot;)</span><br><span class="line"> </span><br><span class="line">for department, data_department in data_departments:</span><br><span class="line">    data_department.to_excel(writer1, department)</span><br><span class="line"> </span><br><span class="line">writer1.save()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201115903.png" alt="20210201115903"></p>
<p>如果我们想要按字段内容生成多个 Excel 表， 可以直接这样做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_departments&#x3D; data.groupby(&quot;地区&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">for department, data_department in data_departments:</span><br><span class="line">    data_department.to_excel(f&quot;&#123;department&#125;.xls&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210201115943.png" alt="20210201115943"></p>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>01.初识Python</title>
    <url>/2021/01/26/01.%E5%88%9D%E8%AF%86Python/</url>
    <content><![CDATA[<h4 id="Python的历史"><a href="#Python的历史" class="headerlink" title="Python的历史"></a>Python的历史</h4><ol>
<li>1989年圣诞节：Guido von Rossum开始写Python语言的编译器。</li>
<li>1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，还有对列表、字典等核心数据类型，同时支持以模块为基础来构造应用程序。</li>
<li>1994年1月：Python 1.0正式发布。</li>
<li>2000年10月16日：Python 2.0发布，增加了完整的<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">垃圾回收</a>，提供了对<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。</li>
<li>2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6/2.7版本中。</li>
</ol>
<p>目前我们使用的Python 3.7.x的版本是在2018年发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以阅读名为<a href="http://www.cnblogs.com/vamei/archive/2013/02/06/2892628.html">《Python简史》</a>的网络文章。</p>
<h4 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h4><p>Python的优点很多，简单的可以总结为以下几点。</p>
<ol>
<li>简单明了，学习曲线低，比很多编程语言都容易上手。</li>
<li>开放源代码，拥有强大的社区和生态圈，尤其是在数据分析和机器学习领域。</li>
<li>解释型语言，天生具有平台可移植性，代码可以工作于不同的操作系统。</li>
<li>对两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。</li>
<li>代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。</li>
</ol>
<p>Python的缺点主要集中在以下几点。</p>
<ol>
<li>执行效率稍低，对执行效率要求高的部分可以由其他语言（如：C、C++）编写。</li>
<li>代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被弱化。</li>
<li>在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。</li>
</ol>
<h4 id="Python的应用领域"><a href="#Python的应用领域" class="headerlink" title="Python的应用领域"></a>Python的应用领域</h4><p>目前Python在Web应用后端开发、云基础设施建设、DevOps、网络数据采集（爬虫）、自动化测试、数据分析、机器学习等领域都有着广泛的应用。</p>
<h3 id="安装Python解释器"><a href="#安装Python解释器" class="headerlink" title="安装Python解释器"></a>安装Python解释器</h3><p>想要开始Python编程之旅，首先得在自己使用的计算机上安装Python解释器环境，下面将以安装官方的Python解释器为例，讲解如何在不同的操作系统上安装Python环境。官方的Python解释器是用C语言实现的，也是使用最为广泛的Python解释器，通常称之为CPython。除此之外，Python解释器还有Java语言实现的Jython、C#语言实现的IronPython以及PyPy、Brython、Pyston等版本，有兴趣的读者可以自行了解。</p>
<h3 id="Python开发工具"><a href="#Python开发工具" class="headerlink" title="Python开发工具"></a>Python开发工具</h3><h4 id="IDLE-自带的集成开发工具"><a href="#IDLE-自带的集成开发工具" class="headerlink" title="IDLE - 自带的集成开发工具"></a>IDLE - 自带的集成开发工具</h4><p>IDLE是安装Python环境时自带的集成开发工具，如下图所示。但是由于IDLE的用户体验并不是那么好所以很少在实际开发中被采用。</p>
<p><img src="./res/python-idle.png"></p>
<h4 id="Visual-Studio-Code-更好的交互式编程工具"><a href="#Visual-Studio-Code-更好的交互式编程工具" class="headerlink" title="Visual Studio Code - 更好的交互式编程工具"></a>Visual Studio Code - 更好的交互式编程工具</h4><p>Visual Studio Code（简称 VS Code ）是一个由微软开发，同时支持 Windows 、 Linux 和 macOS 等操作系统的 免费代码编辑器，它支持 测试，并内置了 Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和 代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。</p>
<p>在 2019 年的 Stack Overflow 组织的开发者调研中，VS Code 被认为是最受开发者欢迎的开发环境，据调查 87317 名受访者中有 50.7% 的受访者声称正在使用 VS Code。</p>
<p>Visual Studio Code 具备了现代文本编辑器所具有的功能，例如更改字符编码、更换换行符、语法高亮、支持正则表达式、安装扩展、创建 snippet 等。</p>
<p>此外 Visual Studio Code 还支持扩展程序。通过安装扩展程序，Code 可以支持更多新的语言、界面主题、测试器，以及更多的增值服务。Visual Studio Code 的扩展程序运行于独立的进程中，以保证编辑器的运行速度不受干扰。</p>
<p>Visual Studio Code 支持多种编程语言，集成终端，可以在编辑器中运行脚本、编译软件、调试脚本、设置断点、做版本管理。</p>
<p>可以在命令面板中（快捷键 Ctrl+Shift+P）搜索和输入命令，从而实现指定功能，例如安装扩展、设置属性等、调用扩展的命令。</p>
<p>在控制面板做的设置都会自动保存到 json，也可以直接修改 json 文件，方便备份或部署。</p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>02.1数值和字符串</title>
    <url>/2021/01/29/02-1%E6%95%B0%E5%80%BC%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>1、数值</p>
<ul>
<li>数值数据类型</li>
</ul>
<p>python 支持如下数值型数据：</p>
<table>
<thead>
<tr>
<th align="center">数值类型</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数（int）</td>
<td align="center">0, -3</td>
</tr>
<tr>
<td align="center">浮点数（float）</td>
<td align="center">3.1415926, 0.3E+1, 3E-1</td>
</tr>
<tr>
<td align="center">十六进制（hexadecimal）</td>
<td align="center">0xAF（以0x开头，其后都是数字或者大小写字母）</td>
</tr>
<tr>
<td align="center">八进制（octal）</td>
<td align="center">0o10（以0o或0O开头，其后其后都是0-7之间的整数）</td>
</tr>
<tr>
<td align="center">二进制（binary）</td>
<td align="center">0b1011010010（以0b或0B开头,其后都是0、1）</td>
</tr>
</tbody></table>
<ul>
<li>数值运算<br>常见数字运算类型及内置函数如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运算符  含义</span><br><span class="line">+      （加）    </span><br><span class="line">-      （减）</span><br><span class="line">*      （乘）</span><br><span class="line">&#x2F;      （除）</span><br><span class="line">&#x2F;&#x2F;     （整除运算）</span><br><span class="line">%      （求余数）</span><br><span class="line">**     （幂）</span><br><span class="line">int(x)   (取x整数部分)</span><br><span class="line">float(x) （将x转化为浮点数）</span><br><span class="line">pow(x,y)  （求x的y次幂）</span><br><span class="line">abs(x)   （求x的绝对值）</span><br><span class="line">round(x)  (x四舍五入)</span><br><span class="line">bin(x)   (将x转化为二进制)</span><br><span class="line">oct(x)  （将x转化为八进制）</span><br><span class="line">hex(x) （将x转化为十六进制）</span><br><span class="line">math.floor(x) (math模块中向下取整，floor中文有地板的意思)</span><br><span class="line">math.ceil(x) （math模块中向上取整，ceil中文天花板的意思）</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数值运算举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  In [1]: #加</span><br><span class="line">   ...: print(2 + 3)</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">In [2]: #减</span><br><span class="line">   ...: print(2 - 3)</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">In [3]: #乘</span><br><span class="line">   ...: print(2 * 3)</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">In [4]: #除</span><br><span class="line">   ...: print(2 &#x2F; 3)</span><br><span class="line">0.6666666666666666</span><br><span class="line"></span><br><span class="line">In [5]: #整除运算，向下取整</span><br><span class="line">   ...: print(1 &#x2F;&#x2F; 3)</span><br><span class="line">   ...: print(5.0 &#x2F;&#x2F; 2.0)#输出结果类型与除数和被除数一致</span><br><span class="line">   ...: print(5.0 &#x2F;&#x2F; 2)</span><br><span class="line">   ...: print(5 &#x2F;&#x2F; 2.0)</span><br><span class="line">   ...: print(-5 &#x2F;&#x2F; 2)#向下（向负3）取整</span><br><span class="line">0</span><br><span class="line">2.0</span><br><span class="line">2.0</span><br><span class="line">2.0</span><br><span class="line">-3</span><br><span class="line"></span><br><span class="line">In [6]: #求余运算</span><br><span class="line">    ...: print(5 % 2)</span><br><span class="line">    ...: print(5.0 % 2.0)</span><br><span class="line">    ...: print(5.0 % 2)</span><br><span class="line">    ...: print(5 % 2.0)</span><br><span class="line">1</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line">1.0</span><br><span class="line"></span><br><span class="line">In [7]: #求幂</span><br><span class="line">    ...: print(2 ** 3)</span><br><span class="line">    ...: print(-2 ** 2)#注意比较区别</span><br><span class="line">    ...: print((-2) ** 2)</span><br><span class="line">8</span><br><span class="line">-4</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">In [8]: #取浮点数</span><br><span class="line">    ...: print(float(2))</span><br><span class="line">    ...:</span><br><span class="line">    ...:</span><br><span class="line">2.0</span><br><span class="line"></span><br><span class="line">In [9]: #取整数</span><br><span class="line">    ...: print(int(2.3))</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">In [10]: #取浮点数</span><br><span class="line">    ...: print(float(2))</span><br><span class="line">2.0</span><br><span class="line"></span><br><span class="line">In [11]: #pow函数求幂</span><br><span class="line">    ...: print(pow(2,3))</span><br><span class="line">    ...: print(2 ** 3)#与上行等价</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">In [12]: #取绝对值</span><br><span class="line">    ...: print(abs(-2))</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">In [13]: #四舍五入</span><br><span class="line">    ...: print(round(2.3))</span><br><span class="line">    ...: print(round(2.6))</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">In [14]: #转二进制</span><br><span class="line">    ...: print(bin(2))</span><br><span class="line">    ...:</span><br><span class="line">    ...: #转八进制</span><br><span class="line">    ...: print(oct(2))</span><br><span class="line">    ...:</span><br><span class="line">    ...: #转十六进制</span><br><span class="line">    ...: print(hex(2))</span><br><span class="line">0b10</span><br><span class="line">0o2</span><br><span class="line">0x2</span><br><span class="line"></span><br><span class="line">In [15]: #向下取整和向上取整</span><br><span class="line">   ...: import math</span><br><span class="line">   ...: print(math.floor(3.5))#向下取整</span><br><span class="line">   ...: print(math.ceil(3.5))#向上取整</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>2、字符串<br>字符串使用单引号，双引号或者三引号包围起来，例如，”hello, boy!”，’hello, boy!’，’’’hello,boy!’’’。</p>
</li>
<li><p>单引号双引号区别</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [16]: #该场景单引号和双引号作用一致</span><br><span class="line">   ...: print(&quot;hello boy!&quot;)</span><br><span class="line">   ...: print(&#39;hello girl!&#39;)</span><br><span class="line">hello boy!</span><br><span class="line">hello girl!</span><br><span class="line"></span><br><span class="line">#以下场景双引号和单引号作用不一致</span><br><span class="line">In [13]: print(&#39;hello,boy! Let&#39;s do it&#39;)</span><br><span class="line">  File &quot;&lt;ipython-input-13-be7bb4cf818c&gt;&quot;, line 1</span><br><span class="line">    print(&#39;hello,boy! Let&#39;s do it&#39;)</span><br><span class="line">                                  ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>反斜杠 \ 转义符<br>
  可添加转义字符使以上场景发挥相同作用。

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [15]: print(&#39;hello,boy! Let\&#39;s do it&#39;)</span><br><span class="line">hello,boy! Let&#39;s do it</span><br></pre></td></tr></table></figure>
<ul>
<li>输出原始字符串<br> 
输出字符串例如，换行符（\n），tab 分隔符（\t）等的原始字符串，而不是换行或者 tab 分割

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [16]: #方法一，反斜线转义</span><br><span class="line">    ...: #分别在特殊字符钱加反斜线转义</span><br><span class="line">    ...: print(&quot;Hi\\tHello\\nboy!&quot;)</span><br><span class="line">    ...:</span><br><span class="line">    ...: #方法二，使用r</span><br><span class="line">    ...: print(repr(&quot;Hi\tHello\nboy!&quot;))</span><br><span class="line">    ...: print(r&quot;Hi\tHello\nboy!&quot;)</span><br><span class="line"></span><br><span class="line">        Hi\tHello\nboy!</span><br><span class="line">        Hi\tHello\nboy!</span><br></pre></td></tr></table></figure>
<ul>
<li>三引号<br>
三引号内的字符可自由换行。

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [26]: print(&quot;&quot;&quot;Hello</span><br><span class="line">    ...: ,</span><br><span class="line">    ...: boy!&quot;&quot;&quot;)</span><br><span class="line">Hello</span><br><span class="line">,</span><br><span class="line">boy!</span><br></pre></td></tr></table></figure>
<p>三引号内可以随意使用双引号和单引号而不需要转义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [22]: print(&quot;&quot;&quot;hello,boy! Let&#39;s d&quot;o it&quot;&quot;&quot;)</span><br><span class="line">hello,boy! Let&#39;s d&quot;o it</span><br></pre></td></tr></table></figure>
<ul>
<li>操作字符串</li>
</ul>
<p>索引、切片、乘法、成员资格检查、长度、最小值和最大值都适用于字符串。</p>
<ul>
<li>字符串修改</li>
</ul>
<p>字符串是不可变的，所有的元素赋值和切片赋值都是非法的；<br>强行修改字符串的值会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [128]: &quot;Hello&quot;[1:]&#x3D;&quot;o&quot;</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-128-0a82fa2a7175&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 &quot;Hello&quot;[1:]&#x3D;&quot;o&quot;</span><br><span class="line"></span><br><span class="line">TypeError: &#39;str&#39; object does not support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>索引</li>
</ul>
<p>索引每次取一个元素，python 索引从 0 开始，可以为负数，最后一位索引为 - 1, 倒数第二位索引为 - 2，依次类推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [6]: &quot;Keepstudying&quot;[0:3]#取出索引位为0到2的元素</span><br><span class="line">Out[6]: &#39;Kee&#39;</span><br><span class="line"></span><br><span class="line">In [7]: &quot;Keepstudying&quot;[0:-2]#取出索引位为0到倒数第三个元素</span><br><span class="line">Out[7]: &#39;Keepstudyi&#39;</span><br><span class="line"></span><br><span class="line">In [8]: &quot;Keepstudying&quot;[-4:-2]#取出索引位为-4到-3的元素</span><br><span class="line">Out[8]: &#39;yi&#39;</span><br><span class="line"></span><br><span class="line">In [9]: &quot;Keepstudying&quot;[:3]#第一个参数可以省略</span><br><span class="line">Out[9]: &#39;Kee&#39;</span><br><span class="line"></span><br><span class="line">In [10]: &quot;Keepstudying&quot;[:]#取出所有元素</span><br><span class="line">Out[10]: &#39;Keepstudying&#39;</span><br><span class="line"></span><br><span class="line">In [11]: &quot;Keepstudying&quot;[1:]#第二个参数也可以省略</span><br><span class="line">Out[11]: &#39;eepstudying&#39;</span><br><span class="line"></span><br><span class="line">In [13]: &quot;Keepstudying&quot;[1:5:2]#步长为2</span><br><span class="line">Out[13]: &#39;ep&#39;</span><br><span class="line"></span><br><span class="line">In [14]: &quot;Keepstudying&quot;[::-1]#将字符颠倒</span><br><span class="line">Out[14]: &#39;gniydutspeeK&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>乘法<br>str*n，重复 str n 次。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [27]: print(&quot;Keepstudying\t&quot; * 10)#重复10次</span><br><span class="line">Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying    Keepstudying</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>拼接</p>
<bf>
使用加号拼接。

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [27]: print(&quot;Hello,&quot;+&quot;world!&quot;)</span><br><span class="line">Hello,world!</span><br></pre></td></tr></table></figure>
<ul>
<li>in 成员资格检查</li>
</ul>
<p>使用 in 判断字符串是否包含某个子字符串，包含返回 True，不包含返回 False。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [15]: &quot;stu&quot; in &quot;Keepstudying&quot;</span><br><span class="line">Out[15]: True</span><br><span class="line"></span><br><span class="line">In [16]: &quot;stv&quot; in &quot;Keepstudying&quot;</span><br><span class="line">Out[16]: False</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历</li>
</ul>
<p>依次输出字符串中每个元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [18]: for i in &quot;Keepstudying&quot;:</span><br><span class="line">    ...:     print(i)</span><br><span class="line">K</span><br><span class="line">e</span><br><span class="line">e</span><br><span class="line">p</span><br><span class="line">s</span><br><span class="line">t</span><br><span class="line">u</span><br><span class="line">d</span><br><span class="line">y</span><br><span class="line">i</span><br><span class="line">n</span><br><span class="line">g</span><br></pre></td></tr></table></figure>
<ul>
<li><p>求长度</p>
<p>使用 len 函数，计算字符串个数，\t，\n 算一个字符。</p>
<pre><code>In [23]: len(&quot;Keepstudyin  \t\ng&quot;)
Out[23]: 16
```
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>02.2数值和字符串</title>
    <url>/2021/01/29/02-2%E6%95%B0%E5%80%BC%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<ul>
<li>字符串方法</li>
</ul>
<p>字符串处理方法很多（下面斜体为所有内置方法），本文介绍常用的几种方法，详细可见链接：<a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html">https://docs.python.org/zh-cn/3.7/library/stdtypes.html</a> 。</p>
<p><code>In [23]: print(dir(str))#dir列出字符串所用方法</code></p>
<p>[‘<strong>add</strong>‘, ‘<strong>class</strong>‘, ‘<strong>contains</strong>‘, ‘<strong>delattr</strong>‘, ‘<strong>dir</strong>‘, ‘<strong>doc</strong>‘, ‘<strong>eq</strong>‘, ‘<strong>format</strong>‘, ‘<strong>ge</strong>‘, ‘<strong>getattribute</strong>‘, ‘<strong>getitem</strong>‘, ‘<strong>getnewargs</strong>‘, ‘<strong>gt</strong>‘, ‘<strong>hash</strong>‘, ‘<strong>init</strong>‘, ‘<strong>init_subclass__’, ‘<strong>iter</strong>‘, ‘<strong>le</strong>‘, ‘<strong>len</strong>‘, ‘<strong>lt</strong>‘, ‘<strong>mod</strong>‘, ‘<strong>mul</strong>‘, ‘<strong>ne</strong>‘, ‘<strong>new</strong>‘, ‘<strong>reduce</strong>‘, ‘__reduce_ex</strong>‘, ‘<strong>repr</strong>‘, ‘<strong>rmod</strong>‘, ‘<strong>rmul</strong>‘, ‘<strong>setattr</strong>‘, ‘<strong>sizeof</strong>‘, ‘<strong>str</strong>‘, ‘<strong>subclasshook</strong>‘, <strong><em>‘capitalize’, ‘casefold’, ‘center’, ‘count’, ‘encode’, ‘endswith’, ‘expandtabs’, ‘find’, ‘format’, ‘format_map’, ‘index’, ‘isalnum’, ‘isalpha’, ‘isascii’, ‘isdecimal’, ‘isdigit’, ‘isidentifier’, ‘islower’, ‘isnumeric’, ‘isprintable’, ‘isspace’, ‘istitle’, ‘isupper’, ‘join’, ‘ljust’, ‘lower’, ‘lstrip’, ‘maketrans’, ‘partition’, ‘replace’, ‘rfind’, ‘rindex’, ‘rjust’, ‘rpartition’, ‘rsplit’, ‘rstrip’, ‘split’, ‘splitlines’, ‘startswith’, ‘strip’, ‘swapcase’, ‘title’, ‘translate’, ‘upper’, ‘zfill’]</em></strong></p>
<ul>
<li><p>find 方法</p>
<p>语法，str.find (sub_str,a,b)</p>
</li>
</ul>
<p>字符串 str 中查找子字符串 sub_str 所在位置时使用，a，b 分别制定从 str 中开始搜索的位置，默认从第一个字符开始，a，b 均可忽略；如果找到 sub_str，就返回 sub_str 的第一个字符的索引，没找到返回 - 1。可用来判断 str 中是否包 sub_str 以及位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [32]: print(&quot;xiyangyang lanyangyang&quot;.find(&quot;huitanglang&quot;))</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">In [33]: print(&quot;xiyangyang lanyangyang&quot;.find(&quot;yang&quot;))</span><br><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>join 方法</li>
</ul>
<p>语法：sep.join (str)，以 sep 为分隔符拼接字符串 str。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [36]: print(&quot;+&quot;.join(&quot;xiyangyang&quot;))</span><br><span class="line">x+i+y+a+n+g+y+a+n+g</span><br></pre></td></tr></table></figure>
<ul>
<li>split 方法</li>
</ul>
<p>语法：str.split (sep)，以 sep 为分隔符，拆分字符串 str 为一个 list。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [37]: print(&quot;x+i+y+a+n+g+y+a+n+g&quot;.split(&quot;+&quot;))</span><br><span class="line">[&#39;x&#39;, &#39;i&#39;, &#39;y&#39;, &#39;a&#39;, &#39;n&#39;, &#39;g&#39;, &#39;y&#39;, &#39;a&#39;, &#39;n&#39;, &#39;g&#39;]</span><br></pre></td></tr></table></figure>
<ul>
<li>lower 方法</li>
</ul>
<p>语法：str.lower ()，将字符串 str 转化为小写版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [39]: print(&quot;Hello! Hi!&quot;.lower())</span><br><span class="line">hello! hi!</span><br></pre></td></tr></table></figure>
<ul>
<li>upper 方法</li>
</ul>
<p>语法：str.upper ()，将字符串 str 转化为大写版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [41]: print(&quot;Hello! Hi!&quot;.upper())</span><br><span class="line">HELLO! HI!</span><br></pre></td></tr></table></figure>
<ul>
<li>replace 方法</li>
</ul>
<p>语法：str.replace (“sub_str1”, “sub_str2”, max)。将字符串 str 中的子字符串 sub_str1 替换为 sub_str2，max 为允许替换的最大次数，可忽略，默认替换所有。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [48]: print(&quot;xiyangyang lanyangyang&quot;.replace(&quot;an&quot;,&quot;XX&quot;,2))</span><br><span class="line">xiyXXgyXXg lanyangyang</span><br></pre></td></tr></table></figure>
<ul>
<li><p>strip，lstrip 和 rstrip 方法</p>
<p>语法：三个方法类似，str.strip (sub_str)。strip 方法去掉 str 开头和结尾的子字符串 sub_str，sub_str 可忽略，默认为空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [49]: print(&quot; Hello &quot;.strip())</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">In [50]: print(&quot; Hello &quot;.lstrip())</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">In [51]: print(&quot; Hello &quot;.rstrip())</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">In [52: print(&quot; Hello &quot;.rstrip(&quot;o &quot;))</span><br><span class="line">Hell</span><br></pre></td></tr></table></figure></li>
<li><p>translate 方法</p>
</li>
</ul>
<p>语法：str.translate (table)，该方法同时替换 str 中多个字符，replace 一次只能替换一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [56]: old &#x3D; &quot;axy&quot;</span><br><span class="line">    ...: new &#x3D; &quot;123&quot;</span><br><span class="line">    ...: #调用字符串str的maketrans方法制作转换表</span><br><span class="line">    ...: table &#x3D; str.maketrans(old, new)</span><br><span class="line">    ...:</span><br><span class="line">    ...: str1 &#x3D; &quot;xiyangyang lanyangyang&quot;</span><br><span class="line">    ...: print (str1.translate(table))</span><br><span class="line">2i31ng31ng l1n31ng31ng</span><br></pre></td></tr></table></figure>
<ul>
<li>startswith 方法</li>
</ul>
<p>语法：str.startswith (sub_str, a, b)。判断 str 是否以 sub_str 开头，是则返回 True，否则返回 False，a，b 指定检索开始和结束（ 默认是字符串的长度，表示结束搜索的位置）为止，默认从第一个字符开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [64]: print(&quot;Hello&quot;.startswith(&quot;H&quot;))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<ul>
<li>endswith 方法</li>
</ul>
<p>使用类似 startswith，判断 str 是否以 sub_str 结尾。</p>
<ul>
<li><p>is 开头的诸多方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isascii&#39;, &#39;isdecimal&#39;,</span><br><span class="line">&#39;isdigit&#39;, &#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;,</span><br><span class="line">&#39;istitle&#39;, &#39;isupper&#39;</span><br></pre></td></tr></table></figure>
<p>以上分别为判断字符时否是字母或数字、字母、ASCII 等，详细参考 <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html%EF%BC%8C%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E">https://docs.python.org/zh-cn/3.7/library/stdtypes.html，结果返回</a> True 或者 False。</p>
</li>
<li><p>字符串格式化输出：format 方法</p>
</li>
<li><ul>
<li>调用参数</li>
</ul>
</li>
</ul>
<p>按顺序将字段和参数配对输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#按顺序将字段和参数配对输出</span><br><span class="line">In [79]: &quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(1, 2, 4, 3)</span><br><span class="line">Out[79]: &#39;1 2 4 3&#39;</span><br><span class="line"> </span><br><span class="line">#给参数指定名称，通过参数名称调用输出</span><br><span class="line">In [80]: &quot;&#123;a&#125; &#123;a&#125; &#123;b&#125; &#123;b&#125;&quot;.format(a&#x3D;1, b&#x3D;2)</span><br><span class="line">Out[80]: &#39;1 1 2 2&#39;</span><br><span class="line"> </span><br><span class="line">#以上两种方法混用</span><br><span class="line">In [81]: &quot;&#123;&#125; &#123;a&#125; &#123;&#125; &#123;b&#125;&quot;.format(0, 3, a&#x3D;1, b&#x3D;2)</span><br><span class="line">Out[81]: &#39;0 1 3 2&#39;</span><br><span class="line"> </span><br><span class="line">#未命名参数通过索引调用输出</span><br><span class="line">In [82]: &quot;&#123;1&#125; &#123;a&#125; &#123;0&#125; &#123;b&#125;&quot;.format(0, 3, a&#x3D;1, b&#x3D;2)</span><br><span class="line">Out[82]: &#39;3 1 0 2&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>参数格式转换</li>
</ul>
</li>
</ul>
<p>指定要转换的值是哪种类型，如下例中的 f b。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [85]: &quot;The number is &#123;:f&#125;&quot;.format(42)#f将小数表示为定点数</span><br><span class="line">Out[85]: &#39;The number is 42.000000&#39;</span><br><span class="line"> </span><br><span class="line">In [86]: &quot;The number is &#123;:b&#125;&quot;.format(42)#b将整数表示为二进制数</span><br><span class="line">Out[86]: &#39;The number is 101010&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>python 指定字符宽度，精度</li>
</ul>
</li>
</ul>
<p>常用转化类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b             将整数表示为二进制数</span><br><span class="line">c             将整数解读为Unicode码点</span><br><span class="line">d             将整数视为十进制数进行处理，这是整数默认使用的说明符</span><br><span class="line">e             使用科学表示法来表示小数（用e来表示指数）</span><br><span class="line">E             与e相同，但使用E来表示指数</span><br><span class="line">f              将小数表示为定点数</span><br><span class="line">F            与f相同，但对于特殊值（nan和inf），使用大写表示</span><br><span class="line">g            自动在定点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少有1位小数</span><br><span class="line">G            与g相同，但使用大写来表示指数和特殊值</span><br><span class="line">n            与g相同，但插入随区域而异的数字分隔符</span><br><span class="line">o            将整数表示为八进制数</span><br><span class="line">s            保持字符串的格式不变，这是默认用于字符串的说明符</span><br><span class="line">x            将整数表示为十六进制数并使用小写字母</span><br><span class="line">X            与x相同，但使用大写字母</span><br><span class="line">%            将数表示为百分比值（乘以100，按说明符f设置格式，再在后面加上%）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [96]: &quot;Pi is &#123;pi:10.2f&#125;&quot;.format(pi&#x3D;math.pi)#指定字符快读为10，精度为2个小数位</span><br><span class="line">Out[96]: &#39;Pi is       3.14&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>指定字符千分位分隔符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [101]: &#39;Oh gold banknote is &#123;:,&#125; yuan&#39;.format(100000000000)</span><br><span class="line">Out[101]: &#39;Oh gold banknote is 100,000,000,000 yuan&#39;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li>对齐</li>
</ul>
</li>
</ul>
<p>分别使用 &lt;、&gt; 和 ^ 指定左对齐，右对齐和居中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [107]: print(&#39;&#123;0:&lt;10.2f&#125;\n&#123;0:^10.2f&#125;\n&#123;0:&gt;10.2f&#125;&#39;.format(math.pi))</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210128181624.png" alt="20210128181624"></p>
<ul>
<li><ul>
<li>指定填充字符</li>
</ul>
</li>
</ul>
<p>默认为空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [113]: print(&#39;&#123;0:$&lt;10.2f&#125;\n&#123;0:@^10.2f&#125;\n&#123;0:&amp;&gt;10.2f&#125;&#39;.format(math.pi))</span><br><span class="line">3.14$$$$$$</span><br><span class="line">@@@3.14@@@</span><br><span class="line">&amp;&amp;&amp;&amp;&amp;&amp;3.14</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>等号（=），指定将填充字符放在符号和数字之间。</li>
</ul>
</li>
</ul>
<p>此处 = 类似于 &lt;、&gt; 和 ^</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [127]: print(&#39;&#123;0:$&gt;10.2f&#125;\n&#123;1:$&#x3D;10.2f&#125;&#39;.format(math.pi, -math.pi))</span><br><span class="line">$$$$$$3.14</span><br><span class="line">-$$$$$3.14</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>02.语言元素</title>
    <url>/2021/01/26/02.%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h4 id="指令和程序"><a href="#指令和程序" class="headerlink" title="指令和程序"></a>指令和程序</h4><p>计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器放在一起就是我们通常所说的中央处理器，它的功能是执行各种运算和控制指令以及处理计算机软件中的数据。我们通常所说的程序实际上就是指令的集合，我们程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。今天我们大多数时候使用的计算机，虽然它们的元器件做工越来越精密，处理能力越来越强大，但究其本质来说仍然属于<a href="https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84">“冯·诺依曼结构”</a>的计算机。“冯·诺依曼结构”有两个关键点，一是指出要将存储设备与中央处理器分开，二是提出了将数据以二进制方式编码。二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法没有实质性的区别，人类因为有十根手指所以使用了十进制（因为在数数时十根手指用完之后就只能进位了，当然凡事都有例外，玛雅人可能是因为长年光着脚的原因把脚趾头也算上了，于是他们使用了二十进制的计数法，在这种计数法的指导下玛雅人的历法就与我们平常使用的历法不一样，而按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为”2012年是玛雅人预言的世界末日“这种荒诞的说法，今天我们可以大胆的猜测，玛雅文明之所以发展缓慢估计也与使用了二十进制有关）。对于计算机来说，二进制在物理器件上来说是最容易实现的（高电压表示1，低电压表示0），于是在“冯·诺依曼结构”的计算机都使用了二进制。虽然我们并不需要每个程序员都能够使用二进制的思维方式来工作，但是了解二进制以及它与我们生活中的十进制之间的转换关系，以及二进制与八进制和十六进制的转换关系还是有必要的。如果你对这一点不熟悉，可以自行使用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">维基百科</a>或者<a href="https://baike.baidu.com/">百度百科</a>科普一下。</p>
<blockquote>
<p><strong>说明</strong>：近期关于<strong>量子计算机</strong>的研究已经被推倒了风口浪尖，量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息。2018年6月，Intel宣布开发出新款量子芯片并通过了在接近绝对零度环境下的测试；2019年，IBM和Google都推出了自己的量子计算机。</p>
</blockquote>
<h3 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h3><p>在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多种类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），我们先介绍几种常用的数据类型。</p>
<ul>
<li>整型：Python中可以处理任意大小的整数（Python 2.x中有<code>int</code>和<code>long</code>两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如<code>0b100</code>，换算成十进制是4）、八进制（如<code>0o100</code>，换算成十进制是64）、十进制（<code>100</code>）和十六进制（<code>0x100</code>，换算成十进制是256）的表示法。</li>
<li>浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如<code>123.456</code>）之外还支持科学计数法（如<code>1.23456e2</code>）。</li>
<li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如<code>&#39;hello&#39;</code>和<code>&quot;hello&quot;</code>,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。</li>
<li>布尔型：布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如<code>3 &lt; 5</code>会产生布尔值<code>True</code>，而<code>2 == 1</code>会产生布尔值<code>False</code>）。</li>
<li>复数型：形如<code>3+5j</code>，跟数学上的复数表示一样，唯一不同的是虚部的<code>i</code>换成了<code>j</code>。实际上，这个类型并不常用，大家了解一下就可以了。</li>
</ul>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。</p>
<ul>
<li>硬性规则：<ul>
<li>变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。</li>
<li>大小写敏感（大写的<code>a</code>和小写的<code>A</code>是两个不同的变量）。</li>
<li>不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。</li>
</ul>
</li>
<li>PEP 8要求：<ul>
<li>用小写字母拼写，多个单词用下划线连接。</li>
<li>受保护的实例属性用单个下划线开头（后面会讲到）。</li>
<li>私有的实例属性用两个下划线开头（后面会讲到）。</li>
</ul>
</li>
</ul>
<p>当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名时做到见名知意也是非常重要的。</p>
<h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><p>下面通过几个例子来说明变量的类型和变量使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用变量保存数据并进行加减乘除运算</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">a = <span class="number">321</span></span><br><span class="line">b = <span class="number">12</span></span><br><span class="line">print(a + b)    <span class="comment"># 333</span></span><br><span class="line">print(a - b)    <span class="comment"># 309</span></span><br><span class="line">print(a * b)    <span class="comment"># 3852</span></span><br><span class="line">print(a / b)    <span class="comment"># 26.75</span></span><br></pre></td></tr></table></figure>
<p>在Python中可以使用<code>type</code>函数对变量的类型进行检查。程序设计中函数的概念跟数学上函数的概念是一致的，数学上的函数相信大家并不陌生，它包括了函数名、自变量和因变量。如果暂时不理解这个概念也不要紧，我们会在后续的章节中专门讲解函数的定义和使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用type()检查变量的类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line">b = <span class="number">12.345</span></span><br><span class="line">c = <span class="number">1</span> + <span class="number">5j</span></span><br><span class="line">d = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">e = <span class="literal">True</span></span><br><span class="line">print(<span class="built_in">type</span>(a))    <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(b))    <span class="comment"># &lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(c))    <span class="comment"># &lt;class &#x27;complex&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(d))    <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(e))    <span class="comment"># &lt;class &#x27;bool&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以使用Python中内置的函数对变量类型进行转换。</p>
<ul>
<li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li>
<li><code>float()</code>：将一个字符串转换成浮点数。</li>
<li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li>
<li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li>
<li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。</li>
</ul>
<p>下面的代码通过键盘输入两个整数来实现对两个整数的算术运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用input()函数获取键盘输入(字符串)</span></span><br><span class="line"><span class="string">使用int()函数将输入的字符串转换成整数</span></span><br><span class="line"><span class="string">使用print()函数输出带占位符的字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;a = &#x27;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;b = &#x27;</span>))</span><br><span class="line">print(<span class="string">&#x27;%d + %d = %d&#x27;</span> % (a, b, a + b))</span><br><span class="line">print(<span class="string">&#x27;%d - %d = %d&#x27;</span> % (a, b, a - b))</span><br><span class="line">print(<span class="string">&#x27;%d * %d = %d&#x27;</span> % (a, b, a * b))</span><br><span class="line">print(<span class="string">&#x27;%d / %d = %f&#x27;</span> % (a, b, a / b))</span><br><span class="line">print(<span class="string">&#x27;%d // %d = %d&#x27;</span> % (a, b, a // b))</span><br><span class="line">print(<span class="string">&#x27;%d %% %d = %d&#x27;</span> % (a, b, a % b))</span><br><span class="line">print(<span class="string">&#x27;%d ** %d = %d&#x27;</span> % (a, b, a ** b))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面的print函数中输出的字符串使用了占位符语法，其中<code>%d</code>是整数的占位符，<code>%f</code>是小数的占位符，<code>%%</code>表示百分号（因为百分号代表了占位符，所以带占位符的字符串中要表示百分号必须写成<code>%%</code>），字符串之后的<code>%</code>后面跟的变量值会替换掉占位符然后输出到终端中，运行上面的程序，看看程序执行结果就明白啦。</p>
</blockquote>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，运算符的优先级指的是多个运算符同时出现时，先做什么运算然后再做什么运算。除了我们之前已经用过的赋值运算符和算术运算符，我们稍后会陆续讲到其他运算符的使用。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code> <code>[:]</code></td>
<td>下标，切片</td>
</tr>
<tr>
<td><code>**</code></td>
<td>指数</td>
</tr>
<tr>
<td><code>~</code> <code>+</code> <code>-</code></td>
<td>按位取反, 正负号</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td>
<td>乘，除，模，整除</td>
</tr>
<tr>
<td><code>+</code> <code>-</code></td>
<td>加，减</td>
</tr>
<tr>
<td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td>右移，左移</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>^</code> <code>|</code></td>
<td>按位异或，按位或</td>
</tr>
<tr>
<td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>小于等于，小于，大于，大于等于</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code></td>
<td>等于，不等于</td>
</tr>
<tr>
<td><code>is</code>  <code>is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in</code> <code>not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not</code> <code>or</code> <code>and</code></td>
<td>逻辑运算符</td>
</tr>
<tr>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> `</td>
<td>=<code> </code>^=<code> </code>&gt;&gt;=<code> </code>&lt;&lt;=`</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong> 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。</p>
</blockquote>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。下面的例子演示了赋值运算符和复合赋值运算符的使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">赋值运算符和复合赋值运算符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">a += b        <span class="comment"># 相当于：a = a + b</span></span><br><span class="line">a *= a + <span class="number">2</span>    <span class="comment"># 相当于：a = a * (a + 2)</span></span><br><span class="line">print(a)      <span class="comment"># 算一下这里会输出什么</span></span><br></pre></td></tr></table></figure>
<h3 id="比较运算符和逻辑运算符"><a href="#比较运算符和逻辑运算符" class="headerlink" title="比较运算符和逻辑运算符"></a>比较运算符和逻辑运算符</h3><p>比较运算符有的地方也称为关系运算符，包括<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>，我相信没有什么好解释的，大家一看就能懂，唯一需要提醒的是比较相等用的是<code>==</code>，请注意这个地方是两个等号，因为<code>=</code>是赋值运算符，我们在上面刚刚讲到过，<code>==</code>才是比较相等的比较运算符。比较运算符会产生布尔值，要么是<code>True</code>要么是<code>False</code>。</p>
<p>逻辑运算符有三个，分别是<code>and</code>、<code>or</code>和<code>not</code>。<code>and</code>字面意思是“而且”，所以<code>and</code>运算符会连接两个布尔值，如果两个布尔值都是<code>True</code>，那么运算的结果就是<code>True</code>；左右两边的布尔值有一个是<code>False</code>，最终的运算结果就是<code>False</code>。相信大家已经想到了，如果<code>and</code>左边的布尔值是<code>False</code>，不管右边的布尔值是什么，最终的结果都是<code>False</code>，所以在做运算的时候右边的值会被跳过（短路处理），这也就意味着在<code>and</code>运算符左边为<code>False</code>的情况下，右边的表达式根本不会执行。<code>or</code>字面意思是“或者”，所以<code>or</code>运算符也会连接两个布尔值，如果两个布尔值有任意一个是<code>True</code>，那么最终的结果就是<code>True</code>。当然，<code>or</code>运算符也是有短路功能的，在它左边的布尔值为<code>True</code>的情况下，右边的表达式根本不会执行。<code>not</code>运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值，也就是说，后面的布尔值如果是<code>True</code>运算结果就是<code>False</code>，而后面的布尔值如果是<code>False</code>则运算结果就是<code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">比较运算符和逻辑运算符的使用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">flag0 = <span class="number">1</span> == <span class="number">1</span></span><br><span class="line">flag1 = <span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line">flag2 = <span class="number">2</span> &lt; <span class="number">1</span></span><br><span class="line">flag3 = flag1 <span class="keyword">and</span> flag2</span><br><span class="line">flag4 = flag1 <span class="keyword">or</span> flag2</span><br><span class="line">flag5 = <span class="keyword">not</span> (<span class="number">1</span> != <span class="number">2</span>)</span><br><span class="line">print(<span class="string">&#x27;flag0 =&#x27;</span>, flag0)    <span class="comment"># flag0 = True</span></span><br><span class="line">print(<span class="string">&#x27;flag1 =&#x27;</span>, flag1)    <span class="comment"># flag1 = True</span></span><br><span class="line">print(<span class="string">&#x27;flag2 =&#x27;</span>, flag2)    <span class="comment"># flag2 = False</span></span><br><span class="line">print(<span class="string">&#x27;flag3 =&#x27;</span>, flag3)    <span class="comment"># flag3 = False</span></span><br><span class="line">print(<span class="string">&#x27;flag4 =&#x27;</span>, flag4)    <span class="comment"># flag4 = True</span></span><br><span class="line">print(<span class="string">&#x27;flag5 =&#x27;</span>, flag5)    <span class="comment"># flag5 = False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：比较运算符的优先级高于赋值运算符，所以<code>flag0 = 1 == 1</code>先做<code>1 == 1</code>产生布尔值<code>True</code>，再将这个值赋值给变量<code>flag0</code>。<code>print</code>函数可以输出多个值，多个值之间可以用<code>,</code>进行分隔，输出的内容之间默认以空格分开。</p>
</blockquote>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：华氏温度转换为摄氏温度。"><a href="#练习1：华氏温度转换为摄氏温度。" class="headerlink" title="练习1：华氏温度转换为摄氏温度。"></a>练习1：华氏温度转换为摄氏温度。</h4><blockquote>
<p>提示：华氏温度到摄氏温度的转换公式为：$C=(F - 32) \div 1.8$。</p>
</blockquote>
<p>参考答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">将华氏温度转换为摄氏温度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">f = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入华氏温度: &#x27;</span>))</span><br><span class="line">c = (f - <span class="number">32</span>) / <span class="number">1.8</span></span><br><span class="line">print(<span class="string">&#x27;%.1f华氏度 = %.1f摄氏度&#x27;</span> % (f, c))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：在使用<code>print</code>函数输出时，也可以对字符串内容进行格式化处理，上面<code>print</code>函数中的字符串<code>%1.f</code>是一个占位符，稍后会由一个<code>float</code>类型的变量值替换掉它。同理，如果字符串中有<code>%d</code>，后面可以用一个<code>int</code>类型的变量值替换掉它，而<code>%s</code>会被字符串的值替换掉。除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中<code>&#123;f:.1f&#125;</code>和<code>&#123;c:.1f&#125;</code>可以先看成是<code>&#123;f&#125;</code>和<code>&#123;c&#125;</code>，表示输出时会用变量<code>f</code>和变量<code>c</code>的值替换掉这两个占位符，后面的<code>:.1f</code>表示这是一个浮点数，小数点后保留1位有效数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;f:<span class="number">.1</span>f&#125;</span>华氏度 = <span class="subst">&#123;c:<span class="number">.1</span>f&#125;</span>摄氏度&#x27;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="练习2：输入圆的半径计算计算周长和面积。"><a href="#练习2：输入圆的半径计算计算周长和面积。" class="headerlink" title="练习2：输入圆的半径计算计算周长和面积。"></a>练习2：输入圆的半径计算计算周长和面积。</h4><p>参考答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输入半径计算圆的周长和面积</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">radius = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入圆的半径: &#x27;</span>))</span><br><span class="line">perimeter = <span class="number">2</span> * <span class="number">3.1416</span> * radius</span><br><span class="line">area = <span class="number">3.1416</span> * radius * radius</span><br><span class="line">print(<span class="string">&#x27;周长: %.2f&#x27;</span> % perimeter)</span><br><span class="line">print(<span class="string">&#x27;面积: %.2f&#x27;</span> % area)</span><br></pre></td></tr></table></figure>
<h4 id="练习3：输入年份判断是不是闰年。"><a href="#练习3：输入年份判断是不是闰年。" class="headerlink" title="练习3：输入年份判断是不是闰年。"></a>练习3：输入年份判断是不是闰年。</h4><p>参考答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输入年份 如果是闰年输出True 否则输出False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">year = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入年份: &#x27;</span>))</span><br><span class="line"><span class="comment"># 如果代码太长写成一行不便于阅读 可以使用\对代码进行折行</span></span><br><span class="line">is_leap = year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">or</span> \</span><br><span class="line">          year % <span class="number">400</span> == <span class="number">0</span></span><br><span class="line">print(is_leap)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：比较运算符会产生布尔值，而逻辑运算符<code>and</code>和<code>or</code>会对这些布尔值进行组合，最终也是得到一个布尔值，闰年输出<code>True</code>，平年输出<code>False</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>DataFrame读写及路径问题总结</title>
    <url>/2021/02/04/DataFrame%E8%AF%BB%E5%86%99%E5%8F%8A%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="一、路径问题"><a href="#一、路径问题" class="headerlink" title="一、路径问题"></a>一、路径问题</h2><h3 id="在写代码前一定要先导入相关的库"><a href="#在写代码前一定要先导入相关的库" class="headerlink" title="在写代码前一定要先导入相关的库"></a>在写代码前一定要先导入相关的库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import os </span><br></pre></td></tr></table></figure>
<h4 id="1、导入文件"><a href="#1、导入文件" class="headerlink" title="1、导入文件"></a>1、导入文件</h4><p><code>data = pd.read_excel(&quot;D:\\PycharmProjects\\hellow\\excel\\招生信息.xlsx&quot;)     # 打开原始工作表</code></p>
<a id="more"></a>

<p>&emsp;&emsp;文件目录采用双斜线替换了反斜线，避免了因为误识别文件目录为转义符导致的错误，类似解决错误转义符出错的方法如下。<br><br><br>（1）路径前加‘r’<br><br><br>（2）替换为双斜线<br><br><br>（3）替换为正斜线</p>
<p>注意：在 read_excel 时一定是读取原文件路径，大部分程序出错都是因为读取路径的问题</p>
<h4 id="2、获取工作表行数列数"><a href="#2、获取工作表行数列数" class="headerlink" title="2、获取工作表行数列数"></a>2、获取工作表行数列数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lens &#x3D; data.shape[1]  # 获取行数 shape[1]获取列数</span><br><span class="line">rows &#x3D; data.shape[0]  # 获取行数 shape[0]获取行数</span><br></pre></td></tr></table></figure>
<h4 id="3、获取指定工作表"><a href="#3、获取指定工作表" class="headerlink" title="3、获取指定工作表"></a>3、获取指定工作表</h4><p><code>data = pd.read_excel(r&quot;D:\excel\招生信息.xlsx&quot;,sheetname=&#39;sheet名&#39;) </code></p>
<h4 id="4、获取指定工作薄中所有工作表"><a href="#4、获取指定工作薄中所有工作表" class="headerlink" title="4、获取指定工作薄中所有工作表"></a>4、获取指定工作薄中所有工作表</h4><p><code>data = pd.read_excel(r&quot;D:\excel\招生信息.xlsx&quot;,sheetname=None) </code></p>
<h4 id="5、获取所有工作表中指定列"><a href="#5、获取所有工作表中指定列" class="headerlink" title="5、获取所有工作表中指定列"></a>5、获取所有工作表中指定列</h4><p><code>data = pd.read_excel(r&quot;D:\excel\招生信息.xlsx&quot;,sheetname=None，usecols=[&#39;A1&#39;,&#39;A2&#39;,....]) </code></p>
<h2 id="二、批量读取-Excel-文件"><a href="#二、批量读取-Excel-文件" class="headerlink" title="二、批量读取 Excel 文件"></a>二、批量读取 Excel 文件</h2><h3 id="1、读取同一个文件夹下的多个-Excel-文件"><a href="#1、读取同一个文件夹下的多个-Excel-文件" class="headerlink" title="1、读取同一个文件夹下的多个 Excel 文件"></a>1、读取同一个文件夹下的多个 Excel 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x3D; r&#39;D:\jupyter notebook\test&#39; </span><br><span class="line">filenames &#x3D; os.listdir(dir)</span><br><span class="line">dfs &#x3D; []</span><br><span class="line">for filename in filenames:</span><br><span class="line">   print(&#39;正在处理第&#39;) + str(index+1) + &#39;个表格&#39;）</span><br><span class="line">   # print(&#39;需要合并的文件为:&#39;,dir + filename)    # 为第二种写法</span><br><span class="line">   dfs.append(pd.read_excel(dir + &#39;\\&#39; + filename))</span><br><span class="line">   # dfs.append(pd.read_excel(os.path.join(dir,filename)))  # 为第二种写法</span><br><span class="line">   index +&#x3D;1</span><br><span class="line">df &#x3D; pd.concat(dfs)</span><br><span class="line">df.to_excel(&#39;&#39;dir + &#39;\\&#39; + total.xlsx&#39;&#39;,index &#x3D; False)</span><br><span class="line">print(&#39;合并后的数据大小为:&#39;,df.shape)</span><br><span class="line">print(&#39;合并完成&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="2、读取同一个文件夹下的多个不同文件内的-Excel-文件"><a href="#2、读取同一个文件夹下的多个不同文件内的-Excel-文件" class="headerlink" title="2、读取同一个文件夹下的多个不同文件内的 Excel 文件"></a>2、读取同一个文件夹下的多个不同文件内的 Excel 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_paths &#x3D; r&#39;D:\jupyter notebook\test&#39; </span><br><span class="line">file_list &#x3D; []</span><br><span class="line">dfs &#x3D; []</span><br><span class="line">for root,dirs,files in os.walk(file_paths):</span><br><span class="line">   print(root,dirs,files)   # 输出看看就会明白都是些什么信息了</span><br><span class="line">   for file in files:</span><br><span class="line">      file_path &#x3D; os.path.join(root,file)  # 使用os.path.join(dirpath, name)得到全路径</span><br><span class="line">      file_list.append(file_path)</span><br><span class="line">      df &#x3D; pd.read_excel(file_path)  # 将excel转换成DataFrame</span><br><span class="line">      dfs.append(df)</span><br><span class="line">df &#x3D; pd.concat(dfs,axis &#x3D; 1)  # 将多个DataFrame合并为一个</span><br></pre></td></tr></table></figure>
<h2 id="python-对-excel-操作获取某一列，某一行的值，对某一列信息筛选"><a href="#python-对-excel-操作获取某一列，某一行的值，对某一列信息筛选" class="headerlink" title="python 对 excel 操作获取某一列，某一行的值，对某一列信息筛选"></a>python 对 excel 操作获取某一列，某一行的值，对某一列信息筛选</h2><p>以下为<a href="https://blog.csdn.net/weixin_43245453/article/details/90747259">转载文章</a><br>向大神学习</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">path &#x3D; &#39;G:\动力系\新建文件夹\什么.xls&#39;</span><br><span class="line">data &#x3D; pd.read_excel(path,None)#读取数据,设置None可以生成一个字典，字典中的key值即为sheet名字，此时不用使用DataFram，会报错</span><br><span class="line">print(data.keys())#查看sheet的名字</span><br><span class="line">for sh_name in data.keys():</span><br><span class="line">    print(&#39;sheet_name的名字是：&#39;,sh_name)</span><br><span class="line">    sh_data &#x3D; pd.DataFrame(pd.read_excel(path,sh_name))#获得每一个sheet中的内容</span><br><span class="line">    print(sh_data)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210203225541.png" alt="20210203225541"></p>
</div>

<h4 id="获得某一行，某一列的值"><a href="#获得某一行，某一列的值" class="headerlink" title="获得某一行，某一列的值"></a>获得某一行，某一列的值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">path &#x3D; &#39;G:\动力系\新建文件夹\什么.xls&#39;</span><br><span class="line">data &#x3D; pd.DataFrame(pd.read_excel(path))#读取数据,设置None可以生成一个字典，字典中的key值即为sheet名字，此时不用使用DataFram，会报错</span><br><span class="line">print(data.index)#获取行的索引名称</span><br><span class="line">print(data.columns)#获取列的索引名称</span><br><span class="line">print(data[&#39;姓名&#39;])#获取列名为姓名这一列的内容</span><br><span class="line">print(data.loc[0])#获取行名为0这一行的内容</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210203225808.png" alt="20210203225808"></p>
</div>

<h4 id="对某一列的信息进行筛选"><a href="#对某一列的信息进行筛选" class="headerlink" title="对某一列的信息进行筛选"></a>对某一列的信息进行筛选</h4><p>筛选使用的是 data.loc [列名称 = 提取的信息]</p>
<p>假如我要提取院系下面的动力，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">path &#x3D; &#39;G:\动力系\新建文件夹\什么.xls&#39;</span><br><span class="line">data &#x3D; pd.DataFrame(pd.read_excel(path))#读取数据,设置None可以生成一个字典，字典中的key值即为sheet名字，此时不用使用DataFram，会报错</span><br><span class="line">result &#x3D; data.loc[data[&#39;院系&#39;] &#x3D;&#x3D; &#39;动力&#39;]#获取列明为院系，内容为动力的内容</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210203225916.png" alt="20210203225916"></p>
</div>

<h2 id="python-下-pandas-库中读取指定行或列数据"><a href="#python-下-pandas-库中读取指定行或列数据" class="headerlink" title="python 下 pandas 库中读取指定行或列数据"></a>python 下 pandas 库中读取指定行或列数据</h2><p>关键！！！！使用 loc 函数来查找。<br>话不多说，直接演示：<br>有以下名为 try.xlsx 表：[此文为转载，出处在CSDN上，具体忘记了，表示感谢]</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210203230209.png" alt="20210203230209"></p>
</div>

<h4 id="1-根据-index-查询"><a href="#1-根据-index-查询" class="headerlink" title="1. 根据 index 查询"></a>1. 根据 index 查询</h4><p>条件：首先导入的数据必须的有 index<br>或者自己添加吧，方法简单，读取 excel 文件时直接加 index_col<br>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd                      #导入pandas库</span><br><span class="line"></span><br><span class="line">excel_file &#x3D; &#39;.&#x2F;try.xlsx&#39;               #导入excel数据</span><br><span class="line">data &#x3D; pd.read_excel(excel_file, index_col&#x3D;&#39;姓名&#39;)        </span><br><span class="line">#这个的index_col就是index，可以选择任意字段作为索引index，读入数据</span><br><span class="line">print(data.loc[&#39;李四&#39;])</span><br></pre></td></tr></table></figure>
<p>打印结果就是:<br><br><br>部门 B<br><br><br>工资 6600<br><br><br>Name: 李四，dtype: object<br><br><br>（注意点：索引）</p>
<h4 id="2-已知数据在第几行找到想要的数据"><a href="#2-已知数据在第几行找到想要的数据" class="headerlink" title="2. 已知数据在第几行找到想要的数据"></a>2. 已知数据在第几行找到想要的数据</h4><p>假如我们的表中，有某个员工的工资数据为空了，那我们怎么找到自己想要的数据呢。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in data.columns:</span><br><span class="line">    for j in range(len(data)):</span><br><span class="line">        if (data[i].isnull())[j]:</span><br><span class="line">            bumen &#x3D; data.iloc[j, [0]]                             #找出缺失值所在的部门</span><br><span class="line">            data[i][j] &#x3D; charuzhi(bumen)</span><br></pre></td></tr></table></figure>
<p>原理很简单，首先检索全部的数据，然后我们可以用 pandas 中的 iloc 函数。上面的 iloc [j, [2]] 中 j 是具体的位置，【0】是你要得到的数据所在的 column</p>
<h4 id="3-根据条件查询找到指定行数据"><a href="#3-根据条件查询找到指定行数据" class="headerlink" title="3. 根据条件查询找到指定行数据"></a>3. 根据条件查询找到指定行数据</h4><p>例如查找 A 部门所有成员的的姓名和工资或者工资低于 3000 的人：<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;根据条件查询某行数据&quot;&quot;&quot;</span><br><span class="line">import pandas as pd            #导入pandas库</span><br><span class="line"></span><br><span class="line">excel_file &#x3D; &#39;.&#x2F;try.xlsx&#39;        #导入文件</span><br><span class="line">data &#x3D; pd.read_excel(excel_file)      #读入数据</span><br><span class="line"></span><br><span class="line">print(data.loc[data[&#39;部门&#39;] &#x3D;&#x3D; &#39;A&#39;, [&#39;姓名&#39;, &#39;工资&#39;]])     #部门为A，打印姓名和工资</span><br><span class="line">print(data.loc[data[&#39;工资&#39;] &lt; 3000, [&#39;姓名&#39;,&#39;工资&#39;]])    #查找工资小于3000的人</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210203230509.png" alt="20210203230509"></p>
</div>
若要把这些数据独立生成 excel 文件或者 csv 文件：
添加以下代码:

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;导出为excel或csv文件&quot;&quot;&quot;</span><br><span class="line">dataframe_1 &#x3D; data.loc[data[&#39;部门&#39;] &#x3D;&#x3D; &#39;A&#39;, [&#39;姓名&#39;, &#39;工资&#39;]]</span><br><span class="line">dataframe_2 &#x3D; data.loc[data[&#39;工资&#39;] &lt; 3000, [&#39;姓名&#39;, &#39;工资&#39;]]</span><br><span class="line">dataframe_1.to_excel(&#39;dataframe_1.xlsx&#39;)</span><br><span class="line">dataframe_2.to_excel(&#39;dataframe_2.xlsx&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="4-找出指定列"><a href="#4-找出指定列" class="headerlink" title="4. 找出指定列"></a>4. 找出指定列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data[&#39;columns&#39;]  #columns即你需要的字段名称即可</span><br><span class="line">#注意这列的columns不能是index的名称</span><br><span class="line">#如果要打印index的话就data.index</span><br><span class="line">data.columns  #与上面的一样</span><br></pre></td></tr></table></figure>
<p>以上全过程用到的库：<br>pandas，xlrd , openpyxl</p>
<h4 id="5-找出指定的行和指定的列"><a href="#5-找出指定的行和指定的列" class="headerlink" title="5. 找出指定的行和指定的列"></a>5. 找出指定的行和指定的列</h4><p>主要使用的就是函数 iloc</p>
<p><code>data.iloc[:,:2]  #即全部行，前两列的数据</code></p>
<p>逗号前是行，逗号后是列的范围，很容易理解</p>
<h4 id="6-在规定范围内找出符合条件的数据"><a href="#6-在规定范围内找出符合条件的数据" class="headerlink" title="6. 在规定范围内找出符合条件的数据"></a>6. 在规定范围内找出符合条件的数据</h4><p><code>data.iloc[:10,:][data.工资&gt;6000]</code></p>
<p>这样即可找出前 11 行里工资大于 6000 的所有人的信息了</p>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法查看</title>
    <url>/2021/01/29/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%9F%A5%E7%9C%8B/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/191d1e21f7ed/">1. Markdown 基本语法含流程图的创建</a></p>
<p><a href="http://markdown.p2hp.com/basic-syntax/index.html">2. 基本语法 官网</a></p>
<p><a href="https://www.jianshu.com/p/ebe52d2d468f">3. Markdown语法大全(超级版)</a></p>
<pre><code>表头|表头|表头
:--|:--:|:--:
内容|内容|内容
内容|内容|内容

第二行分割表头和内容。
- 有一个就行，为了对齐，多加了几个
文字默认居左
-两边加：表示文字居中
-右边加：表示文字居右
</code></pre>
<p>效果如下：</p>
<table>
<thead>
<tr>
<th align="center">姓名</th>
<th align="center">技能</th>
<th align="center">排行</th>
</tr>
</thead>
<tbody><tr>
<td align="center">刘备</td>
<td align="center">哭</td>
<td align="center">大哥</td>
</tr>
<tr>
<td align="center">关羽</td>
<td align="center">打</td>
<td align="center">二哥</td>
</tr>
<tr>
<td align="center">张飞</td>
<td align="center">骂</td>
<td align="center">三弟</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas在github上获取原始数据集</title>
    <url>/2021/02/16/Pandas%E5%9C%A8github%E4%B8%8A%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>GitHub repository 的文件地址后面直接加？raw=true</code></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1、文本类文件，小文件 (txt,xml,gif) 可以直接展示；</p>
<p>2、压缩文件会提示下载，这就可以通过 github 升级程序。</p>
<p>Sample：</p>
<p>在github的文件地址后面直接加上(？raw=true)</p>
<p>zip 提示 save</p>
<p><a href="https://github.com/Song2017/PersonalLab/blob/master/0_testRaw/raw.zip?raw=true">https://github.com/Song2017/PersonalLab/blob/master/0_testRaw/raw.zip?raw=true</a></p>
<p>txt</p>
<p><a href="https://github.com/Song2017/PersonalLab/blob/master/0_testRaw/rawTxt.txt?raw=true">https://github.com/Song2017/PersonalLab/blob/master/0_testRaw/rawTxt.txt?raw=true</a></p>
<p>Pandas读取github上的数据集:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210216122500.png" alt="20210216122500"></p>
</div>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在数据分析的过程里，你已经体会到 Python 生态系统的强大了吧？</p>
<p>数据采集、整理、可视化、统计分析…… 一直到深度学习，都有相应的 Python 包支持。</p>
<p>但是你会发现，没有任何一个 Python 软件包，是全能的。</p>
<p>这是一种非常好的设计思维 —— 用优秀的工具，做专业的事儿；用许多优秀工具组成的系统，来有条不紊地处理复杂问题。</p>
<p>所以，在这个过程中，你大概率会经常遇到数据的交换问题。</p>
<p>有时候，是把分析结果存起来，下次读取回来继续使用。</p>
<p>更重要的时候，是把一个工具的分析结果导出，导入到另一个工具包中。</p>
<p>这些数据存取的功能，几乎分布在每一个 Python 数据科学软件包之内。</p>
<p>但是，其中有一个最重要的枢纽，那就是 Pandas 。</p>
<p>不止一次跟你提起过，学好 Pandas 的重要性。</p>
<p>很多情况下，看似复杂的数据整理与可视化，Pandas 只需要一行语句就能搞定。</p>
<p>回顾我们的教程里，也曾使用过各种不同的格式读取数据到 Pandas 进行处理。</p>
<p>然而，当你需要自己独立面对软件包的格式要求时，也许仅仅是因为不了解如何正确生成或读取某种格式，结果导致出错，甚至会使你丧失探索的信心与兴趣。</p>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas排序简单排复杂排</title>
    <url>/2021/02/05/Pandas%E6%8E%92%E5%BA%8F%E7%AE%80%E5%8D%95%E6%8E%92%E5%A4%8D%E6%9D%82%E6%8E%92/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">lists &#x3D; pd.read_excel(&quot;..&#x2F;007&#x2F;List.xlsx&quot;)</span><br><span class="line"></span><br><span class="line"># 按指定的一列排序</span><br><span class="line">lists.sort_values(by&#x3D;&quot;Price&quot;,inplace&#x3D;True,ascending&#x3D;False)</span><br><span class="line"></span><br><span class="line"># 指定多列排序(注意：对Worthy列升序，再对Price列降序)，ascending不指定的话，默认是True升序</span><br><span class="line">lists.sort_values(by&#x3D;[&quot;Worthy&quot;,&quot;Price&quot;],inplace&#x3D;True,ascending&#x3D;[True,False])</span><br><span class="line"></span><br><span class="line">print(lists)</span><br></pre></td></tr></table></figure>
<p>结果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205123136.png" alt="20210205123136"></p>
</div>

<h3 id="Pandas-函数填充、计算列"><a href="#Pandas-函数填充、计算列" class="headerlink" title="Pandas_函数填充、计算列"></a>Pandas_函数填充、计算列</h3><h4 id="函数填充、计算列"><a href="#函数填充、计算列" class="headerlink" title="函数填充、计算列"></a>函数填充、计算列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">books &#x3D; pd.read_excel(&quot;..&#x2F;006&#x2F;Books.xlsx&quot;,index_col&#x3D;&quot;ID&quot;)</span><br><span class="line">print(books.dtypes)</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure>
<p>结果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205123512.png" alt="20210205123512"></p>
</div>

<h4 id="一、将-“ListPrice”-列-和-“Discount”-列-相乘的值赋给-Price"><a href="#一、将-“ListPrice”-列-和-“Discount”-列-相乘的值赋给-Price" class="headerlink" title="一、将 “ListPrice” 列 和 “Discount” 列 相乘的值赋给 Price"></a>一、将 “ListPrice” 列 和 “Discount” 列 相乘的值赋给 Price</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方法1：按列来运算</span><br><span class="line">books[&quot;Price&quot;] &#x3D; books[&quot;ListPrice&quot;]*books[&quot;Discount&quot;]</span><br><span class="line">books[&quot;Price&quot;]&#x3D;books[&quot;ListPrice&quot;]*8   </span><br><span class="line"></span><br><span class="line"># 方法2：按单元格来运算（类似excel里的操作）</span><br><span class="line">print(books.index)</span><br><span class="line">for i in books.index:</span><br><span class="line">    books[&quot;Price&quot;].at[i]&#x3D;books[&quot;ListPrice&quot;].at[i]*books[&quot;Discount&quot;].at[i] #一旦其中一个是指定到单元格的，其他列也要指定到单元格</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 一般我们需要对某几行操作运算时才会用方法2,比如，我们只对第5行到第15行之间的价格运算</span><br><span class="line">for i in range(5,15):</span><br><span class="line">    books[&quot;Price&quot;].at[i]&#x3D;books[&quot;ListPrice&quot;].at[i]*books[&quot;Discount&quot;].at[i]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205123821.png" alt="20210205123821"></p>
</div>

<h4 id="二、将-“ListPrice”-列-2-元-后-赋给-Price"><a href="#二、将-“ListPrice”-列-2-元-后-赋给-Price" class="headerlink" title="二、将 “ListPrice” 列 +2 元 后 赋给 Price"></a>二、将 “ListPrice” 列 +2 元 后 赋给 Price</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方法1：直接加</span><br><span class="line">books[&quot;Price&quot;] &#x3D; books[&quot;ListPrice&quot;]+2</span><br><span class="line"></span><br><span class="line"># 方法2：用函数</span><br><span class="line">def add_2(x):</span><br><span class="line">    return x+2</span><br><span class="line"></span><br><span class="line">books[&quot;Price&quot;]&#x3D;books[&quot;ListPrice&quot;].apply(add_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方法3：用lambda</span><br><span class="line">books[&quot;Price&quot;]&#x3D;books[&quot;ListPrice&quot;].apply(lambda x:x+2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205123940.png" alt="20210205123940"></p>
</div>

]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas操作Excel的四种类型</title>
    <url>/2021/02/04/Pandas%E6%93%8D%E4%BD%9CExcel%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_41278904/article/details/100167702">转载</a>表示感谢，只是在此记录一下，以便以后自己使用</p>
<h3 id="使用-python-一分钟完成-Excel-数据由多个文件合并为一个文件（pandas）"><a href="#使用-python-一分钟完成-Excel-数据由多个文件合并为一个文件（pandas）" class="headerlink" title="使用 python 一分钟完成 Excel 数据由多个文件合并为一个文件（pandas）"></a>使用 python 一分钟完成 Excel 数据由多个文件合并为一个文件（pandas）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一步：调用pandas包</span><br><span class="line">import pandas as pd</span><br><span class="line">import os</span><br><span class="line">iris_concat &#x3D; pd.DataFrame()</span><br><span class="line"># 第二步：读取数据并合并</span><br><span class="line">for name in os.listdir(&#39;.&#x2F;data&#x2F;&#39;):</span><br><span class="line">    iris &#x3D; pd.read_excel(&#39;.&#x2F;data&#x2F;%s&#39;%(name))</span><br><span class="line">    iris_concat &#x3D; pd.concat([iris_concat,iris])</span><br><span class="line">iris_concat.to_excel(&#39;.&#x2F;iris_concat.xlsx&#39;)#数据保存路径   </span><br></pre></td></tr></table></figure>
<h3 id="使用-Python-一分钟完成-Excel-数据由多个-sheet-合并为一个-sheet（pandas）"><a href="#使用-Python-一分钟完成-Excel-数据由多个-sheet-合并为一个-sheet（pandas）" class="headerlink" title="使用 Python 一分钟完成 Excel 数据由多个 sheet 合并为一个 sheet（pandas）"></a>使用 Python 一分钟完成 Excel 数据由多个 sheet 合并为一个 sheet（pandas）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一步：调用pandas包</span><br><span class="line">import pandas as pd</span><br><span class="line">#第二步：读取数据</span><br><span class="line">iris &#x3D; pd.read_excel(&#39;.&#x2F;iris_sheets.xlsx&#39;,None)#读入数据文件</span><br><span class="line">keys &#x3D; list(iris.keys())</span><br><span class="line">#第三步：数据合并</span><br><span class="line">iris_concat &#x3D; pd.DataFrame()</span><br><span class="line">for i in keys:</span><br><span class="line">    iris1 &#x3D; iris[i]</span><br><span class="line">    iris_concat &#x3D; pd.concat([iris_concat,iris1])</span><br><span class="line">iris_concat.to_excel(&#39;.&#x2F;iris_concat.xlsx&#39;)#数据保存路径   </span><br></pre></td></tr></table></figure>
<h3 id="使用-Python-中-pandas-按照某一列把一个-Excel-文件拆分为多个-Excel-文件"><a href="#使用-Python-中-pandas-按照某一列把一个-Excel-文件拆分为多个-Excel-文件" class="headerlink" title="使用 Python 中 pandas 按照某一列把一个 Excel 文件拆分为多个 Excel 文件"></a>使用 Python 中 pandas 按照某一列把一个 Excel 文件拆分为多个 Excel 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一步：调用pandas包</span><br><span class="line">import pandas as pd</span><br><span class="line">#第二步：读入文件</span><br><span class="line">iris &#x3D; pd.read_excel(&#39;.&#x2F;iris.xlsx&#39;)</span><br><span class="line"># 第三步：获取class列表并去重</span><br><span class="line">class_list &#x3D; list(iris[&#39;class&#39;].drop_duplicates())</span><br><span class="line">#第四步：按照类别分文件存放数据</span><br><span class="line">for i in class_list:</span><br><span class="line">    iris1 &#x3D; iris[iris[&#39;class&#39;]&#x3D;&#x3D;i]</span><br><span class="line">    iris1.to_excel(&#39;.&#x2F;%s.xlsx&#39;%(i))</span><br></pre></td></tr></table></figure>
<h3 id="使用-Python-一分钟完成按照某一列将-Excel-数据由一个-sheet-拆分为多个-sheet（使用-pandas-超简单）"><a href="#使用-Python-一分钟完成按照某一列将-Excel-数据由一个-sheet-拆分为多个-sheet（使用-pandas-超简单）" class="headerlink" title="使用 Python 一分钟完成按照某一列将 Excel 数据由一个 sheet 拆分为多个 sheet（使用 pandas 超简单）"></a>使用 Python 一分钟完成按照某一列将 Excel 数据由一个 sheet 拆分为多个 sheet（使用 pandas 超简单）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一步：调用pandas包</span><br><span class="line">import pandas as pd</span><br><span class="line">#第二步：读取数据</span><br><span class="line">iris &#x3D; pd.read_excel(&#39;.&#x2F;iris.xlsx&#39;)#读入数据文件</span><br><span class="line">class_list &#x3D; list(iris[&#39;class&#39;].drop_duplicates())#获取数据class列，去重并放入列表</span><br><span class="line"># 第三步：按照类别分sheet存放数据</span><br><span class="line">writer &#x3D; pd.ExcelWriter(&#39;.&#x2F;iris_sheets.xlsx&#39;)#创建数据存放路径</span><br><span class="line">for i in class_list: </span><br><span class="line">    iris1 &#x3D; iris[iris[&#39;class&#39;]&#x3D;&#x3D;i]</span><br><span class="line">    iris1.to_excel(writer,i)</span><br><span class="line">writer.save()#文件保存</span><br><span class="line">writer.close()#文件关闭</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas整理表格数据</title>
    <url>/2021/02/04/Pandas%E6%95%B4%E7%90%86%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_41629698/article/details/105393136">转载</a> 在此感谢作者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data&#x3D;[]</span><br><span class="line">dfd &#x3D; pd.read_excel(&#39;F:\gbh\python\practice\大创\data\武汉疫情数据\迁徙.xlsx&#39;)</span><br><span class="line">#dfd.head(10)</span><br><span class="line">index&#x3D;</span><br><span class="line">dfd[&#39;日期&#39;] &#x3D; pd.to_datetime(dfd[&#39;日期&#39;].astype(&#39;str&#39;))</span><br><span class="line">time&#x3D;[&#39;2020-01-24&#39;,&#39;2020-01-25&#39;,&#39;2020-01-26&#39;,&#39;2020-01-27&#39;,&#39;2020-01-28&#39;,&#39;2020-01-29&#39;,&#39;2020-01-30&#39;,&#39;2020-01-31&#39;,&#39;2020-02-01&#39;,&#39;2020-02-02&#39;,&#39;2020-02-03&#39;]</span><br><span class="line">for i in range(12):</span><br><span class="line">    index+&#x3D;1</span><br><span class="line">    data_china &#x3D; dfd[dfd[&#39;日期&#39;] &#x3D;&#x3D; time[i]]</span><br><span class="line">    print(data_china)</span><br><span class="line">    data.append(data_china)</span><br><span class="line">    #data_china.to_csv(&#39;E:\data_tengxun\迁徙1.23.csv&#39;,index&#x3D;0,encoding&#x3D;&#39;utf_8_sig&#39;)</span><br><span class="line">    data_china.to_csv(&#39;E:\data_tengxun\迁徙1.2&#39;+str(index)+&#39;.csv&#39;,index&#x3D;0,encoding&#x3D;&#39;utf_8_sig&#39;)  </span><br></pre></td></tr></table></figure>
<p>以上代码实现批量筛选<br><br><br>如果是单独筛选，可以使用一下代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data&#x3D;[]</span><br><span class="line">dfd &#x3D; pd.read_excel(&#39;F:\gbh\python\practice\大创\data\武汉疫情数据\迁徙.xlsx&#39;)</span><br><span class="line">#dfd.head(10)</span><br><span class="line"></span><br><span class="line">dfd[&#39;日期&#39;] &#x3D; pd.to_datetime(dfd[&#39;日期&#39;].astype(&#39;str&#39;))</span><br><span class="line">#time&#x3D;[&#39;2020-01-24&#39;,&#39;2020-01-25&#39;,&#39;2020-01-26&#39;,&#39;2020-01-27&#39;,&#39;2020-01-28&#39;,&#39;2020-01-29&#39;,&#39;2020-01-30&#39;,&#39;2020-01-31&#39;,&#39;2020-02-01&#39;,&#39;2020-02-02&#39;,&#39;2020-02-03&#39;]</span><br><span class="line">data_china &#x3D; dfd[dfd[&#39;日期&#39;] &#x3D;&#x3D; &#39;2020-02-03&#39;]</span><br><span class="line">print(data_china)</span><br><span class="line">data.append(data_china)</span><br><span class="line">#data_china.to_csv(&#39;E:\data_tengxun\迁徙1.23.csv&#39;,index&#x3D;0,encoding&#x3D;&#39;utf_8_sig&#39;)</span><br><span class="line">data_china.to_csv(&#39;E:\data_tengxun\迁徙2.03.csv&#39;,index&#x3D;0,encoding&#x3D;&#39;utf_8_sig&#39;)  </span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204000207.png" alt="20210204000207"></p>
</div>




<h2 id="用-pandas-按列合并两个文件"><a href="#用-pandas-按列合并两个文件" class="headerlink" title="用 pandas 按列合并两个文件"></a>用 pandas 按列合并两个文件</h2><p><a href="https://blog.csdn.net/destiny_python/article/details/78666839">我是来学习的</a> 转载自此处，感谢</p>
<p>A 文件：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204000638.png" alt="20210204000638"></p>
</div>


<p>B 文件：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204000742.png" alt="20210204000742"></p>
</div>

<p>可以发现，A 文件中 “汉字井号” 这一列和 B 文件中 “WELL” 这一列的属性相同，以这一列为主键，把 B 文件中 “TIME” 这一列数据添加到 A 文件中，如果 B 文件缺少某些行，则空着，最后 A 文件的行数不变，效果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204000832.png" alt="20210204000832"></p>
</div>

<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">df1 &#x3D; pd.read_csv(u&#39;input.csv&#39;, encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line"> </span><br><span class="line">df2 &#x3D; pd.read_csv(&#39;input1.csv&#39;, encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line"> </span><br><span class="line">outfile &#x3D; pd.merge(df1, df2, how&#x3D;&#39;left&#39;, left_on&#x3D;u&#39;汉字井号&#39;,right_on&#x3D;&#39;WELL&#39;)</span><br><span class="line"> </span><br><span class="line">outfile.to_csv(&#39;outfile.csv&#39;, index&#x3D;False, encoding&#x3D;&#39;gbk&#39;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas的合并及拼接问题</title>
    <url>/2021/02/04/Pandas%E7%9A%84%E5%90%88%E5%B9%B6%E5%8F%8A%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>concat 与其说是连接，更准确的说是拼接。就是把两个表直接合在一起。于是有一个突出的问题，是横向拼接还是纵向拼接，所以 concat 函数的关键参数是 axis 。<br>函数的具体参数是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">concat(objs,axis&#x3D;0,join&#x3D;&#39;outer&#39;,join_axes&#x3D;None,</span><br><span class="line">ignore_index&#x3D;False,keys&#x3D;None,levels&#x3D;None,names&#x3D;None,verigy_integrity&#x3D;False)</span><br></pre></td></tr></table></figure>
<p>objs 是需要拼接的对象集合，一般为列表或者字典</p>
<p>axis=0 是行拼接，拼接之后行数增加，列数也根据 join 来定，join=’outer’时，列数是两表并集。同理 join=’inner’, 列数是两表交集。</p>
<p>在默认情况下，axis=0 为纵向，按行拼接，此时有:</p>
<p><code>concat([df1,df2]) 等价于 df1.append(df2)</code></p>
<p>在 axis=1 时为横向拼接 ，此时有:</p>
<p><code>concat([df1,df2],axis=1) 等价于 merge(df1,df2,left_index=True,right_index=True,how=&#39;outer&#39;)</code></p>
<h3 id="pandas-的连接函数-concat-函数"><a href="#pandas-的连接函数-concat-函数" class="headerlink" title="pandas 的连接函数 concat () 函数"></a>pandas 的连接函数 concat () 函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.concat(objs, axis&#x3D;0, join&#x3D;&#39;outer&#39;, join_axes&#x3D;None, ignore_index&#x3D;False,</span><br><span class="line">          keys&#x3D;None, levels&#x3D;None, names&#x3D;None, verify_integrity&#x3D;False,</span><br><span class="line">          copy&#x3D;True)</span><br></pre></td></tr></table></figure>
<h4 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义:"></a>参数含义:</h4><ul>
<li>objs：Series，DataFrame 或 Panel 对象的序列或映射。如果传递了 dict，则排序的键将用作键参数，除非它被传递，在这种情况下，将选择值（见下文）。任何无对象将被静默删除，除非它们都是无，在这种情况下将引发一个 ValueError。</li>
<li>axis：{0,1，…}，默认为 0。沿着连接的轴。</li>
<li>join：{‘inner’，’outer’}，默认为 “outer”。如何处理其他轴上的索引。outer 为联合和 inner 为交集。</li>
<li>ignore_index：boolean，default False。如果为 True，请不要使用并置轴上的索引值。结果轴将被标记为 0，…，n-1。如果要连接其中并置轴没有有意义的索引信息的对象，这将非常有用。注意，其他轴上的索引值在连接中仍然受到尊重。</li>
<li>join_axes：Index 对象列表。用于其他 n-1 轴的特定索引，而不是执行内部 / 外部设置逻辑。</li>
<li>keys：序列，默认值无。使用传递的键作为最外层构建层次索引。如果为多索引，应该使用元组。</li>
<li>levels：序列列表，默认值无。用于构建 MultiIndex 的特定级别（唯一值）。否则，它们将从键推断。</li>
<li>names：list，default 无。结果层次索引中的级别的名称。</li>
<li>verify_integrity：boolean，default False。检查新连接的轴是否包含重复项。这相对于实际的数据串联可能是非常昂贵的。</li>
<li>copy：boolean，default True。如果为 False，请勿不必要地复制数据。</li>
</ul>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: df1 &#x3D; pd.DataFrame(&#123;&#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],</span><br><span class="line">   ...:                     &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;],</span><br><span class="line">   ...:                     &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;],</span><br><span class="line">   ...:                     &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]&#125;,</span><br><span class="line">   ...:                     index&#x3D;[0, 1, 2, 3])</span><br><span class="line">   ...: </span><br><span class="line"> </span><br><span class="line">In [2]: df2 &#x3D; pd.DataFrame(&#123;&#39;A&#39;: [&#39;A4&#39;, &#39;A5&#39;, &#39;A6&#39;, &#39;A7&#39;],</span><br><span class="line">   ...:                     &#39;B&#39;: [&#39;B4&#39;, &#39;B5&#39;, &#39;B6&#39;, &#39;B7&#39;],</span><br><span class="line">   ...:                     &#39;C&#39;: [&#39;C4&#39;, &#39;C5&#39;, &#39;C6&#39;, &#39;C7&#39;],</span><br><span class="line">   ...:                     &#39;D&#39;: [&#39;D4&#39;, &#39;D5&#39;, &#39;D6&#39;, &#39;D7&#39;]&#125;,</span><br><span class="line">   ...:                      index&#x3D;[4, 5, 6, 7])</span><br><span class="line">   ...: </span><br><span class="line"> </span><br><span class="line">In [3]: df3 &#x3D; pd.DataFrame(&#123;&#39;A&#39;: [&#39;A8&#39;, &#39;A9&#39;, &#39;A10&#39;, &#39;A11&#39;],</span><br><span class="line">   ...:                     &#39;B&#39;: [&#39;B8&#39;, &#39;B9&#39;, &#39;B10&#39;, &#39;B11&#39;],</span><br><span class="line">   ...:                     &#39;C&#39;: [&#39;C8&#39;, &#39;C9&#39;, &#39;C10&#39;, &#39;C11&#39;],</span><br><span class="line">   ...:                     &#39;D&#39;: [&#39;D8&#39;, &#39;D9&#39;, &#39;D10&#39;, &#39;D11&#39;]&#125;,</span><br><span class="line">   ...:                     index&#x3D;[8, 9, 10, 11])</span><br><span class="line">   ...: </span><br><span class="line"> </span><br><span class="line">In [4]: frames &#x3D; [df1, df2, df3]</span><br><span class="line"> </span><br><span class="line">In [5]: result &#x3D; pd.concat(frames)</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204071032.png" alt="20210204071032"></p>
</div>

<p>KEY 参数:</p>
<p><code>result = pd.concat(frames, keys=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204071126.png" alt="20210204071126"></p>
</div>

<p>JOIN 参数:</p>
<p>默认 join = ‘outer’, 为取并集的关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [8]: df4 &#x3D; pd.DataFrame(&#123;&#39;B&#39;: [&#39;B2&#39;, &#39;B3&#39;, &#39;B6&#39;, &#39;B7&#39;],</span><br><span class="line">   ...:                  &#39;D&#39;: [&#39;D2&#39;, &#39;D3&#39;, &#39;D6&#39;, &#39;D7&#39;],</span><br><span class="line">   ...:                  &#39;F&#39;: [&#39;F2&#39;, &#39;F3&#39;, &#39;F6&#39;, &#39;F7&#39;]&#125;,</span><br><span class="line">   ...:                 index&#x3D;[2, 3, 6, 7])</span><br><span class="line">   ...: </span><br><span class="line"> </span><br><span class="line">In [9]: result &#x3D; pd.concat([df1, df4], axis&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204071210.png" alt="20210204071210"></p>
</div>

<p>当设置 join = ‘inner’，则说明为取交集</p>
<p><code>In [10]: result = pd.concat([df1, df4], axis=1, join=&#39;inner&#39;)</code></p>
<p>结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204071315.png" alt="20210204071315"></p>
</div>

<p>如果索引想从原始 DataFrame 重用确切索引：</p>
<p><code>In [11]: result = pd.concat([df1, df4], axis=1, join_axes=[df1.index]) #设置索引为df1的索引</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204071446.png" alt="20210204071446"></p>
</div>

<h3 id="一、concat：沿着一条轴，将多个对象堆叠到一起"><a href="#一、concat：沿着一条轴，将多个对象堆叠到一起" class="headerlink" title="一、concat：沿着一条轴，将多个对象堆叠到一起"></a>一、concat：沿着一条轴，将多个对象堆叠到一起</h3><p>concat 方法相当于数据库中的全连接（union all），它不仅可以指定连接的方式（outer join 或 inner join）还可以指定按照某个轴进行连接。与数据库不同的是，它不会去重，但是可以使用 drop_duplicates 方法达到去重的效果。</p>
<h3 id="二、merge：通过键拼接列"><a href="#二、merge：通过键拼接列" class="headerlink" title="二、merge：通过键拼接列"></a>二、merge：通过键拼接列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类似于关系型数据库的连接方式，可以根据一个或多个键将不同的DatFrame连接起来。该函数的典型应用场景是，针对同一个主键存在两张不同字段的表，根据主键整合到一张表里面。</span><br></pre></td></tr></table></figure>
<h3 id="三、join：主要用于索引上的合并"><a href="#三、join：主要用于索引上的合并" class="headerlink" title="三、join：主要用于索引上的合并"></a>三、join：主要用于索引上的合并</h3><h3 id="四、使用-apply-函数实现-group-by-分组拼接"><a href="#四、使用-apply-函数实现-group-by-分组拼接" class="headerlink" title="四、使用 apply 函数实现 group by 分组拼接"></a>四、使用 apply 函数实现 group by 分组拼接</h3><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204072137.png" alt="20210204072137"></p>
</div>

<p>最后 4 行合并为 1 行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def ab(df):</span><br><span class="line">return&#39;,&#39;.join(df.values)</span><br><span class="line"></span><br><span class="line">df &#x3D; df.groupby([&#39;股票代码&#39;,&#39;股票简称&#39;])[&#39;所属概念&#39;].apply(ab)</span><br><span class="line">df &#x3D; df.reset_index()</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204072207.png" alt="20210204072207"></p>
</div>

<h3 id="python-把几个-DataFrame-合并成一个-DataFrame——merge-append-join-conca"><a href="#python-把几个-DataFrame-合并成一个-DataFrame——merge-append-join-conca" class="headerlink" title="python 把几个 DataFrame 合并成一个 DataFrame——merge,append,join,conca"></a>python 把几个 DataFrame 合并成一个 DataFrame——merge,append,join,conca</h3><p>1、merge</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, how&#x3D;&#39;inner&#39;, on&#x3D;None, left_on&#x3D;None, right_on&#x3D;None,</span><br><span class="line">         left_index&#x3D;False, right_index&#x3D;False, sort&#x3D;True,</span><br><span class="line">         suffixes&#x3D;(&#39;_x&#39;, &#39;_y&#39;), copy&#x3D;True, indicator&#x3D;False)</span><br></pre></td></tr></table></figure>
<ul>
<li>left ︰   对象</li>
<li>right ︰   另一个 对象</li>
<li>on︰   要 加入 的 列   （名称） 。 必须 在 左 、   右 综合 对象 中 找到 。 如果 不 能 通过   left_index   和   right_index   是 假 ， 将 推断   DataFrames   中 的 列 的 交叉点 为 连接 键</li>
<li>left_on ︰   从 左边 的 综合 使用 作为 键 列 。 可以 是 列名 或 数组 的 长度 等于 长度 综合</li>
<li>right_on ︰   从 正确 的 综合 ， 以 用作 键 列 。 可以 是 列名 或 数组 的 长度 等于 长度 综合</li>
<li>left_index ︰  如果为  True ， 则 使用 索引   （行 标签）   从 左 综合 作为 其 联接 键。 在 与 多重   （层次）  的 综合 ， 级别 数 必须 匹配 联接 键 从 右 综合 的 数目<br>r- ight_index ︰   相同 用法 作为 正确 综合   left_index<br>how︰   之一   ‘ 左 ‘， ‘ 右 ‘， ‘ 外在 ‘、   ‘ 内部 ‘。 默认 为 内部 。 每个 方法 的 更 详细 说明 请 参阅 ︰</li>
<li>sort︰   综合 通过 联接 键 按 字典 顺序 对 结果 进行排序 。 默认值 为   True ， 设置 为   False 将 提高 性能 极大地 在 许多 情况下</li>
<li>suffixes︰   字符串 后缀 并 不适 用于 重叠 列 的 元组 。 默认值 为   (‘_x’， ‘_y’)。</li>
<li>copy︰   即使 重新索引 是 不 必要 总是 从 传递 的 综合 对象 ， 复制 的 数据   （默认值 True） 。 在 许多 情况下 不能 避免 ， 但 可能会 提高 性能   /   内存 使用情况 。 可以 避免 复制 上述 案件 有些 病理 但 尽管如此 提供 此 选项 。</li>
<li>indicator︰  将 列 添加 到 输出 综合 呼吁   _merge   与 信息 源 的 每 一行 。 _merge   是 绝对类型 ， 并 对 观测 其 合并 键 只 出现 在   ‘ 左’  的 综合 ， 观测 其 合并 键 只 会出现 在   ‘ 正确’  的 综合 ， 和 两个 如果 观察 合并 关键 发现 在 两个   right_only   left_only  的 值 。</li>
</ul>
<p><code>result = pd.merge(left, right, on=&#39;key&#39;)</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204072600.png" alt="20210204072600"></p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; pd.merge(left, right, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])</span><br><span class="line"></span><br><span class="line">result &#x3D; pd.merge(left, right, how&#x3D;&#39;left&#39;, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])</span><br><span class="line"></span><br><span class="line">result &#x3D; pd.merge(left, right, how&#x3D;&#39;right&#39;, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])</span><br><span class="line"></span><br><span class="line">result &#x3D; pd.merge(left, right, how&#x3D;&#39;outer&#39;, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])</span><br></pre></td></tr></table></figure>
<p>2、append</p>
<p><code>result = df1.append(df2)</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204072716.png" alt="20210204072716"></p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; df1.append(df4)</span><br><span class="line"></span><br><span class="line">result &#x3D; df1.append([df2, df3])</span><br><span class="line"></span><br><span class="line">result &#x3D; df1.append(df4, ignore_index&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>4、join</p>
<p><code>left.join(right, on=key_or_keys)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, left_on&#x3D;key_or_keys, right_index&#x3D;True,</span><br><span class="line">      how&#x3D;&#39;left&#39;, sort&#x3D;False)</span><br></pre></td></tr></table></figure>
<p><code>1.result = left.join(right, on=&#39;key&#39;)</code></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204072925.png" alt="20210204072925"></p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.result &#x3D; left.join(right, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])</span><br><span class="line"></span><br><span class="line">3.result &#x3D; left.join(right, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;], how&#x3D;&#39;inner&#39;)</span><br></pre></td></tr></table></figure>
<p>4、concat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.concat(objs, axis&#x3D;0, join&#x3D;&#39;outer&#39;, join_axes&#x3D;None, ignore_index&#x3D;False,</span><br><span class="line">          keys&#x3D;None, levels&#x3D;None, names&#x3D;None, verify_integrity&#x3D;False,</span><br><span class="line">          copy&#x3D;True)</span><br></pre></td></tr></table></figure>
<ul>
<li>objs︰   一个 序列 或 系列 、   综合 或 面板 对象 的 映射 。 如果 字典 中 传递 ， 将 作为 键 参数 ， 使用 排序 的 键 ， 除非 它 传递 ， 在 这 种情况下 的 值 将 会 选择   （见 下文）。 任何 没有任何 反对 将 默默地 被 丢弃 ， 除非 他们 都 没有 在 这 种情况下 将 引发   ValueError 。</li>
<li>axis:   {0， 1， …}， 默认值 为 0。 要 连接 沿 轴 。</li>
<li>join :   {‘ 内部 ‘、   ‘ 外 ‘}， 默认   ‘ 外 ‘。 如何 处理 其他   axis(es)   上 的 索引 。 联盟 内 、   外 的 交叉口 。</li>
<li>ignore_index ︰   布尔值 、   默认   False 。 如果 为  True ， 则 不要 串联 轴 上 使用 的 索引 值 。 由此产生 的 轴 将 标记   0， … ， n - 1。 这 是 有用 的 如果 你 串联 串联 轴 没有 有意义 的 索引 信息 的 对象 。 请注意 在 联接 中 仍然 受到尊重 的 其他 轴 上 的 索引 值 。</li>
<li>join_axes ︰   索引 对象 的 列表 。 具体 的 指标 ， 用于 其他   n - 1   轴 而不是 执行 内部 / 外部 设置 逻辑 。</li>
<li>keys ︰   序列 ， 默认 为 无 。 构建 分层 索引 使用 通过 的 键 作为 最 外面 的 级别 。 如果 多个 级别 获得通过 ， 应 包含 元组 。</li>
<li>levels ︰   列表 的 序列 ， 默认 为 无 。 具体 水平   （唯一 值）   用于 构建 多重 。 否则 ， 他们 将 推断 钥匙 。</li>
<li>names ︰   列表中 ， 默认 为 无 。 由此产生 的 分层 索引 中 的 级 的 名称 。</li>
<li>verify_integrity ︰   布尔值 、   默认   False 。 检查 是否 新 的 串联 的 轴 包含 重复项 。 这 可以 是 相对于 实际 数据 串联 非常 昂贵 。<br>副本 ︰   布尔值 、   默认   True 。 如果 为  False ， 请 不要 ， 不必要地 复制 数据 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.frames &#x3D; [df1, df2, df3]</span><br><span class="line"></span><br><span class="line">2.result &#x3D; pd.concat(frames)</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210204073202.png" alt="20210204073202"></p>
</div>

<p><code>3.result = pd.concat(frames, keys=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</code></p>
<p><code>4.result.ix[&#39;y&#39;]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    A   B   C   D</span><br><span class="line">4  A4  B4  C4  D4</span><br><span class="line">5  A5  B5  C5  D5</span><br><span class="line">6  A6  B6  C6  D6</span><br><span class="line">7  A7  B7  C7  D7</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5.result &#x3D; pd.concat([df1, df4], axis&#x3D;1)</span><br><span class="line"></span><br><span class="line">6.result &#x3D; pd.concat([df1, df4], axis&#x3D;1, join&#x3D;&#39;inner&#39;)</span><br><span class="line"></span><br><span class="line">7.result &#x3D; pd.concat([df1, df4], axis&#x3D;1, join_axes&#x3D;[df1.index])</span><br><span class="line"></span><br><span class="line">8.result &#x3D; pd.concat([df1, df4], ignore_index&#x3D;True)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas筛选的具体应用</title>
    <url>/2021/02/04/Pandas%E7%AD%9B%E9%80%89%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>stu.xlsx表里的数据如下：</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205120704.png" alt="20210205120704"></p>
</div >

<p>筛选出语文成绩在90以上,且数学成绩在80-120分之间的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stu1&#x3D;st.loc[st.语文.apply(lambda x:x&gt;&#x3D;90)].loc[st.数学.apply(lambda y:80&lt;&#x3D;y&lt;&#x3D;120)]</span><br><span class="line">stu1</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205120917.png" alt="20210205120917"></p>
</div>

<p>筛选出语文成绩在90以上,且数学成绩在80-120分之间的，英语成绩在60分以上的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stu2&#x3D;st.loc[st.语文.apply(lambda x:x&gt;&#x3D;90)].loc[st.数学.apply(lambda y:80&lt;&#x3D;y&lt;&#x3D;120)].loc[st.英语.apply(lambda z:z&gt;60)]</span><br><span class="line">stu2</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205121131.png" alt="20210205121131"></p>
</div>

<p>另一种方式是用函数来筛选，如筛选出英语成绩在90分以上的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def score_60(c):</span><br><span class="line">    return c&gt;90</span><br><span class="line">stu3&#x3D;st.loc[st.英语.apply(score_60)]</span><br><span class="line">stu3</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205121323.png" alt="20210205121323"></p>
</div>

<h3 id="Pandas-两表联合（类似-excel-的-vlookup-操作）"><a href="#Pandas-两表联合（类似-excel-的-vlookup-操作）" class="headerlink" title="Pandas_两表联合（类似 excel 的 vlookup 操作）"></a>Pandas_两表联合（类似 excel 的 vlookup 操作）</h3><p><a href="https://www.cnblogs.com/wodexk/p/10803979.html">转自</a></p>
<p>student 表：</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205121731.png" alt="20210205121731"></p>
</div>

<p>score 表：</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205121826.png" alt="20210205121826"></p>
</div>

<h4 id="要求从-students-表里查出每个学生对应的成绩"><a href="#要求从-students-表里查出每个学生对应的成绩" class="headerlink" title="要求从 students 表里查出每个学生对应的成绩"></a>要求从 students 表里查出每个学生对应的成绩</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">students &#x3D; pd.read_excel(&quot;..&#x2F;016&#x2F;Student_Score.xlsx&quot;,sheet_name&#x3D;&quot;Students&quot;)</span><br><span class="line">scores &#x3D; pd.read_excel(&quot;..&#x2F;016&#x2F;Student_Score.xlsx&quot;,sheet_name&#x3D;&quot;Scores&quot;)</span><br><span class="line">print(students.dtypes)</span><br><span class="line">print(scores.dtypes)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 思路：将学生表和成绩表联合起来，即可查到每个学生对应的成绩，关联的列时ID列</span><br><span class="line"># tables &#x3D; students.merge(scores)    # 如果不设置连接的方式，则默认时内连接</span><br><span class="line"></span><br><span class="line"># 要求把学生表的所有学生都显示出来，包括那些没有成绩的学生:用左连接 how&#x3D;&quot;left&quot;</span><br><span class="line">tables &#x3D; students.merge(scores,how&#x3D;&quot;left&quot;,on&#x3D;&quot;ID&quot;)</span><br><span class="line"></span><br><span class="line"># 把没有匹配到的NaN 改为 0</span><br><span class="line"># tables &#x3D; students.merge(scores,how&#x3D;&quot;left&quot;,on&#x3D;&quot;ID&quot;).fillna(&quot;--&quot;)</span><br><span class="line">tables &#x3D; students.merge(scores,how&#x3D;&quot;left&quot;,on&#x3D;&quot;ID&quot;).fillna(0)</span><br><span class="line"></span><br><span class="line"># 将成绩列的浮点类型改为整数型</span><br><span class="line">tables &#x3D; students.merge(scores,how&#x3D;&quot;left&quot;,on&#x3D;&quot;ID&quot;).fillna(0)</span><br><span class="line">tables.Score &#x3D; tables.Score.astype(int)</span><br><span class="line"></span><br><span class="line">print(tables)</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122009.png" alt="20210205122009"></p>
</div>

<h3 id="Pandas-对某列的内容分列"><a href="#Pandas-对某列的内容分列" class="headerlink" title="Pandas_对某列的内容分列"></a>Pandas_对某列的内容分列</h3><p>Employees 表：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122142.png" alt="20210205122142"></p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">employees &#x3D; pd.read_excel(&quot;..&#x2F;018&#x2F;Employees.xlsx&quot;,index_col&#x3D;&quot;ID&quot;)</span><br><span class="line">employees .head()</span><br></pre></td></tr></table></figure>
<h4 id="对-Full-Name-进行切割分列："><a href="#对-Full-Name-进行切割分列：" class="headerlink" title="对 Full Name 进行切割分列："></a>对 Full Name 进行切割分列：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df &#x3D; employees[&quot;Full Name&quot;].str.split()  # str.split()不写参数，会把分隔的内容放在一个列表里</span><br><span class="line"># df</span><br><span class="line"></span><br><span class="line">df &#x3D; employees[&quot;Full Name&quot;].str.split(expand&#x3D;True)  # expand&#x3D;True  可以把用分割的内容直接分列</span><br><span class="line">employees[&quot;FirstName&quot;]&#x3D;df[0]</span><br><span class="line">employees[&quot;LastName&quot;]&#x3D;df[1]</span><br><span class="line">print(employees)</span><br></pre></td></tr></table></figure>
<p>部分结果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122250.png" alt="20210205122250"></p>
</div>

<h4 id="把分隔后的-FistName-都变成大写"><a href="#把分隔后的-FistName-都变成大写" class="headerlink" title="把分隔后的 FistName 都变成大写"></a>把分隔后的 FistName 都变成大写</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">employees[&quot;FirstName&quot;]&#x3D;employees[&quot;FirstName&quot;].str.upper()</span><br><span class="line">print(employees)</span><br></pre></td></tr></table></figure>
<p>结果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122330.png" alt="20210205122330"></p>
</div>

<h4 id="把分隔的-LastName-都变成小写"><a href="#把分隔的-LastName-都变成小写" class="headerlink" title="把分隔的 LastName 都变成小写"></a>把分隔的 LastName 都变成小写</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">employees[&quot;LastName&quot;]&#x3D;employees[&quot;LastName&quot;].str.lower()</span><br><span class="line">print(employees)</span><br></pre></td></tr></table></figure>
<p>结果图：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122404.png" alt="20210205122404"></p>
</div>

<h4 id="Series-str-spilt："><a href="#Series-str-spilt：" class="headerlink" title="Series.str.spilt："></a>Series.str.spilt：</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205122456.png" alt="20210205122456"></p>
</div>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas设置单元格条件格式</title>
    <url>/2021/02/05/Pandas%E8%AE%BE%E7%BD%AE%E5%8D%95%E5%85%83%E6%A0%BC%E6%9D%A1%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Pandas-设置单元格条件格式-1——-指定值字体变色、指定值设置背景色"><a href="#Pandas-设置单元格条件格式-1——-指定值字体变色、指定值设置背景色" class="headerlink" title="Pandas_设置单元格条件格式 1—— 指定值字体变色、指定值设置背景色"></a>Pandas_设置单元格条件格式 1—— 指定值字体变色、指定值设置背景色</h2><p><a href="https://www.cnblogs.com/wodexk/p/10801344.html">转载于</a></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd  </span><br><span class="line">df &#x3D; pd.read_excel(&#39;..&#x2F;数据&#x2F;测试数据成绩.xls&#39;)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205125354.png" alt="20210205125354"></p>
</div>

<h4 id="一、用-def-函数对三科目低于60分的成绩标识红色字体"><a href="#一、用-def-函数对三科目低于60分的成绩标识红色字体" class="headerlink" title="一、用 def 函数对三科目低于60分的成绩标识红色字体"></a>一、用 def 函数对三科目低于60分的成绩标识红色字体</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def low_score_red(s):</span><br><span class="line">    color &#x3D; &#39;red&#39; if s&lt;60 else &#39;black&#39;</span><br><span class="line">    return f&#39;color:&#123;color&#125;&#39;</span><br></pre></td></tr></table></figure>
<h4 id="二、用-def-函数对每科最高分标记背景色为绿色"><a href="#二、用-def-函数对每科最高分标记背景色为绿色" class="headerlink" title="二、用 def 函数对每科最高分标记背景色为绿色"></a>二、用 def 函数对每科最高分标记背景色为绿色</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def highest_score_green(col):</span><br><span class="line">    return [&#39;background-color:lime&#39; if s&#x3D;&#x3D;col.max() else &#39;background-color:white&#39; for s in col]</span><br></pre></td></tr></table></figure>
<p>引用 def_low_score_red(s) 函数，让分数低于60分的字体变红</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df.style.applymap(low_score_red,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br><span class="line"># df.style.apply(highest_score_green,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205125737.png" alt="20210205125737"></p>
</div>

<p>引用 highest_score_green(col) 函数，让分数低于90分的单元格背景变绿</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.style.apply(highest_score_green,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br></pre></td></tr></table></figure>
<p>部分结果图:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205132448.png" alt="20210205132448"></p>
</div>

<p>同时引用两个 def 函数，让分数低于60分的字体变红，每个科目最高分背景为绿色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.applymap:是对subset所有列的值一起操作</span><br><span class="line">.apply:是对subset里的每一列的值操作</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.style.applymap(low_score_red,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])\</span><br><span class="line">.apply(highest_score_green,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br></pre></td></tr></table></figure>
<p>部分结果图:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205130602.png" alt="20210205130602"></p>
</div>

<h2 id="Pandas-设置单元格条件格式-2——-迷你条形图、用颜色深浅表示值大小"><a href="#Pandas-设置单元格条件格式-2——-迷你条形图、用颜色深浅表示值大小" class="headerlink" title="Pandas_设置单元格条件格式 2—— 迷你条形图、用颜色深浅表示值大小"></a>Pandas_设置单元格条件格式 2—— 迷你条形图、用颜色深浅表示值大小</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd  </span><br><span class="line">df &#x3D; pd.read_excel(&#39;..&#x2F;数据&#x2F;测试数据成绩.xls&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="对每一列的值设置迷你条形图来表示数值的大小"><a href="#对每一列的值设置迷你条形图来表示数值的大小" class="headerlink" title="对每一列的值设置迷你条形图来表示数值的大小"></a>对每一列的值设置迷你条形图来表示数值的大小</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .style.bar （颜色，作用的数值区）</span><br><span class="line">df.style.bar(color&#x3D;&#39;skyblue&#39;,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br></pre></td></tr></table></figure>
<h4 id="用颜色深浅来表示数值的大小，值趣大颜色越深"><a href="#用颜色深浅来表示数值的大小，值趣大颜色越深" class="headerlink" title="用颜色深浅来表示数值的大小，值趣大颜色越深"></a>用颜色深浅来表示数值的大小，值趣大颜色越深</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 需要引入seahorn的调色板:light_palette</span><br><span class="line">import seaborn as sns</span><br><span class="line"></span><br><span class="line"># sns.light_palette:调色板，里面的参数分别是要填充的颜色</span><br><span class="line">color_map &#x3D;  sns.light_palette(&#39;green&#39;,as_cmap&#x3D;True)</span><br><span class="line"># .background_gradient()  表示填充subset参数里所有值的背景色（按列云识别大小填充）</span><br><span class="line">df.style.background_gradient(color_map,subset&#x3D;[&#39;语文&#39;,&#39;数学&#39;,&#39;英语&#39;])</span><br></pre></td></tr></table></figure>
<p>部分结果图:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210205132224.png" alt="20210205132224"></p>
</div>

]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>pip第三方库备份与恢复</title>
    <url>/2021/02/17/Pip%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p><code>pip list //查看当前环境中安装的库</code></p>
<h3 id="导出当前环境-pip-安装的包表"><a href="#导出当前环境-pip-安装的包表" class="headerlink" title="导出当前环境 pip 安装的包表"></a>导出当前环境 pip 安装的包表</h3><p><code>pip freeze &gt; requirements.txt</code></p>
<p>导出的路径为:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217114531.png" alt="20210217114531"></p>
</div>

<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217114951.png" alt="20210217114951"></p>
</div>

<h3 id="根据导出的-pip-安装包表安装-pip-包"><a href="#根据导出的-pip-安装包表安装-pip-包" class="headerlink" title="根据导出的 pip 安装包表安装 pip 包"></a>根据导出的 pip 安装包表安装 pip 包</h3><p><code>pip install -r requirements.txt</code></p>
<p>在进行恢复前，先修改 pip 安装源为国内源，之后进行安装时速度会快很多，键入命令后等待一会即可完成安装。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-pip配置国内镜像源</title>
    <url>/2021/02/02/Python-pip%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<h3 id="推荐的国内镜像站"><a href="#推荐的国内镜像站" class="headerlink" title="推荐的国内镜像站"></a>推荐的国内镜像站</h3><blockquote>
<p>个人推荐清华大学 pypi 镜像站 (<a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/)%EF%BC%8C%E6%AF%8F%E4%BA%94%E5%88%86%E9%92%9F%E5%90%8C%E6%AD%A5%E4%B8%80%E6%AC%A1%EF%BC%8C%E8%B5%84%E6%BA%90%E4%B8%B0%E5%AF%8C%EF%BC%8C%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%BE%88%E5%BF%AB">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/)，每五分钟同步一次，资源丰富，下载速度很快</a><br>清华大学：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p>
</blockquote>
<h3 id="临时使用国内镜像源进行-pip-安装"><a href="#临时使用国内镜像源进行-pip-安装" class="headerlink" title="临时使用国内镜像源进行 pip 安装"></a>临时使用国内镜像源进行 pip 安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; numpy</span><br><span class="line"># 如果上一个提示不受信任，就使用这个，此参数“--trusted-host”表示信任</span><br><span class="line">pip install -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;--trusted-host pypi.douban.com  </span><br></pre></td></tr></table></figure>
<h3 id="永久使用国内镜像源进行-pip-安装"><a href="#永久使用国内镜像源进行-pip-安装" class="headerlink" title="永久使用国内镜像源进行 pip 安装"></a>永久使用国内镜像源进行 pip 安装</h3><p>1.进入相应目录下 C 盘 -&gt;Users / 用户 -&gt;xxx-&gt; 新建 pip 文件夹</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210202102603.png" alt="20210202102603"></p>
</div>

<p>2.进入 pip 文件夹 -&gt; 新建 pip.ini 文件</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210202103008.png" alt="20210202103008"></p>
</div>

<p>3.进入 pip.ini 文件，并添加配置如下：（清华源）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn  # trusted-host 此参数是为了避免麻烦，否则使用的时候可能会提示不受信任</span><br></pre></td></tr></table></figure>
<p>4.修改完成后保存，启动 cmd，使用 “pip install xxx”(xxx 为你要下载的包名)，即可默认使用国内源下载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#我下载的是python的numpy函数库</span><br><span class="line">  pip install numpy</span><br><span class="line">&#x3D;&#x3D;》报错解决</span><br><span class="line">#此命令有可能报错：文件拒绝访问，需要以管理员权限运行cmd窗口</span><br><span class="line">#或者下载失败，可能是被他人挤占导致失败，可以再次输入命令重试即可</span><br></pre></td></tr></table></figure>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210202103312.png" alt="20210202103312"></p>
</div>]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的几种数据类型</title>
    <url>/2021/02/06/Python%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>大体上把 Python 中的数据类型分为如下几类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number（数字）                  包括 int,long,float,complex   </span><br><span class="line">String（字符串）                例如：hello,&quot;hello&quot;,hello   </span><br><span class="line">Bool（布尔）                    包括 True、False   </span><br></pre></td></tr></table></figure>
<p>Python 中的数据结构分为如下几类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List（列表）                    例如：[1,2,3],[1,2,3,[1,2,3],4]   </span><br><span class="line">Dictionary（字典）              例如：&#123;1:&quot;nihao&quot;,2:&quot;hello&quot;&#125;   </span><br><span class="line">Tuple（元组）                   例如：(1,2,3,abc) </span><br><span class="line">set （集合）</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>由于 Python 中认为所有的东西都是对象，所以 Python 不用像其它一些高级语言那样主动声明一个变量的类型。</p>
<p>例如我要给一个变量 i 赋值 100，python 的实现 ：</p>
<p><code>i=100</code>  </p>
<p>C# 的实现：</p>
<p><code>int i = 100;</code>  </p>
<p>下面一一简单介绍这几种数据类型</p>
<p>数字类型</p>
<p>int 和 long</p>
<p>之所以要把 int 和 long 放在一起的原因是 python3.x 之后已经不区分 int 和 long, 统一用 int。python2.x 还是区分的。下面我以 Python2.7 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;i &#x3D; 10  </span><br><span class="line">t&gt;&gt;&gt;ype(i)  </span><br><span class="line">&lt;type &#39;int&#39;&gt;  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt;i&#x3D;10000000000  </span><br><span class="line">&gt;&gt;&gt;type(i)  </span><br><span class="line">&lt;type &#39;long&#39;&gt; </span><br></pre></td></tr></table></figure>
<p>那么为什么 10 就是 int,10000000000 就是 long 呢，当然这就和 int 的最大值有关了，int 类型的最大值为 231-1，即 2147483647，也可以用 sys.maxint。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;2**31-1  </span><br><span class="line">2147483647L  </span><br><span class="line">&gt;&gt;&gt;sys.maxint  </span><br><span class="line">2147483647 </span><br></pre></td></tr></table></figure>
<p>为什么用上面的方法求的值就是 long 型的呢（数字后面加‘L’表示是 long 型），因为 2**31 的值为 2147483648, 这个值是一个 long 型，用一个 long 型减去 1，结果还是一个 long, 但实际上 int 型的最大值就是 2147483647</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;type(2147483647)  </span><br><span class="line">&lt;type &#39;int&#39;&gt;  </span><br><span class="line">&gt;&gt;&gt;type(2147483648)  </span><br><span class="line">&lt;type &#39;long&#39;&gt;  </span><br></pre></td></tr></table></figure>
<p>float 类型</p>
<p>float 类型和其它语言的 float 基本一致，浮点数，说白了，就是带小数点的数，精度与机器相关。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;i &#x3D; 10000.1212  </span><br><span class="line">&gt;&gt;&gt;type(i)  </span><br><span class="line">&lt;type &#39;float&#39;&gt;  </span><br></pre></td></tr></table></figure>
<p>complex：复数类型，具体含义及用法可自行查看相关文档。</p>
<p>字符串类型</p>
<p>字符串的声明有三种方式：单引号、双引号和三引号（包括三个单引号或三个双引号）。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;str1 &#x3D; &#39;hello world&#39;  </span><br><span class="line">&gt;&gt;&gt;str2 &#x3D; &quot;hello world&quot;  </span><br><span class="line">&gt;&gt;&gt;str3 &#x3D; &#39;&#39;&#39;hello world&#39;&#39;&#39;  </span><br><span class="line">&gt;&gt;&gt;str4 &#x3D; &quot;&quot;&quot;hello world&quot;&quot;&quot;  </span><br><span class="line">&gt;&gt;&gt;print str1  </span><br><span class="line">hello world  </span><br><span class="line">&gt;&gt;&gt;print str2  </span><br><span class="line">hello world  </span><br><span class="line">&gt;&gt;&gt;print str3  </span><br><span class="line">hello world  </span><br><span class="line">&gt;&gt;&gt;print str4  </span><br><span class="line">hello world </span><br></pre></td></tr></table></figure>
<p>Python 中的字符串有两种数据类型：str 类型和 unicode 类型。str 类型采用的 ASCII 编码，也就是说它无法表示中文。unicode 类型采用 unicode 编码，能够表示任意字符，包括中文及其它语言。并且 python 中不存在像 c 语言中的 char 类型，就算是单个字符也是字符串类型。字符串默认采用的 ASCII 编码，如果要显示声明为 unicode 类型的话，需要在字符串前面加上 ‘u’ 或者 ‘U’。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;str1 &#x3D; &quot;hello&quot;  </span><br><span class="line">&gt;&gt;&gt;print str1  </span><br><span class="line">hello  </span><br><span class="line">&gt;&gt;&gt;str2 &#x3D; u&quot;中国&quot;  </span><br><span class="line">&gt;&gt;&gt;print str2  </span><br><span class="line">中国 </span><br></pre></td></tr></table></figure>
<p>由于项目中经常出现对字符串的操作，而且由于字符串编码问题出现的问题很多，下面，来说一下关于字符串的编码问题。在与 python 打交道的过程中经常会碰到 ASCII、Unicode 和 UTF-8 三种编码。具体的介绍请参见这篇文章。我简单的理解就是，ASCII 编码适用英文字符，Unicode 适用于非英文字符（例如中文、韩文等），而 utf-8 则是一种储存和传送的格式，是对 Uncode 字符的再编码（以 8 位为单位编码）。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u &#x3D; u&#39; 汉&#39;  </span><br><span class="line">print repr(u) # u&#39;\u6c49&#39;  </span><br><span class="line">s &#x3D; u.encode(&#39;UTF-8&#39;)  </span><br><span class="line">print repr(s) # &#39;\xe6\xb1\x89&#39;  </span><br><span class="line">u2 &#x3D; s.decode(&#39;UTF-8&#39;)  </span><br><span class="line">print repr(u2) # u&#39;\u6c49&#39;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">解释：声明 unicode 字符串” 汉 “，它的 unicode 编码为”\u6c49“，经过 utf-8 编码转换后，它的编码变成”\xe6\xb1\x89“。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">对于编码的经验总结：</span><br><span class="line"></span><br><span class="line">1. 在 python 文件头声明编码格式 ；</span><br><span class="line"></span><br><span class="line">&#96;#-*- coding: utf-8 -*- &#96;</span><br><span class="line"></span><br><span class="line">2. 将字符串统一声明为 unicode 类型，即在字符串前加 u 或者 U;</span><br><span class="line"></span><br><span class="line">3. 对于文件读写的操作，建议适用 codecs.open () 代替内置的 open ()，遵循一个原则，用哪种格式写，就用哪种格式读；</span><br><span class="line"></span><br><span class="line">假设在一个以 ANSI 格式保存的文本文件中有 “中国汉字” 几个字，如果直接用以下代码，并且要在 GUI 上或者在一个 IDE 中打印出来（例如在 sublime text 中，或者在 pydev 中打印），就会出现乱码或者异常，因为 codecs 会依据文本本身的编码格式读取内容：</span><br></pre></td></tr></table></figure>
<p>f = codecs.open(“d:/test.txt”)<br>content = f.read()<br>f.close()<br>print content  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">改用如下方法即可（只对中文起作用）：</span><br></pre></td></tr></table></figure>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>import codecs  </p>
<p>f = codecs.open(“d:/test.txt”)<br>content = f.read()<br>f.close()  </p>
<p>if isinstance(content,unicode):<br>    print content.encode(‘utf-8’)<br>    print “utf-8”<br>else:<br>    print content.decode(‘gbk’).encode(‘utf-8’)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">列表类型</span><br><span class="line"></span><br><span class="line">列表是一种可修改的集合类型，其元素可以是数字、string 等基本类型，也可以是列表、元组、字典等集合对象，甚至可以是自定义的类型。其定义方式如下：</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>nums = [1,2,3,4]<br>type(nums)<br>&lt;type ‘list’&gt;<br>print nums<br>[1, 2, 3, 4]<br>strs = [“hello”,”world”]<br>print strs<br>[‘hello’, ‘world’]<br>lst = [1,”hello”,False,nums,strs]<br>type(lst)<br>&lt;type ‘list’&gt;<br>print lst<br>[1, ‘hello’, False, [1, 2, 3, 4], [‘hello’, ‘world’]]  </p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">用索引的方式访问列表元素，索引从 0 开始，支持负数索引，-1 为最后一个.</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>lst = [1,2,3,4,5]<br>print lst[0]<br>1<br>print lst[-1]<br>5<br>print lst[-2]<br>4 </p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">支持分片操作，可访问一个区间内的元素，支持不同的步长，可利用分片进行数据插入与复制操作</span><br></pre></td></tr></table></figure>
<p>nums = [1,2,3,4,5]<br>print nums[0:3]  #[1, 2, 3] # 前三个元素  </p>
<p>print nums[3:]   #[4, 5]    # 后两个元素  </p>
<p>print nums[-3:]  #[3, 4, 5] # 后三个元素 不支持 nums [-3:0]  </p>
<p>numsclone = nums[:]    </p>
<p>print numsclone    #[1, 2, 3, 4, 5]  复制操作  </p>
<p>print nums[0:4:2]   #[1, 3]    步长为 2  </p>
<p>nums[3:3] = [“three”,”four”]   #[1, 2, 3, ‘three’, ‘four’, 4, 5]  在 3 和 4 之间插入  </p>
<p>nums[3:5] = []    #[1, 2, 3, 4, 5] 将第 4 和第 5 个元素替换为 [] 即删除 [“three”,”four”] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">支持加法和乘法操作</span><br></pre></td></tr></table></figure>
<p>lst1 = [“hello”,”world”]<br>lst2 = [‘good’,’time’]<br>print lst1+lst2  #[‘hello’, ‘world’, ‘good’, ‘time’]  </p>
<p>print lst1*5  #[‘hello’, ‘world’, ‘hello’, ‘world’, ‘hello’, ‘world’, ‘hello’, ‘world’, ‘hello’, ‘world’] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">列表所支持的方法，可以用如下方式查看列表支持的公共方法：</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>[x for x in dir([]) if not x.startswith(“__”)]<br>[‘append’, ‘count’, ‘extend’, ‘index’, ‘insert’, ‘pop’, ‘remove’, ‘reverse’, ‘sort’] </p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96; </span><br><span class="line">def compare(x,y):  </span><br><span class="line">    return 1 if x&gt;y else -1  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">#【append】  在列表末尾插入元素  </span><br><span class="line">lst &#x3D; [1,2,3,4,5]  </span><br><span class="line">lst.append(6)   </span><br><span class="line">print lst     #[1, 2, 3, 4, 5, 6]  </span><br><span class="line">lst.append(&quot;hello&quot;)  </span><br><span class="line">print lst     #[1, 2, 3, 4, 5, 6]  </span><br><span class="line">  </span><br><span class="line">#【pop】  删除一个元素，并返回此元素的值 支持索引 默认为最后一个  </span><br><span class="line">x &#x3D; lst.pop()  </span><br><span class="line">print x,lst     #hello [1, 2, 3, 4, 5, 6]  # 默认删除最后一个元素  </span><br><span class="line">x &#x3D; lst.pop(0)  </span><br><span class="line">print x,lst     #1 [2, 3, 4, 5, 6]  删除第一个元素  </span><br><span class="line">  </span><br><span class="line">#【count】  返回一个元素出现的次数  </span><br><span class="line">print lst.count(2)    #1     </span><br><span class="line">  </span><br><span class="line">#【extend】  扩展列表  此方法与 “+” 操作的不同在于此方法改变原有列表，而 “+” 操作会产生一个新列表  </span><br><span class="line">lstextend &#x3D; [&quot;hello&quot;,&quot;world&quot;]  </span><br><span class="line">lst.extend(lstextend)  </span><br><span class="line">print lst           #[2, 3, 4, 5, 6, &#39;hello&#39;, &#39;world&#39;]  在 lst 的基础上扩展了 lstextend 进来   </span><br><span class="line">  </span><br><span class="line">#【index】  返回某个值第一次出现的索引位置，如果未找到会抛出异常  </span><br><span class="line">print lst.index(&quot;hello&quot;)  #5      </span><br><span class="line">  </span><br><span class="line">#print lst.index (&quot;kitty&quot;) #ValueError: &#39;kitty&#39; is not in list  出现异常  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">#【remove】 移除列表中的某个元素，如果待移除的项不存在，会抛出异常  无返回值  </span><br><span class="line">lst.remove(&quot;hello&quot;)  </span><br><span class="line">print lst     #[2, 3, 4, 5, 6, &#39;world&#39;]  &quot;hello&quot; 被移除  </span><br><span class="line">  </span><br><span class="line">#lst.remove(&quot;kitty&quot;)         #ValueError: list.remove(x): x not in list  </span><br><span class="line">  </span><br><span class="line">#【reverse】  意为反转 没错 就是将列表元素倒序排列，无返回值  </span><br><span class="line">print lst        #[2, 3, 4, 5, 6, &#39;world&#39;]  </span><br><span class="line">lst.reverse()   </span><br><span class="line">print lst        #[2, 3, 4, 5, 6, &#39;world&#39;]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">#【sort】 排序  </span><br><span class="line">print lst    #由于上面的反转 目前排序为 [&#39;world&#39;, 6, 5, 4, 3, 2]  </span><br><span class="line">lst.sort()    </span><br><span class="line">print lst    #排序后  [2, 3, 4, 5, 6, &#39;world&#39;]  </span><br><span class="line">  </span><br><span class="line">nums &#x3D; [10,5,4,2,3]  </span><br><span class="line">print nums     #[10,5,4,2,3]  </span><br><span class="line">nums.sort(compare)  </span><br><span class="line">print nums     #[2, 3, 4, 5, 10]  </span><br></pre></td></tr></table></figure>
<p>列表转换为迭代器。</p>
<p>所谓的迭代器就是具有 next 方法（这个方法在调用时不需要任何参数）的对象。在调用 next 方法时，迭代器会返回它的下一个值。如果 next 方法被调用，但迭代器没有值可以返回，就会引发一个 StopIteration 异常。迭代器相对于列表的优势在于，使用迭代器不必一次性将列表加入内存，而可以依次访问列表的数据。</p>
<p>依然用上面的方法查看迭代器的公共方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; [1,2,3,4,5]  </span><br><span class="line">lstiter &#x3D; iter(lst)  </span><br><span class="line">&gt;&gt;&gt;print [x for x in dir(numiter) if not x.startswith(&quot;__&quot;)]  </span><br><span class="line">&#39;next&#39;]  </span><br></pre></td></tr></table></figure>
<p>没错，只有 next 一个方法，对于一个迭代器，可以这样操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; [1,2,3,4,5]  </span><br><span class="line">lstiter &#x3D; iter(lst)  </span><br><span class="line">  </span><br><span class="line">for i in range(len(lst)):  </span><br><span class="line">    print lstiter.next()  #依次打印  </span><br><span class="line">    1  </span><br><span class="line">    2  </span><br><span class="line">    3  </span><br><span class="line">    4  </span><br><span class="line">    5 </span><br></pre></td></tr></table></figure>
<p>元组类型</p>
<p>元组类型和列表一样，也是一种序列，与列表不同的是，元组是不可修改的。元组的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; (0,1,2,2,2)  </span><br><span class="line">lst1&#x3D;(&quot;hello&quot;,)  </span><br><span class="line">lst2 &#x3D; (&quot;hello&quot;)  </span><br><span class="line">print type(lst1)    #&lt;type &#39;tuple&#39;&gt;  只有一个元素的情况下后面要加逗号 否则就是 str 类型  </span><br><span class="line">print type(lst2)    #&lt;type &#39;str&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>字典类型</p>
<p>字典类型是一种键值对的集合，类似于 C# 中的 Dictionary&lt;object,object&gt; 或 js 中的 json 对象。其初始化方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 &#x3D; &#123;&#125;  </span><br><span class="line">print type(dict1)      #&lt;type &#39;dict&#39;&gt;  声明一个空字典  </span><br><span class="line">  </span><br><span class="line">dict2 &#x3D; &#123;&quot;name&quot;:&quot;kitty&quot;,&quot;age&quot;:18&#125;   #直接声明字典类型  </span><br><span class="line">  </span><br><span class="line">dict3 &#x3D; dict([(&quot;name&quot;,&quot;kitty&quot;),(&quot;age&quot;,18)])  #利用 dict 函数将列表转换成字典  </span><br><span class="line">  </span><br><span class="line">dict4 &#x3D; dict(name&#x3D;&#39;kitty&#39;,age&#x3D;18)           #利用 dict 函数通过关键字参数转换为字典  </span><br><span class="line">  </span><br><span class="line">dict5 &#x3D; &#123;&#125;.fromkeys([&quot;name&quot;,&quot;age&quot;])      #利用 fromkeys 函数将 key 值列表生成字典，对应的值为 None   &#123;&#39;age&#39;: None, &#39;name&#39;: None&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字典基本的操作方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#【添加元素】    </span><br><span class="line">dict1 &#x3D; &#123;&#125;  </span><br><span class="line">dict1[&quot;mykey&quot;] &#x3D; &quot;hello world&quot;     #直接给一个不存在的键值对赋值 即时添加新元素  </span><br><span class="line">  </span><br><span class="line">dict1[(&#39;my&#39;,&#39;key&#39;)] &#x3D; &quot;this key is a tuple&quot;   #字典的键可以是任何一中不可变类型，例如数字、字符串、元组等  </span><br><span class="line">  </span><br><span class="line">#【键值对个数】  </span><br><span class="line">print len(dict1)  </span><br><span class="line">  </span><br><span class="line">#【检查是否含有键】  </span><br><span class="line">print &quot;mykey&quot; in dict1         #True  检查是否含有键为 mykey 的键值对  </span><br><span class="line">print &quot;hello&quot; in dict1         #False  </span><br><span class="line">  </span><br><span class="line">#【删除】  </span><br><span class="line">del dict1[&quot;mykey&quot;]           #删除键为 mykey 的键值对  </span><br></pre></td></tr></table></figure>
<p>继续利用上面的方法查看字典的所有公共方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[x for x in dir(&#123;&#125;) if not x.startswith(&quot;__&quot;)]  </span><br><span class="line">[&#39;clear&#39;, &#39;copy&#39;, &#39;fromkeys&#39;, &#39;get&#39;, &#39;has_key&#39;, &#39;items&#39;, &#39;iteritems&#39;, &#39;iterkeys&#39;, &#39;itervalues&#39;,  </span><br><span class="line"> &#39;keys&#39;, &#39;pop&#39;, &#39;popitem&#39;, &#39;setdefault&#39;, &#39;update&#39;, &#39;values&#39;, &#39;viewitems&#39;, &#39;viewkeys&#39;, &#39;viewvalues&#39;] </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict.clear ()                          删除字典中所有元素  </span><br><span class="line">  </span><br><span class="line">dict.copy ()                          返回字典 (浅复制) 的一个副本  </span><br><span class="line">  </span><br><span class="line">dict.get(key,default&#x3D;None)     对字典 dict 中的键 key, 返回它对应的值 value，如果字典中不存在此键，则返回 default 的值 (注意，参数 default 的默认值为 None)  </span><br><span class="line">  </span><br><span class="line">dict.has_key (key)                 如果键 (key) 在字典中存在，返回 True，否则返回 False. 在 Python2.2 版本引入 in 和 not in 后，此方法几乎已废弃不用了，但仍提供一个 可工作的接口。  </span><br><span class="line">  </span><br><span class="line">dict.items ()                         返回一个包含字典中 (键， 值) 对元组的列表  </span><br><span class="line">  </span><br><span class="line">dict.keys ()                          返回一个包含字典中键的列表  </span><br><span class="line">  </span><br><span class="line">dict.values ()                        返回一个包含字典中所有值的列表  </span><br><span class="line">  </span><br><span class="line">dict.iter ()                            方法 iteritems (), iterkeys (), itervalues () 与它们对应的非迭代方法一样，不同的是它们返回一个迭代器，而不是一个列表。  </span><br><span class="line">  </span><br><span class="line">dict.pop (key [, default])         和方法 get () 相似，如果字典中 key 键存在，删除并返回 dict [key]，如果 key 键不存在，且没有给出 default 的值，引发 KeyError 异常。  </span><br><span class="line">  </span><br><span class="line">dict.setdefault(key,default&#x3D;None)  和方法 set () 相似，如果字典中不存在 key 键，由 dict [key]&#x3D;default 为它赋值。  </span><br><span class="line">  </span><br><span class="line">dict.setdefault(key,default&#x3D;None)   和方法 set () 相似，如果字典中不存在 key 键，由 dict [key]&#x3D;default 为它赋值。 </span><br></pre></td></tr></table></figure>
<p>布尔类型</p>
<p>布尔类型即 True 和 False, 和其它语言中的布尔类型基本一致。下面列出典型的布尔值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print bool(0)   #False  </span><br><span class="line">print bool(1)   #True  </span><br><span class="line">print bool(-1)  #True  </span><br><span class="line">  </span><br><span class="line">print bool([])  #False  </span><br><span class="line">print bool(())  #False  </span><br><span class="line">print bool(&#123;&#125;)  #False  </span><br><span class="line">print bool(&#39;&#39;)  #False  </span><br><span class="line">print bool(None) #False  </span><br></pre></td></tr></table></figure>
<h2 id="python-四种数值类型-int-long-float-complex-介绍"><a href="#python-四种数值类型-int-long-float-complex-介绍" class="headerlink" title="python 四种数值类型 (int,long,float,complex) 介绍"></a>python 四种数值类型 (int,long,float,complex) 介绍</h2><p>Python 支持四种不同的数值类型，包括 int（整数）long（长整数）float（浮点实际值）complex （复数）</p>
<p>数字数据类型存储数值。他们是不可改变的数据类型，这意味着改变数字数据类型的结果，在一个新分配的对象的值。</p>
<p>Number 对象被创建，当你给他们指派一个值。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var1 &#x3D; 1</span><br><span class="line">var2 &#x3D; 10</span><br></pre></td></tr></table></figure>
<p>您也可以删除数字对象的参考，使用 del 语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del 语句的语法是：</span><br><span class="line"></span><br><span class="line">del var1[,var2[,var3[....,varN]]]]</span><br></pre></td></tr></table></figure>
<p>你可以使用 del 语句删除单个对象或多个对象。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure>
<h4 id="Python-支持四种不同的数值类型："><a href="#Python-支持四种不同的数值类型：" class="headerlink" title="Python 支持四种不同的数值类型："></a>Python 支持四种不同的数值类型：</h4><ul>
<li><strong>int</strong>（符号整数）：通常被称为是整数或整数，没有小数点的正或负整数。</li>
<li><strong>long</strong>（长整数）：或渴望，无限大小的整数，这样写整数和一个大写或小写的 L。</li>
<li><strong>float</strong>（浮点实际值）：彩车，代表实数，小数除以整数部分和小数部分的书面。花车也可能是在科学记数法与 E 或指示的 10 次方 é（2.5e2= 2.5×102=250）。</li>
<li><strong>complex</strong>  （复数）：+ BJ 的形式，其中 a，b 是彩车和 J（或 J）表示 - 1 的平方根（这是一个虚数）。 a 是真正的数字部分，b 是虚部。复数不使用 Python 编程。</li>
</ul>
<p>下面是一些数字的例子：</p>
<table>
<thead>
<tr>
<th align="center">int</th>
<th align="center">long</th>
<th align="center">float</th>
<th align="center">complex</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">51924361L</td>
<td align="center">0.0</td>
<td align="center">3.14j</td>
</tr>
<tr>
<td align="center">100</td>
<td align="center">-0x19323L</td>
<td align="center">15.20</td>
<td align="center">45.j</td>
</tr>
<tr>
<td align="center">-786</td>
<td align="center">0122L</td>
<td align="center">-21.9</td>
<td align="center">9.322e-36j</td>
</tr>
<tr>
<td align="center">080</td>
<td align="center">0xDEFABCECBDAECBFBAEl</td>
<td align="center">32.3+e18</td>
<td align="center">.876j</td>
</tr>
<tr>
<td align="center">-0490</td>
<td align="center">535633629843L</td>
<td align="center">-90.</td>
<td align="center">-.6545+0J</td>
</tr>
<tr>
<td align="center">-0x260</td>
<td align="center">-052318172735L</td>
<td align="center">-32.54e100</td>
<td align="center">3e+26J</td>
</tr>
<tr>
<td align="center">0x69</td>
<td align="center">-4721885298529L</td>
<td align="center">70.2-E12</td>
<td align="center">4.53e-7j</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>Python 允许你使用长 L 的小写，但建议您只使用一个大写字母 L，以避免与数字 1 混淆。python 长整数显示一个大写字母 L。</li>
<li>一个复杂的数字组成的有序对一个真正的浮点数字 + BJ，其中 a 是实部和 b 是复数的虚部表示。</li>
</ul>
<h3 id="数字类型转换："><a href="#数字类型转换：" class="headerlink" title="数字类型转换："></a><strong>数字类型转换：</strong></h3><ul>
<li><p>Python 的数字转换内部包含一个共同的评价类型的混合型的表达。但有时，你需要明确强迫一个数字从一个类型到另一个运算符或函数的参数，以满足要求。</p>
</li>
<li><p><strong>int</strong> 类型（X）转换 X 到一个普通整数。</p>
</li>
<li><p><strong>long</strong>（X）转换 X 到一个长整数。</p>
</li>
<li><p><strong>float</strong> 类型（X）转换 X 到浮点数字。</p>
</li>
<li><p><strong>complex</strong> （x）的转换与真正的第 X 部和虚部为零的 x 到一个复杂的数量。 类型复杂（X，Y）转换 x 和 y 的第 X 部和虚部Ÿ复数。 x 和 y 是数值表达式 内置数功能：</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的数据结构</title>
    <url>/2021/02/06/Python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student_list &#x3D; [</span><br><span class="line">    &#123;&#39;name&#39;: &#39;zs&#39;, &#39;age&#39;: 12&#125;,</span><br><span class="line">    &#123;&#39;name&#39;: &#39;ls&#39;, &#39;age&#39;: 23&#125;</span><br><span class="line">]</span><br><span class="line">student_dic &#x3D; &#123;</span><br><span class="line">    &#123;&#39;zs&#39;&#125;:&#123;&#39;sx&#39;,23&#125;,</span><br><span class="line">    &#123;&#39;ls&#39;&#125;:&#123;&#39;ls&#39;,24&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数据结构也就是存储数据的结构，我们对数据组织的方式就叫做数据结构。</p>
</li>
<li><p>比如上面保存学生信息的方式，是以列表的方式组织还是使用字典的方式组织。</p>
</li>
<li><p>数据结构解决的就是一组数据如何保存，保存形式是怎么样的。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="Python-的数据结构"><a href="#Python-的数据结构" class="headerlink" title="Python 的数据结构"></a>Python 的数据结构</h2><h3 id="一、认识-Python-数据结构"><a href="#一、认识-Python-数据结构" class="headerlink" title="一、认识 Python 数据结构"></a>一、认识 Python 数据结构</h3><p>&emsp;&emsp;Python 有 4 个内建的数据结构，它们可以统称为容器（container），因为它们实际上是一些 “东西” 组合而成的结构，而这些 “东西”，可以是数字、字符甚至列表，或是它们的组合。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206162226.png" alt="20210206162226"></p>
</div>

<p>&emsp;&emsp;Python 中的绝大部分数据结构可以被最终分解为三种类型：集合（Set），序列（Sequence），映射（Mapping）。这表明了数据存储时所需的基本单位，其重要性如同欧式几何公理之于欧式空间。</p>
<p>1、集合是独立于标量，序列和映射之外的特殊数据结构，它支持数学理论的各种集合的运算。它的存在使得用程序代码实现数学理论变得方便。</p>
<p>2、序列是 Python 中最为基础的内建类型。它分为七种类型：列表、字符串、元组、Unicode 字符串、字节数组、缓冲区和 xrange 对象。常用的是：列表（List）、字符串（String）、元组（Tuple）。</p>
<p>3、映射在 Python 的实现是数据结构字典（Dictionary）。作为第三种基本单位，映射的灵活使得它在多种场合中都有广泛的应用和良好的可拓展性。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206162317.png" alt="20210206162317"></p>
</div>

<h3 id="二、Python-数据结构之列表"><a href="#二、Python-数据结构之列表" class="headerlink" title="二、Python 数据结构之列表"></a>二、Python 数据结构之列表</h3><h4 id="1、列表的基本操作"><a href="#1、列表的基本操作" class="headerlink" title="1、列表的基本操作"></a>1、列表的基本操作</h4><ul>
<li>all_list = [1,‘word’,{‘like’:‘pythom’},True,[1,2]]</li>
<li>all_list =list((1,‘word’,{‘like’:‘pythom’},True,[1,2]))</li>
<li>长度：len (all_list)</li>
<li>计数：all_list.count (‘word’)</li>
<li>下标：all_list.index (‘word’)</li>
<li>反转：all_list [::-1] 或者 all_list.reverse ()</li>
<li>合并：list1+list2</li>
<li>重复：all_list * 3</li>
<li>判断元素是否存在：‘word’ in all_list</li>
<li>切片与索引：all_list [0]</li>
<li>all_list[-4]</li>
<li>all_list[1:4]</li>
<li>all_list[:3]<ul>
<li>①、列表中每个元素都是可变的；</li>
<li>②、列表中的元素是有序的，每个元素对应一个位置；</li>
<li>③、列表可以容纳 Python 中的任何对象。<h4 id="2、列表的增删改查"><a href="#2、列表的增删改查" class="headerlink" title="2、列表的增删改查"></a>2、列表的增删改查</h4></li>
</ul>
</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163047.png" alt="20210206163047"></p>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163117.png" alt="20210206163117"></p>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163127.png" alt="20210206163127"></p>
</div>

<p>fruit = [1,‘word’,True,‘pear’]</p>
<p>month=[‘January’,‘February’,‘March’,‘April’]</p>
<p>增添</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruit.append(‘July’)</span><br><span class="line">fruit.extend(month)</span><br><span class="line">fruit.insert(1,‘grap’)</span><br><span class="line">fruit.insert(-1,‘apple’)</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruit.remove(‘grape’)</span><br><span class="line">fruit.remove(fruit[0])</span><br><span class="line">fruit.pop(2)</span><br><span class="line">del fruit[0:2]</span><br><span class="line">fruit.clear () # 清空</span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruit[0] &#x3D; (‘orange’)</span><br><span class="line">fruit2 &#x3D; fruit.copy()</span><br></pre></td></tr></table></figure>
<p>查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruit.index(‘pear’)</span><br><span class="line">fruit[3]</span><br></pre></td></tr></table></figure>
<h4 id="3、列表内建函数"><a href="#3、列表内建函数" class="headerlink" title="3、列表内建函数"></a>3、列表内建函数</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163350.png" alt="20210206163350"></p>
</div>

<h3 id="三、Python-数据结构之元组"><a href="#三、Python-数据结构之元组" class="headerlink" title="三、Python 数据结构之元组"></a>三、Python 数据结构之元组</h3><h4 id="1、元组的概念"><a href="#1、元组的概念" class="headerlink" title="1、元组的概念"></a>1、元组的概念</h4><p>&emsp;&emsp;元组与列表和字符串一样，是序列的一种。而元组与列表的唯一不同的元组不能修改，元组和字符串都具有不可变性。列表的可变性可能更方便处理复杂问题，例如更新动态数据等，但很多时候不希望某些处理过程修改对象内容，例如敏感数据，这就需要元组的不可变性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tup &#x3D; (‘Google’, ‘Runoob’, 1997, 2000)</span><br><span class="line">tup1 &#x3D; (50,) # 元组中只包含一个元素时，要在元素后面添加逗号</span><br></pre></td></tr></table></figure>
<ul>
<li>长度：len (tup)</li>
<li>计数：tup.count (‘Google’)</li>
<li>下标：tup.index (‘Google’)</li>
<li>反转：tup [::-1]</li>
<li>合并：tup1+tup2</li>
<li>重复：tup * 3</li>
<li>判断元素是否存在：‘Google’ in tup</li>
<li>切片与索引：tup [0]</li>
<li>tup[1:4]</li>
<li>tup[:3]</li>
<li>元组解包：A,B,C,D=tup # 将元组中各元素分别赋值给对应变量</li>
</ul>
<h4 id="2、元组内建函数"><a href="#2、元组内建函数" class="headerlink" title="2、元组内建函数"></a>2、元组内建函数</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163628.png" alt="20210206163628"></p>
</div>

<h2 id="四、Python-数据结构之字典"><a href="#四、Python-数据结构之字典" class="headerlink" title="四、Python 数据结构之字典"></a>四、Python 数据结构之字典</h2><h4 id="1、字典的概念"><a href="#1、字典的概念" class="headerlink" title="1、字典的概念"></a>1、字典的概念</h4><p>字典（Dictionary）是基础数据结构映射 (Mapping) 的一种。序列是按照顺序来存储数据的，而字典是通过键存储数据。字典的内部实现是基于二叉树 (Binary Tree) 的，数据没有严格的顺序。字典将键映射到值，通过键来调取数据。如果键值本来是有序的，那么我们不应该使用字典，如映射：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206163743.png" alt="20210206163743"></p>
</div>

<p>直接用列表 [‘A’,’B’,’C’] 即可，字典的效率比列表差得多。但是在很多情形下，字典比列表更加适用。比如我们手机的通讯录（假设人名均不相同）可以使用字典实现，把人的名字映射到一个电话号码，由于名字是无序的，不能直接用一个列表实现，使用字典直接高效。</p>
<h4 id="2、字典的增删改查"><a href="#2、字典的增删改查" class="headerlink" title="2、字典的增删改查"></a>2、字典的增删改查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code &#x3D; &#123;‘BIDU’:‘Baidu’,‘SINA’:‘Sina’,‘YOKU’:‘Youku’&#125;</span><br><span class="line">code &#x3D; dict([(‘BIDU’,‘Baidu’),(‘SINA’,‘Sina’),(‘YOKU’,‘Youku’)])</span><br></pre></td></tr></table></figure>
<p>插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code[‘QQ’] &#x3D; ‘tengxun’</span><br><span class="line">code.update(&#123;‘FB’:‘Facebook’,‘TSLA’:‘Tesla’&#125;)</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del code[‘FB’]</span><br><span class="line">code_QQ &#x3D; code.pop(‘QQ’)</span><br><span class="line">code.clear () # 清空</span><br></pre></td></tr></table></figure>
<p>修改（赋值）</p>
<p><code>code[‘YOJKU’] = ‘Yoku’</code></p>
<p>查找</p>
<p><code>code[‘FB’]</code></p>
<h4 id="3、映射在-Python-的实现是数据结构字典"><a href="#3、映射在-Python-的实现是数据结构字典" class="headerlink" title="3、映射在 Python 的实现是数据结构字典"></a>3、映射在 Python 的实现是数据结构字典</h4><ul>
<li>①、键－值成对出现；</li>
<li>②、键不能重复；</li>
<li>③、键不可更改，值可修改；</li>
<li>④、键来索引值。<h4 id="4、字典的常用操作"><a href="#4、字典的常用操作" class="headerlink" title="4、字典的常用操作"></a>4、字典的常用操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code &#x3D; &#123;‘BIDU’:‘Baidu’, ‘SINA’:‘Sina’,‘YOKU’:‘Youku’&#125;</span><br><span class="line">len () 测量字典中，键值对的个数</span><br><span class="line">len(code)</span><br><span class="line">keys 返回一个包含字典所有 KEY 的列表</span><br><span class="line">code.keys()</span><br><span class="line">values 返回一个包含字典所有 value 的列表</span><br><span class="line">code.values()</span><br><span class="line">items 返回一个包含所有（键，值）元祖的列表</span><br><span class="line">code.items()</span><br><span class="line">has_key</span><br><span class="line">code.has_key (key) 如果 key 在字典中，返回 True，否则返回 False。</span><br></pre></td></tr></table></figure>
<h3 id="五、Python-数据结构之集合"><a href="#五、Python-数据结构之集合" class="headerlink" title="五、Python 数据结构之集合"></a>五、Python 数据结构之集合</h3></li>
</ul>
<h4 id="1、集合的概念"><a href="#1、集合的概念" class="headerlink" title="1、集合的概念"></a>1、集合的概念</h4><p>Python 有一种特殊的数据类型称为集合。因为它既不是序列也不是映射类型，更不是标量。集合是自成一体的类型。集合是唯一的，不可变的对象是一个无序集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set1 &#x3D; set([2,3,1,4,False,2.5,‘one’])</span><br><span class="line">set2 &#x3D; &#123;‘A’,‘C’,‘D’,‘B’,‘A’,‘B’&#125; # 创建可变集合</span><br><span class="line"></span><br><span class="line">set3 &#x3D; frozenset ([3,2,3,‘one’,frozenset ([1,2]),True]) # 创建不可变集合</span><br></pre></td></tr></table></figure>
<p>集合能够通过表达式操作符支持一般的数学集合运算。这是集合特有的操作，序列和映射不支持这样的表达式。</p>
<h4 id="2、集合的并集"><a href="#2、集合的并集" class="headerlink" title="2、集合的并集"></a>2、集合的并集</h4><p>由属于集合 A 或集合 B 的所有元素组成的集合，称为集合 A 和 B 的并集，数学表达式为 A∪B={x|x∈A 或 x∈B}。在 Python 中可以使用符号 “|” 或者集合方法 union 函数来得出两个集合的并集。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206164047.png" alt="20210206164047"></p>
</div>

<p>A={‘足球’,‘游泳’,‘羽毛球’,‘乒乓球’}</p>
<p>B={‘篮球’,‘乒乓球’,‘羽毛球’,‘排球’}</p>
<p>A|B # 使用符号’|’获取并集</p>
<p>A.union (B) # 使用集合方法 union 函数获取并集</p>
<h4 id="3-集合的交集"><a href="#3-集合的交集" class="headerlink" title="3. 集合的交集"></a>3. 集合的交集</h4><p>同时属于集合 A 和 B 的元素组成的集合，称为集合 A 和 B 的交集，数学表达式为 A∩B={x|x∈A 且 x∈B}。可以利用符号 “&amp;” 或者集合方法 intersection 函数来获取两个集合对象的交集。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206164305.png" alt="20210206164305"></p>
</div>

<p>A={‘足球’,‘游泳’,‘羽毛球’,‘乒乓球’}</p>
<p>B={‘篮球’,‘乒乓球’,‘羽毛球’,‘排球’}</p>
<p>A&amp;B # 使用符号’&amp;’获取交集</p>
<p>A.intersection (B) # 使用集合方法 intersection 函数获取交集</p>
<h4 id="4、集合的差集"><a href="#4、集合的差集" class="headerlink" title="4、集合的差集"></a>4、集合的差集</h4><p>属于集合 A 而不属于集合 B 中的元素所构成的集合，称为集合 A 减集合 B，数学表达式为 A-B={x|x∈A,x∉B}。这个集合也称为集合 A 与集合 B 的差集。反过来，也有差集 B-A={x|x∈B,x∉A}。在 Python 中可以简单地使用减号 “－” 来得到相应的差集，或者可以通过集合方法 difference 函数来实现。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206164412.png" alt="20210206164412"></p>
</div>

<p>A={‘足球’,‘游泳’,‘羽毛球’,‘乒乓球’}</p>
<p>B={‘篮球’,‘乒乓球’,‘羽毛球’,‘排球’}</p>
<p>A-B # 使用减号 “－” 来获取差集</p>
<p>A.difference (B) # 使用集合方法 difference 函数获取差集</p>
<h4 id="5、集合的异或集"><a href="#5、集合的异或集" class="headerlink" title="5、集合的异或集"></a>5、集合的异或集</h4><p>属于集合 A 或集合 B，但不同时属于集合 A 和 B 的元素所组成的集合，称为集合 A 和 B 的异或集，其相当 (A∪B)-(A∩B)。利用符号 “^” 或者集合方法 symmetric_difference 函数即可求出两个集合对象的异或集。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206164453.png" alt="20210206164453"></p>
</div>

<p>A={‘足球’,‘游泳’,‘羽毛球’,‘乒乓球’}</p>
<p>B={‘篮球’,‘乒乓球’,‘羽毛球’,‘排球’}</p>
<p>A^B # 获取异或集</p>
<p>A.symmetric_difference (B) # 使用集合方法 symmetric_difference 函数获取异或集</p>
<h4 id="6、集合内建函数"><a href="#6、集合内建函数" class="headerlink" title="6、集合内建函数"></a>6、集合内建函数</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206164538.png" alt="20210206164538"></p>
</div>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数应用实例2</title>
    <url>/2021/02/28/Python%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B2/</url>
    <content><![CDATA[<h2 id="函数传值为-list-的坑"><a href="#函数传值为-list-的坑" class="headerlink" title="函数传值为 list 的坑"></a>函数传值为 list 的坑</h2><p>函数传入 list 参数时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f(x,li&#x3D;[]):</span><br><span class="line">    for i in range(x):</span><br><span class="line">        li.append(i*i)</span><br><span class="line">    print(li)</span><br><span class="line">期望结果：</span><br><span class="line">f(4)</span><br><span class="line">#运算结果:[0, 1, 4, 9]</span><br><span class="line">f(5)</span><br><span class="line">#运算结果:[0, 1, 4, 9, 16]</span><br><span class="line">print（‘--------------------------------------’）</span><br><span class="line">#运算结果</span><br><span class="line">f(4)</span><br><span class="line">#运算结果:[0, 1, 4, 9]</span><br><span class="line">f(5)</span><br><span class="line">#运算结果:[0, 1, 4, 9, 0, 1, 4, 9, 16]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当定义函数时，会保存函数中默认参数 list 的值，也就是列表 li=[]；<br>在每次调用的时候如果传递了新的列表，则使用传递的列表，没有传递，使用定义函数时保存的默认参数（li=[]）；<br>上面两次调用中，都没有传递新的列表（使用默认列表 li=[] ），程序会调用定义函数时保存的默认参数 (（li=[]）);<br>列表在 append 的时候会在 li=[] 原来的基础上 append 追加值，所以会产生以上结果.</p>
</blockquote>
<p>通过打印列表的 ID 进行辨识</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f(x,li&#x3D;[]):</span><br><span class="line">    print(&#39;id:&#39;,id(li))</span><br><span class="line">    for i in range(x):</span><br><span class="line">        li.append(i*i)</span><br><span class="line">    print(li)</span><br><span class="line"></span><br><span class="line">f(4)</span><br><span class="line">#id: 2154086435336</span><br><span class="line">#结果:[0, 1, 4, 9]</span><br><span class="line">f(5)</span><br><span class="line">#id: 2154086435336</span><br><span class="line">#结果:[0, 1, 4, 9, 0, 1, 4, 9, 16]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会发现 ID 值是相同的；<br>说明两次执行时使用的都是定义函数时的默认参数 li=[ ]</p>
</blockquote>
<p>执行时往里面传新的列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f(x,li&#x3D;[]):</span><br><span class="line">    for i in range(x):</span><br><span class="line">        li.append(i*i)</span><br><span class="line">    print(li)</span><br><span class="line">f(4)</span><br><span class="line">#结果:[0, 1, 4, 9]</span><br><span class="line">f(5,[])</span><br><span class="line">#结果:[0, 1, 4, 9, 16]</span><br><span class="line">f(6)</span><br><span class="line">#结果:[0, 1, 4, 9, 0, 1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当传递空列表时，函数体当中会使用传递的空列表，没有传递时，使用函数默认值 li=[ ], 所以会产生以上结果。</p>
</blockquote>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>如果想要达到预期的结果，只需要在函数体里进行判断即可:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f(x, li&#x3D;[]):</span><br><span class="line">    if not li:</span><br><span class="line">        # 如果li不为空的话,就往下走(清空列表); 为空就不走</span><br><span class="line">        li &#x3D; []</span><br><span class="line">    for i in range(x):</span><br><span class="line">        li.append(i * i)</span><br><span class="line">    print(li)</span><br><span class="line">f(4)</span><br><span class="line">#结果:[0, 1, 4, 9]</span><br><span class="line">f(5)</span><br><span class="line">#结果:[0, 1, 4, 9,16]</span><br><span class="line">f(6)</span><br><span class="line">#结果:[0, 1, 4, 9,16,25]</span><br></pre></td></tr></table></figure>
<h2 id="向函数传递列表"><a href="#向函数传递列表" class="headerlink" title="向函数传递列表"></a>向函数传递列表</h2><p><a href="https://www.cnblogs.com/OliverQin/p/7801600.html">转载</a></p>
<p>在实际使用中你会发现，向函数传递列表是比较实用的，这种列表可能包含名字、数字、可能更复杂的对象 (字典)</p>
<p>假设向一个函数传递一堆水果，我们说出我们喜欢所有的水果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Obj(fruits):</span><br><span class="line">    for fruit in fruits:</span><br><span class="line">        msg &#x3D; &#39;I like &#39;+fruit+&#39;!&#39;</span><br><span class="line">        print(msg)</span><br><span class="line"></span><br><span class="line">L &#x3D; [&#39;apple&#39;,&#39;orange&#39;]</span><br><span class="line">Obj(L)</span><br></pre></td></tr></table></figure>
<p>我们将 Obj 定义成接受一个水果种类列表，并将其存储在形参 Obj 中，这个函数遍历接受到的列表，然后打印 ‘I like ..!’</p>
<h2 id="在函数中修改列表"><a href="#在函数中修改列表" class="headerlink" title="在函数中修改列表"></a>在函数中修改列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#首先定义一个列表，其中包含要打印的字母</span><br><span class="line">letters &#x3D; [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]</span><br><span class="line">already_letter &#x3D; []</span><br><span class="line"></span><br><span class="line">#模拟阅读每个字母，直到字母读取完毕为止</span><br><span class="line">#将每个已经阅读过的字母转移到列表already_letter中</span><br><span class="line">while letters:</span><br><span class="line">    current_letter &#x3D; letters.pop()</span><br><span class="line">    print(&quot;Printing letter:&quot;+current_letter)</span><br><span class="line">    already_letter.append(current_letter)</span><br><span class="line"></span><br><span class="line">#显示已经读取的所有字母</span><br><span class="line">print(&quot;\nThe follwing letter has been read:&quot;)</span><br><span class="line">for letter in already_letter:</span><br><span class="line">    print(letter)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们首先需要创建一个列表，还创建一个名为 already_letter 的空列表，每个已经阅读过的字母都存储到这个列表中，只要列表中还有字母，while 循环就模拟阅读过程：从该列表中删除一个已经读取的字母，然后将其存储到变量 current_letter 中，并显示一条消息，再将该字母存储到新列表中，等到循环结束后，再打印出所有的字母。</p>
<h2 id="上述程序改编版"><a href="#上述程序改编版" class="headerlink" title="上述程序改编版"></a>上述程序改编版</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def read_letter(letters,already_letter):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    读取每个字母，直到读取完毕为止</span><br><span class="line">    将读取完毕后的字母存储到新的列表中</span><br><span class="line">    :param letters:</span><br><span class="line">    :param already_letter:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    while letters:</span><br><span class="line">        current_letter &#x3D; letters.pop()</span><br><span class="line"></span><br><span class="line">        #模拟读取字母的过程</span><br><span class="line">        print(&quot;Printing letter:&quot; + current_letter)</span><br><span class="line">        already_letter.append(current_letter)</span><br><span class="line">def show_already_letter(already_letter):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    显示已经阅读的所有字母</span><br><span class="line">    :param already_letter:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&quot;\nThe follwing letters has been read:&quot;)</span><br><span class="line">    for letter in already_letter:</span><br><span class="line">        print(letter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">letters &#x3D; [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]</span><br><span class="line">already_letter&#x3D;[]</span><br><span class="line"></span><br><span class="line">read_letter(letters,already_letter)</span><br><span class="line">show_already_letter(already_letter)</span><br></pre></td></tr></table></figure>
<p>我们定义了函数 read_letter (), 它包含 2 个形参：一个需要阅读字母的列表和一个存储已经阅读字母的列表。给定这两个列表，这个函数模拟阅读过程：将字母一个个阅读，然后打印，最后将其转存到存储已阅读的列表中，函数 show_already_letter () 主要是打印已经阅读字母列表，最后四条语句是定义一个列表与一个空列表，调用上面的两个函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的函数中，在读取完毕之后，letters 列表就编程空列表了，那么假如我们想在读取完列表后还保留该列表，该怎么办呢？</p>
<p>使用切片法 [:] 创建列表的副本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def read_letter(letters,already_letter):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    读取每个字母，直到读取完毕为止</span><br><span class="line">    将读取完毕后的字母存储到新的列表中</span><br><span class="line">    :param letters:</span><br><span class="line">    :param already_letter:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    while letters:</span><br><span class="line">        current_letter &#x3D; letters.pop()</span><br><span class="line"></span><br><span class="line">        #模拟读取字母的过程</span><br><span class="line">        print(&quot;Printing letter:&quot; + current_letter)</span><br><span class="line">        already_letter.append(current_letter)</span><br><span class="line">def show_already_letter(already_letter):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    显示已经阅读的所有字母</span><br><span class="line">    :param already_letter:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&quot;\nThe follwing letters has been read:&quot;)</span><br><span class="line">    for letter in already_letter:</span><br><span class="line">        print(letter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">letters &#x3D; [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]</span><br><span class="line">already_letter&#x3D;[]</span><br><span class="line"></span><br><span class="line">read_letter(letters[:],already_letter)</span><br><span class="line">show_already_letter(already_letter)</span><br><span class="line"></span><br><span class="line">print(letters)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数的基础知识</title>
    <url>/2021/02/28/Python%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h3><p>&emsp;&emsp;我们在编程过程中往往会碰到这样的事情 —– 很多地方都用到了相同的一段代码。虽然复制 / 粘贴这段代码不费多大的功夫，但是这样就无声中增加了程序的维护成本。比如，我们后来需求变动了，要修改原来的这段共用代码才能完成目的，这样如果这段代码在很多地方出现，我们只能一处一处的发现并修改。后来我们有个想法，将这段代码单独拿出来，并给这段代码起一个名字，我们在用到这段代码的地方直接使用这个名字来代替这段代码，那如果日后还要修改这里，我们就可以只修改一处，因为名字没有改变，其他使用名字来替换代码的地方也就不需要改变。这样以来即减少了代码的行数，也方便了日后的维护，我们给拿出来的这段代码起了个名字：函数，每个函数都有一个名字，叫函数名，其他的代码使用这个函数的时候，通过函数名调用这个函数就可以了。</p>
<p>函数最主要的目的：封装一个功能。</p>
<!--more>

一个函数的简单例子:

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login_status &#x3D; 0     # 定义一个记录登录状态的变量</span><br><span class="line"></span><br><span class="line">def welcome_user():  # 定义一个函数，函数的功能就是打印&#39;welcome!&#39;</span><br><span class="line">	print(&#39;Welcome!&#39;)</span><br><span class="line"></span><br><span class="line">while not login_status::</span><br><span class="line">	name &#x3D; input(&#39;Input username here: &#39;)</span><br><span class="line">	if name:</span><br><span class="line">	login_status &#x3D; 1</span><br><span class="line">	welcome_user()</span><br><span class="line"></span><br><span class="line"># do other things</span><br></pre></td></tr></table></figure>
<p>上面的例子，如果用户输入有效的用户名，就会调用函数 welcome_user, 该函数实现打印 “Weclome !” 的作用，接着就跳出 while 循环做其他的工作.</p>
<p>上面简单的介绍了函数的定义和使用，函数的定义就是函数实现功能的那段代码，函数的使用就是通过 函数名 来使用.</p>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数的定义阶段只检查函数的语法，不执行函数.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def hello():</span><br><span class="line">	print(&#39;foo&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>向上面这样的定义是不会有问题的，因为没有调用函数</p>
<p>函数定义的方式简单的分为以下两种</p>
<h4 id="无参数函数"><a href="#无参数函数" class="headerlink" title="无参数函数:"></a>无参数函数:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_hello(): # 函数定义</span><br><span class="line">print(&#39;*&#39;*40)</span><br><span class="line">print(&#39;hello&#39;)</span><br><span class="line">print(&#39;*&#39;*40)</span><br><span class="line"></span><br><span class="line">print_hello() # 函数的使用</span><br></pre></td></tr></table></figure>
<p>上面的函数就是无参数函数，这些函数往往是做一些操作而没有返回值 (return somethings).</p>
<h4 id="有参数函数"><a href="#有参数函数" class="headerlink" title="有参数函数:"></a>有参数函数:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def put_together_hello(name&#x3D;&#39;&#39;)                 # 函数包含一个参数</span><br><span class="line">    valid_user&#x3D;&#39;xiaoming&#39;</span><br><span class="line">    print(&#39;*&#39;*40)</span><br><span class="line">    res_str &#x3D; hello %s&#39; % name</span><br><span class="line">    return res_str                                 # 返回一个字符串</span><br><span class="line"></span><br><span class="line">name &#x3D; input(&#39;Input username here: &#39;)</span><br><span class="line"></span><br><span class="line">result&#x3D;put_together_hello(name)                    给函数传递一个参数</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>我们给上面的函数传递了一个值，这个传给函数的值，通常叫做函数的参并且在函数末尾用 return 返回了一个值，我们在函数调用处用一个新量接收该值，并且打印.</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><pre><code>有参函数的参数可大致分为 5 种情况:

1). 位置参数

2). 关键字参数

3). 默认值参数

4). 可变长参数 (*args,**kwargs)

5). 命名关键字参数

下面分别介绍:
</code></pre>
<p>第一种情况：位置参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_info(name,age):</span><br><span class="line">    print(&#39;your name is %s and your are %d years old&#39; % (name,age))</span><br><span class="line"></span><br><span class="line">name&#x3D;&#39;xiaoming&#39;</span><br><span class="line">age&#x3D;16</span><br><span class="line">print_info(name,age)</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">your name is xiaoming and your are 16 years old</span><br></pre></td></tr></table></figure>
<p>上面是位置参数，简单来说，就是调用的时候，参数的位置，应该和函数定义处的函数位置相同，这样才能打印出正确的信息.</p>
<p>第二种情况：关键字参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_info(name,age):</span><br><span class="line">    print(&#39;your name is %s and your are %d years old&#39; % (name,age))</span><br><span class="line"></span><br><span class="line">name&#x3D;&#39;xiaoming&#39;</span><br><span class="line">age&#x3D;16</span><br><span class="line">print_info(age&#x3D;age,name&#x3D;name)</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">your name is xiaoming and your are 16 years old</span><br></pre></td></tr></table></figure>
<pre><code>   这里传递参数的时候指定了传递参数的关键字，就是将 age 变量赋值给 age 参数，就是将 name 变量赋值给 name 参数。这样的就没有问题.
</code></pre>
<p>第三种情况：默认参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_info(name,age&#x3D;17):</span><br><span class="line">    print(&#39;your name is %s and your are %d years old&#39; % (name,age))</span><br><span class="line"></span><br><span class="line">name&#x3D;&#39;xiaoming&#39;</span><br><span class="line">age&#x3D;16</span><br><span class="line">print_info(age&#x3D;age,name&#x3D;name)</span><br><span class="line"></span><br><span class="line">print_info(&#39;xiaohong&#39;)</span><br><span class="line"></span><br><span class="line">print_info(&#39;xiaohong&#39;,20)</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">your name is xiaoming and your are 16 years old</span><br><span class="line">your name is xiaohomg and your are 17 years old</span><br><span class="line">your name is xiaohong and your are 20 years ol</span><br></pre></td></tr></table></figure>
<pre><code> 上面的例子，函数定义的时候，给了一个默认的参数 age=17, 我们将这样含有这种默认值的参数叫做默认值参数，既然函数已经有一个默认值，因此我们可以给函数传递 age 这个信息，也可以不传 age 信息，如果传了 age 信息，则函数运行的时候会将我们传递的 age 覆盖默认的值 (16). 如果我们没有传递参数信息，则输出函数的时候会输出默认值 (16). 有种情况需要注意，在函数定义的时候，默认值参数必须在没有默认值的参数的右侧.

第四种情况：可变长参数
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_info(name,age,*args,**kwargs):</span><br><span class="line">	print(&#39;your name is %s and your age is %d&#39; % (name,age))</span><br><span class="line">	print(args)</span><br><span class="line">	print(kwargs)</span><br><span class="line"></span><br><span class="line">print_info(&#39;xiaoming&#39;,16,&#39;football&#39;,&#39;baskatball&#39;,favorite_color&#x3D;&#39;black&#39;,vorite_book&#x3D;&#39;A&#39;)</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">yourname is xiaoming and your age is 16</span><br><span class="line">(&#39;football&#39;, &#39;baskatball&#39;) #元组</span><br><span class="line">&#123;&#39;favorite_book&#39;: &#39;A&#39;, &#39;favorite_color&#39;: &#39;black&#39;&#125; #字典</span><br></pre></td></tr></table></figure>
<p>我们这里定义 print_info 函数，顺便打印了除 name 和 age 之外的变量，这里除了函数前面的两个值按位置赋值给 name 和 age 外，其余多传递的值中，单个字符串或其他单个变量的都被赋值给 args, 包含简单语句 “A=B” 的变量都被赋值给 kwargs 变量，从上面我们也可以看出，args 是一个 tuple (元组), 而 kwargs 是一个 dict (字典).</p>
<pre><code>第五种情况：命名关键字参数
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foo(name,age,_,sex&#x3D;&#39;male&#39;,height):</span><br><span class="line">	print(name,age)</span><br><span class="line">	print(sex)</span><br><span class="line">	print(height)</span><br><span class="line"></span><br><span class="line"># * 后定义的参数为命名关键字参数,这类参数必须被传值,而且必须以&quot;变量名&#x3D; 变量值&quot;的形式传值</span><br><span class="line"></span><br><span class="line">foo(&#39;xiaoming&#39;,16,height&#x3D;&#39;185&#39;)</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">xiaoming 16</span><br><span class="line">male</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<p>再来看其他的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foo(*args):</span><br><span class="line">	print(args)</span><br><span class="line"></span><br><span class="line">foo(1,2,3,4)</span><br><span class="line">foo(_[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line"></span><br><span class="line"># * [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;] &#x3D;&#x3D;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;</span><br><span class="line">#&#x3D;&#x3D;&gt;f(*[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) &#x3D;&#x3D;&gt; f(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)</span><br><span class="line"># * 打散后面的参数,使之成为位置参数</span><br></pre></td></tr></table></figure>
<p>再来一个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foo(**kwargs):</span><br><span class="line">	print(kwargs)</span><br><span class="line"></span><br><span class="line">foo(x&#x3D;1,y&#x3D;2)</span><br><span class="line"></span><br><span class="line"># x&#x3D;1,y&#x3D;2 &#x3D;&#x3D; **&#123;&#39;y&#39;:2,&#39;x&#39;:1&#125;</span><br><span class="line"># &#x3D;&#x3D;&gt; foo(**&#123;&#39;y&#39;:2,&#39;x&#39;:1&#125;) &#x3D;&#x3D; foo(x&#x3D;1,y&#x3D;2)</span><br><span class="line"># ** 将后面的字典打散成为关键字参数</span><br><span class="line"></span><br><span class="line"> # 结果</span><br><span class="line"> &#123;&#39;x&#39;:1,&#39;y&#39;:2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二，函数的优点是什么"><a href="#二，函数的优点是什么" class="headerlink" title="二，函数的优点是什么"></a>二，函数的优点是什么</h2><p>1、减少代码重复率。</p>
<p>2、增强代码可阅读性。 # 不可能看一百行才知道你这个东西到底是干什么大的吧。</p>
<h2 id="三、函数的组成部分"><a href="#三、函数的组成部分" class="headerlink" title="三、函数的组成部分"></a>三、函数的组成部分</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_len(): # 关键字，函数名，括号，冒号</span><br><span class="line">    l &#x3D; [1, 2, 3, 4]   # 函数体</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    for i in l:</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">    print(count)</span><br></pre></td></tr></table></figure>
<h2 id="四、执行函数"><a href="#四、执行函数" class="headerlink" title="四、执行函数"></a>四、执行函数</h2><p><code>my len() # 函数名 + 括号</code></p>
<h2 id="五、函数的返回值：return-的作用停止函数体的运行。和-break-的功能一样。并且返回给这个函数一个值。"><a href="#五、函数的返回值：return-的作用停止函数体的运行。和-break-的功能一样。并且返回给这个函数一个值。" class="headerlink" title="五、函数的返回值：return 的作用停止函数体的运行。和 break 的功能一样。并且返回给这个函数一个值。"></a>五、函数的返回值：return 的作用停止函数体的运行。和 break 的功能一样。并且返回给这个函数一个值。</h2><p>1&gt; return 空或者没有 return 时，打印函数执行者时，为 None</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func1():</span><br><span class="line">    print (888)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">def func2():</span><br><span class="line">    print(9)</span><br><span class="line"></span><br><span class="line">print(func1())</span><br><span class="line">print(func2())</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line"></span><br><span class="line">888</span><br><span class="line">None</span><br><span class="line">9</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>2&gt; return 加一个值，返回给函数这个值，这个值是什么类型就返回什么类型</p>
<p>3&gt; return 加多个值是，返回给函数一个由这些值组成的元组，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func1():</span><br><span class="line">    a &#x3D; 8</span><br><span class="line">    return a</span><br><span class="line">def func2():</span><br><span class="line">    a &#x3D; 9</span><br><span class="line">    b &#x3D; 20</span><br><span class="line">    return a, b</span><br><span class="line"></span><br><span class="line">print(func1())</span><br><span class="line">print(func2())</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">(9, 20)</span><br></pre></td></tr></table></figure>
<h2 id="六、函数的传参，函数的参数分为形参和实参"><a href="#六、函数的传参，函数的参数分为形参和实参" class="headerlink" title="六、函数的传参，函数的参数分为形参和实参"></a>六、函数的传参，函数的参数分为形参和实参</h2><p>顾名思义，一个形式上的参数，一个实实在在的参数。</p>
<h4 id="1-形参的角度分类："><a href="#1-形参的角度分类：" class="headerlink" title="1. 形参的角度分类："></a>1. 形参的角度分类：</h4><p>1&gt; 位置参数， 按照顺序 ，一 一对应。就是这个位置我占了，谁在我位置上，我就是谁。先来后到。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227215944.png" alt="20210227215944"></p>
</div>

<p>2&gt; 默认参数，如果你给我一个值，我会将原来默认的参数覆盖掉。如果你不给我传值，就是设置好的默认参数</p>
<p>3&gt; 万能参数，也叫动态参数，*args ，**kwargs</p>
<p>4&gt; 形参的顺序 ：位置参数，*args，默认参数，**kwargs。</p>
<p>1.位置参数是最大的，一定要摆在第一位，实参中的也一样，如果摆在后面肯定报错，要么少了，要么多了</p>
<p>2.*args 实际上也是位置参数，就是实参中在形参中的 _ args 的位置有多少个参数，那就吃多少个参数。</p>
<p>3.如果把默认参数摆在他两前，都被 * args 给吸走了。</p>
<p>4.**kwargs 一定是在最后的。实质上是一个默认参数</p>
<p>5，传参陷阱：如果默认参数是一个可变的数据类型，那么他的内存地址用的是一个。</p>
<p>例 1（传默认参数时的运行结果）：</p>
<div align=cneter>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220504.png" alt="20210227220504"></p>
</div>

<p>运行结果如下:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220551.png" alt="20210227220551"></p>
</div>

<p>例 2（把变量放入局部命名空间）：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220639.png" alt="20210227220639"></p>
</div>

<p>运行结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220651.png" alt="20210227220651"></p>
</div>

<ol>
<li>站在实参的角度分为：位置传参，关键字传参，混合传参。</li>
</ol>
<p>例</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220802.png" alt="20210227220802"></p>
</div>

<p>运行结果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/20210227220852.png" alt="20210227220852"></p>
</div>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数的应用实例</title>
    <url>/2021/02/28/Python%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="函数二（返回值-传递列表）"><a href="#函数二（返回值-传递列表）" class="headerlink" title="函数二（返回值 / 传递列表）"></a>函数二（返回值 / 传递列表）</h2><p>1.返回值：函数并非总是直接显示输出，它可以处理一些数据，并返回一个或一组值，函数返回的值被称为返回值。在函数中使用 return 语句将值返回到调用函数的代码行。调用返回值的函数时，需要提供一个变量，用于存储返回的值。</p>
<p>2.return 和 print 的区别</p>
<!--more>

a. 在执行函数的时候 return 无法打印出值，return 返回的结果只能用于给变量赋值，return 返回值只能通过 print 打印出来

b. 在函数中，凡是遇到 return，这个函数就会结束

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func1():</span><br><span class="line">	for i in range(1, 5):</span><br><span class="line">		print(i)</span><br><span class="line"></span><br><span class="line"># print(func1())输出结果为 1 2 3 4 none 直接 func1 的结果为 1 2 3 4</span><br><span class="line"></span><br><span class="line">def func2():</span><br><span class="line">    for i in range(1, 5):</span><br><span class="line">		return i</span><br><span class="line"></span><br><span class="line"># print(func2())输出结果为 1，直接 func2()没有输出</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">print(func1())</span><br><span class="line">print(func2())</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>返回字典：函数可以返回任何类型的值，包括列表和字典。同时可以使用 while 循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def one_user(user_name, pass_word):</span><br><span class="line">    info &#x3D; &#123;&#39;name&#39;: user_name,</span><br><span class="line">    &#39;password&#39;: pass_word&#125;</span><br><span class="line">    return info</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    print(&#39;you can quit whenever you enter a q&#39;)</span><br><span class="line">    user_name1 &#x3D; input(&#39;create a user name: &#39;)</span><br><span class="line">    if user_name1 &#x3D;&#x3D; &#39;q&#39;:</span><br><span class="line">        break</span><br><span class="line">    pass_word1 &#x3D; input(&#39;create a pass word: &#39;)</span><br><span class="line">    if pass_word1 &#x3D;&#x3D; &#39;q&#39;:</span><br><span class="line">        break</span><br><span class="line">    print(one_user(user_name1, pass_word1))</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>向函数传递列表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def loved_music(new_songs, old_songs):</span><br><span class="line">    while new_songs:</span><br><span class="line">        choosed_song &#x3D; input(&#39;which song do you want to listen? &#39;)</span><br><span class="line">        new_songs.remove(choosed_song)</span><br><span class="line">        old_songs.append(choosed_song)</span><br><span class="line">        for loved_song in old_songs:</span><br><span class="line">            print(&#39;%s is a good song&#39; % loved_song)</span><br><span class="line"></span><br><span class="line">new_songs &#x3D; [&#39;roar&#39;, &#39;lemon&#39;, &#39;sugar&#39;, &#39;hero&#39;]</span><br><span class="line">old_songs &#x3D; []</span><br><span class="line"></span><br><span class="line">loved_music(new_songs[:], old_songs) # 不会修改原列表 new_songs</span><br><span class="line">print(new_songs)</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>传递任意数量的实参</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def favorite_songs(*songs):     # 使用 * 创建一个名为 songs 的空元组，将收到的所有实参都封装到这个元组中</span><br><span class="line">&quot;&quot;&quot;打印最喜欢的音乐&quot;&quot;&quot; # 文档字符串，描述函数的作用</span><br><span class="line">    print(songs)</span><br><span class="line"></span><br><span class="line">favorite_songs(&#39;lemon&#39;, &#39;city song&#39;, &#39;stray&#39;)</span><br></pre></td></tr></table></figure>
<p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后</p>
<ol start="6">
<li>使用任意数量的关键字实参</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def make_car(manufacturer, type, **car_info): # 使用**创建一个字典，将收到的所有键值对都封装到这个字典中</span><br><span class="line"></span><br><span class="line">    car &#x3D; &#123;&#125;</span><br><span class="line">    car[&#39;manufacturer _name&#39;] &#x3D; manufacturer</span><br><span class="line">    car[&#39;type_name&#39;] &#x3D; type</span><br><span class="line">    for key, value in car_info.items():</span><br><span class="line">        car[key] &#x3D; value</span><br><span class="line">    return car</span><br><span class="line"></span><br><span class="line">cars &#x3D; make_car(&#39;subaru&#39;, &#39;outback&#39;, color&#x3D;&#39;blue&#39;, two_package&#x3D;True)</span><br><span class="line">print(cars)</span><br><span class="line">print(make_car(&#39;subaru&#39;, &#39;outback&#39;, color&#x3D;&#39;blue&#39;, two_package&#x3D;True))</span><br></pre></td></tr></table></figure>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>###函数定义###</p>
<p>#一般函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;&#x3D; 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>
<p>#匿名函数，使用 lambda 创建</p>
<p><code>sum = lambda arg1, arg2: arg1 + arg2;</code></p>
<p>#缺省参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def printinfo( name, age &#x3D; 35 ):</span><br><span class="line">    &quot;打印任何传入的字符串&quot;</span><br><span class="line">    print( &quot;Name: &quot;, name);</span><br><span class="line">    print (&quot;Age &quot;, age);</span><br><span class="line">    return;</span><br></pre></td></tr></table></figure>
<p>#不定长参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def printinfo2( arg1, *vartuple ):</span><br><span class="line">    &quot;打印任何传入的参数&quot;</span><br><span class="line">    print( &quot;输出: &quot;,arg1)</span><br><span class="line">    for var in vartuple:</span><br><span class="line">        print (var)</span><br><span class="line">    return;</span><br></pre></td></tr></table></figure>
<p>###函数定义###</p>
<p>###函数调用###</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printinfo2(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;my_abs&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;) #调用函数 my_abs</span><br><span class="line">absVal&#x3D;my_abs(-3) #按照参数顺序传参</span><br><span class="line">print(&quot;my_abs(-3)&#x3D;&quot;,absVal)</span><br><span class="line">absVal2&#x3D;my_abs(x&#x3D;-4) #关键字参数，可以不按照参数熟悉传参</span><br><span class="line">print(&quot;my_abs(x&#x3D;-4)&#x3D;&quot;,absVal2)</span><br></pre></td></tr></table></figure>
<p>#调用函数 sum</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printinfo2(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sum&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">print (&quot;sum(10,20)&#x3D;&quot;, sum( 10, 20 ))</span><br></pre></td></tr></table></figure>
<p>#调用函数 printinfo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printinfo2(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;printinfo&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">printinfo(&quot;zhangsan&quot;,18);</span><br><span class="line">printinfo(&quot;lisi&quot;);</span><br></pre></td></tr></table></figure>
<p>#调用函数 printinfo2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printinfo2(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;printinfo2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">printinfo2( 10 );</span><br><span class="line">printinfo2( 70, 60, 50 ); ###函数调用###</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路</title>
    <url>/2021/02/14/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文源自知乎网文，有学习的同感，故抄来以此鞭策自己。感谢原作者</p>
<p>&emsp;&emsp;首先不要觉着编程难，只要你认识 26 个英文字母，有一点点小学或初中的词汇量就完全没问题！！要在心理上对自己有信心，不就是个编程嘛，搞他！！抄我也得把他抄下来！！</p>
<a id="more"></a>

<p>&emsp;&emsp;作为过来人建议从最最基础的语法命令开始，能让自己有一个小小的成就感就行，不要贪大，比如打印显示出一句话都能有满满的成就感，从小小的成就感中一点点得体会编程的乐趣，这样心理的抵触感和恐惧会慢慢的消失，伴随而来的就是好奇与探索的欲望，久而久之就会去研究 python 的语法去掌握它。这个小小的成就感非常非常重要！！</p>
<p>&emsp;&emsp;总是有评论区知友问我，不知道如何从 0 入手来获得这种小小的成就感？这里统一回复一下：对于小白来说，有个人引导会比自学要高效的多，尤其容易坚持不下去的小伙伴。可以试试下面这个入门课程，不用本地安装 Python 环境，能直接在网页上敲代码，还有大牛老师的直播课带着入门，能少走很多弯路！只要跟着老师一行行的敲代码，坚持下来会发现其实学 Python 非常容易！</p>
<p>&emsp;&emsp;如果你学完了上面的基础训课程，接下来，可以给自己设立个小目标，来学以致用，比如要用 Python 解决工作或学习中的一个重复复制粘贴的小问题！经过自己查找搜索发现 Python 可以用爬虫解决我这个问题，那就搞他！！</p>
<p>&emsp;&emsp;站在巨人的肩膀上，先去搜一搜有没有几行代码的小爬虫案例，肯定有的，就拿最简单的，爬百度首页，不管是啥，先一把梭，照着代码敲一遍，然后运行，肯定能出来东西，不管是正确结果还是报错，先跑一遍再说！！</p>
<p>&emsp;&emsp;精读代码，滤清思路，照葫芦画瓢，先看看都用了哪些第三方包，爬虫的话觉对是 requests 库了，顾名思义，就是发送请求接受请求的库，如果还不明白就是把这个库想象成你的浏览器，现在他是另一种浏览器了，只是没有界面。不用鼠标点击访问网页，而是用另一种方式，请求和响应，看明白响应的 HTML 代码咋解析呀，网上一搜，就有了另一个库 bs4，以此类推，然后试着用这个代码去请求一下自己的那个目标网址试试看看都返回啥。</p>
<p>&emsp;&emsp;学习过程中，缺啥补啥！哪里不会补哪里！后面你就会了解到 python 除了可以写爬虫，还可以做网站，可以做数据分析，期间就会遇到更底层的困难，emmm 做网络应该更了解一些网络协议，类似 http 协议，以及握手挥手原理，数据请求原理等。</p>
<p>&emsp;&emsp;同时就还需要抓包工具的使用配置，json 等数据格式的学习，html 的学习，js 的学习，总之会发现自己遇到的困难一个接一个，需要的前置知识需要一个坑一个坑的去填，这些应该比较痛苦，但是其乐无穷。</p>
<p>&emsp;&emsp;基础要精通，勤加练习，多看书！python 本身语法学习中还会在面向对象这个概念中卡住，因为之前的语法都是面向过程，写个函数封装起来就完事了，后来遇到面向对象，思路就要转变一下了，三大特性，类的概念，继承，对象，多态，封装，以及各种魔法函数，需要大量练习和理解。</p>
<p>&emsp;&emsp;后来基本的书籍已经满足不了自己了，就去看流畅的 python ，cookbook 等书籍，发现 python 还有很多的特性需要掌握，实在是学无止境。<br>&emsp;&emsp;这些还是 python 语法本身，后面的 python 爬虫就要学习除了网络协议，抓包，以及各种 requests 库，还要学习提高速度多线程，多进程，分布式的抓取，另外还会需要代理 ip，伪登录，等难题。</p>
<p>&emsp;&emsp;在抓数据上已经费了老劲了，接下来就要存数据，数据库得学习一下 mysql sql 语句 mongodb ，redis 都得学习下。</p>
<p>&emsp;&emsp;好不容易存好了数据，就要去分析了，numpy pandas 就又要学习各种函数去学习，于是就又找了一本利用 python 进行数据分析的书。<br>&emsp;&emsp;使劲看完之后，分析数据也差不多了，就要考虑数据展示了，matplotlib seaborn echart 就要学习了 js 语言也要学习了，于是折腾一波，就可以做出基本的数据图表了。</p>
<p>&emsp;&emsp;然后又希望展示到网站，让同事看，于是就又要学习 django flask 这样的网络框架，一顿猛学之后基本就可以展示了。后来发现自己需要优化一下网站，性能更高，耦合度更小一些，要做成前后端分离的形式，于是又去学了 restful 的开发方式和 vue 框架，实现前后端分离。</p>
<p>&emsp;&emsp;后面发现自己的数据分析深度不太够，于是又恶补了一些统计学的知识，于是又进了统计学到机器学习到深度学习的深坑，于是自然语言处理，计算机视觉，这些依靠神经网络的技术也就入门了，当然这些需要一点点的死磕，从线性代数到手写神经网络，到应用框架一步步理解其原理，是最有乐趣的。</p>
<p>&emsp;&emsp;总之小白学 Python 方法总比困难多！你要问我最大的困难是什么？我的答案是如何高度保持持续进取学习应用的好奇心与耐心是最困难的。<br>&emsp;&emsp;编程是一个全新的世界，就像学英语，打开了英语世界，那么编程就是打开了全新的编程世界，日常那些重复的问题、报表等，都变得苍白无力！困难与乐趣同在！</p>
<p>&emsp;&emsp;最后！记录，搜索，基础，这三个很重要！！找个地方写博客记录自己学习历程很重要，解决了任何问题都记录下来，比如这个知乎专栏啥的，不会的问题多搜索答案，肯定能搜到！，反复练习基础语法，理解基础知识，看书，看视频都可以！</p>
<p>&emsp;&emsp;加油吧！人生没有无意义的努力，现在的付出，将来一定会有回报，说不定什么时候就用到了</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Python序列得到所有元素索引及值的方法</title>
    <url>/2021/02/14/Python%E5%BA%8F%E5%88%97%E5%BE%97%E5%88%B0%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="元祖序列的索引及值"><a href="#元祖序列的索引及值" class="headerlink" title="元祖序列的索引及值"></a>元祖序列的索引及值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; (18,20,&#39;黄&#39;,True,1.2)</span><br><span class="line">for i in range(len(x)):</span><br><span class="line">    print(&#39;这是第&#123;&#125;个字符&#123;&#125;&#39;.format(str(i+1),str(x[i])))</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是第1个字符18</span><br><span class="line">这是第2个字符20</span><br><span class="line">这是第3个字符黄</span><br><span class="line">这是第4个字符True</span><br><span class="line">这是第5个字符1.2</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="获取列表中元素的索引位置"><a href="#获取列表中元素的索引位置" class="headerlink" title="获取列表中元素的索引位置"></a>获取列表中元素的索引位置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;new&#39;, &#39;D&#39;, &#39;z&#39;, &#39;example&#39;, &#39;new&#39;, &#39;two&#39;, &#39;elements&#39;]</span><br><span class="line">print(list1.index(&#39;example&#39;))</span><br><span class="line">print(list1.index(&#39;new&#39;))</span><br><span class="line">print(list1.index(&#39;z&#39;))</span><br><span class="line">print(&#39;c&#39; in list1)</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myList &#x3D; [&#39;Google&#39;, &#39;Runoob&#39;, 1997, &#39;Runoob&#39;]</span><br><span class="line">myListlength &#x3D; len(myList)</span><br><span class="line">print (&#39; 长度为：&#39; + str (myListlength))</span><br><span class="line">for x in myList:</span><br><span class="line">    idx &#x3D; myList.index(x, )</span><br><span class="line">    idxStr &#x3D; str(idx)</span><br><span class="line">#     print(idxStr)</span><br><span class="line">    print(idxStr ,end&#x3D;&#39;&#39;)</span><br><span class="line">    print(&quot;,&quot; + str(x))</span><br><span class="line">    </span><br><span class="line">print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line"></span><br><span class="line">for y in range(myListlength):</span><br><span class="line">    print(str(y) + &quot; , &quot; + str(myList[y]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码的结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">长度为：4</span><br><span class="line">0,Google</span><br><span class="line">1,Runoob</span><br><span class="line">2,1997</span><br><span class="line">1,Runoob</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0 , Google</span><br><span class="line">1 , Runoob</span><br><span class="line">2 , 1997</span><br><span class="line">3 , Runoob</span><br></pre></td></tr></table></figure>
<h3 id="下面的例子使用-L-列表，找到-2-所在的位置："><a href="#下面的例子使用-L-列表，找到-2-所在的位置：" class="headerlink" title="下面的例子使用 L 列表，找到 2 所在的位置："></a>下面的例子使用 L 列表，找到 2 所在的位置：</h3><h5 id="方法一，使用-enumerate-函数，它不仅可以直接列出位置，还可以列出值："><a href="#方法一，使用-enumerate-函数，它不仅可以直接列出位置，还可以列出值：" class="headerlink" title="方法一，使用 enumerate 函数，它不仅可以直接列出位置，还可以列出值："></a>方法一，使用 enumerate 函数，它不仅可以直接列出位置，还可以列出值：</h5><p><code>L = [2,4,5,6,2,6,0,4]</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i,j in enumerate(L):</span><br><span class="line">　　if j &#x3D;2:</span><br><span class="line">　　print(i,j)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0   2</span><br><span class="line"></span><br><span class="line">4   2</span><br></pre></td></tr></table></figure>
<h5 id="方法二，直接用-index-函数："><a href="#方法二，直接用-index-函数：" class="headerlink" title="方法二，直接用 index 函数："></a>方法二，直接用 index 函数：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [2,4,5,6,2,6,0,4]</span><br><span class="line">print(L.index(2))</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<pre><code>0 

4
</code></pre>
<h5 id="方法三，使用-for-循环："><a href="#方法三，使用-for-循环：" class="headerlink" title="方法三，使用 for 循环："></a>方法三，使用 for 循环：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [2,4,5,6,2,6,0,4] </span><br><span class="line"></span><br><span class="line">for i in L:</span><br><span class="line">　　if L[i] &#x3D;&#x3D; 2:</span><br><span class="line">　　print(i)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line"></span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h4 id="此处有个小知识点，找到某元素出现的第一个位置："><a href="#此处有个小知识点，找到某元素出现的第一个位置：" class="headerlink" title="此处有个小知识点，找到某元素出现的第一个位置："></a>此处有个小知识点，找到某元素出现的第一个位置：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [2,4,5,6,2,6,0,4]</span><br><span class="line">for i in L:</span><br><span class="line">　　if L[i] &#x3D;&#x3D; 2:</span><br><span class="line">　　print(i)</span><br><span class="line">　　break</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<pre><code>    0
</code></pre>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件路径问题汇总</title>
    <url>/2021/02/14/Python%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="Python-中-os-listdir-函数用法"><a href="#Python-中-os-listdir-函数用法" class="headerlink" title="Python 中 os.listdir () 函数用法"></a>Python 中 os.listdir () 函数用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.listdir() </span><br></pre></td></tr></table></figure>
<p>语法格式：</p>
<blockquote>
<p>os.listdir(path)</p>
</blockquote>
<p>1、参数</p>
<blockquote>
<p>path—- 需要列出的目录路径</p>
</blockquote>
<p>2、返回值</p>
<blockquote>
<p>返回指定路径下的文件和文件夹列表。</p>
</blockquote>
<a id="more"></a>

<p>实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"> </span><br><span class="line">path &#x3D; r&#39;D:\APK\data1&#39;</span><br><span class="line">file_list &#x3D;os.listdir(path)</span><br><span class="line"></span><br><span class="line">print(file_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：1、2 为文件夹，123.txt 为文件</p>
<p><code>[&#39;Iris-setosa.xlsx&#39;, &#39;Iris-versicolor.xlsx&#39;, &#39;Iris-virginica.xlsx&#39;, &#39;文件夹 1&#39;, &#39;文件夹 2&#39;]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 输出所有文件和文件夹</span><br><span class="line">for filename in file_list:</span><br><span class="line">    print(filename)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210214151032.png" alt="20210214151032"> </p>
</div>

<h2 id="listdir-完整路径"><a href="#listdir-完整路径" class="headerlink" title="listdir 完整路径"></a>listdir 完整路径</h2><ul>
<li>列表推导式写法</li>
</ul>
<p><code>filenames=[os.path.join(file_folder, file) for file in os.listdir(file_folder)]</code></p>
<ul>
<li>for循环写法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for filename in file_list:</span><br><span class="line">    filedir &#x3D; os.path.join(path,filename)</span><br><span class="line">    print(filedir)</span><br></pre></td></tr></table></figure>
运行结果:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\APK\data1\Iris-setosa.xlsx</span><br><span class="line">D:\APK\data1\Iris-versicolor.xlsx</span><br><span class="line">D:\APK\data1\Iris-virginica.xlsx</span><br><span class="line">D:\APK\data1\文件夹 1</span><br><span class="line">D:\APK\data1\文件夹 2</span><br></pre></td></tr></table></figure>
<h2 id="python-中的-os-listdir-os-listdir-os-listdir-os-listdir-path-的区别"><a href="#python-中的-os-listdir-os-listdir-os-listdir-os-listdir-path-的区别" class="headerlink" title="python 中的 os.listdir (),os.listdir (.),os.listdir (..),os.listdir (path) 的区别"></a>python 中的 os.listdir (),os.listdir (.),os.listdir (..),os.listdir (path) 的区别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 为空时，默认为当前路径，返回当前路径下的文件名和文件夹名：</span><br><span class="line"></span><br><span class="line">os.listdir()</span><br><span class="line"></span><br><span class="line">2. 返回当前目录下的文件名和文件夹名:</span><br><span class="line"></span><br><span class="line">os.listdir(.)</span><br><span class="line"></span><br><span class="line">3. 当前上一级目录下的文件名和文件夹名:</span><br><span class="line"></span><br><span class="line">os.listdir(..)</span><br><span class="line"></span><br><span class="line">4. 某一具体目录下的文件名和文件夹名：</span><br><span class="line"></span><br><span class="line">os.listdir(path)</span><br></pre></td></tr></table></figure>
<h2 id="模块-os-中的-walk-函数"><a href="#模块-os-中的-walk-函数" class="headerlink" title="模块 os 中的 walk () 函数"></a>模块 os 中的 walk () 函数</h2><p>python 中 os.walk 是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情。</p>
<h3 id="1、导入模块"><a href="#1、导入模块" class="headerlink" title="1、导入模块"></a>1、导入模块</h3><p>要使用 os.walk, 首先要载入该函数</p>
<p>可以使用以下两种方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">from os import walk</span><br></pre></td></tr></table></figure>
<h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><p>os.walk 的函数声明为:</p>
<p><code>walk(top, topdown=True, οnerrοr=None, followlinks=False)</code></p>
<p>参数:</p>
<blockquote>
<p>top 是你所要便利的目录的地址</p>
</blockquote>
<p>topdown 为真，则优先遍历 top 目录，否则优先遍历 top 的子目录 (默认为开启)</p>
<p>onerror 需要一个 callable 对象，当 walk 需要异常时，会调用</p>
<p>followlinks 如果为真，则会遍历目录下的快捷方式 (linux 下是 symbolic link) 实际所指的目录 (默认关闭)</p>
<p>os.walk 的返回值是一个生成器 (generator), 也就是说我们需要不断的遍历它，来获得所有的内容。</p>
<p>每次遍历的对象都是返回的是一个三元组 (root,dirs,files)</p>
<ul>
<li>root 所指的是当前正在遍历的这个文件夹的本身的地址</li>
<li>dirs 是一个 list ，内容是该文件夹中所有的目录的名字 (不包括子目录)</li>
<li>files 同样是 list , 内容是该文件夹中所有的文件 (不包括子目录)</li>
<li>如果 topdown 参数为真，walk 会遍历 top 文件夹，与 top 文件夹中每一个子目录。</li>
</ul>
<h4 id="模块-os-中的-walk-函数可以遍历文件夹下所有的文件。"><a href="#模块-os-中的-walk-函数可以遍历文件夹下所有的文件。" class="headerlink" title="模块 os 中的 walk () 函数可以遍历文件夹下所有的文件。"></a>模块 os 中的 walk () 函数可以遍历文件夹下所有的文件。</h4><p><code>os.walk(top, topdown=Ture, onerror=None, followlinks=False)</code></p>
<p>该函数可以得到一个三元 tupple (dirpath, dirnames, filenames).</p>
<p>参数含义：</p>
<ul>
<li><p>dirpath：string，代表目录的路径；</p>
</li>
<li><p>dirnames：list，包含了当前 dirpath 路径下所有的子目录名字（不包含目录路径）；</p>
</li>
<li><p>filenames：list，包含了当前 dirpath 路径下所有的非目录子文件的名字（不包含目录路径）。</p>
</li>
<li><p>注意，dirnames 和 filenames 均不包含路径信息，如需完整路径，可使用 os.path.join (dirpath, dirnames)</p>
</li>
</ul>
<p>代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-  </span><br><span class="line"></span><br><span class="line">import os </span><br><span class="line"></span><br><span class="line">def file_name(file_dir):  </span><br><span class="line">  for root, dirs, files in os.walk(file_dir): </span><br><span class="line">    print(root) #当前目录路径 </span><br><span class="line">    print(dirs) #当前路径下所有子目录 </span><br><span class="line">    print(files) #当前路径下所有非目录子文件</span><br></pre></td></tr></table></figure>
<p>当需要特定类型的文件时，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*- </span><br><span class="line"></span><br><span class="line">import os </span><br><span class="line"></span><br><span class="line">def file_name(file_dir):  </span><br><span class="line">  L&#x3D;[]  </span><br><span class="line">  for root, dirs, files in os.walk(file_dir): </span><br><span class="line">    for file in files: </span><br><span class="line">      if os.path.splitext(file)[1] &#x3D;&#x3D; &#39;.jpeg&#39;: </span><br><span class="line">        L.append(os.path.join(root, file)) </span><br><span class="line">  return L</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line">import os</span><br><span class="line">mypath &#x3D; &quot;C:\\Users\\LiLong\\Desktop\\tt&quot;</span><br><span class="line"></span><br><span class="line">for root , dirs, files in os.walk(mypath):</span><br><span class="line">    print(root)</span><br><span class="line">    print(dirs)</span><br><span class="line">    print(files)</span><br><span class="line">print(&#39;..................................................&#39;)    </span><br><span class="line">for root,dirs,files in os.walk(mypath):</span><br><span class="line">    print(root)</span><br><span class="line">    for dr in dirs:</span><br><span class="line">        print(dr)</span><br><span class="line">    for name in files:</span><br><span class="line">        if name.endswith(&quot;.txt&quot;):</span><br><span class="line">            print(os.path.join(root, name))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">path &#x3D; &#39;&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#39;</span><br><span class="line">for root,dirs,files in os.walk(path):</span><br><span class="line">        print root,dirs,files</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort [&#39;test&#39;] [&#39;nameout.txt&#39;, &#39;namelist.txt&#39;, &#39;namesorttest.py&#39;]</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;test [] [&#39;nameout.txt&#39;, &#39;name2.txt&#39;, &#39;namelist.txt&#39;, &#39;namesort.py&#39;]</span><br></pre></td></tr></table></figure>
<h3 id="获得所有子文件路径（os-path-join-使用）"><a href="#获得所有子文件路径（os-path-join-使用）" class="headerlink" title="获得所有子文件路径（os.path.join 使用）"></a>获得所有子文件路径（os.path.join 使用）</h3><p>由于 os.walk 获得的并不是路径，所以需要将其内容进行连接得到路径。</p>
<p>这时使用 python 自带函数 os.path.join, 其语法为：</p>
<p><code>os.path.join(path1[, path2[, ...]])</code></p>
<p>其中嵌套的 [] 表示写在最前面的是高级目录，后面的是低级的，也就是按参数排列顺序拼接。</p>
<p>举例：</p>
<p><code>os.path.join(&quot;home&quot;, &quot;me&quot;, &quot;mywork&quot;)</code></p>
<p>在 Linux 系统上会返回 home/me/mywork</p>
<p>在 Windows 系统上会返回 home\me\mywork</p>
<blockquote>
<p>可能大家已经注意到了，此函数并不是简单的字符串连接函数，你不需要在输入的参数字符串中加入分隔符，函数会根据你的系统自动加入对应的分隔符，这也是这个函数存在的意义所在。</p>
</blockquote>
<p>所以我们正好使用 os.path.join() 来处理上面生成的遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">path &#x3D; &#39;&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#39;</span><br><span class="line">for root,dirs,files in os.walk(path):</span><br><span class="line">        for file in files:</span><br><span class="line">                print(os.path.join(root,file))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;nameout.txt</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;namelist.txt</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;namesorttest.py</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;test&#x2F;nameout.txt</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;test&#x2F;name2.txt</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;test&#x2F;namelist.txt</span><br><span class="line">&#x2F;home&#x2F;jhxie&#x2F;Workspace&#x2F;namesort&#x2F;test&#x2F;namesort.py</span><br></pre></td></tr></table></figure>
<h4 id="接下来是大量的例子"><a href="#接下来是大量的例子" class="headerlink" title="接下来是大量的例子"></a>接下来是大量的例子</h4><p>Python– 遍历文件夹下所有文件和目录的方法（os.walk (rootdir) 函数返回一个三元素元祖）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import os.path</span><br><span class="line"></span><br><span class="line"># This folder is custom</span><br><span class="line">rootdir &#x3D; &#39;&#x2F;Users&#x2F;macbookpro&#x2F;Desktop&#x2F;test&#39;</span><br><span class="line">for parent, dirnames, filename in os.walk(rootdir):</span><br><span class="line">    # Case1: traversal the directories</span><br><span class="line">    for dirname in dirnames:</span><br><span class="line">        print(&quot;Parent folder:&quot;, parent)</span><br><span class="line">        print(&quot;Dirname:&quot;, filename)</span><br><span class="line">    # Case2: traversal the files</span><br><span class="line">    for filename in filenames:</span><br><span class="line">        print(&quot;Parent folder:&quot;, parent)</span><br><span class="line">        print(&quot;Filename:&quot;, filename)</span><br></pre></td></tr></table></figure>
<p>解释说明：os.walk (rootdir) 函数返回一个三元素元祖，其中 parent 是父目录，dirnames 是所有文件夹名字（不包含路径），filenames 是所有文件的名字（不包含路径）</p>
<p>以上，case1、case2 分别演示了遍历该文件夹下（/Users/macbookpro/Desktop/test）的所有目录、文件的方法</p>
<h4 id="1、综合例子"><a href="#1、综合例子" class="headerlink" title="1、综合例子"></a>1、综合例子</h4><p>简单的例子</p>
<p>保持目录 a 的目录结构，在 b 中创建对应的文件夹，并把 a 中所有的文件加上后缀 _bak</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">Root &#x3D; &#39;a&#39;</span><br><span class="line">Dest &#x3D; &#39;b&#39;</span><br><span class="line"></span><br><span class="line">for (root, dirs, files) in os.walk(Root):</span><br><span class="line">    new_root &#x3D; root.replace(Root, Dest, 1)</span><br><span class="line">    if not os.path.exists(new_root):</span><br><span class="line">        os.mkdir(new_root)</span><br><span class="line">    </span><br><span class="line">    for d in dirs:</span><br><span class="line">        d &#x3D; os.path.join(new_root, d)</span><br><span class="line">        if not os.path.exists(d):</span><br><span class="line">            os.mkdir(d)</span><br><span class="line">    </span><br><span class="line">    for f in files:</span><br><span class="line">        # 把文件名分解为 文件名.扩展名</span><br><span class="line">        # 在这里可以添加一个 filter，过滤掉不想复制的文件类型，或者文件名</span><br><span class="line">        (shotname, extension) &#x3D; os.path.splitext(f)</span><br><span class="line">        # 原文件的路径</span><br><span class="line">        old_path &#x3D; os.path.join(root, f)</span><br><span class="line">        new_name &#x3D; shotname + &#39;_bak&#39; + extension</span><br><span class="line">        # 新文件的路径</span><br><span class="line">        new_path &#x3D; os.path.join(new_root, new_name)</span><br><span class="line">        try:</span><br><span class="line">            # 复制文件</span><br><span class="line">            open(new_path, &#39;wb&#39;).write(open(old_path, &#39;rb&#39;).read())</span><br><span class="line">        except IOError as e:</span><br><span class="line">            print(e)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python统计list中各元素出现的次数</title>
    <url>/2021/02/14/Python%E7%BB%9F%E8%AE%A1list%E4%B8%AD%E5%90%84%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h3 id="用-python-统计-list-中各元素出现的次数（同理统计字符串中各字符出现的次数）"><a href="#用-python-统计-list-中各元素出现的次数（同理统计字符串中各字符出现的次数）" class="headerlink" title="用 python 统计 list 中各元素出现的次数（同理统计字符串中各字符出现的次数）"></a>用 python 统计 list 中各元素出现的次数（同理统计字符串中各字符出现的次数）</h3><p>统计 list 中各元素出现的次数，下面的方法也适用于统计字符串中各字符出现的次数</p>
<a id="more"></a>

<h4 id="1、用字典的形式来处理"><a href="#1、用字典的形式来处理" class="headerlink" title="1、用字典的形式来处理"></a>1、用字典的形式来处理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; &quot;abhcjdjje&quot;</span><br><span class="line"></span><br><span class="line">a_dict &#x3D; &#123;&#125;</span><br><span class="line">for i in a:</span><br><span class="line">　　a_dict[i] &#x3D; a.count(i)</span><br><span class="line">print(a_dict)</span><br></pre></td></tr></table></figure>
<p>结果如下:<br><code>&#123;&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;h&#39;: 1, &#39;c&#39;: 1, &#39;j&#39;: 3, &#39;d&#39;: 1, &#39;e&#39;: 1&#125;</code> </p>
<h4 id="2、用-count-函数直接打印出来"><a href="#2、用-count-函数直接打印出来" class="headerlink" title="2、用 count 函数直接打印出来"></a>2、用 count 函数直接打印出来</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [2,4,5,6,2,6,0,4]</span><br><span class="line">for i in L:</span><br><span class="line">　　print (&quot;% d 的次数:% d&quot;%(i,L.count (i)))</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2的次数:2</span><br><span class="line">4的次数:2</span><br><span class="line">5的次数:1</span><br><span class="line">6的次数:2</span><br><span class="line">2的次数:2</span><br><span class="line">6的次数:2</span><br><span class="line">0的次数:1</span><br><span class="line">4的次数:2</span><br></pre></td></tr></table></figure>
<h4 id="3、用-collections-的-Counter-函数"><a href="#3、用-collections-的-Counter-函数" class="headerlink" title="3、用 collections 的 Counter 函数"></a>3、用 collections 的 Counter 函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line">L &#x3D; [2,4,5,6,2,6,0,4]</span><br><span class="line">result &#x3D; Counter(L)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p><code>Counter(&#123;2: 2, 4: 2, 6: 2, 5: 1, 0: 1&#125;)</code></p>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python遍历文件实例</title>
    <url>/2021/02/15/Python%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="listdir-读取某一目录下面的所有文件"><a href="#listdir-读取某一目录下面的所有文件" class="headerlink" title="listdir 读取某一目录下面的所有文件"></a>listdir 读取某一目录下面的所有文件</h2><p>某一文件下面的.txt文本比较多，那么怎么才能讲该文件夹下面的所有的文件中的内容读取出来，这样就需要一个函数直接读取某一文件夹里面所有的文件。</p>
<p>在python中listdir就可以实现上述的功能</p>
<p>程序代码如下所示：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def data_all():##该函数主要是将所有的.txt文本合并成一个文件</span><br><span class="line">    f1 &#x3D; open(&#39;.&#x2F;data_all.txt&#39;,&#39;w&#39;,encoding&#x3D;&#39;utf8&#39;)</span><br><span class="line">    path &#x3D; &#39;.&#x2F;1&#x2F;&#39;</span><br><span class="line">    file_name &#x3D; os.listdir(path)</span><br><span class="line">    # print(file_name)</span><br><span class="line">    for file in file_name:</span><br><span class="line">        with open(path+file,encoding&#x3D;&#39;utf8&#39;) as fp:</span><br><span class="line">            for line in fp.readlines():</span><br><span class="line">                line &#x3D; line.strip()</span><br><span class="line">                if line &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">                    continue</span><br><span class="line">                f1.write(line+&#39;\n&#39;)</span><br><span class="line">    f1.close()</span><br><span class="line">data_all()</span><br></pre></td></tr></table></figure>
<h2 id="python-下递归遍历目录和文件-方法"><a href="#python-下递归遍历目录和文件-方法" class="headerlink" title="python 下递归遍历目录和文件(方法)"></a>python 下递归遍历目录和文件(方法)</h2><h4 id="方法一：递归调用："><a href="#方法一：递归调用：" class="headerlink" title="方法一：递归调用："></a>方法一：递归调用：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">#coding:utf8</span><br><span class="line"> </span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">def dirlist(path, allfile):</span><br><span class="line">	filelist &#x3D;  os.listdir(path)</span><br><span class="line"> </span><br><span class="line">	for filename in filelist:</span><br><span class="line">		filepath &#x3D; os.path.join(path, filename)</span><br><span class="line">		if os.path.isdir(filepath):</span><br><span class="line">			dirlist(filepath, allfile)</span><br><span class="line">		else:</span><br><span class="line">			allfile.append(filepath)</span><br><span class="line">	return allfile</span><br><span class="line"> </span><br><span class="line">print dirlist(&quot;&#x2F;home&#x2F;yuan&#x2F;testdir&quot;, [])	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="方法二：os-walk"><a href="#方法二：os-walk" class="headerlink" title="方法二：os.walk()"></a>方法二：os.walk()</h4><p>该函数式穿件一个生成器对象来遍历整棵目录树。</p>
<p>top 指定目录的顶级，而 topdown 是一个布尔值，用于指示由上而下（默认值）还是由下而上来遍历目录。返回的生成器将生成元组（dirpath，dirnames，filenames），其</p>
<p>中 dirpath 是一个字符串，包含通向目录的路径，dirnames 是 dirpath 中所有子目录的一个列表，而 filename 是 dirpath 中文件的一个列表，不包括目录。oneerror </p>
<p>参数是一个接受单个参数的函数。</p>
<p>如果处理期间出现任何错误，将使用 os.error 的是咧来调用此函数。默认行为时忽略错误。如果由上而下地遍历目录，修改 dirnames 将影响到遍历过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">g &#x3D; os.walk(&quot;&#x2F;home&#x2F;yuan&#x2F;testdir&quot;)</span><br><span class="line"></span><br><span class="line">for path,d,filelist in g:</span><br><span class="line">	print d;</span><br><span class="line">	for filename in filelist:</span><br><span class="line">		print os.path.join(path, filename)</span><br></pre></td></tr></table></figure>
<h4 id="递归实现文件反向输出："><a href="#递归实现文件反向输出：" class="headerlink" title="递归实现文件反向输出："></a>递归实现文件反向输出：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!user&#x2F;bin&#x2F;python</span><br><span class="line">fr &#x3D; open(&#39;aa.txt&#39;,&#39;r&#39;)</span><br><span class="line">fw &#x3D; open(&#39;b.txt&#39;, &#39;w+&#39;)</span><br><span class="line"> </span><br><span class="line">def restr(s):                 #递归实现函数</span><br><span class="line">	str1 &#x3D; s.readline()     </span><br><span class="line">	if len(str1) !&#x3D; 0:</span><br><span class="line">		restr(s)</span><br><span class="line">	fw.write(str1)</span><br><span class="line"> </span><br><span class="line">restr(fr)	</span><br><span class="line">fr.close()</span><br><span class="line">fw.close()</span><br></pre></td></tr></table></figure>
<h2 id="遍历文件"><a href="#遍历文件" class="headerlink" title="遍历文件"></a>遍历文件</h2><ol>
<li>第一个参数 fpath 是遍历打印所有的文件路径<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import os</span><br><span class="line">path &#x3D; r&quot;D:\APK\data1&quot;  # 查找文件的路径</span><br><span class="line">for fpath, dirname, fnames in os.walk(path):</span><br><span class="line">    print(fpath)  # 所有的文件夹路径 </span><br></pre></td></tr></table></figure>
运行结果:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\APK\data1</span><br><span class="line">D:\APK\data1\文件夹 1</span><br><span class="line">D:\APK\data1\文件夹 2</span><br></pre></td></tr></table></figure></li>
<li>第二个参数 dirname 是遍历打印所有的文件夹名称</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import os</span><br><span class="line">path &#x3D; r&quot;D:\APK\data1&quot;  # 查找文件的路径</span><br><span class="line">for fpath, dirname, fnames in os.walk(path):</span><br><span class="line">    print(dirname)  # 所有的文件名 </span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;文件夹 1&#39;, &#39;文件夹 2&#39;]</span><br><span class="line">[]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>第三个参数 fnames 是遍历打印所有的文件名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import os</span><br><span class="line">path &#x3D; r&quot;D:\APK\data1&quot;  # 查找文件的路径</span><br><span class="line">for fpath, dirname, fnames in os.walk(path):</span><br><span class="line">    print(fnames)  # 所有的文件名</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;Iris-setosa.xlsx&#39;, &#39;Iris-versicolor.xlsx&#39;, &#39;Iris-virginica.xlsx&#39;]</span><br><span class="line">[]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h4 id="遍历所有的文件"><a href="#遍历所有的文件" class="headerlink" title="遍历所有的文件"></a>遍历所有的文件</h4></li>
<li><p>遍历查找文件夹内所有的子文件（不包含文件夹）</p>
</li>
<li><p>用 endswith 判断查找后置是.py 结尾的</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def get_files(path&#x3D;&#39;D:\APK\data1&#39;, rule&#x3D;&quot;.xlsx&quot;):</span><br><span class="line">    all &#x3D; []</span><br><span class="line">    for fpathe,dirs,fs in os.walk(path):   # os.walk是获取所有的目录</span><br><span class="line">        for f in fs:</span><br><span class="line">            filename &#x3D; os.path.join(fpathe,f)</span><br><span class="line">            if filename.endswith(rule):  # 判断是否是&quot;xxx&quot;结尾</span><br><span class="line">                all.append(filename)</span><br><span class="line">    return all</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    b &#x3D; get_files(r&quot;D:\APK\data1&quot;)</span><br><span class="line">    for i in b:</span><br><span class="line">        print (i)</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\APK\data1\Iris-setosa.xlsx</span><br><span class="line">D:\APK\data1\Iris-versicolor.xlsx</span><br><span class="line">D:\APK\data1\Iris-virginica.xlsx</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode快捷键及小技巧</title>
    <url>/2021/02/17/VsCode%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ul>
<li>「Ctrl + F」当前文件内搜索，当选中文本时直接按「Ctrl + F」，可直接填写搜索内容，界面如下：</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217131854.png" alt="20210217131854"></p>
</div>

<hr>
<a id="more"></a>

<ul>
<li>「Ctrl + D」当选中文本时直接按「Ctrl + D」，可直接同时选中其他相同文本（按一次 ‘D’，选中一个，可按住不放），可进行同时编辑，界面如下：</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217131911.png" alt="20210217131911"></p>
</div>

<hr>
<ul>
<li><p>「Ctrl + E」当前文件内按「Ctrl + E」, 输入文件名可快速打开其他文件</p>
<br>
</li>
<li><p>「F2」重命名一个变量</p>
<br>
- 选中一个变量，然后按 F2，弹出一个小窗口，在里面输入内容后按回车，所有该变量都会被重命名。（注意：在 js 文件中，如果这个变量没有用 var 或者 const 或者 let 声明，会无法重命名）

</li>
</ul>
<hr>
<ul>
<li>「按住 alt，用鼠标左键点击」可以出现多个光标，输入的代码可以在光标处同时增加</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20191007144725963.gif" alt="20191007144725963"></p>
</div>

<hr>
<ul>
<li>「按 shift+alt，再使用鼠标拖动」可以出现竖直的列光标，同时可以选中多列</li>
</ul>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/tuodong.gif" alt="tuodong"></p>
</div>

<hr>
<h2 id="VS-Code-使用技巧整理"><a href="#VS-Code-使用技巧整理" class="headerlink" title="VS Code 使用技巧整理"></a>VS Code 使用技巧整理</h2><h4 id="一、多光标插入功能"><a href="#一、多光标插入功能" class="headerlink" title="一、多光标插入功能"></a>一、多光标插入功能</h4><p>Alt + 鼠标左键，添加多光标输入</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217133338.png" alt="20210217133338"></p>
</div>

<hr>
<h4 id="二、自由多行选择"><a href="#二、自由多行选择" class="headerlink" title="二、自由多行选择"></a>二、自由多行选择</h4><p>Alt 键 + 鼠标左键拖动选择各行的部分内容</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217133415.png" alt="20210217133415"></p>
</div>

<hr>
<h4 id="三、列选择"><a href="#三、列选择" class="headerlink" title="三、列选择"></a>三、列选择</h4><p>Shift+Alit + 鼠标左键拖动，选中拖动的区域内容</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217133842.png" alt="20210217133842"></p>
</div>

<hr>
<h4 id="四、将自动高亮的变量、字符一次性替换："><a href="#四、将自动高亮的变量、字符一次性替换：" class="headerlink" title="四、将自动高亮的变量、字符一次性替换："></a>四、将自动高亮的变量、字符一次性替换：</h4><p>双击变量，右键‘更改所有匹配项’。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217134125.png" alt="20210217134125"></p>
</div>

<hr>
<p>或者</p>
<p>双击变量，Ctrl+F2</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210217134138.png" alt="20210217134138"></p>
</div>



<ul>
<li><p>格式调整</p>
<ul>
<li>代码行缩进 Ctrl+[， Ctrl+]</li>
<li>折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+]</li>
<li>Ctrl+C Ctrl+V 如果不选中，默认复制或剪切一整行</li>
<li>代码格式化：Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code</li>
<li>修剪空格 Ctrl+Shift+X</li>
<li>上下移动一行： Alt+Up 或 Alt+Down</li>
<li>向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down</li>
<li>在当前行下边插入一行 Ctrl+Enter</li>
<li>在当前行上方插入一行 Ctrl+Shift+Enter</li>
</ul>
<br>
</li>
<li><p>光标相关</p>
<ul>
<li>移动到行首：Home</li>
<li>移动到行尾：End</li>
<li>移动到文件结尾：Ctrl+End</li>
<li>移动到文件开头：Ctrl+Home</li>
<li>移动到后半个括号 Ctrl+Shift+]</li>
<li>选中当前行 Ctrl+i（双击）</li>
<li>选择从光标到行尾 Shift+End</li>
<li>选择从行首到光标处 Shift+Home</li>
<li>删除光标右侧的所有字 Ctrl+Delete</li>
<li>Shrink/expand selection： Shift+Alt+Left 和 Shift+Alt+Right</li>
<li>Multi-Cursor：可以连续选择多处，然后一起修改，Alt+Click 添加 cursor 或者 Ctrl   - +Alt+Down 或 Ctrl+Alt+Up</li>
<li>同时选中所有匹配的 Ctrl+Shift+L</li>
<li>Ctrl+D 下一个匹配的也被选中 (被我自定义成删除当前行了，见下边 Ctrl+Shift+K)</li>
<li>回退上一个光标操作 Ctrl+U</li>
</ul>
<br>
</li>
<li><p>构代码</p>
<ul>
<li>跳转到定义处：F12</li>
<li>定义处缩略图：只看一眼而不跳转过去 Alt+F12</li>
<li>列出所有的引用：Shift+F12</li>
<li>同时修改本文件中所有匹配的：Ctrl+F12</li>
<li>重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件 - 都修改过了。</li>
<li>跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转</li>
<li>查看 diff 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右    - 键选择 Compare with ‘file_name_you_chose’.</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><p>查找替换</p>
<ul>
<li>查找 Ctrl+F</li>
<li>查找替换 Ctrl+H</li>
<li>整个文件夹中查找 Ctrl+Shift+F<br>
</li>
</ul>
</li>
<li><p>显示相关</p>
<ul>
<li>全屏:F11</li>
<li>zoomIn/zoomOut：Ctrl + =/Ctrl + -</li>
<li>侧边栏显 / 隐：Ctrl+B</li>
<li>预览 markdown Ctrl+Shift+V<br>
</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>自动保存：File -&gt; AutoSave ，或者 Ctrl+Shift+P，输入 auto</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode插件同步到云</title>
    <url>/2021/02/28/Vscode%E6%8F%92%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%88%B0%E4%BA%91/</url>
    <content><![CDATA[<h3 id="安装-Settings-Sync"><a href="#安装-Settings-Sync" class="headerlink" title="安装 Settings Sync"></a>安装 Settings Sync</h3><p>Vscode 插件中心直接搜索安装即可。</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210210184154.png" alt="20210210184154"></p>
</div>

<a id="more"></a>

<h3 id="github-生成-token-和-gistid"><a href="#github-生成-token-和-gistid" class="headerlink" title="github 生成 token 和 gistid"></a>github 生成 token 和 gistid</h3><p>token 获取步骤：</p>
<p>网址：github：<a href="https://github.com/">https://github.com/</a></p>
<p>路径：Settings -&gt; Developer settings -&gt; Personal access tokens</p>
<p>操作：点击按钮 Generate new token 新增一个 token，选择 gistid 即可。</p>
<p>记住生成的 token 值</p>
<p>gistid 获取步骤</p>
<p>网址：github：<a href="https://github.com/">https://github.com/</a></p>
<p>路径： 点击右上角 + 号 New gist</p>
<p>操作： 任意填写 gist 描述 -&gt; 点击生成私钥 (英文的) -&gt; 记录下来</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210210185647.png" alt="20210210185647"></p>
</div>

<h3 id="配置本设备-gistId-和-token"><a href="#配置本设备-gistId-和-token" class="headerlink" title="配置本设备 gistId 和 token"></a>配置本设备 gistId 和 token</h3><ul>
<li>Ctrl + P / F1，弹出命令窗口</li>
<li>输入 &gt; sync</li>
<li>选择 Advaced Options</li>
</ul>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210210184505.png" alt="20210210184505"></p>
</div>

<h3 id="填写-gistid-和-token-即可"><a href="#填写-gistid-和-token-即可" class="headerlink" title="填写 gistid 和 token 即可"></a>填写 gistid 和 token 即可</h3><div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210210200919.png" alt="20210210200919"></p>
</div>

<p>同步、下载</p>
<p>上载设定</p>
<p>按 Shift + Alt + U（macOS：Shift + Option + U）</p>
<blockquote>
<p>在命令面板中键入 “&gt; 同步”，以顺序下载 / 上传</p>
</blockquote>
<p>首次下载或上传时，欢迎页面将自动打开，您可以在其中配置 “设置同步”。</p>
<p>选择上传后，上传设置后。您将看到 “摘要” 详细信息以及每个上传的文件和扩展名的列表。</p>
<div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210210201241.png" alt="20210210201241"></p>
</div>

<h3 id="在其他电脑下载插件和配置"><a href="#在其他电脑下载插件和配置" class="headerlink" title="在其他电脑下载插件和配置"></a>在其他电脑下载插件和配置</h3><p>在 Vscode 的插件扩展中输入 sync 查找并安装，按 ctrl+p 输入 ‘&gt;sync’ ，在弹出窗口中选择高级设置，并打开 github 设置，在打开的网页中输入 github 的用户名和密码，本地配置已完成，之后用快捷键即可进行下载配置。</p>
<p><strong>Setting Sync 快捷键</strong></p>
<p>上传： Shift + Alt + U (Sync: Update / Upload Settings)</p>
<p>下载： Shift + Alt + D (Sync: Download Settings)</p>
<p>如果快捷键有冲突，可 Ctrl + K + S 快捷键设置配置其它快捷键 或 Ctrl + P / F1 在命令窗口输入 &gt;sync 即会出现相应命令供选择</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>不同方法读取excel中的多个不同sheet表格性能比较</title>
    <url>/2021/02/06/%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95%E8%AF%BB%E5%8F%96excel%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8Csheet%E8%A1%A8%E6%A0%BC%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p><a href="https://www.jb51.net/article/190704.htm">转自脚本之家</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方法1</span><br><span class="line">def read_excel(path):</span><br><span class="line">  df&#x3D;pd.read_excel(path,None)</span><br><span class="line">  print(df.keys())</span><br><span class="line">  # for k,v in df.items():</span><br><span class="line">  #   print(k)</span><br><span class="line">  #   print(v)</span><br><span class="line">  #   print(type(v))</span><br><span class="line">  return df</span><br><span class="line"> </span><br><span class="line"># 方法2</span><br><span class="line">def read_excel1(path):</span><br><span class="line">  data_xls &#x3D; pd.ExcelFile(path)</span><br><span class="line">  print(data_xls.sheet_names)</span><br><span class="line">  data&#x3D;&#123;&#125;</span><br><span class="line">  for name in data_xls.sheet_names:</span><br><span class="line">    df&#x3D;data_xls.parse(sheetname&#x3D;name,header&#x3D;None)</span><br><span class="line">    data[name]&#x3D;df</span><br><span class="line">    # print(df)</span><br><span class="line">    # print(name)</span><br><span class="line">  return data</span><br><span class="line"> </span><br><span class="line"># 方法3</span><br><span class="line">def read_excel2(path):</span><br><span class="line">  data_xls &#x3D; pd.io.excel.ExcelFile(path)</span><br><span class="line">  data&#x3D;&#123;&#125;</span><br><span class="line">  print(data_xls.sheet_names)</span><br><span class="line">  for name in data_xls.sheet_names:</span><br><span class="line">    df&#x3D;pd.read_excel(data_xls,sheetname&#x3D;name,header&#x3D;None)</span><br><span class="line">    data[name]&#x3D;df</span><br><span class="line">  return data</span><br></pre></td></tr></table></figure>
<h3 id="结论：若读取多个-sheet-表格时，方法-2-和方法-3-相对于方法-1-的效率较高。"><a href="#结论：若读取多个-sheet-表格时，方法-2-和方法-3-相对于方法-1-的效率较高。" class="headerlink" title="结论：若读取多个 sheet 表格时，方法 2 和方法 3 相对于方法 1 的效率较高。"></a>结论：若读取多个 sheet 表格时，方法 2 和方法 3 相对于方法 1 的效率较高。</h3><p>需要解决的问题：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075001.png" alt="20210206075001"></p>
</div>

<p>方法 1 的解析结果:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075043.png" alt="20210206075043"></p>
</div>

<p>方法 2 的解析结果:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075101.png" alt="20210206075101"></p>
</div>

<p>方法 3 的解析结果:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075119.png" alt="20210206075119"></p>
</div>

<h2 id="Python-对-Excel-按列值筛选并拆分表格到多个文件的代码"><a href="#Python-对-Excel-按列值筛选并拆分表格到多个文件的代码" class="headerlink" title="Python 对 Excel 按列值筛选并拆分表格到多个文件的代码"></a>Python 对 Excel 按列值筛选并拆分表格到多个文件的代码</h2><h4 id="场景：集团中心下发本省数据时，并未按地市、业务拆分，现需要按地市、业务拆分并分发到地市。"><a href="#场景：集团中心下发本省数据时，并未按地市、业务拆分，现需要按地市、业务拆分并分发到地市。" class="headerlink" title="场景：集团中心下发本省数据时，并未按地市、业务拆分，现需要按地市、业务拆分并分发到地市。"></a>场景：集团中心下发本省数据时，并未按地市、业务拆分，现需要按地市、业务拆分并分发到地市。</h4><p>本文利用 Python 的 pandas 包实现了以上场景。</p>
<p>注：本示例代码只实现按单列拆分，如果需要多列筛选拆分，请修改本示例中的 filter_column_name 与 city_name_to_list，并多套一层循环。</p>
<p>now, show u the code: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Fri Nov 1 09:53:30 2019</span><br><span class="line">@author: lanxuxml</span><br><span class="line"></span><br><span class="line">应用场景：</span><br><span class="line"></span><br><span class="line"> 包含多个sheet的Excel 需要按列筛选出来另存为其它文件</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import pandas as pd</span><br><span class="line">split_excel_name_head &#x3D; &#39;name_head_&#39;</span><br><span class="line">split_excel_name_tail &#x3D; &#39;_name_tail.xlsx&#39;</span><br><span class="line">xlsx_name &#x3D; &#39;x:\xxxx\xxxxxxxx.xls&#39;</span><br><span class="line">#用来筛选的列名</span><br><span class="line">filter_column_name &#x3D; &#39;column_name&#39;</span><br><span class="line">#将该列去重后保存为list</span><br><span class="line">df &#x3D; pd.read_excel(xlsx_name)</span><br><span class="line">city_names &#x3D; df[filter_column_name].unique().tolist()</span><br><span class="line">#获取所有sheet名</span><br><span class="line">df &#x3D; pd.ExcelFile(xlsx_name)</span><br><span class="line">sheet_names &#x3D; df.sheet_names</span><br><span class="line">#不需要筛选的sheet名</span><br><span class="line">sheet_not_filter_names &#x3D; sheet_names[9:2]</span><br><span class="line">for city_name in city_names:</span><br><span class="line">  city_excel_name &#x3D; split_excel_name_head + str(city_name) + split_excel_name_tail</span><br><span class="line">  writer &#x3D; pd.ExcelWriter(city_excel_name)</span><br><span class="line">  #将city_name转为list</span><br><span class="line">  #如果是两列筛选，在此处多套上一层循环</span><br><span class="line">  #如果是多列筛选，请修改代码使用多维list进行循环遍历</span><br><span class="line">  city_name_to_list &#x3D; []</span><br><span class="line">  city_name_to_list.append(city_name)</span><br><span class="line">  for sheet_name in sheet_names:</span><br><span class="line">    tmp_df &#x3D; pd.read_excel(xlsx_name, sheet_name&#x3D;sheet_name)</span><br><span class="line">    if sheet_name not in sheet_not_filter_names:</span><br><span class="line">      #如果是两列筛选，在此处添加一行代码</span><br><span class="line">     tmp_sheet &#x3D; tmp_df[tmp_df[filter_column_name].isin(city_name_to_list)]</span><br><span class="line">    else:</span><br><span class="line">     tmp_sheet &#x3D; tmp_df</span><br><span class="line">    tmp_sheet.to_excel(excel_writer&#x3D;writer, sheet_name&#x3D;sheet_name, encoding&#x3D;&quot;utf-8&quot;, index&#x3D;False)</span><br><span class="line">  writer.save()</span><br><span class="line">  writer.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-读取-Excel-表格文件的方法"><a href="#python-读取-Excel-表格文件的方法" class="headerlink" title="python 读取 Excel 表格文件的方法"></a>python 读取 Excel 表格文件的方法</h2><p>python 读取 Excel 表格文件，例如获取这个文件的数据:</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075741.png" alt="20210206075741"></p>
</div>

<p>#引入Excel库的xlrd<br>import xlrd</p>
<p>2、获取 Excel 文件的位置并且读取进来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#导入需要读取Excel表格的路径</span><br><span class="line">data &#x3D; xlrd.open_workbook(r&#39;C:\Users\NHT\Desktop\Data\\test1.xlsx&#39;)</span><br><span class="line">table &#x3D; data.sheets()[0]</span><br></pre></td></tr></table></figure>
<p>3、读取指定的行和列的内容，并将内容存储在列表中（将第三列的时间格式转换）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建一个空列表，存储Excel的数据</span><br><span class="line">tables &#x3D; []</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#将excel表格内容导入到tables列表中</span><br><span class="line">def import_excel(excel):</span><br><span class="line">  for rown in range(excel.nrows):</span><br><span class="line">   array &#x3D; &#123;&#39;road_name&#39;:&#39;&#39;,&#39;bus_plate&#39;:&#39;&#39;,&#39;timeline&#39;:&#39;&#39;,&#39;road_type&#39;:&#39;&#39;,&#39;site&#39;:&#39;&#39;&#125;</span><br><span class="line">   array[&#39;road_name&#39;] &#x3D; table.cell_value(rown,0)</span><br><span class="line">   array[&#39;bus_plate&#39;] &#x3D; table.cell_value(rown,1)</span><br><span class="line">   #将Excel表格中的时间格式转化</span><br><span class="line">   if table.cell(rown,2).ctype &#x3D;&#x3D; 3:</span><br><span class="line">     date &#x3D; xldate_as_tuple(table.cell(rown,2).value,0)</span><br><span class="line">     array[&#39;timeline&#39;] &#x3D; datetime.datetime(*date)</span><br><span class="line">   array[&#39;road_type&#39;] &#x3D; table.cell_value(rown,3)</span><br><span class="line">   array[&#39;site&#39;] &#x3D; table.cell_value(rown,4)</span><br><span class="line">   tables.append(array)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、运行程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">  #将excel表格的内容导入到列表中</span><br><span class="line">  import_excel(table)</span><br><span class="line">  #验证Excel文件存储到列表中的数据</span><br><span class="line">  for i in tables:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5、最终的运行效果如下：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210206075948.png" alt="20210206075948"></p>
</div>

<p>6、完整的程序代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import xlrd</span><br><span class="line">from xlrd import xldate_as_tuple</span><br><span class="line">import datetime</span><br><span class="line">#导入需要读取的第一个Excel表格的路径</span><br><span class="line">data1 &#x3D; xlrd.open_workbook(r&#39;C:\Users\NHT\Desktop\Data\\test.xlsx&#39;)</span><br><span class="line">table &#x3D; data1.sheets()[0]</span><br><span class="line">#创建一个空列表，存储Excel的数据</span><br><span class="line">tables &#x3D; []</span><br><span class="line">#将excel表格内容导入到tables列表中</span><br><span class="line">def import_excel(excel):</span><br><span class="line">  for rown in range(excel.nrows):</span><br><span class="line">   array &#x3D; &#123;&#39;road_name&#39;:&#39;&#39;,&#39;bus_plate&#39;:&#39;&#39;,&#39;timeline&#39;:&#39;&#39;,&#39;road_type&#39;:&#39;&#39;,&#39;site&#39;:&#39;&#39;&#125;</span><br><span class="line">   array[&#39;road_name&#39;] &#x3D; table.cell_value(rown,0)</span><br><span class="line">   array[&#39;bus_plate&#39;] &#x3D; table.cell_value(rown,1)</span><br><span class="line">   if table.cell(rown,2).ctype &#x3D;&#x3D; 3:</span><br><span class="line">     date &#x3D; xldate_as_tuple(table.cell(rown,2).value,0)</span><br><span class="line">     array[&#39;timeline&#39;] &#x3D; datetime.datetime(*date)</span><br><span class="line">   array[&#39;road_type&#39;] &#x3D; table.cell_value(rown,3)</span><br><span class="line">   array[&#39;site&#39;] &#x3D; table.cell_value(rown,4)</span><br><span class="line">   tables.append(array)</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">  #将excel表格的内容导入到列表中</span><br><span class="line">  import_excel(table)</span><br><span class="line">  for i in tables:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用-python-对-excel-表格处理的一些小功能"><a href="#使用-python-对-excel-表格处理的一些小功能" class="headerlink" title="使用 python 对 excel 表格处理的一些小功能"></a>使用 python 对 excel 表格处理的一些小功能</h2><p>pandas 库的一些应用</p>
<p>文件读入</p>
<p>代码如下，每一句后面都有注释！<br>包括知识点：</p>
<ol>
<li>excel 文件的写入和输出；</li>
<li>检验表格中是否有 NaN，有即删除一行；</li>
<li>把表格某列中所有某字母替换成另一字母，所有某数字替换成另一数字；</li>
<li>检验表格某列中每一格是 Y 还是 N，是 Y 就在新列中对应输出 1，反之则为 0；</li>
<li>对表格中多列进行运算<br>（首先要配置 pandas 库，如果需要读取和写入文件，要配置 xlsxwriter 库）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import xlsxwriter </span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;my_pacifier.xlsx&#39;) #excel表格文件读入，括号里面写文件地址</span><br><span class="line">word&#x3D;word.replace([&#39;n&#39;,&#39;y&#39;],[&#39;N&#39;,&#39;Y&#39;])  #把excel表里的所有n替换成N，y替换成Y</span><br><span class="line">word&#x3D;word.dropna(axis&#x3D;0)    #如果表格里有一行中有NaN，即删除这一行</span><br><span class="line">word[&#39;m&#39;] &#x3D; word[&#39;a&#39;].str.contains(&#39;Y&#39;).astype(int)   #如果列索引为a的这一列中有Y则对应新列中取值为1</span><br><span class="line">word[&#39;n&#39;]&#x3D;word[&#39;vine&#39;].str.contains(&#39;Y&#39;).astype(int)</span><br><span class="line">word[&#39;n&#39;]&#x3D;word[&#39;n&#39;].replace(1,2)      #把列索引为n的这一列中所有为1的值转换为2</span><br><span class="line">s &#x3D; word.apply(lambda word: word[&#39;a&#39;] *(word[&#39;m&#39;]+word[&#39;n&#39;]) , axis&#x3D;1)    #s列是由表格中其他列的计算得到</span><br><span class="line">word[&#39;Si&#39;]&#x3D;(s - s.min())&#x2F;(s.max() - s.min()) #对s列中的值进行归一化处理</span><br><span class="line">print(word[&#39;Si&#39;])                             &#x2F;&#x2F;打印索引为Si的列</span><br><span class="line">#print(s)</span><br><span class="line">#print(word[&#39;n&#39;])</span><br><span class="line">word.to_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;SVVp.xlsx&#39;,engine&#x3D;&#39;xlsxwriter&#39;)      &#x2F;&#x2F;输出excel文件到电脑中</span><br><span class="line">print(&#39;finished&#39;) </span><br></pre></td></tr></table></figure>
<p>计算表格中每一行的英文单词数</p>
<p>包含知识点:</p>
<ol>
<li>dataframe 和字典、列表的转换；</li>
<li>如何遍历字典；</li>
<li>计算 dataframe 中每一列的英文句子中的单词数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import xlsxwriter </span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;reviewh.xlsx&#39;)  #里面只有一列数据</span><br><span class="line">c&#x3D;[]      #列表，用来统计每一行的英文句子的英文单词个数</span><br><span class="line">word&#x3D;word.set_index(word.index).T.to_dict(&#39;list&#39;) #把这一列数据按dataframe的索引转换成字典     </span><br><span class="line">for key,value in word.items():    #遍历字典</span><br><span class="line">  s&#x3D;str(value)           #先把表格里当前行的内容转换成字符串</span><br><span class="line">  a&#x3D;s.split(&#39; &#39;)          #把英文句子按空格分割</span><br><span class="line">  num_s&#x3D;len(a)            #计算出单词个数</span><br><span class="line">  c.append(num_s)          #添加到c中</span><br><span class="line">c&#x3D;pd.DataFrame(c)           #由列表转换为dataframe</span><br><span class="line">c.to_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;counth.xlsx&#39;,engine&#x3D;&#39;xlsxwriter&#39;)  &#x2F;&#x2F;输出成新的文件</span><br><span class="line">print(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>
简单用 textblob 进行自然语言情感分析</li>
</ol>
<p>用 NLP 简单分析表格中每一格的英文句子的情感极性和主观性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from textblob import TextBlob</span><br><span class="line">import xlsxwriter </span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;reviewh.xlsx&#39;)</span><br><span class="line">c&#x3D;[]</span><br><span class="line">word&#x3D;word.set_index(word.index).T.to_dict(&#39;list&#39;)</span><br><span class="line">for key,value in word.items(): </span><br><span class="line">  s&#x3D;str(value)</span><br><span class="line">  blob &#x3D; TextBlob(s)     #把s转化成textblob对象</span><br><span class="line">  blob &#x3D; blob.sentences   #利用TextBlob句子标记化句子</span><br><span class="line">  first &#x3D; blob[0].sentiment   #对标记化后的句子进行情感分析（我这里只有一个句子，如果有很多句就添加second&#x3D;blob[1].sentiment）</span><br><span class="line">  c.append(first.polarity)    #这里只添加了情感极性，如果还需要主观性，就直接用first</span><br><span class="line">c&#x3D;pd.DataFrame(c)</span><br><span class="line">c.to_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;NLPh.xlsx&#39;,engine&#x3D;&#39;xlsxwriter&#39;)</span><br><span class="line">print(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>
<p>判断一行中是不是有两列值都与其他行重复（可推广至多列）</p>
<p>判断表中是不是有在同一行中 a 列和 b 列值都相同的情况。如第一行中 a=1，b=2，第 4 行中 a=1，b=2，则这两行相同；如果第 8 行中 a=1，b=3，则它和第一行不重复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import xlsxwriter</span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;my_hair_dryer.xlsx&#39;)</span><br><span class="line">x&#x3D;word[&#39;a&#39;]     </span><br><span class="line">y&#x3D;word[&#39;b&#39;]</span><br><span class="line">z&#x3D;pd.concat([x,y],axis&#x3D;1)#对axis&#x3D;1即把两列按行对齐，即左右拼接成一张表       </span><br><span class="line">z[&#39;repeat&#39;]&#x3D;z.duplicated()  #判断表中有没有重复的，如果有则输出为true</span><br><span class="line">ll &#x3D; z[&#39;repeat&#39;].values.tolist()   #把这一列转变成列表   </span><br><span class="line">if &#39;True&#39; in ll:   #遍历列表，如果里面有true，就说明有重复，就输出yes</span><br><span class="line">  print(&#39;yes&#39;)</span><br><span class="line">print(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>
<p>对表格中的两列自定义函数运算</p>
<p>（此处定义的是除法运算）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import xlsxwriter </span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;my_hair_dryer.xlsx&#39;)</span><br><span class="line">def chu(x,y):</span><br><span class="line">  if y&#x3D;&#x3D;0:   #分母为0，则不运算，结果直接为0</span><br><span class="line">    result&#x3D;0</span><br><span class="line">  else:</span><br><span class="line">    result&#x3D;x&#x2F;y</span><br><span class="line">  return result</span><br><span class="line">s &#x3D; word.apply(lambda word:chu(word[&#39;helpful_votes&#39;],word[&#39;total_votes&#39;]), axis&#x3D;1)</span><br><span class="line">s.to_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;voteh.xlsx&#39;,engine&#x3D;&#39;xlsxwriter&#39;)</span><br><span class="line">print(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>
<p>判断表格中某列中是否有空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import xlsxwriter </span><br><span class="line">word&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;my_hair_dryer.xlsx&#39;)</span><br><span class="line">train&#x3D;word[&#39;review_date&#39;]</span><br><span class="line">print(train.isnull().any())   #有空即输出true</span><br></pre></td></tr></table></figure>
<p>对表格某列中时间格式的修正</p>
<p>原格式是月 / 日 / 年，如 1/11/2014，改为标准 datetime 格式 2014-01-11（此处还要舍去后面的 00：00：00），方便之后画图，也方便排序等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import datetime  #引入库</span><br><span class="line"></span><br><span class="line">#导入数据集</span><br><span class="line">data &#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;Exx.xlsx&#39;)</span><br><span class="line"></span><br><span class="line">data &#x3D; data.loc[:, [&#39;review_date&#39;]] # 获取数据集中列名为review_date</span><br><span class="line">#s&#x3D; pd.to_datetime(data[&#39;review_date&#39;], format&#x3D;&#39;%m&#x2F;%d&#x2F;%Y&#39;)</span><br><span class="line"></span><br><span class="line"># 标准化日期，获取时间的“年、月、日”</span><br><span class="line">def change_date(s):</span><br><span class="line">  s &#x3D; datetime.datetime.strptime(s, &quot;%m&#x2F;%d&#x2F;%Y&quot;) #这里是原格式的形式，俺是月&#x2F;日&#x2F;年，可根据实际情况修改 </span><br><span class="line">  # 把日期标准化，如把1&#x2F;11&#x2F;2014变成2014-01-011 00:00:00</span><br><span class="line">  s &#x3D; str(s) # 上一步把date转化为了时间格式，此处把date转回str格式</span><br><span class="line">  return s[:10] #只获取年月日的方法,即“位置10”之前的字符串</span><br><span class="line">  #字符串的切片</span><br><span class="line"></span><br><span class="line">data[&#39;review_date&#39;] &#x3D; data[&#39;review_date&#39;].map(change_date) </span><br><span class="line"># 用change_date函数处理列表中date这一列，如把“1&#x2F;11&#x2F;2014”转化为“2014-01-11”</span><br><span class="line">#data &#x3D; data.sort_values(by&#x3D;&#39;review_date&#39;) # 按date这一列进行排序，根据需要采用</span><br><span class="line">data.to_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;Exxx.xlsx&#39;,engine&#x3D;&#39;xlsxwriter&#39;)</span><br><span class="line">print(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>
<p>运用 matplotlib 画时间序列图，重叠图</p>
<p>画时间序列图<br>（如果要画重叠图，记得 x 要一样，y 可以不一样，然后用 plt.plot (x,y0,x,y1,x,y2) 即可画出重叠图）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib</span><br><span class="line">import datetime</span><br><span class="line">from statsmodels.graphics.factorplots import interaction_plot</span><br><span class="line">import xlsxwriter </span><br><span class="line">data&#x3D;pd.read_excel(&#39;C:&#x2F;math&#x2F;Problem_C_Data&#x2F;Exx.xlsx&#39;)</span><br><span class="line"># # create data </span><br><span class="line">s&#x3D;data[&#39;E&#39;]      #y轴</span><br><span class="line">e0&#x3D;s[2907:5043]</span><br><span class="line">t&#x3D;data[&#39;review_date&#39;] </span><br><span class="line">t0&#x3D;t[2907:5043]</span><br><span class="line">y0 &#x3D;e0.values.tolist()</span><br><span class="line">x0 &#x3D; pd.to_datetime(t0)     #x轴</span><br><span class="line"># # plot</span><br><span class="line">plt.plot(x0,y0)        </span><br><span class="line">plt.gcf().autofmt_xdate()</span><br><span class="line">plt.grid(ls &#x3D; &#39;--&#39;)      #设置背后的网格线</span><br><span class="line">plt.show()  #最后一定要show()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>人最重要的能力是什么</title>
    <url>/2021/02/16/%E4%BA%BA%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E8%83%BD%E5%8A%9B%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>人最重要的能力是什么</p>
<p>随时保持内心平静的能力</p>
<p>我开始第一个想到的是「坚持」，后来我认为不对。</p>
<a id="more"></a>

<p>「坚持」仅仅是成功所必备的能力，并不是人生最重要的能力，亦不是我们最缺乏的能力。</p>
<p>坚持的目的是为了成功，成功的目的是为了幸福。然而我见过很多人能成功，但并不幸福。</p>
<p>要讨论人生最重要的能力，我们必须要放眼于整个人生：</p>
<p>人到底追求什么？</p>
<p>很多人会说「要一份成功的事业」、「要赚大把钱」、「要找到自己相爱的人厮守一生」。</p>
<p>我们纵观这些欲望，无一不在诉求着一个共同的追求：幸福。</p>
<p>我在以前诉说过，人要达到理想中的幸福状态是很难的。因为我们大多数人理解的幸福为：我想要干嘛就干嘛。</p>
<p>但是想想，如果一个人真的能随心所欲，想得到什么就能得到什么。那么他剩下的，就只有无聊了。这时他会到处找事做，寻找新的欲望。</p>
<p>我见过坐拥千万的富翁，他们买了一个又一个的包，玩了一个又一个的女人。然而他们表现出来的并不是幸福，而是永不满足的焦虑。</p>
<p>一个包买回来，用几天又马上束之高阁，因为他看中了又一个更漂亮的包。</p>
<p>我见过退休的老干部，老两口一个月上万工资。然而经常为儿子没有找到公务员的工作烦恼，儿子娶媳妇的事烦恼，孙子的教育烦恼。</p>
<p>儿子不在身边，他们又烦恼「厅里的灯没有关怎么办」，「房门是不是锁紧了」，「我的高血压什么时候能治愈，我还能活多久」。</p>
<p>无时不刻处在焦虑和不安之中，换而言之，他们并没有达到自己想象中的幸福状态。</p>
<p>反观我自己，我小的时候期盼快读大学，那样就不用天天上学听家长唠叨成绩了。</p>
<p>后来进了大学，我又期盼着早点出来工作。因为工作就有工资，有钱，有钱才有自由。</p>
<p>现在我出来工作这么多年，我又想着退休——我想退休的人整天浇浇花、散散步，那一定会很幸福了吧。</p>
<p>在看了别人的生活、以及读了一些书以后，我开始明白，一个人如果没有刻意地去修炼，在社会的这座染缸里搅成一团，是永远没法安宁的。</p>
<p>他永远觉得此时此刻是最痛苦的时候，而我现在的痛苦，是为了明天的光明，明天一定会过得比今天好。</p>
<p>事实上这是一种幻觉，明天不一定会更好，还有可能会更坏。</p>
<p>一个不平静的人，无论给他什么样的条件，他都不得安宁，因为他没有获得幸福的能力。</p>
<p>我们生而为人，既不能活在过去，亦不能活在未来，我们所拥有的，只有一分一秒正在流逝的当下。所以把握住当下，这一分一秒的平静就是最重要的。</p>
<p>看了我的答案肯定会有人说：「我觉得你所谓的平静还不够，我要追求的是天天开心。」</p>
<p>我们很多时候所谓的开心，即感官之快乐。</p>
<p>同样是愉悦，做爱和读书带来的就不一样。前者的快乐亦即感官的快乐，这种感觉让人飘飘然，茫然而不知所措。而后者则悠远而绵长，回味无穷，因为它是平静的。</p>
<p>一个人如果很容易快乐，那么相应的，他也将很容易哭泣。因为他感性，情绪波动大。而同样的一件事情，带来的痛苦往往比快乐大得多。</p>
<p>试想想，同样是一万块钱，是你得到时的快乐多还是失去时的痛苦多？</p>
<p>年轻的时候，对所有能让人开心的事，要保持谨慎的态度：比如熬夜玩游戏；比如性爱；比如抽烟；比如喝酒。</p>
<p>最后我们会发现，每一个能让你开心的事情，背后都会付出更为沉重的代价。</p>
<p>一个懂得审时度势的人，应该学会避免不必要的痛苦，而不是去一味追求快乐。</p>
<p>关于这个话题太大，和我们讨论的题目关系不大，所以用一句话概括之，即「片刻之欢愉，不如须臾之宁静」。</p>
<p>我记得有一次搭地铁，整个车厢里的人都显得很焦躁。和无数个早晨一样，人们都显出一副很忙的样子，不停地按手机，打电话，聊天刷微信，抖腿，东张西望。</p>
<p>唯有一个女生静静地坐在那里，手安静地放在膝盖上，一动不动，像一棵树一样，不争不取，不偏不倚，安静地生长。注视着她，我想起了一首诗：</p>
<p>草在结它的种子，</p>
<p>风在摇它的叶子，</p>
<p>我们站着，不说话。</p>
<p>就十分美好。</p>
<p>有些人注定要在人群中卓尔不群，因为她的修养，因为她的气质。</p>
<p>我以前根本不知道自己要追求怎样的女孩，孝顺？多金？漂亮？聪明？</p>
<p>在这一刻我明白了，这就是我要追求的人，要追求的人生。</p>
<p>2</p>
<p>独处的能力</p>
<p>总有一天，你会明白，独处的能力有多重要。</p>
<p>你是否也有过这样的时刻？</p>
<p>高中的时候，很清楚的记得女生上厕所都喜欢三两结伴一起去。不是因为彼此刚好都有需求，只是想有个人说说话不无聊。</p>
<p>大学食堂，多是两人或以上一起吃饭。如果是一个人吃饭，便打包回宿舍。不是人多坐不下，而是一个人吃饭的身影显得孤单又凄凉。</p>
<p>电影院，更多的是一对对的情侣和三两成群的好友。不是一个人不能感受，而是好像有人一起分享悲喜和情怀才够味儿。</p>
<p>一个人的时候，似乎无论何处，总是叫人觉着孤单，羞赧而别扭。</p>
<p>在这个人以群居的社会，我们好像很难忍受「一个人」。在这个快节奏的时代，我们好像很难专注「一个人」。课本、课堂也从来没有教育过我们如何学会独处的能力，如何享受一个人的时光。</p>
<p>而这两年，我已慢慢习得了这种能力。</p>
<p>因为逐渐意识到，即便是和自己有着血浓于水关系的父母，也终有别离的一天；</p>
<p>即便是关系再好的朋友也有因自己的生活而顾不上你的时刻；</p>
<p>即便是情深的伉俪也有生死别离到来的那一日；</p>
<p>即便有了孩子也是一个独立于你的个体，终有一日他将渴望一个没有你介入的世界。</p>
<p>那么这些时刻、这些岁月里，一个无法享受独处的人，是很难拥有真正的幸福和快乐的。</p>
<p>你必须要知道的是：</p>
<p>生病了，没有人能替你难受。那句被网友调侃了无数次的「多喝开水多休息」就是最好的灵丹妙药。</p>
<p>脆弱的时刻，没有人能给予你真正的强大，只有自己筑建坚强，自己给予自己力量。</p>
<p>悲伤的时候，没有人能擦干你心里的眼泪，即便他用纸巾温柔地拭去你脸上的泪水。</p>
<p>失意的时候，没有人在乎你蕴藏的才华和能力。只有不断积蓄能量用行动挥以他们最漂亮的一拳。</p>
<p>学会独立，习得独处能力，享受「一个人」。我开始爱上一个人的生活，一个人的时光。</p>
<p>一个人，读书，写字，绘画，听音乐。一个人吃饭，一个人出行，一个人看一场电影，一个人专心地练琴。一个人的夏日撑伞，一个人的冬日穿暖。一个人的日子里，照顾好自己的身体，安放好自己的情绪。</p>
<p>在我看来，即便恋爱了也该坚持拥有一个人的时光。</p>
<p>两个人在一起，是为了多一个人分享你一个人时的精彩与诗意，而不是去填补你一个人时的空洞与虚无。</p>
<p>两个人在一起，千万不要奢求由另一个人给予你一个人时没有的东西。</p>
<p>「雪中送炭」固然让人温暖，但如果你自己就是那块炭，拥有自燃产热的能力，那么是不是就没那么惧怕「寒冬飘雪」了？</p>
<p>比起「雪中送炭」，我更希望两个人在一起，是「锦上添花」。</p>
<p>你来与不来，我都是匹锦；你来更好，你不来我也很美。</p>
<p>英国心理学家唐纳德 · 温尼科特（Donald<br>W.Winnicott）说过，他认为恋人间完美的相处关系是「窝在爱人怀里孤独」。</p>
<p>我始终觉得，在所有形式的恋爱中，异地恋更是一场美好的恋爱。</p>
<p>能坚持下来的异地恋，在相爱的基础上，更多的是发生在两个人格独立和精神独立的人之间。它经受住了时间和距离的考验，更是练就了彼此独处的能力和拥抱孤独的心性。</p>
<p>而当你进入婚姻后，更该保留一个人独处的时光。</p>
<p>正如高伟所说，每个女人其实都是独身女人。女人灵魂的成长几乎是个人的事情，女人成长中的疼痛没有人可以代替。</p>
<p>婚姻里，即便是感情再好的夫妻，也不可能做到让两个原本必然存在差异的个体事事相通全然理解。</p>
<p>那么，一个人的时光里，避开那些繁杂和琐碎，沉浸专注于自己。</p>
<p>自己与自己对话，自己取悦自己，去排解那些不被理解的忧伤。然后，一个优雅的转身，和爱人互相扶持，和婚姻握手讲和。</p>
<p>蒋勋说，我渴望孤独；珍惜孤独。好像只有孤独，生命可以变得丰富而华丽。他说，孤独没有什么不好。使孤独变得不好，是因为你害怕孤独。</p>
<p>龙应台说，有些事，只能一个人做；有些关，只能一个人过；有些路，只能一个人走。</p>
<p>她说，修行的路，总是孤独的，因为智慧必然来自孤独。</p>
<p>对于他们的文字，我感同身受。</p>
<p>因为专注于一个人的时光，我坚持写了 15 年的日记，毕业后坚持了近 450 天的背单词。</p>
<p>我始终没有放弃从小热爱的绘画，我开始练钢琴，开始下厨，开始伺弄花草，开始着手微信公众号。</p>
<p>所有喜欢的事，所有想做的事，都在一个人的时光里，被温柔以待。</p>
<p>一个人的时光里，还有许多想学的事。例如：烘焙、PPT、摄影。我开始相信，孤独是饱满的。正像此刻在深夜码字的我，孤独而饱满。</p>
<p>一个人，还有许许多多的好处。</p>
<p>一个人吃饭，可以自在地享用美食，不用在意别人吃饭的快慢。</p>
<p>一个人跑步，可以按着自己的节奏，不用迎合别人跑步的速度。</p>
<p>一个人逛街，可以随性地挑选与试穿，不必担心旁人可能逐渐消磨的耐性。</p>
<p>一个人看电影，可以尽情欢笑与哭泣，不必惆怅那张哭花的脸取代了原本的精致妆容。</p>
<p>一个人旅行，不用配合别人的时间，「说走就走」不再是几次三番合计不下后的奢望。</p>
<p>一个人看风景，才能更清楚地看清沿途的美，因为那是仅属于你和风景之间单独的私会。</p>
<p>……</p>
<p>一个人的时光，你自由，任性，潇洒，放荡不羁。</p>
<p>所以，请试着去学会「一个人」，去习得独处的能力。你会发现，这种能力将让你受用一生。</p>
<p>少年读书之际，让你抵得住周遭的诱惑，在自律与孤独中求知。</p>
<p>青春等待爱情的岁月，让你更笃定「不将就」，更有底气更有自信去对抗世俗和年龄。</p>
<p>暮年之际，让你更有勇气与力量去面对另一半的离开，依旧精彩地过活。</p>
<p>杨绛先生在《我们仨》中深情描述了她和丈夫钱钟书的伉俪情深，和女儿钱瑗的母女情深。然而在女儿和丈夫相继去世后，仅剩一人的她又写了两本书，翻译和口述了各一本书，把丈夫钱钟书<br>7 万页的笔记整理成英文和中文笔记分别出版。</p>
<p>有人说，「人生最曼妙的风景，竟是内心的淡定与从容。我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系。」</p>
<p>我想，只有一个具有强大独处能力的人，才能在如此悲痛之余，继续建树生命的智慧和光芒。</p>
<p>我想，杨绛就是高伟口中「将孤独培育成孤绝」的女人。</p>
<p>总有那么些时刻，需要你用孤独去对抗；总有那些个岁月，需要你一个人踽踽独行。</p>
<p>我们必须明白，我们从孤独而来，最终回到孤独。</p>
<p>我依然记得那一晚，一个人去影院。买票时，售票小姐说，「一张吗？」</p>
<p>我说，「是的，一张。」</p>
<p>售票小姐不确定地又问了一遍，「是一个人吗？」</p>
<p>我说，「是的，就一个人，买一张票。」</p>
<p>语气平和而笃定。</p>
<p>终有一日，你不再是忍受「一个人」，而是享受「一个人」，你将拥有从未有过的平静和从容。</p>
<p>是的，世界很喧嚣，网络很热闹。而我希望，我们终将用独处时的平静和从容去感知生活中的鸟语花香，去对抗人生中的风雨飘摇。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>创建Markdown文章图床</title>
    <url>/2021/01/27/%E5%88%9B%E5%BB%BAMarkdown%E6%96%87%E7%AB%A0%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="VSCode-Github-PicGo-jsDelivr-搭建稳定快速高效图床"><a href="#VSCode-Github-PicGo-jsDelivr-搭建稳定快速高效图床" class="headerlink" title="VSCode + Github + PicGo + jsDelivr 搭建稳定快速高效图床"></a><center>VSCode + Github + PicGo + jsDelivr 搭建稳定快速高效图床</center></h1><p>&emsp;&emsp;图床是个什么玩意就不多说了，比较喜欢的是利用 Picgo 插件的 Github 图床，但是其服务器不在国内，访问起来比较的慢，甚至无法访问。所以需要利用到 jsDelivr CDN 加速 (jsDelivr 是一个免费开源的 CDN 解决方案)，Picgo 插件一键上传，GIthub 和 jsDelivr 又是知名大厂，不怕他删库跑路。</p>
<a id="more"></a>

<h4 id="这是转载的，感谢作者！"><a href="#这是转载的，感谢作者！" class="headerlink" title="这是转载的，感谢作者！"></a>这是转载的，感谢作者！</h4><h2 id="新建-Github-仓库"><a href="#新建-Github-仓库" class="headerlink" title="新建 Github 仓库"></a>新建 Github 仓库</h2><h4 id="1-创建新仓库，必须是-public"><a href="#1-创建新仓库，必须是-public" class="headerlink" title="1.创建新仓库，必须是 public"></a>1.创建新仓库，必须是 public</h4><div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/00.png" alt="00"></p>
</div>

<h4 id="2-进入个人设置页面，选择开发者设置"><a href="#2-进入个人设置页面，选择开发者设置" class="headerlink" title="2.进入个人设置页面，选择开发者设置"></a>2.进入个人设置页面，选择开发者设置</h4><div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/11.png" alt="11"></p>
</div>

<h4 id="3-选择-Personal-access-tokens，选择生成新-token，此-token-是图床上传时验证身份用的"><a href="#3-选择-Personal-access-tokens，选择生成新-token，此-token-是图床上传时验证身份用的" class="headerlink" title="3.选择 Personal access tokens，选择生成新 token，此 token 是图床上传时验证身份用的"></a>3.选择 Personal access tokens，选择生成新 token，此 token 是图床上传时验证身份用的</h4><div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/22.png" alt="22"></p>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/33.png" alt="33"></p>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/44.png" alt="44"></p>
</div>

<h4 id="4-添加描述，然后将-repo-选上"><a href="#4-添加描述，然后将-repo-选上" class="headerlink" title="4.添加描述，然后将 repo 选上"></a>4.添加描述，然后将 repo 选上</h4><div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/55.png" alt="55"></p>
</div>

<h4 id="5-将生成的字符串保存，关闭页面后将再也无法看到这个字符串了"><a href="#5-将生成的字符串保存，关闭页面后将再也无法看到这个字符串了" class="headerlink" title="5.将生成的字符串保存，关闭页面后将再也无法看到这个字符串了"></a>5.将生成的字符串保存，关闭页面后将再也无法看到这个字符串了</h4><div align = center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/66.png" alt="66"></p>
</div>

<h2 id="picgo-设置"><a href="#picgo-设置" class="headerlink" title="picgo 设置"></a>picgo 设置</h2><p>打开软件，安装相关插件</p>
<div align =center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/0.png" alt="0"></p>
</div>

<p>1.在 VsCode 左侧扩展栏里找到 PicGo 扩展项</p>
<br>

<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/1.png" alt="1"></p>
</div>

<p>2.左键单击 PiGgo 右下角的的齿轮图标，打开‘扩展设置’项</p>
<div align =center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/2.png" alt="2"></p>
</div>

<p>3.打开后的界面里的具体设置为：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/3.png" alt="3"></p>
<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo/blogs/pictures/30.png" alt="30"></p>
</div>

<h4 id="具体设置为"><a href="#具体设置为" class="headerlink" title="具体设置为:"></a>具体设置为:</h4><p>1.current 设置为 GitHub</p>
<p>2.Branch 是我们仓库的分支，默认为 master</p>
<p>3.custom url 使我们图片上传的连接，有两种方式可以使用</p>
<ul>
<li><p>1.原生方式</p>
<ul>
<li><p>1.使用 GitHub 原生连接，格式为 <a href="https://raw.githubusercontent.com/[%E7%94%A8%E6%88%B7%E5%90%8D]/[%E4%BB%93%E5%BA%93%E5%90%8D]/[%E5%88%86%E6%94%AF%E5%90%8D]">https://raw.githubusercontent.com/[用户名]/[仓库名]/[分支名]</a></p>
</li>
<li><p>2.我的例子 <a href="https://raw.githubusercontent.com/leiyu1997/PicBed/master">https://raw.githubusercontent.com/leiyu1997/PicBed/master</a></p>
</li>
<li><p>3.原生方式有一个弊端就是国内速度比较感人。</p>
</li>
</ul>
</li>
<li><p>2.cdn 加速方式</p>
<ul>
<li><p>1.格式为 <a href="https://cdn.jsdelivr.net/gh/[%E7%94%A8%E6%88%B7%E5%90%8D]/[%E4%BB%93%E5%BA%93%E5%90%8D]@[%E5%88%86%E6%94%AF%E5%90%8D]">https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@[分支名]</a></p>
</li>
<li><p>2.我的例子 <a href="https://cdn.jsdelivr.net/gh/leiyu1997/PicBed@master">https://cdn.jsdelivr.net/gh/leiyu1997/PicBed@master</a></p>
</li>
<li><p>3.cdn 加速的优点是国内访问速度比较快</p>
</li>
</ul>
</li>
</ul>
<br>

<p><strong>Ctrl + Alt + U 图片在剪贴板上</strong></p>
<br>

<p><strong>Ctrl + Alt + E 从文件夹中选择图片</strong></p>
<p>注意：如果重新安装安装软件或重新安装 PicGo 插件，则要重新设置上述操作。否则无法上传图片。</p>
<h3 id="接下来就是愉快的写作过程了，如丝般顺滑。啧啧！"><a href="#接下来就是愉快的写作过程了，如丝般顺滑。啧啧！" class="headerlink" title="接下来就是愉快的写作过程了，如丝般顺滑。啧啧！"></a>接下来就是愉快的写作过程了，如丝般顺滑。啧啧！</h3><!--  这是一种注释
&ensp;&ensp; 等待
<br/>
&emsp;等等
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;等等-->
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>合并文件夹内所有工作薄的所有工作表</title>
    <url>/2021/02/02/%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E8%96%84%E7%9A%84%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="这是第一个"><a href="#这是第一个" class="headerlink" title="这是第一个"></a>这是第一个</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这个是最完善的一个，值得借鉴</span><br><span class="line"># 导入库</span><br><span class="line">import pandas as pd</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.DataFrame()</span><br><span class="line">path_str &#x3D; r&#39;D:\jupyter notebook\test&#39;</span><br><span class="line"></span><br><span class="line">for excel_str in os.listdir(path_str):</span><br><span class="line">    print(&#39;需要合并的文件:&#39;, path_str + excel_str)</span><br><span class="line"></span><br><span class="line">    new_path &#x3D; os.path.join(path_str, excel_str)</span><br><span class="line">    if os.path.isfile(new_path):</span><br><span class="line">        excel &#x3D; pd.ExcelFile(new_path)</span><br><span class="line">        for sheet in excel.sheet_names:</span><br><span class="line"></span><br><span class="line">            sheet_excel &#x3D; excel.parse(sheet)</span><br><span class="line">            sheet_excel[&#39;test&#39;] &#x3D; excel_str.split(&#39;.&#39;)[0]  # 将原工作簿名作为合并后工作表的列</span><br><span class="line">            df &#x3D; pd.concat([df, sheet_excel])</span><br><span class="line"></span><br><span class="line"># 导出到原文件夹</span><br><span class="line"></span><br><span class="line"># if os.path.exists(new_str):</span><br><span class="line">#     os.remove(new_str)</span><br><span class="line">new_str &#x3D; os.path.join(path_str, &#39;合并文件.xlsx&#39;)</span><br><span class="line">df.to_excel(new_str, index&#x3D;False)</span><br><span class="line">print(&#39;合并后数据的大小:&#39;, df.shape)</span><br><span class="line">print(&#39;合并工作已完成，请到原文件夹内查看结果！&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="这是第二个"><a href="#这是第二个" class="headerlink" title="这是第二个"></a>这是第二个</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 合并同一文件夹下工作薄名相似的所有工作表，这是最完整的一个</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import datetime as dt</span><br><span class="line"></span><br><span class="line">import glob</span><br><span class="line">import os</span><br><span class="line"># runDir &#x3D; r&#39;D:\jupyter notebook\test\11.xlsx&#39;</span><br><span class="line"># if os.getcwd()!&#x3D;runDir:</span><br><span class="line">#     os.chdir(runDir)</span><br><span class="line">files &#x3D; glob.glob(&#39;11*.xlsx&#39;)</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.DataFrame()</span><br><span class="line"></span><br><span class="line">for each in files:</span><br><span class="line">    sheets &#x3D; pd.ExcelFile(each).sheet_names</span><br><span class="line"></span><br><span class="line">    for sheet in sheets:</span><br><span class="line">        df &#x3D; df.append(pd.read_excel(each, sheet, index_col&#x3D;0))</span><br><span class="line"></span><br><span class="line">df.to_excel(r&#39;D:\jupyter notebook\test\1111.xlsx&#39;, index&#x3D;False)</span><br><span class="line">print(&#39;数据大小为:&#39;, df.shape)</span><br></pre></td></tr></table></figure>
<h3 id="这是合并一个工作薄内的所有工作表"><a href="#这是合并一个工作薄内的所有工作表" class="headerlink" title="这是合并一个工作薄内的所有工作表"></a>这是合并一个工作薄内的所有工作表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.ExcelFile(&#39;your_file&#39;)</span><br><span class="line"></span><br><span class="line">df_new &#x3D; pd.DataFrame()</span><br><span class="line"></span><br><span class="line">for name in df.sheet_names:  # 获取每个Sheet的名称</span><br><span class="line">    # 循环读取每个Sheet表内容，同时设置某列为字符串，避免长数字文本被识别为数字</span><br><span class="line">    df_pre &#x3D; df.parse(sheet_name&#x3D;name, dtype&#x3D;&#123;&#39;columns_name&#39;: str&#125;)</span><br><span class="line">    df_new &#x3D; df_new.append(df_pre)</span><br><span class="line"></span><br><span class="line">df_new.to_excel(&#39;your_newfile&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="这是简单高效的方法"><a href="#这是简单高效的方法" class="headerlink" title="这是简单高效的方法"></a>这是简单高效的方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Folder_Path &#x3D; r&#39;D:\jupyter notebook\test&#39;</span><br><span class="line">file_list &#x3D; os.listdir(Folder_Path)</span><br><span class="line"></span><br><span class="line">dfs &#x3D; []</span><br><span class="line">for item in file_list:</span><br><span class="line">    print(&#39;需要合并的文件为:&#39;, Folder_Path+item)</span><br><span class="line">    dfs.append(pd.read_excel(Folder_Path + &#39;\\&#39; + item))</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.concat(dfs, sort&#x3D;False)</span><br><span class="line">df.to_excel(r&#39;D:\jupyter notebook\test\test.xlsx&#39;, index&#x3D;False)</span><br><span class="line">print(&#39;合并后的数据大小为:&#39;, df.shape)</span><br><span class="line">print(&#39;合并完成&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这个带进度表</span><br><span class="line"></span><br><span class="line">dir &#x3D; &#39;test&#x2F;&#39;</span><br><span class="line">filenames &#x3D; os.listdir(dir)</span><br><span class="line">index &#x3D; 0</span><br><span class="line">dfs &#x3D; []</span><br><span class="line">for name in filenames:</span><br><span class="line">    print(&#39;正在处理第&#39; + str(index+1) + &#39;个表格&#39;)</span><br><span class="line">    dfs.append(pd.read_excel(os.path.join(dir, name)))</span><br><span class="line">    index +&#x3D; 1</span><br><span class="line">df &#x3D; pd.concat(dfs)</span><br><span class="line">df.to_excel(&#39;test&#x2F;total.xlsx&#39;, index&#x3D;False)</span><br></pre></td></tr></table></figure>
<h3 id="这是一个更高级的用函数来写多功能的"><a href="#这是一个更高级的用函数来写多功能的" class="headerlink" title="这是一个更高级的用函数来写多功能的"></a>这是一个更高级的用函数来写多功能的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import xlrd</span><br><span class="line">import xlsxwriter</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_file_list(dir, file_type_list&#x3D;[&#39;txt&#39;, &#39;csv&#39;, &#39;xlsx&#39;, &#39;xls&#39;], file_list&#x3D;[]):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    获取指定文件夹下指定类型文件路径</span><br><span class="line">    :param dir: 文件夹路径</span><br><span class="line">    :param file_type_list: 文件类型</span><br><span class="line">    :param file_list: 文件列表</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    for root, _, files in os.walk(dir):</span><br><span class="line">        for file in files:</span><br><span class="line">            file_type &#x3D; file[file.rfind(&#39;.&#39;) + 1:]</span><br><span class="line">            if file_type in file_type_list:</span><br><span class="line">                file_list.append(os.path.join(root, file))</span><br><span class="line">    return file_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def merge_xlsx_files(file_dir_path, out_file_path,</span><br><span class="line">                     file_type_list&#x3D;[&#39;txt&#39;, &#39;csv&#39;, &#39;xlsx&#39;, &#39;xls&#39;],</span><br><span class="line">                     out_file_name&#x3D;&#39;result.xlsx&#39;):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    合并目录下指定类型的文件</span><br><span class="line">    :param file_dir_path: 文件夹路径</span><br><span class="line">    :param out_file_path:  输出文件夹路径</span><br><span class="line">    :param file_type_list: 需要合并的文件类型</span><br><span class="line">    :param out_file_name:  输出文件名称</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    file_paths &#x3D; get_file_list(file_dir_path, file_type_list)</span><br><span class="line">    if not os.path.exists(out_file_path):</span><br><span class="line">        os.makedirs(out_file_path)</span><br><span class="line">    dfs &#x3D; []</span><br><span class="line">    for file in file_paths:</span><br><span class="line">        print(f&#39;file&#x3D;&#123;file&#125;&#39;)</span><br><span class="line">        dfs.append(pd.read_excel(file))</span><br><span class="line">    df &#x3D; pd.concat(dfs)</span><br><span class="line">    df.to_excel(os.path.join(out_file_path, out_file_name), index&#x3D;False)</span><br><span class="line">    print(f&#39;out_file_path&#x3D;&#123;out_file_path&#125;&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    file_dir_path &#x3D; os.path.join(sys.path[0], r&#39;D:\jupyter notebook\test&#39;)</span><br><span class="line">    out_file_path &#x3D; os.path.join(sys.path[0], r&#39;D:\jupyter notebook\test&#39;)</span><br><span class="line">    merge_xlsx_files(file_dir_path, out_file_path, [&#39;xls&#39;])</span><br></pre></td></tr></table></figure>
<h3 id="这个是带用弹窗保存的"><a href="#这个是带用弹窗保存的" class="headerlink" title="这个是带用弹窗保存的"></a>这个是带用弹窗保存的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># python pandas合并多个excel(xls和xlsx)文件（弹窗选择文件夹和保存文件）</span><br><span class="line"></span><br><span class="line">import tkinter as tk</span><br><span class="line">from tkinter import filedialog</span><br><span class="line">import os</span><br><span class="line">import pandas as pd</span><br><span class="line">import glob</span><br><span class="line"></span><br><span class="line">root &#x3D; tk.Tk()</span><br><span class="line">root.withdraw()</span><br><span class="line"></span><br><span class="line"># 选择文件夹位置</span><br><span class="line">filelocation &#x3D; os.path.normpath(</span><br><span class="line">    filedialog.askdirectory(initialdir&#x3D;os.getcwd()))</span><br><span class="line">lst &#x3D; []</span><br><span class="line"></span><br><span class="line"># 读取文件夹下所有文件（xls和xlsx都读取）</span><br><span class="line">for i in glob.glob(filelocation + &quot;\\\\&quot; + &quot;*.*&quot;):</span><br><span class="line">    if os.path.splitext(i)[1] in [&quot;.xls&quot;, &quot;.xlsx&quot;]:</span><br><span class="line">        lst.append(pd.read_excel(i))</span><br><span class="line"></span><br><span class="line"># 保存合并后的excel文件</span><br><span class="line">writer &#x3D; pd.ExcelWriter(filedialog.asksaveasfilename(title&#x3D;&quot;保存&quot;, initialdir&#x3D;filelocation,</span><br><span class="line">                                                     defaultextension&#x3D;&quot;xlsx&quot;, filetypes&#x3D;[(&quot;Excel 工作簿&quot;, &quot;*.xlsx&quot;), (&quot;Excel 97-2003 工作簿&quot;, &quot;*.xls&quot;)]))</span><br><span class="line">pd.concat(lst).to_excel(writer, &#39;all&#39;, index&#x3D;False)</span><br><span class="line">writer.save()</span><br><span class="line"></span><br><span class="line">print(&#39;\n%d个文件已经合并成功！&#39; % len(lst))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Python必须要养成的几个习惯</title>
    <url>/2021/02/19/%E5%AD%A6%E4%B9%A0Python%E5%BF%85%E9%A1%BB%E8%A6%81%E5%85%BB%E6%88%90%E7%9A%84%E5%87%A0%E4%B8%AA%E4%B9%A0%E6%83%AF/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/296731634">源自知乎</a>感谢作者，以此来鞭策及督促自己学习。</p>
<p>首先，我就是从零基础开始学的 Python，在学习 Python 前，首先你要具备以下条件。</p>
<p>1、能够坚持学下去的精神<br>2、一台电脑</p>
<p>没错，就只要这两点，就可以学会 Python，因为 Python 本身设计的目的就是简单易上手，换句话来说，学会 Python，有手就行。</p>
<a id="more"></a>

<p>对于小白来说，有个人引导会比自学要高效的多，尤其容易坚持不下去的小伙伴。</p>
<p>但有句话也说的好，师傅领进门，修行看个人。学习 Python 是需要一个 “师傅” 带你入门的。Python 的初步学习十分简单。</p>
<p>在学习完这些 Python 的基础课程之后，你已经对编程的世界有了初步的认识，不过在你进一步向更深处学习 Python 之前，你需要再审视一下你的学习之路，想想你能把 Python 用在生活中的哪里。</p>
<blockquote>
<p>你或许可以通过新学的 Python 去完成一些重复性的任务。<br>你或许可以靠 Python 提高工作效率。<br>你或许可以用 Python 赚点外快。<br>你又或许可以直接转行成为一名程序员。<br>如果你一时间想不到 Python 的用武之地，你不妨先放下 Python，等到生活中需要 Python 去解决一些问题的时候在重新回来学习 Python。<br>如果你打算继续深入，先做到以下两点。<br>找到一个适合自己的 IDE。好的 IDE，可以帮助你很快完成任务。<br>明确方向。这决定你会在 Python 这条路上走多远。</p>
</blockquote>
<p>最后，努力学习，学以致用。生活中可以用到 Python 的位置远比你想象的多得多，等到你学会 Python 之后你会发现生活中有很多的问题都是可以通过 Python 来帮助你快速解决的。</p>
<p>学编程最需要的就是耐心！现在大家想学编程太方便了，跟着教程满天飞。刚开始入门的时候有高手带，往往能有事半功倍的效果，尤其是自己不知道怎么找资料，怎么去配置编程环境什么的时候。有人手把手教的话，入门就高效很多了。</p>
<p>还是想先泼点冷水！不要被市面上的各种 Python 培训广告冲昏了头脑：</p>
<p>① 学完 Python，并不能立马拿一两万的工资，甚至可能找不到工作！</p>
<p>②Python 也没有那么简单，不是有手就行！</p>
<p>③别想着 1 个月、2 个月就能学会，你至少得腾出半年时间全职学习！</p>
<p>如果你还是执意要学 Python，那么好，接下来我们看看怎么学。Python 作为一门脚本语言，难度上相较于其他语言略微简单点。但对于没有计算机基础的人来说，可能最开始配置 Python 编译环境都能让他望而却步。这里推荐一个无需安装配置的在线编程平台（新手可以先在线写一段时间的代码，适应下）</p>
<p>1、Python 学习路线图</p>
<p>学习一定不是盲目的，只有先明确了要学哪些东西，怎么学，才能更高效地去学 Python。</p>
<p>这是 Python 的整个知识体系图谱，对于新手来说，没必要学那么多。先把 Python 基础和进阶知识吃透，才是入门的关键。后续你是往前端开发深造，还是去新潮时髦的大数据、人工智能，就全凭自己的兴趣。但我相信这时候的你，应该不会像现在这么迷茫。</p>
<p>2、关于如何学 Python</p>
<p>其实网上的 Python 课程很多，都是比较有体系的。学 Python 入门和进阶的知识，用网课完全足够。但 Python 本质上是对一门语言工具的运用，实战比理论更重要。</p>
<p>我们在学习的时候一定要多敲、多练、多思考！！！</p>
<p>写代码不只是跟着视频课或者照着书本写完就行的，我们要理清每行代码的逻辑。刚开始学，最好对每一句代码都加以注释，帮助我们理清逻辑，加深印象。</p>
<p>同时，学完一个知识点后应该多去找对应的案例来练习，做到理论与实战的深度结合。</p>
<p>3、Python 学习资源</p>
<p>Python 书籍：</p>
<p>《零基础入门学习Python》</p>
<p>《Think Python 2e 中译版》</p>
<p>《Python+Cookbook》第三版中文v3.0.0</p>
<p>《Python数据科学手册》</p>
<p>《Python知识手册-v2.2》</p>
<p>学习网站：</p>
<p><a href="http://www.pythontutor.com/visualize.html#mode=edit">在线工具Python代码运行原理过程演示</a></p>
<p>最后，自学 Python 最重要的就是心态。我们在学习过程中必然会遇到很多难题，可能自己想破脑袋都无法解决。这都是正常的，千万别急着否定自己，怀疑自己。找一个靠谱点的师兄，没事知乎一下，其实这些难题也就迎刃而解了。</p>
<p>在学习 Python 的过程中需要养成几个好习惯。</p>
<p>下面我给大家分享几条：</p>
<blockquote>
<p>缩进</p>
</blockquote>
<p>由于跟其他编程语言的区别性，缩进在 python 编程中显得十分重要；在 Python 的代码块中必须使用相同数目的行首缩进空格数，否则会造成脚本运行错误，提示你格式不正确之类的信息。因此，在使用 python 语言写脚本的时候，保证缩进的一致性相当重要。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211018.png" alt="20210218211018"></p>
</div>

<blockquote>
<p>空格</p>
</blockquote>
<p>虽然在 python 编程过程中，空行并不是 Python 语法的必需部分，但是，保持函数之间或类的方法之间用空行分隔，可以使得代码看起来更加清晰明了，也有利于后期的代码维护或重构。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211111.png" alt="20210218211111"></p>
</div>

<blockquote>
<p>注释</p>
</blockquote>
<p>注释相对经常使用编程语言的人来说应该不是很陌生吧，主要因为注释不仅使得阅读代码的人容易理解，也让代码作者更好地定位代码函数等。python 跟其它语言一样，注释在一些该注释的地方，可以让效率事半功倍。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211352.png" alt="20210218211352"></p>
</div>

<blockquote>
<p>源代码</p>
</blockquote>
<p>python 作为完全开源的语言，代码对于任何人都可以随意浏览。这种方式可以更好地帮助人们发现有利精简扼要的代码，在很多方面可以省去不必要的时间，因为觉得合适可以直接拿过来使用或者简单修改。经常看一下好的源代码，不仅会让你学习别人的编程方式，还在另一方面大大的帮助你更好地学习。</p>
<blockquote>
<p>编程思想</p>
</blockquote>
<p>使用任何一门编程语言，都需要保持很好的编程思想，对 python 来说也是一样的。学会创造使用适合自己的编程思想是至关重要的，因此，去多读一些讲解编程思想之类的书籍来充实自己吧。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211449.png" alt="20210218211449"></p>
</div>

<blockquote>
<p>多实践</p>
</blockquote>
<p>学习任何一门编程语言都需要多做多写多看，通过不同的项目，来让自己得到更好的锻炼，相信是一件很棒的事情。在业余时间，经常的去敲写一些代码，也是很有意思的。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211542.png" alt="20210218211542"></p>
</div>

<p>兴趣<br>兴趣是成功的一半，兴趣促使你更好地去使用学习编程语言，而不单单为了忙碌的工作。很多创造出编程语言的人来说，正时因为兴趣的使然，才成就了如此好的一些编程语言。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210218211606.png" alt="20210218211606"></p>
</div>
]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>将本地项目上传到Github</title>
    <url>/2021/02/14/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u014135752/article/details/79951802">本文来源</a></p>
<p>首先你需要一个 github 账号，所有还没有的话先去注册吧！</p>
<p><a href="https://github.com/">https://github.com/</a></p>
<p>我们使用 git 需要先安装 git 工具，这里给出下载地址，下载后一路直接安装即可：</p>
<p><a href="https://git-for-windows.github.io/">https://git-for-windows.github.io/</a></p>
<ol>
<li>进入 Github 首页，点击 New repository 新建一个项目</li>
</ol>
<a id="more"></a>

<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160444.png" alt="20210213160444"></p>
</div>

<ol start="2">
<li>填写相应信息后点击 create 即可 </li>
</ol>
<p>Repository name: 仓库名称</p>
<p>Description (可选): 仓库描述介绍</p>
<p>Public, Private : 仓库权限（公开共享，私有或指定合作者）</p>
<p>Initialize this repository with a README: 添加一个 README.md</p>
<p>gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore</p>
<p>license: 证书类型，对应生成文件 LICENSE</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160533.png" alt="20210213160533"></p>
</div>

<ol start="3">
<li>点击 Clone or dowload 会出现一个地址，copy 这个地址备用。</li>
</ol>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160640.png" alt="20210213160640"></p>
</div>

<ol start="4">
<li>接下来就到本地操作了，首先右键你的项目，如果你之前安装 git 成功的话，右键会出现两个新选项，分别为 Git Gui Here,Git Bash Here, 这里我们选择 Git Bash Here，进入如下界面，Test_Bluetooth 即为我的项目名。</li>
</ol>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160729.png" alt="20210213160729"></p>
</div>

<ol start="5">
<li>接下来输入如下代码（关键步骤），把 github 上面的仓库克隆到本地</li>
</ol>
<p>git clone <a href="https://github.com/CKTim/BlueTooth.git%EF%BC%88https://github.com/CKTim/BlueTooth.git">https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git</a> 替换成你之前复制的地址）</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160753.png" alt="20210213160753"></p>
</div>

<ol start="6">
<li>这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你 github 上面的项目名，如图我多出了个 Test 文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下</li>
</ol>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160827.png" alt="20210213160827"></p>
</div>

<ol start="7">
<li>接着继续输入命令 cd Test，进入 Test 文件夹</li>
</ol>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213160852.png" alt="20210213160852"></p>
</div>

<ol start="8">
<li>接下来依次输入以下代码即可完成其他剩余操作：</li>
</ol>
<p>git add .        （注：别忘记后面的.，此操作是把 Test 文件夹下面的文件都添加进来）</p>
<p>git commit  -m  ” 提交信息”  （注：“提交信息” 里面换成你需要，如 “first commit”）</p>
<p>git push -u origin master   （注：此操作目的是把本地仓库 push 到 github 上面，此步骤需要你输入帐号和密码）</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210213161016.png" alt="20210213161016"></p>
</div>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析之pandas</title>
    <url>/2021/01/28/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas/</url>
    <content><![CDATA[<p>&emsp;&emsp;最近开始学习使用Python的Pandas库处理工作中的一些重复性劳动，发现它真是个好东西，用起来真是太高效了。由于一直都处于零散的学习状态，现在对这些知识进行一个简单的总结，以便于形成知识体系。个人认为知识只有形成了体系才能灵活的应用。</p>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>series 类似一维数组，他由一组数据及数据对应的标签组成。说是类似数组，但其实和数组是有区别的，主要是由于 Series 的索引的存在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pandas import Series, DataFrame</span><br><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure>
<p><code>obj = Series([1,2,3,4])# 创建一个Series对象，如果不声明索引，则默认的索引是0到N-1(N是数据的长度)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj.index 代表Series对象的索引，我们可以手动声明索引</span><br><span class="line">obj.values 代表Series对象的值，此时才相当于数组，即为python中的list</span><br></pre></td></tr></table></figure>
<p>我们可以手动声明 series 的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj2&#x3D; Series([1,2,3,4], index&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line">obj2[&#39;c&#39;]#通过索引获取元素的值</span><br></pre></td></tr></table></figure>
<p>判断是否缺失数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj2.isnull() #使用series对象的方法，返回series，值为True或False</span><br><span class="line">pd.isnull(obj2) # 使用pandas的方法</span><br><span class="line">pd.notnull(obj2)</span><br></pre></td></tr></table></figure>
<p>series 对象本身及其索引都有一个 name 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdata &#x3D; &#123;&#39;ohino&#39;: 3500, &#39;texas&#39;: 7100, &#39;utah&#39;: 500&#125;</span><br><span class="line">obj &#x3D; Series(sdata)</span><br><span class="line">obj.name &#x3D; &#39;population&#39;</span><br><span class="line">obj.index.name &#x3D; &#39;state&#39;</span><br></pre></td></tr></table></figure>
<h2 id="Series-总结"><a href="#Series-总结" class="headerlink" title="Series 总结"></a>Series 总结</h2><p>Series 可以看成是一个定长的有序字典，可以认为字典的 key 值即为对应的 Series 的值的索引。</p>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>Dataframe 是一种表格型的数据结构，可以看成 Series 组成的字典，最常用的构建方法是传入一个由登场列表或者 numpy 数组组成的字典。DataFrame 会自动加上索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#x3D; &#123;‘state’: [&#39;ohio&#39;,&#39;ohio&#39;,&#39;ohio&#39;], &#39;year&#39;: [2001, 2002, 2003], &#39;pop&#39;: [1.5, 1.6, 1.7]&#125;</span><br><span class="line">frame &#x3D; DataFrame(data, columns&#x3D;[&#39;year&#39;, &#39;state&#39;,&#39;pop&#39;])</span><br></pre></td></tr></table></figure>
<p>获取元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame[&#39;state&#39;]#获取Series，返回的Series与原来的DataFrame有相同的索引。而且其name属性已经被设置为该columns的值，即为state</span><br><span class="line">frame.state # 也可以使用属性的方式获取series</span><br></pre></td></tr></table></figure>
<p>当需要获取一行元素时，使用位置或者名称的方式进行获取。<br><code>frame.ix[2] #获取第三行数据，此时仍为series，只是columns的值变成了索引</code></p>
<p>另一种常见的数据形式是嵌套字典，外层的字典的键作为列，内层字典的键作为行索引，内层字典的键会被合并，排序，形成最终的索引，也可以指定索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame.values #以二维数组的方式返回DataFrame中的数据</span><br><span class="line">frame.index.name #设置索引的名字</span><br><span class="line">frame.columns.name #设置columns的名字</span><br></pre></td></tr></table></figure>
<h2 id="DataFrame-切片"><a href="#DataFrame-切片" class="headerlink" title="DataFrame 切片"></a>DataFrame 切片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj[val]# 选取DataFrame的单个列或者一组列</span><br><span class="line">obj.ix[val] # 选取DataFrame的单个行或者一组行</span><br><span class="line">obj.ix[:,val] #选取单个列或者列子集</span><br><span class="line">obj.ix[val1, val2] #同时选取行和列</span><br></pre></td></tr></table></figure>
<h2 id="DataFrame-和-Series-之间的运算"><a href="#DataFrame-和-Series-之间的运算" class="headerlink" title="DataFrame 和 Series 之间的运算"></a>DataFrame 和 Series 之间的运算</h2><p>默认情况下，DataFrame 和 Series 之间的算术运算会将 Series 的索引匹配到 DataFrame 的列，然后沿着行一直向下传播</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame &#x3D; DataFrame(np.arange(12.).reshape((4,3)), columns&#x3D;list(&#39;bde&#39;), index&#x3D;[&#39;Utah&#39;, &#39;Ohio&#39;, &#39;Texas&#39;, &#39;Oregon&#39;])</span><br><span class="line">series &#x3D; frame.ix[0]</span><br></pre></td></tr></table></figure>
<p><code>frame - series = DataFrame(&#123;&#39;b&#39;:[0,3,6,9],&#39;d&#39;:[0,3,6,9],&#39;e&#39;:[0,3,6,9]&#125;, index=[&#39;Utah&#39;, &#39;Ohio&#39;, &#39;Texas&#39;, &#39;Oregon&#39;])</code></p>
<p>是因为逐行传播的原因，frame 每一行的元素都会减去 series 的对应值。</p>
<p>如果某个索引值在 DataFrame 的列或者 Series 的索引中找不到，则参与运算的两个对象就会被重新索引形成并集</p>
<p><a href="http://www.airghc.top/2017/04/27/python/">转自</a></p>
<p>这位兄弟的总结太好了，谢谢。我只是来学习的，学习用Markdown语法写作，真是太好了。</p>
]]></content>
      <categories>
        <category>Python库之Pandas</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>没有深度思考勤奋都是扯淡</title>
    <url>/2021/01/30/%E6%B2%A1%E6%9C%89%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E5%8B%A4%E5%A5%8B%E9%83%BD%E6%98%AF%E6%89%AF%E6%B7%A1/</url>
    <content><![CDATA[<p>&emsp;&emsp;在今天去看我们周遭的信息环境，不得不说移动互联网的普及让人对信息的摄取广度有了延展，却因此限制了我们摄取信息的深度。我们日常的视野中，总是充斥着碎片化信息之 “过” 的问题——即 99% 的东西，与我们一点关系都没有，或者说在 “浅尝辄止，浮于表面” 的思考模式下对我们没有任何价值。<br>&emsp;&emsp;麦克卢汉曾说：我们创造了工具，工具反过来塑造我们。放到现在来看，也是一样的：一旦你习惯了 “低成本、高回报” 的刺激，你就很难去做那些 “高投入” 的事情，因此成为“低效勤奋者”——看起来每天忙碌，到头来却一无所获。<br>&emsp;&emsp;为什么？因为战术上你很勤奋，实际上却刻意回避了真正困难却更有价值的部分——战略思维与战略决策。而这种 “战略思维懒惰” 的行为，最终会导致你战略决策失误，陷入了低成长的陷阱。<br>&emsp;&emsp;其实，人生最大的悲哀，莫过于将一辈子的聪明，都耗费在肢体的勤奋上。要想成为真正的 “高成长人群”，防止你与预期 “背道而驰”，就要学会并保持深度思考的能力。今天这篇文章，希望能对你有所启发。<br>&emsp;&emsp;许多人宁愿做 “低效勤奋者”也不愿意深度思考。以下这个故事，人们常常用来说明执行力的问题。其实是只知其一，不知其二。<br>&emsp;&emsp;张三和李四同时受雇于一家店铺，拿着同样的薪水。 一段时间后，张三升职加薪，李四却没有，于是李四找老板理论。老板对他说：“李四，你现在帮我到集市上去一下，看看今天早上有什么卖的。”不一会儿，李四从集市回来，向老板汇报：“只有一个农民拉了一车土豆在卖。” 老板问：“有多少？” 李四不知道，于是赶紧又跑到集市上，然后回来告诉老板：“一共 40 袋土豆。” 老板又问他：“价格呢？” 李四说：“您没有叫我打听价格啊。”<br>&emsp;&emsp;于是老板让李四先坐下休息，并把张三叫来，吩咐他说去做同一件事。 张三回来，向老板汇报：“今天集市上只有一个农民在卖土豆，一共 40 袋，价格是两毛五分钱一斤。我看了一下，这些土豆的质量不错，价格也便宜，根据我们以往的销量，40 袋土豆在一个星期左右就可以全部卖掉，一定能赚钱。”<br>&emsp;&emsp;此时老板转向了李四，说：“现在你知道为什么张三的薪水比你高了吧？”<br>&emsp;&emsp;从执行力角度看，是李四做事没有责任心；但再深入地分析，他的思维方式存在问题，他有两个方面不如张三：一是不愿多动脑筋深入思考，二是釆取低级思考方式，很多方面想不到。伯特兰 · 罗素说：“许多人宁愿死，也不愿思考，事实上他们也确实至死都没有思考。”观察我们身边不少看似勤奋的人，却混得不行，为什么？因为他们是 “低效勤奋者”。“低效勤奋者” 有两个特征：不愿深入思考，釆取低级思考。这就导致他们做事效率低，效能低，成长慢。“低效勤奋者” 之所以不愿深入思考与釆取低级思考，是因为这些人不会深度思考。学渣与学霸之间的差别就在于深度思考。普通员工与卓越员工之间的差别也在于深度思考。小老板与大老板之间的差别更在于深度思考。<br>&emsp;&emsp;从 “被动学习” 向“主动学习”升级深度思考，首先是从 “被动学习” 向“主动学习”升级。大多数人从学校开始，就习惯了被学校和老师的教学计划牵着鼻子走；到了工作单位后，被上级的指令与监督驱使着行动。这就是所谓的被动学习与被动思考。本文开头故事中的李四就是这么一个人。釆取这种被动的学习与工作方式的人，亦步亦趋，跟着别人的思维走，既没有偷着懒，一样的累得像狗；又做什么都做不好，做不到位，内心充满压力感。而主动学习不是这样的。我注意到那些学校中的一些学霸，他们有自己的学习计划与学习节奏，以自学为主。在他们眼里，学校统一的学习计划与老师，只是其中之一的辅助途径。我见过一位高中学霸，高一就学完了全部高中课程。我年轻时刚参加工作，就很纳闷：为什么我的上司文化程度不如我，但他批评我时，总能看到我看不到的问题，想出我想不到的办法。有同事解释说，因为领导比我经验丰富。我就不服这个邪，于是，我决定变被动为主动：首先，我强迫自己重视并安心本职工作。其次，在了解工作职责和部门目标的基础上制定自己的较高目标、专业能力体系化学习计划与工作计划。然后，自己找问题，并带着问题在部门內外、行业內外进行广泛的学习与专注思考。这个时候，关键是能够投入业余时间用在学习与工作上。这样一来，经过一段时间，我很快找到了感觉，看问题、想办法、做事情，都能踩到点子上了。在我负责的工作范围内，我所掌握的信息、知识与我的见解，都能走在领导的前面。这样不但使绩效明显提升，博得上司的赏识，而且自己也感到对工作有了发自内心的兴趣，还心情舒畅，不像过去一样有压力了。<br>&emsp;&emsp;人生最大的思想误区认为战略短板可以用战术的勤奋来弥补。<br>&emsp;&emsp;在前几年大众创业的热潮中，我认识的一位老乡，他三十来岁，也按奈不住心潮澎湃，说老子决定不打工了，创业当老板去。他拿出准备结婚买房的钱，加上找众多亲朋好友众筹的款子，共逾百万，开了一家餐馆。我是偶然去吃饭碰上他的。吃完之后，他问我，餐馆办得怎么样？我实话实说，你这个啊有两个战略上的问题：一个是地段偏僻了，另一个是菜品虽然有特色，口味也挺好，但根据我对周边人群的了解，你这定位有点不精准，高不成低不就。这老乡听了有点不高兴，跟我大谈什么工匠精神，要精益求精创一流莱品。最后他说，这地段偏是偏了点，但租金便宜，我可以把省下的资金，用来作广告，搞宣传，打响牌子，还是划算的。后来听说他在广告与促销上做了很大努力与很多动作，如微信宣传，店內有奖促销，优惠促销，派人在路口撒广告传单，到附近小区与写字楼贴广告。可以讲，凡营销教课书上提到的促销招术，他都几乎用了一遍。但最终还是无力回天，半年后便停业倒闭了。我发现，不少人有一个盲目的自信，以为战略上的短板，可以用正确的战术和增加战术资源投入，来弥补，来挽救。这实质上是在用战术上的勤奋，来掩盖战略上的懒惰。战术上你很勤奋，实际上却刻意回避了真正困难却更有价值的部分——战略思维与战略决策。而这种 “战略思维懒惰” 的行为，最终会导致你战略决策失误，结果可能是一失足成千古恨。前面所讲的选择 “低成长区” 还是选择“高成长区”，这都属于战术层面的思考，这些你选择对了，做对了，也还是不够的。比战术层面的深度思考更重要的，是战略层面的深度思考。你必须把决定事业全局与长久成败的战略决策视为头等大事，在战略上多学习，多动脑子，多花时间，多选择，多比较，不怕麻烦，力戒 “战略思维懒惰”。要能 “忍、等、准”，有耐心，时刻准备，创造机会，但勿因急躁而轻举妄动。如果你是公司老板，就须选择一个好的行业，好的商业模式，把握好机会，使机遇同自己的核心能力、关键资源、价值观相匹配。然后，制定公司的发展战略规划。<br>&emsp;&emsp;如果你是职场人士，在注重选好行业、公司平台时，更要选好职业，并且使这些选择与自己的专业、特质潜能、价值观相适合。然后，根据环境和公司未来发展趋势、未来机会制定自己的长远职业发展计划与新能力学习计划。<br>&emsp;&emsp;人生最大的悲伤，莫过于将一辈子的聪明都耗费在战术上。当你抬头一看，你精益求精的事情，它们所在的职业或行业己经衰落，或社会价值与个人价值都很低微，或前进的战略大方向错了。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>没有痛苦你就一无所获</title>
    <url>/2021/01/30/%E6%B2%A1%E6%9C%89%E7%97%9B%E8%8B%A6%E4%BD%A0%E5%B0%B1%E4%B8%80%E6%97%A0%E6%89%80%E8%8E%B7/</url>
    <content><![CDATA[<p>&emsp;&emsp;痛苦是人生不可避免的现实，成功的关键是接受痛苦并从中成长。痛苦的反面是什么？十之八九的人会回答“快乐”。错，真正的反面是“不痛”，也就是舒适。而舒适虽然很好，却不是真正意义上的快乐。穷其一生追求舒适的人最终会感到非常失望，如果一生竭力避免痛苦，你也就避开了最深层次的快乐。虽然每个人都尽力把生活中的痛苦最小化，现实仍然是痛苦不可避免。</p>
<p>&emsp;&emsp;任何事情都有起伏利弊，我们如果想有生之年有所成就，关键是不要排斥痛苦，而要学会如何理解和接受痛苦。痛苦是我们为快乐支付的代价，我们生活中的所有快乐，家庭和睦、事业有成、人生意义的追求，都需要付出艰苦努力来换取。我们经常所说的“痛苦”是一种实际意义上的“努力”：为身体健康付出的努力是痛苦的，为思考付出的努力是痛苦的，为建立和维持友好关系而努力是痛苦的。由此看出，尽管努力是痛苦的，想实现人生目标却离不开它，任何想无风无浪平静度过一生的人，都无法品味到真正意义的快乐。</p>
<p>&emsp;&emsp;真正的快乐离不开痛苦，这里有个例子：什么是你父母的最大快乐？是的，你。父母的最大痛苦是什么？回答同样是：你。父母的最大快乐同时也是他们的最大痛苦并非巧合，快乐越大，努力所需要的痛苦也越大。此外，我们实现目标过程中经历的痛苦越多，我们感受的成功喜悦也越多，换句话说：我们付出越多，也就越要珍惜。</p>
<p>&emsp;&emsp;追求舒适被定义为“颓废堕落”，整个社会以此为主要目标的时候，它就危险了，罗马帝国的坍塌就是由于这个原因，他们太舒适了。西方当前的很低出生率也是当代颓废的一种表现，年轻人为了自己的舒适甚至不顾及国家的前途，整个社会早早晚晚会自食其果。经常的情况是对痛苦的恐惧比痛苦本身还可怕，扎一下疫苗只需几秒钟，对那份疼痛的预期和想象却持续几个小时。害怕痛苦是最大的限制条件，你如果害怕旅行就哪儿都去不成。同样，如果害怕身体和精神上的痛苦，你就不会成长并有所成就，更不用说找到真理。</p>
<p>&emsp;&emsp;我们每个人都面对同一个选择：或是痛苦着努力着，或是忍受痛苦认为自己是懦夫不敢尝试。举个例子，不敢求职，你就避免了被拒绝的痛苦，一生也就成了轻言放弃的懦夫，而且这样的情绪会经常萦绕纠缠着你，挥之不去。事实上，痛苦经常是跨过去进入快乐世界的门槛，一个很好的例子就是治疗牙齿：钻开、充填需要一个小时，疼痛持续两个小时，但修补却可以防止牙的进一步恶化，未来多年里给了你吃东西的快乐。</p>
<p>&emsp;&emsp;最大也是最需要克服的恐惧就是害怕面对现实，有些人宁可活在幻觉里也不愿清醒地正视它。为什么？因为现实总是与我们习惯了的情况有所不同，意味着现存的生活之路必须有所改变，这是很痛苦的。所以我们选择逃避，不肯付出为达到人生目标和雄心壮志而必须付出的努力。我们都想伟大，都想改变世界，关键是并不总是想着要付出相应的努力，所以我们常常分心，刻意回避我们应该成为什么样的人和想要取得什么样成就这样的问题。面对无法回避的现实时我们更加痛苦，特别是感到再也无力做任何事情改变它的时候。所以要经常自问：“我在回避什么样的痛苦？”要尽力准确找出害怕什么，说明理由，可能发生的最糟糕情况是什么。为此，先列出没有痛苦的情况下你想要达到的目标，然后在每个旁边写下要想达到这些目标不可避免的痛苦，再写下是什么使得这些目标拥有价值。现在把两个栏目加以比较，如果某个目标真有价值，你马上就可以看出对痛苦的恐惧是如何阻碍你实现这个目标的，这就可以清楚说明你是多么心甘情愿付出痛苦的代价达到想要取得的目标了。</p>
<p>&emsp;&emsp;重要的是要盯住目标，消除痛苦的最好办法之一就是将其忘记而只是盯住快乐。有人说痛苦和快乐似乎不可能同时发生，痛苦着就不会感到快乐。错！如果把注意力仅仅放在痛苦上，即使有快乐可言的时候你也会对其麻木不仁，转移了注意的重点也就改变了感觉。再举个例子：打棒球的时候，正常情况下你会奔跑、跳跃、投球、防卫，这一次不用球做一次！你想你能坚持玩多久？五分钟？没有球，也就没有了分散痛苦的快乐，每一步都似乎那么沉重。再把球拿上来，又可以玩上两个小时了。圣人说要把双眼盯在目标上，要达到人生目标，你必须学会有关生活的相应知识，这样你才能真正感受到努力带来的快乐。</p>
<p>&emsp;&emsp;想象某个男孩和伙伴玩耍时跌倒擦破了膝盖，开始哭泣，伙伴们冲他喊道：“哭吧，伙计，可劲儿哭！”他却立刻站起来重又加入游戏。回到家里，孩子给妈妈看受的伤，立刻又大哭起来。我们的生活享受与痛苦密切相关，很多人学会说“那又怎么样”，对痛苦毫不在意，而有的人则纠结于自怨自艾情绪，深陷痛苦不能自拔。很多人盯住自己的不能而不是能够，结果造成毫无意义的痛苦。每个人生来都有惊人的天赋和潜力，所以纠缠于自己的缺点就如同衣裳褴褛到高级饭店进餐一样愚蠢–漂亮的风景、精美雅致的餐具，为此你感到局促不安大声喊道：“没有盐！怎么回事？”原本很愉快的经历变成你和周围人的一场噩梦。取得伟大成就的是那些忍受最大痛苦的人，你会因为手指扎根刺就放弃革命吗？你会因为头痛就不再发挥聪明才智吗？有的人在冰水中游泳、在烧红的煤炭上行走，为的就是克服这样做所带来的恐惧，克服恐惧使我们能够感觉到自由意志，让我们能在多大程度上塑造自己的生活。学会专注痛苦中的好处吧，这样你才能发现生活所能给予的最大快乐。</p>
<p>&emsp;&emsp;说到他人的痛苦，那就是两回事了。看望住院朋友的时候，不要说教他应该“看到积极的一面”，同情和理解才能减轻痛苦。同样，也不要对人类的苦难视而不见，你的社区如果出现问题，问自己：“我能做些有助于问题解决的什么事情？”大多数人都能体会到今天人类的苦难：绝望、迫害、残缺的家园……而愿意全力以赴找到真正解决方法的人却凤毛麟角。伟大不仅仅在于比去年更多的捐献，而在于身体力行，把他人的痛苦当作自己的，这就是伟人的伟大之处，这里才是伟大最终得以展现出来之处。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机存储单位</title>
    <url>/2021/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h2><p>存储单位是一种计量单位。指在某一领域以一个特定量，或标准做为一个记录（计数）点。再以此点的某个倍数再去定义另一个点，而这个点的代名词就是计数单位或存储单位。</p>
<a id="more"></a>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在计算机内部，信息都是釆用二进制的形式进行存储、运算、处理和传输的。信息存储单位有位、字节和字等几种。各种存储设备存储容量单位有 KB、MB、GB 和 TB 等几种。</p>
<h3 id="基本储存单元"><a href="#基本储存单元" class="headerlink" title="基本储存单元"></a>基本储存单元</h3><p>位（bit）：二进制数中的一个数位，可以是 0 或者 1，是计算机中数据的最小单位。</p>
<p>字节（Byte，B）：计算机中数据的基本单位，每 8 位组成一个字节。各种信息在计算机中存储、处理至少需要一个字节。例如，一个 ASCII 码用一个字节表示，一个汉字用两个字节表示。</p>
<p>字（Word）：两个字节称为一个字。汉字的存储单位都是一个字。</p>
<h3 id="扩展的存储单位"><a href="#扩展的存储单位" class="headerlink" title="扩展的存储单位"></a>扩展的存储单位</h3><p>在计算机各种存储介质（例如内存、硬盘、光盘等）的存储容量表示中，用户所接触到的存储单位不是位、字节和字，而是 KB、MB、GB 等，但这不是新的存储单位，而是基于字节换算的。</p>
<p>KB：早期用的软盘有 360KB 和 720KB 的，不过软盘已经很少使用。</p>
<p>MB：早期微型机的内存有 128MB、256MB、512MB，目前内存都是 1GB、2GB 甚至更大。</p>
<p>GB：早期微型机的硬盘有 60GB、80GB，目前都是 500GB、1TB 甚至更大。</p>
<p>TB：目前个人用的微型机存储容量也都能达到这个级别了，而作为服务器或者专门的计算机，不可缺少这么大的存储容量。</p>
<h3 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h3><p>换算率约等于 1000（1024），从大到小顺序为 T、GB、MB、KB、B 再小就是位了。</p>
<p>计算机存储单位一般用 bit、B、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB…… 来表示，它们之间的关系是：</p>
<p>1 Byte（B） = 8 bit<br>1 Kilo Byte（KB） = 1024B<br>1 Mega Byte（MB） = 1024 KB<br>1 Giga Byte （GB）= 1024 MB<br>1 Tera Byte（TB）= 1024 GB<br>1 Peta Byte（PB） = 1024 TB<br>1 Exa Byte（EB） = 1024 PB<br>1 Zetta Byte（ZB） = 1024 EB<br>1Yotta Byte（YB）= 1024 ZB<br>1 Bronto Byte（BB） = 1024 YB<br>1Nona Byte（NB）=1024 BB<br>1 Dogga Byte（DB）=1024 NB<br>1 Corydon Byte（CB）=1024DB</p>
<p>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，是最小的存储单位。</p>
<p>[英文缩写：b (固定小写)]</p>
<p>字节 byte：8 个二进制位为一个字节 (B)，计算机存储的基本单位。</p>
<p>字节又被译为 “字节”，即是在电脑内一个英文字所占的最基本单元，而一个中文字是占两个字节的。</p>
<p>至于硬盘容量，一般的制造商总是用十进制的计数。一般计算机的操作系统都是使用二进制的计数，所以你经常会发现计算机中看到的硬盘容量比硬盘上的实际可用容量要小，比如 20GB 的硬盘只显示有 18.6GB。</p>
<p>特别误导人是软盘的情况。720KB 的软盘是 720乘1024 个数位组的值经常用 2 个十六进制的数字（在信息科学中这样一个 16 进制的数字也称为一），而 1.44MB 的软盘则莫名奇妙的是 1.44 乘 1000 乘 1024 个数位组的值经常用两个十六进制的数字（在信息科学中这样一个 16 进制的数字也称为一），即不全是十进制也不全是二进制。</p>
<p>注：“兆” 为百万级数量单位。</p>
<h3 id="b（bit）与-B"><a href="#b（bit）与-B" class="headerlink" title="b（bit）与 B"></a>b（bit）与 B</h3><p>上面的换算相信大家已看过了，可说起存储容量单位，大家很自然的会想起自己的硬盘有多少 GB、内存有多少 MB，我们知道了字节（B）是电脑中表示信息含义的最小单位，通常情况下一个 ACSII 码就是一个字节的空间来存放。而事实上电脑中还有比字节更小的单位，因为一个字节是由八个二进制位组成的，换一句话说，每个二进制位所占的空间才是电脑中最小的单位，我们把它称为位，也称比特（bit）。由此可见，一个字节等于八位。人们之所以把字节称为电脑中表示信息含义的最小单位，是因为一位并不能表示我们现实生活中的一个相对完整的信息。<br>有的时候，为了简写，我们会把位的单位缩写成 b，这个时候大家一定会有疑问了，因为字节的单位我们用 B 表示，两者不就是一样了吗？其实，字节的表示单位 B 是 Byte 的缩写，位的表示单位 b 是 bit 的缩写，1b 与 1B 之间只要大小写不同，那么表示的含义也不同，因为 8b 才等于 1B。</p>
<p>一般来说，我们讲到存储设备时，都是按照字节进行换算，例如 <img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210215123629.png" alt="20210215123629">。但是在网络传输之中，数据传输则是按照位进行传输的。这就可以解释为什么自己家里的宽带 ADSL 是 1Mb 的带宽，但是下载数据却只能在 100KB 左右徘徊。因为1MB=1024KB，由于字节与位之间的关系是八倍，因此将 1024Kb 除以 8 就得到 128KB。由此可见，实现上网络传输带宽中的 1M 只等于电脑中的 128KB。这样加上信号的衰减，一般只能保持在 100KB 左右。<br>相同的道理，我们的网卡一般都是 100M 的，但是为什么传输速度达不到这么高呢？因为 100Mb，将其除以 8 得到 12.5MB，这就是我们网卡能够达到的最高速度了。</p>
<h3 id="换算进率"><a href="#换算进率" class="headerlink" title="换算进率"></a>换算进率</h3><p>计算机都是二进制的，让它们计算单位，只有 2 的整数幂时才能非常方便计算机计算，因为电脑内部的电路工作有高电平和低电平两种状态。所以就用二进制来表示信号，以便计算机识别。而人习惯于使用 10 进制，所以存储器厂商们使用 1000 作进率。这样导致的后果就是实际容量要比标称容量少，不过这是合法的。1024 是 2 的 10 次方，因为如果取大了，不接近 10 的整数次方，不方便人们计算；取小了，进率太低，单位要更多才能满足需求，所以取 2 的 10 次方正好。</p>
<p>计算实例：标称 100GB 的硬盘，其实际容量为：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210215123558.png" alt="20210215123558"></p>
</div>

<h3 id="带宽存储换算"><a href="#带宽存储换算" class="headerlink" title="带宽存储换算"></a>带宽存储换算</h3><p>在我们的记忆中，我们恐怕最熟悉的就是当初用 Modem 接入互联网时，接入的速度仅仅为 56Kbps。在这个单位中，bps 是 bit Per Second 的缩写，翻译成中文就是比特位每秒，也就是表示一秒钟传输多少位（bit）的意思。Kb 与 KB 之间的关系：我们在电脑原理中知道，电脑的最小存储单位是字节 Byte，一个字节，是由八位二进制位组成的。由此，我们可以这样认为，一个字节是由 8 个位组成的，或者说一个字节与八个位所占的空间是相同的。因为，当我们使用 100Mb 带宽的网络下载时，理论上的速度应该是 100 除以 8 等于 12.5MB。</p>
]]></content>
      <categories>
        <category>视频工具使用</category>
      </categories>
      <tags>
        <tag>视频工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>读书最基本的3件事</title>
    <url>/2021/02/16/%E8%AF%BB%E4%B9%A6%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%843%E4%BB%B6%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="读书最基本的-3-件事：一是学会做人，二是打破我执，三是洞察规律"><a href="#读书最基本的-3-件事：一是学会做人，二是打破我执，三是洞察规律" class="headerlink" title="读书最基本的 3 件事：一是学会做人，二是打破我执，三是洞察规律"></a>读书最基本的 3 件事：一是学会做人，二是打破我执，三是洞察规律</h3><p>之前听到一个人说：“我们人修行，就是与天争命。” 这个观点，甚有道理。</p>
<p>古人说，一命二运三风水，四积阴德五读书。对于绝大多数人而言，真正能改变命运的，只能靠读书。</p>
<p>有的人不以为然，说隔壁家老王的儿子，读完大学出来，赚到的钱，还不如人家不读书，自己做生意的多。</p>
<p>读书≠学历 读书≠知识 读书≠知道</p>
<p>这篇文章，给大家解读，如何通过真正的读书，来改变自己，逆袭命运。</p>
<a id="more"></a>

<h4 id="真正的读书，要打破我执。"><a href="#真正的读书，要打破我执。" class="headerlink" title="真正的读书，要打破我执。"></a>真正的读书，要打破我执。</h4><p>我自己工作 10 年后，泡在书城里，又读了 3 年书，读了多少书，自己没算过。很多人叫我推荐一些好书，我的观点是：开卷有益，任何一本书，都是好书。</p>
<p>正规的书籍出版，有对应的书号，审查是很严格的，能上市的书，都是好书，不好的书，根本就没资格出版。</p>
<p>每一个本书，都是一个看世界的窗口，不同的书，就是不同的窗口。</p>
<p>所以，读书，读到最后，要打破我执。</p>
<p>什么是我执？</p>
<p>一个人出生，成长，到成年，自然形成一套看待和评价人、事、物的观念，就是我执。</p>
<p>我执，本身不好，不坏，只是一种认知系统，是看世界的一个窗口。</p>
<p>很多人的毛病，就是只从自己的窗口，去看世界，并认为，自己就是对的，别人的观点和自己不一样，别人就是错的。</p>
<p>如果无法打破我执，一个人读再多的书，都没有用，因为他看世界的窗口，是固定的，是局部的，认知是有限的。</p>
<p>而打破我执的人，可以从任意一个窗口，去看世界。这样的人，认知是无限的。</p>
<h4 id="真正的读书，要洞察规律。"><a href="#真正的读书，要洞察规律。" class="headerlink" title="真正的读书，要洞察规律。"></a>真正的读书，要洞察规律。</h4><p>很多人买书，然后摆在书架上，不管看了多少，占有很多书，就感觉自己有文化了。其实，读书多少，不是关键，关键是，你能通过读书明理，来洞察世间万物的规律。</p>
<p>举个例子：</p>
<p>人逢喜事精神爽，有的人运气好时，就得意忘形，恨不过全世界的人都知道。而等到自己运气下跌时，又抱怨自己倒霉。</p>
<p>而能洞察规律的人，在自己运气好时，懂得谦虚、收敛，免得内心膨胀了，而导致“亢龙有悔”。在运气下跌时，因为前面有做好心理准备，所以也能顺利摆平。吉凶和福祸，都是互相依存，互相转化的，《易经》《老子》《庄子》等等，很多书中，都讲明这些道理。</p>
<p>高明的人，洞察规律，保持心醒；不高明的人，被规律牵着鼻子走。</p>
<p>所以，我们要走出读书的误区，不要认为受教育学历高就好，读书数量多就好，也不是知识渊博就好。</p>
<p>读书，最基本的就是要做好 3 件事：一是学会做人，二是打破我执，三是洞察规律。做到知行合一，就是读书的最高境界。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历目录下的所有文件及文件里的sheet</title>
    <url>/2021/02/02/%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E9%87%8C%E7%9A%84sheet/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"># 遍历某目录下的Excel文件名字，加入列表</span><br><span class="line">list1 &#x3D; []</span><br><span class="line">for file in os.listdir(document_path):</span><br><span class="line">        if file.endswith(&quot;xlsx&quot;) or file.endswith(&quot;xls&quot;):</span><br><span class="line">            list1.append(file)</span><br></pre></td></tr></table></figure>
<h4 id="list1-列表大概是这样-‘a-xlsx’-‘b-xlsx’-‘c-xls’…-接下来可以用相对路径或绝对路径读取"><a href="#list1-列表大概是这样-‘a-xlsx’-‘b-xlsx’-‘c-xls’…-接下来可以用相对路径或绝对路径读取" class="headerlink" title="list1 列表大概是这样 [‘a.xlsx’,‘b.xlsx’,‘c.xls’…], 接下来可以用相对路径或绝对路径读取"></a>list1 列表大概是这样 [‘a.xlsx’,‘b.xlsx’,‘c.xls’…], 接下来可以用相对路径或绝对路径读取</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 相对路径读取,即代码与文件同目录才可以</span><br><span class="line">for i in list1:</span><br><span class="line">	pd.read_excel(i）</span><br><span class="line"># 绝对路径读取</span><br><span class="line">for i in list1:</span><br><span class="line">	excel_path &#x3D; os.path.join(document_path,i)</span><br><span class="line">	pd.read_excel(excel_path)</span><br></pre></td></tr></table></figure>
<h3 id="pandas-读取-Excel-文件下的-sheet"><a href="#pandas-读取-Excel-文件下的-sheet" class="headerlink" title="pandas 读取 Excel 文件下的 sheet"></a>pandas 读取 Excel 文件下的 sheet</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">writer &#x3D; pd.ExcelFile(&#39;.&#x2F;a.xlsx&#39;)</span><br><span class="line">sheet_len &#x3D; len(writer.sheet_names)</span><br><span class="line"># 指定下标读取</span><br><span class="line">for i in range(0,sheet_len):</span><br><span class="line">    df &#x3D; pd.read_excel(writer,sheetname&#x3D;i)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Python库之Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的高级数据结构详解</title>
    <url>/2021/02/07/Python%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>数据结构</p>
<p>&emsp;&emsp;数据结构的概念很好理解，就是用来将数据组织在一起的结构。换句话说，数据结构是用来存储一系列关联数据的东西。在 Python 中有四种内建的数据结构，分别是 List、Tuple、Dictionary 以及 Set。大部分的应用程序不需要其他类型的数据结构，但若是真需要也有很多高级数据结构可供选择，例如 Collection、Array、Heapq、Bisect、Weakref、Copy 以及 Pprint。本文将介绍这些数据结构的用法，看看它们是如何帮助我们的应用程序的。</p>
<a id="more"></a>

<p>&emsp;&emsp;关于四种内建数据结构的使用方法很简单，并且网上有很多参考资料，因此本文将不会讨论它们。</p>
<ol>
<li>Collections</li>
</ol>
<p>&emsp;&emsp;collections 模块包含了内建类型之外的一些有用的工具，例如 Counter、defaultdict、OrderedDict、deque 以及 nametuple。其中 Counter、deque 以及 defaultdict 是最常用的类。</p>
<p>1.1 Counter()</p>
<p>&emsp;&emsp;如果你想统计一个单词在给定的序列中一共出现了多少次，诸如此类的操作就可以用到 Counter。来看看如何统计一个 list 中出现的 item 次数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">li &#x3D; [&quot;Dog&quot;, &quot;Cat&quot;, &quot;Mouse&quot;, 42, &quot;Dog&quot;, 42, &quot;Cat&quot;, &quot;Dog&quot;]</span><br><span class="line"></span><br><span class="line">a &#x3D; Counter(li)</span><br><span class="line"></span><br><span class="line">print a # Counter(&#123;&#39;Dog&#39;: 3, 42: 2, &#39;Cat&#39;: 2, &#39;Mouse&#39;: 1&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若要统计一个 list 中不同单词的数目，可以这么用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">li &#x3D; [&quot;Dog&quot;, &quot;Cat&quot;, &quot;Mouse&quot;, 42, &quot;Dog&quot;, 42, &quot;Cat&quot;, &quot;Dog&quot;]</span><br><span class="line"></span><br><span class="line">a &#x3D; Counter(li)</span><br><span class="line"></span><br><span class="line">print a # Counter(&#123;&#39;Dog&#39;: 3, 42: 2, &#39;Cat&#39;: 2, &#39;Mouse&#39;: 1&#125;)</span><br><span class="line"></span><br><span class="line">print len(set(li)) # 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果需要对结果进行分组，可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">li &#x3D; [&quot;Dog&quot;, &quot;Cat&quot;, &quot;Mouse&quot;,&quot;Dog&quot;,&quot;Cat&quot;, &quot;Dog&quot;]</span><br><span class="line"></span><br><span class="line">a &#x3D; Counter(li)</span><br><span class="line"></span><br><span class="line">print a # Counter(&#123;&#39;Dog&#39;: 3, &#39;Cat&#39;: 2, &#39;Mouse&#39;: 1&#125;)</span><br><span class="line"></span><br><span class="line">print &quot;&#123;0&#125; : &#123;1&#125;&quot;.format(a.values(),a.keys())  # [1, 3, 2] : [&#39;Mouse&#39;, &#39;Dog&#39;, &#39;Cat&#39;]</span><br><span class="line"></span><br><span class="line">print(a.most_common(3)) # [(&#39;Dog&#39;, 3), (&#39;Cat&#39;, 2), (&#39;Mouse&#39;, 1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下的代码片段找出一个字符串中出现频率最高的单词，并打印其出现次数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">string &#x3D; &quot;&quot;&quot;   Lorem ipsum dolor sit amet, consectetur</span><br><span class="line"></span><br><span class="line">    adipiscing elit. Nunc ut elit id mi ultricies</span><br><span class="line"></span><br><span class="line">    adipiscing. Nulla facilisi. Praesent pulvinar,</span><br><span class="line"></span><br><span class="line">    sapien vel feugiat vestibulum, nulla dui pretium orci,</span><br><span class="line"></span><br><span class="line">    non ultricies elit lacus quis ante. Lorem ipsum dolor</span><br><span class="line"></span><br><span class="line">    sit amet, consectetur adipiscing elit. Aliquam</span><br><span class="line"></span><br><span class="line">    pretium ullamcorper urna quis iaculis. Etiam ac massa</span><br><span class="line"></span><br><span class="line">    sed turpis tempor luctus. Curabitur sed nibh eu elit</span><br><span class="line"></span><br><span class="line">    mollis congue. Praesent ipsum diam, consectetur vitae</span><br><span class="line"></span><br><span class="line">    ornare a, aliquam a nunc. In id magna pellentesque</span><br><span class="line"></span><br><span class="line">    tellus posuere adipiscing. Sed non mi metus, at lacinia</span><br><span class="line"></span><br><span class="line">    augue. Sed magna nisi, ornare in mollis in, mollis</span><br><span class="line"></span><br><span class="line">    sed nunc. Etiam at justo in leo congue mollis.</span><br><span class="line"></span><br><span class="line">    Nullam in neque eget metus hendrerit scelerisque</span><br><span class="line"></span><br><span class="line">    eu non enim. Ut malesuada lacus eu nulla bibendum</span><br><span class="line"></span><br><span class="line">    id euismod urna sodales.  &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">words &#x3D; re.findall(r&#39;\w+&#39;, string) #This finds words in the document</span><br><span class="line"></span><br><span class="line">lower_words &#x3D; [word.lower() for word in words] #lower all the words</span><br><span class="line"></span><br><span class="line">word_counts &#x3D; Counter(lower_words) #counts the number each time a word appears</span><br><span class="line"></span><br><span class="line">print word_counts</span><br><span class="line"></span><br><span class="line"># Counter(&#123;&#39;elit&#39;: 5, &#39;sed&#39;: 5, &#39;in&#39;: 5, &#39;adipiscing&#39;: 4, &#39;mollis&#39;: 4, &#39;eu&#39;: 3, </span><br><span class="line"></span><br><span class="line"># &#39;id&#39;: 3, &#39;nunc&#39;: 3, &#39;consectetur&#39;: 3, &#39;non&#39;: 3, &#39;ipsum&#39;: 3, &#39;nulla&#39;: 3, &#39;pretium&#39;:</span><br><span class="line"></span><br><span class="line"># 2, &#39;lacus&#39;: 2, &#39;ornare&#39;: 2, &#39;at&#39;: 2, &#39;praesent&#39;: 2, &#39;quis&#39;: 2, &#39;sit&#39;: 2, &#39;congue&#39;: 2, &#39;amet&#39;: 2, </span><br><span class="line"></span><br><span class="line"># &#39;etiam&#39;: 2, &#39;urna&#39;: 2, &#39;a&#39;: 2, &#39;magna&#39;: 2, &#39;lorem&#39;: 2, &#39;aliquam&#39;: 2, &#39;ut&#39;: 2, &#39;ultricies&#39;: 2, &#39;mi&#39;: 2, </span><br><span class="line"></span><br><span class="line"># &#39;dolor&#39;: 2, &#39;metus&#39;: 2, &#39;ac&#39;: 1, &#39;bibendum&#39;: 1, &#39;posuere&#39;: 1, &#39;enim&#39;: 1, &#39;ante&#39;: 1, &#39;sodales&#39;: 1, &#39;tellus&#39;: 1,</span><br><span class="line"></span><br><span class="line"># &#39;vitae&#39;: 1, &#39;dui&#39;: 1, &#39;diam&#39;: 1, &#39;pellentesque&#39;: 1, &#39;massa&#39;: 1, &#39;vel&#39;: 1, &#39;nullam&#39;: 1, &#39;feugiat&#39;: 1, &#39;luctus&#39;: 1, </span><br><span class="line"></span><br><span class="line"># &#39;pulvinar&#39;: 1, &#39;iaculis&#39;: 1, &#39;hendrerit&#39;: 1, &#39;orci&#39;: 1, &#39;turpis&#39;: 1, &#39;nibh&#39;: 1, &#39;scelerisque&#39;: 1, &#39;ullamcorper&#39;: 1,</span><br><span class="line"></span><br><span class="line"># &#39;eget&#39;: 1, &#39;neque&#39;: 1, &#39;euismod&#39;: 1, &#39;curabitur&#39;: 1, &#39;leo&#39;: 1, &#39;sapien&#39;: 1, &#39;facilisi&#39;: 1, &#39;vestibulum&#39;: 1, &#39;nisi&#39;: 1, </span><br><span class="line"></span><br><span class="line"># &#39;justo&#39;: 1, &#39;augue&#39;: 1, &#39;tempor&#39;: 1, &#39;lacinia&#39;: 1, &#39;malesuada&#39;: 1&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1.2 Deque</p>
<p>　　Deque 是一种由队列结构扩展而来的双端队列 (double-ended queue)，队列元素能够在队列两端添加或删除。因此它还被称为头尾连接列表 (head-tail linked list)，尽管叫这个名字的还有另一个特殊的数据结构实现。</p>
<p>　　Deque 支持线程安全的，经过优化的 append 和 pop 操作，在队列两端的相关操作都能够达到近乎 O (1) 的时间复杂度。虽然 list 也支持类似的操作，但是它是对定长列表的操作表现很不错，而当遇到 pop (0) 和 insert (0, v) 这样既改变了列表的长度又改变其元素位置的操作时，其复杂度就变为 O (n) 了。</p>
<p>　　来看看相关的比较结果：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">from collections import deque</span><br><span class="line"> </span><br><span class="line">num &#x3D; 100000</span><br><span class="line"> </span><br><span class="line">def append(c):</span><br><span class="line">    for i in range(num):</span><br><span class="line">        c.append(i)</span><br><span class="line"> </span><br><span class="line">def appendleft(c):</span><br><span class="line">    if isinstance(c, deque):</span><br><span class="line">        for i in range(num):</span><br><span class="line">            c.appendleft(i)</span><br><span class="line">    else:</span><br><span class="line">        for i in range(num):</span><br><span class="line">            c.insert(0, i)</span><br><span class="line">def pop(c):</span><br><span class="line">    for i in range(num):</span><br><span class="line">        c.pop()</span><br><span class="line"> </span><br><span class="line">def popleft(c):</span><br><span class="line">    if isinstance(c, deque):</span><br><span class="line">        for i in range(num):</span><br><span class="line">            c.popleft()</span><br><span class="line">    else:</span><br><span class="line">        for i in range(num):</span><br><span class="line">            c.pop(0)</span><br><span class="line"> </span><br><span class="line">for container in [deque, list]:</span><br><span class="line">    for operation in [append, appendleft, pop, popleft]:</span><br><span class="line">        c &#x3D; container(range(num))</span><br><span class="line">        start &#x3D; time.time()</span><br><span class="line">        operation(c)</span><br><span class="line">        elapsed &#x3D; time.time() - start</span><br><span class="line">        print &quot;Completed &#123;0&#125;&#x2F;&#123;1&#125; in &#123;2&#125; seconds: &#123;3&#125; ops&#x2F;sec&quot;.format(</span><br><span class="line">              container.__name__, operation.__name__, elapsed, num &#x2F; elapsed)</span><br><span class="line"> </span><br><span class="line"># Completed deque&#x2F;append in 0.0250000953674 seconds: 3999984.74127 ops&#x2F;sec</span><br><span class="line"># Completed deque&#x2F;appendleft in 0.0199999809265 seconds: 5000004.76838 ops&#x2F;sec</span><br><span class="line"># Completed deque&#x2F;pop in 0.0209999084473 seconds: 4761925.52225 ops&#x2F;sec</span><br><span class="line"># Completed deque&#x2F;popleft in 0.0199999809265 seconds: 5000004.76838 ops&#x2F;sec</span><br><span class="line"># Completed list&#x2F;append in 0.0220000743866 seconds: 4545439.17637 ops&#x2F;sec</span><br><span class="line"># Completed list&#x2F;appendleft in 21.3209998608 seconds: 4690.21155917 ops&#x2F;sec</span><br><span class="line"># Completed list&#x2F;pop in 0.0240001678467 seconds: 4166637.52682 ops&#x2F;sec</span><br><span class="line"># Completed list&#x2F;popleft in 4.01799988747 seconds: 24888.0046791 ops&#x2F;sec</span><br></pre></td></tr></table></figure>
<p>另一个例子是执行基本的队列操作：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">q &#x3D; deque(range(5))</span><br><span class="line">q.append(5)</span><br><span class="line">q.appendleft(6)</span><br><span class="line">print q</span><br><span class="line">print q.pop()</span><br><span class="line">print q.popleft()</span><br><span class="line">print q.rotate(3)</span><br><span class="line">print q</span><br><span class="line">print q.rotate(-1)</span><br><span class="line">print q</span><br><span class="line"> </span><br><span class="line"># deque([6, 0, 1, 2, 3, 4, 5])</span><br><span class="line"># 5</span><br><span class="line"># 6</span><br><span class="line"># None</span><br><span class="line"># deque([2, 3, 4, 0, 1])</span><br><span class="line"># None</span><br><span class="line"># deque([3, 4, 0, 1, 2])</span><br></pre></td></tr></table></figure>
<p>译者注:rotate 是队列的旋转操作，Right rotate (正参数) 是将右端的元素移动到左端，而 Left rotate (负参数) 则相反。</p>
<p>1.3 Defaultdict</p>
<p>　　这个类型除了在处理不存在的键的操作之外与普通的字典完全相同。当查找一个不存在的键操作发生时，它的 default_factory 会被调用，提供一个默认的值，并且将这对键值存储下来。其他的参数同普通的字典方法 dict () 一致，一个 defaultdict 的实例同内建 dict 一样拥有同样地操作。</p>
<p>　　defaultdict 对象在当你希望使用它存放追踪数据的时候很有用。举个例子，假定你希望追踪一个单词在字符串中的位置，那么你可以这么做：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"> </span><br><span class="line">s &#x3D; &quot;the quick brown fox jumps over the lazy dog&quot;</span><br><span class="line"> </span><br><span class="line">words &#x3D; s.split()</span><br><span class="line">location &#x3D; defaultdict(list)</span><br><span class="line">for m, n in enumerate(words):</span><br><span class="line">    location[n].append(m)</span><br><span class="line"> </span><br><span class="line">print location</span><br><span class="line"> </span><br><span class="line"># defaultdict(&lt;type &#39;list&#39;&gt;, &#123;&#39;brown&#39;: [2], &#39;lazy&#39;: [7], &#39;over&#39;: [5], &#39;fox&#39;: [3],</span><br><span class="line"># &#39;dog&#39;: [8], &#39;quick&#39;: [1], &#39;the&#39;: [0, 6], &#39;jumps&#39;: [4]&#125;)</span><br></pre></td></tr></table></figure>
<p>是选择 lists 或 sets 与 defaultdict 搭配取决于你的目的，使用 list 能够保存你插入元素的顺序，而使用 set 则不关心元素插入顺序，它会帮助消除重复元素。<br>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"> </span><br><span class="line">s &#x3D; &quot;the quick brown fox jumps over the lazy dog&quot;</span><br><span class="line"> </span><br><span class="line">words &#x3D; s.split()</span><br><span class="line">location &#x3D; defaultdict(set)</span><br><span class="line">for m, n in enumerate(words):</span><br><span class="line">    location[n].add(m)</span><br><span class="line"> </span><br><span class="line">print location</span><br><span class="line"> </span><br><span class="line"># defaultdict(&lt;type &#39;set&#39;&gt;, &#123;&#39;brown&#39;: set([2]), &#39;lazy&#39;: set([7]),</span><br><span class="line"># &#39;over&#39;: set([5]), &#39;fox&#39;: set([3]), &#39;dog&#39;: set([8]), &#39;quick&#39;: set([1]),</span><br><span class="line"># &#39;the&#39;: set([0, 6]), &#39;jumps&#39;: set([4])&#125;)</span><br></pre></td></tr></table></figure>
<p>另一种创建 multidict 的方法：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;the quick brown fox jumps over the lazy dog&quot;</span><br><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">words &#x3D; s.split()</span><br><span class="line"> </span><br><span class="line">for key, value in enumerate(words):</span><br><span class="line">    d.setdefault(key, []).append(value)</span><br><span class="line">print d</span><br><span class="line"> </span><br><span class="line"># &#123;0: [&#39;the&#39;], 1: [&#39;quick&#39;], 2: [&#39;brown&#39;], 3: [&#39;fox&#39;], 4: [&#39;jumps&#39;], 5: [&#39;over&#39;], 6: [&#39;the&#39;], 7: [&#39;lazy&#39;], 8: [&#39;dog&#39;]&#125;</span><br></pre></td></tr></table></figure>
<p>一个更复杂的例子：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example(dict):</span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        try:</span><br><span class="line">            return dict.__getitem__(self, item)</span><br><span class="line">        except KeyError:</span><br><span class="line">            value &#x3D; self[item] &#x3D; type(self)()</span><br><span class="line">            return value</span><br><span class="line"> </span><br><span class="line">a &#x3D; Example()</span><br><span class="line"> </span><br><span class="line">a[1][2][3] &#x3D; 4</span><br><span class="line">a[1][3][3] &#x3D; 5</span><br><span class="line">a[1][2][&#39;test&#39;] &#x3D; 6</span><br><span class="line"> </span><br><span class="line">print a # &#123;1: &#123;2: &#123;&#39;test&#39;: 6, 3: 4&#125;, 3: &#123;3: 5&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Array<br>　　array 模块定义了一个很像 list 的新对象类型，不同之处在于它限定了这个类型只能装一种类型的元素。array 元素的类型是在创建并使用的时候确定的。</li>
</ol>
<p>　　如果你的程序需要优化内存的使用，并且你确定你希望在 list 中存储的数据都是同样类型的，那么使用 array 模块很合适。举个例子，如果需要存储一千万个整数，如果用 list，那么你至少需要 160MB 的存储空间，然而如果使用 array，你只需要 40MB。但虽然说能够节省空间，array 上几乎没有什么基本操作能够比在 list 上更快。</p>
<p>　　在使用 array 进行计算的时候，需要特别注意那些创建 list 的操作。例如，使用列表推导式 (list comprehension) 的时候，会将 array 整个转换为 list，使得存储空间膨胀。一个可行的替代方案是使用生成器表达式创建新的 array。看代码：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import array</span><br><span class="line"> </span><br><span class="line">a &#x3D; array.array(&quot;i&quot;, [1,2,3,4,5])</span><br><span class="line">b &#x3D; array.array(a.typecode, (2*x for x in a))</span><br></pre></td></tr></table></figure>
<p>　　因为使用 array 是为了节省空间，所以更倾向于使用 in-place 操作。一种更高效的方法是使用 enumerate：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import array</span><br><span class="line"> </span><br><span class="line">a &#x3D; array.array(&quot;i&quot;, [1,2,3,4,5])</span><br><span class="line">for i, x in enumerate(a):</span><br><span class="line">    a[i] &#x3D; 2*x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　对于较大的 array，这种 in-place 修改能够比用生成器创建一个新的 array 至少提升 15% 的速度。</p>
<p>　　那么什么时候使用 array 呢？是当你在考虑计算的因素之外，还需要得到一个像 C 语言里一样统一元素类型的数组时。</p>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import array</span><br><span class="line">from timeit import Timer</span><br><span class="line"> </span><br><span class="line">def arraytest():</span><br><span class="line">    a &#x3D; array.array(&quot;i&quot;, [1, 2, 3, 4, 5])</span><br><span class="line">    b &#x3D; array.array(a.typecode, (2 * x for x in a))</span><br><span class="line"> </span><br><span class="line">def enumeratetest():</span><br><span class="line">    a &#x3D; array.array(&quot;i&quot;, [1, 2, 3, 4, 5])</span><br><span class="line">    for i, x in enumerate(a):</span><br><span class="line">        a[i] &#x3D; 2 * x</span><br><span class="line"> </span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    m &#x3D; Timer(&quot;arraytest()&quot;, &quot;from __main__ import arraytest&quot;)</span><br><span class="line">    n &#x3D; Timer(&quot;enumeratetest()&quot;, &quot;from __main__ import enumeratetest&quot;)</span><br><span class="line"> </span><br><span class="line">    print m.timeit() # 5.22479210582</span><br><span class="line">    print n.timeit() # 4.34367196717</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.Heapq</p>
<p>　　heapq 模块使用一个用堆实现的优先级队列。堆是一种简单的有序列表，并且置入了堆的相关规则。</p>
<p>　　堆是一种树形的数据结构，树上的子节点与父节点之间存在顺序关系。二叉堆 (binary heap) 能够用一个经过组织的列表或数组结构来标识，在这种结构中，元素 N 的子节点的序号为 2<em>N+1 和 2</em>N+2 (下标始于 0)。简单来说，这个模块中的所有函数都假设序列是有序的，所以序列中的第一个元素 (seq [0]) 是最小的，序列的其他部分构成一个二叉树，并且 seq [i] 节点的子节点分别为 seq [2<em>i+1] 以及 seq [2</em>i+2]。当对序列进行修改时，相关函数总是确保子节点大于等于父节点。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"> </span><br><span class="line">heap &#x3D; []</span><br><span class="line"> </span><br><span class="line">for value in [20, 10, 30, 50, 40]:</span><br><span class="line">    heapq.heappush(heap, value)</span><br><span class="line"> </span><br><span class="line">while heap:</span><br><span class="line">    print heapq.heappop(heap)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　heapq 模块有两个函数 nlargest () 和 nsmallest ()，顾名思义，让我们来看看它们的用法。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"> </span><br><span class="line">nums &#x3D; [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]</span><br><span class="line">print(heapq.nlargest(3, nums)) # Prints [42, 37, 23]</span><br><span class="line">print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]</span><br></pre></td></tr></table></figure>
<p>两个函数也能够通过一个键参数使用更为复杂的数据结构，例如：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"> </span><br><span class="line">portfolio &#x3D; [</span><br><span class="line">&#123;&#39;name&#39;: &#39;IBM&#39;, &#39;shares&#39;: 100, &#39;price&#39;: 91.1&#125;,</span><br><span class="line">&#123;&#39;name&#39;: &#39;AAPL&#39;, &#39;shares&#39;: 50, &#39;price&#39;: 543.22&#125;,</span><br><span class="line">&#123;&#39;name&#39;: &#39;FB&#39;, &#39;shares&#39;: 200, &#39;price&#39;: 21.09&#125;,</span><br><span class="line">&#123;&#39;name&#39;: &#39;HPQ&#39;, &#39;shares&#39;: 35, &#39;price&#39;: 31.75&#125;,</span><br><span class="line">&#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 45, &#39;price&#39;: 16.35&#125;,</span><br><span class="line">&#123;&#39;name&#39;: &#39;ACME&#39;, &#39;shares&#39;: 75, &#39;price&#39;: 115.65&#125;</span><br><span class="line">]</span><br><span class="line">cheap &#x3D; heapq.nsmallest(3, portfolio, key&#x3D;lambda s: s[&#39;price&#39;])</span><br><span class="line">expensive &#x3D; heapq.nlargest(3, portfolio, key&#x3D;lambda s: s[&#39;price&#39;])</span><br><span class="line"> </span><br><span class="line">print cheap</span><br><span class="line"> </span><br><span class="line"># [&#123;&#39;price&#39;: 16.35, &#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 45&#125;,</span><br><span class="line"># &#123;&#39;price&#39;: 21.09, &#39;name&#39;: &#39;FB&#39;, &#39;shares&#39;: 200&#125;, &#123;&#39;price&#39;: 31.75, &#39;name&#39;: &#39;HPQ&#39;, &#39;shares&#39;: 35&#125;]</span><br><span class="line"> </span><br><span class="line">print expensive</span><br><span class="line"> </span><br><span class="line"># [&#123;&#39;price&#39;: 543.22, &#39;name&#39;: &#39;AAPL&#39;, &#39;shares&#39;: 50&#125;, &#123;&#39;price&#39;: 115.65, &#39;name&#39;: &#39;ACME&#39;,</span><br><span class="line"># &#39;shares&#39;: 75&#125;, &#123;&#39;price&#39;: 91.1, &#39;name&#39;: &#39;IBM&#39;, &#39;shares&#39;: 100&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　来看看如何实现一个根据给定优先级进行排序，并且每次 pop 操作都返回优先级最高的元素的队列例子。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"> </span><br><span class="line">class Item:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"> </span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#39;Item(&#123;!r&#125;)&#39;.format(self.name)</span><br><span class="line"> </span><br><span class="line">class PriorityQueue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._queue &#x3D; []</span><br><span class="line">        self._index &#x3D; 0</span><br><span class="line"> </span><br><span class="line">    def push(self, item, priority):</span><br><span class="line">        heapq.heappush(self._queue, (-priority, self._index, item))</span><br><span class="line">        self._index +&#x3D; 1</span><br><span class="line"> </span><br><span class="line">    def pop(self):</span><br><span class="line">        return heapq.heappop(self._queue)[-1]</span><br><span class="line"> </span><br><span class="line">q &#x3D; PriorityQueue()</span><br><span class="line">q.push(Item(&#39;foo&#39;), 1)</span><br><span class="line">q.push(Item(&#39;bar&#39;), 5)</span><br><span class="line">q.push(Item(&#39;spam&#39;), 4)</span><br><span class="line">q.push(Item(&#39;grok&#39;), 1)</span><br><span class="line"> </span><br><span class="line">print q.pop() # Item(&#39;bar&#39;)</span><br><span class="line">print q.pop() # Item(&#39;spam&#39;)</span><br><span class="line">print q.pop() # Item(&#39;foo&#39;)</span><br><span class="line">print q.pop() # Item(&#39;grok&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Bisect</li>
</ol>
<p>　　bisect 模块能够提供保持 list 元素序列的支持。它使用了二分法完成大部分的工作。它在向一个 list 插入元素的同时维持 list 是有序的。在某些情况下，这比重复的对一个 list 进行排序更为高效，并且对于一个较大的 list 来说，对每步操作维持其有序也比对其排序要高效。</p>
<p>　　假设你有一个 range 集合：</p>
<p>复制代码代码如下:</p>
<p><code>a = [(0, 100), (150, 220), (500, 1000)]</code></p>
<p>　　如果我想添加一个 range (250, 400)，我可能会这么做：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import bisect</span><br><span class="line"> </span><br><span class="line">a &#x3D; [(0, 100), (150, 220), (500, 1000)]</span><br><span class="line"> </span><br><span class="line">bisect.insort_right(a, (250,400))</span><br><span class="line"> </span><br><span class="line">print a # [(0, 100), (150, 220), (250, 400), (500, 1000)]</span><br></pre></td></tr></table></figure>
<p>　　我们可以使用 bisect () 函数来寻找插入点：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import bisect</span><br><span class="line"> </span><br><span class="line">a &#x3D; [(0, 100), (150, 220), (500, 1000)]</span><br><span class="line"> </span><br><span class="line">bisect.insort_right(a, (250,400))</span><br><span class="line">bisect.insort_right(a, (399, 450))</span><br><span class="line">print a # [(0, 100), (150, 220), (250, 400), (500, 1000)]</span><br><span class="line"> </span><br><span class="line">print bisect.bisect(a, (550, 1200)) # 5</span><br></pre></td></tr></table></figure>
<p>　　<code>bisect (sequence, item) =&gt; index 返回元素应该的插入点，但序列并不被修改。</code></p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import bisect</span><br><span class="line"> </span><br><span class="line">a &#x3D; [(0, 100), (150, 220), (500, 1000)]</span><br><span class="line"> </span><br><span class="line">bisect.insort_right(a, (250,400))</span><br><span class="line">bisect.insort_right(a, (399, 450))</span><br><span class="line">print a # [(0, 100), (150, 220), (250, 400), (500, 1000)]</span><br><span class="line"> </span><br><span class="line">print bisect.bisect(a, (550, 1200)) # 5</span><br><span class="line">bisect.insort_right(a, (550, 1200))</span><br><span class="line">print a # [(0, 100), (150, 220), (250, 400), (399, 450), (500, 1000), (550, 1200)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新元素被插入到第 5 的位置。</p>
<ol start="5">
<li>Weakref</li>
</ol>
<p>　　weakref 模块能够帮助我们创建 Python 引用，却不会阻止对象的销毁操作。这一节包含了 weak reference 的基本用法，并且引入一个代理类。</p>
<p>　　在开始之前，我们需要明白什么是 strong reference。strong reference 是一个对对象的引用次数、生命周期以及销毁时机产生影响的指针。strong reference 如你所见，就是当你将一个对象赋值给一个变量的时候产生的：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a</span><br></pre></td></tr></table></figure>
<p>　　在这种情况下，这个列表有两个 strong reference，分别是 a 和 b。在这两个引用都被释放之前，这个 list 不会被销毁。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.obj &#x3D; None</span><br><span class="line">        print &#39;created&#39;</span><br><span class="line"> </span><br><span class="line">    def __del__(self):</span><br><span class="line">        print &#39;destroyed&#39;</span><br><span class="line"> </span><br><span class="line">    def show(self):</span><br><span class="line">        print self.obj</span><br><span class="line"> </span><br><span class="line">    def store(self, obj):</span><br><span class="line">        self.obj &#x3D; obj</span><br><span class="line"> </span><br><span class="line">a &#x3D; Foo() # created</span><br><span class="line">b &#x3D; a</span><br><span class="line">del a</span><br><span class="line">del b # destroyed</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　Weak reference 则是对对象的引用计数器不会产生影响。当一个对象存在 weak reference 时，并不会影响对象的撤销。这就说，如果一个对象仅剩下 weak reference，那么它将会被销毁。</p>
<p>　　你可以使用 weakref.ref 函数来创建对象的 weak reference。这个函数调用需要将一个 strong reference 作为第一个参数传给函数，并且返回一个 weak reference。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import weakref</span><br><span class="line">&gt;&gt;&gt; a &#x3D; Foo()</span><br><span class="line">created</span><br><span class="line">&gt;&gt;&gt; b &#x3D; weakref.ref(a)</span><br><span class="line">&gt;&gt;&gt; b</span><br></pre></td></tr></table></figure>
<p>　　一个临时的 strong reference 可以从 weak reference 中创建，即是下例中的 b ()：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D;&#x3D; b()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b().show()</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>　　请注意当我们删除 strong reference 的时候，对象将立即被销毁。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; del a</span><br><span class="line">destroyed</span><br></pre></td></tr></table></figure>
<p>　　如果试图在对象被摧毁之后通过 weak reference 使用对象，则会返回 None：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b() is None</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>若是使用 weakref.proxy，就能提供相对于 weakref.ref 更透明的可选操作。同样是使用一个 strong reference 作为第一个参数并且返回一个 weak reference，proxy 更像是一个 strong reference，但当对象不存在时会抛出异常。<br>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; Foo()</span><br><span class="line">created</span><br><span class="line">&gt;&gt;&gt; b &#x3D; weakref.proxy(a)</span><br><span class="line">&gt;&gt;&gt; b.store(&#39;fish&#39;)</span><br><span class="line">&gt;&gt;&gt; b.show()</span><br><span class="line">fish</span><br><span class="line">&gt;&gt;&gt; del a</span><br><span class="line">destroyed</span><br><span class="line">&gt;&gt;&gt; b.show()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&quot;, line 1, in ?</span><br><span class="line">ReferenceError: weakly-referenced object no longer exists</span><br></pre></td></tr></table></figure>
<p>完整的例子：<br>　　引用计数器是由 Python 的垃圾回收器使用的，当一个对象的应用计数器变为 0，则其将会被垃圾回收器回收。</p>
<p>　　最好将 weak reference 用于开销较大的对象，或避免循环引用 (虽然垃圾回收器经常干这种事情)。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import weakref</span><br><span class="line">import gc</span><br><span class="line"> </span><br><span class="line">class MyObject(object):</span><br><span class="line">    def my_method(self):</span><br><span class="line">        print &#39;my_method was called!&#39;</span><br><span class="line"> </span><br><span class="line">obj &#x3D; MyObject()</span><br><span class="line">r &#x3D; weakref.ref(obj)</span><br><span class="line"> </span><br><span class="line">gc.collect()</span><br><span class="line">assert r() is obj #r() allows you to access the object referenced: it&#39;s there.</span><br><span class="line"> </span><br><span class="line">obj &#x3D; 1 #Let&#39;s change what obj references to</span><br><span class="line">gc.collect()</span><br><span class="line">assert r() is None #There is no object left: it was gc&#39;ed.</span><br></pre></td></tr></table></figure>
<p>　　提示：只有 library 模块中定义的 class instances、functions、methods、sets、frozen sets、files、generators、type objects 和 certain object types (例如 sockets、arrays 和 regular expression patterns) 支持 weakref。内建函数以及大部分内建类型如 lists、dictionaries、strings 和 numbers 则不支持。</p>
<ol start="6">
<li>Copy()</li>
</ol>
<p>　　通过 shallow 或 deep copy 语法提供复制对象的函数操作。</p>
<p>　　shallow 和 deep copying 的不同之处在于对于混合型对象的操作 (混合对象是包含了其他类型对象的对象，例如 list 或其他类实例)。</p>
<ol>
<li>对于 shallow copy 而言，它创建一个新的混合对象，并且将原对象中其他对象的引用插入新对象。</li>
<li>对于 deep copy 而言，它创建一个新的对象，并且递归地复制源对象中的其他对象并插入新的对象中。</li>
</ol>
<p>　　普通的赋值操作知识简单的将心变量指向源对象。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"> </span><br><span class="line">a &#x3D; [1,2,3]</span><br><span class="line">b &#x3D; [4,5]</span><br><span class="line"> </span><br><span class="line">c &#x3D; [a,b]</span><br><span class="line"> </span><br><span class="line"># Normal Assignment</span><br><span class="line">d &#x3D; c</span><br><span class="line"> </span><br><span class="line">print id(c) &#x3D;&#x3D; id(d)          # True - d is the same object as c</span><br><span class="line">print id(c[0]) &#x3D;&#x3D; id(d[0])    # True - d[0] is the same object as c[0]</span><br><span class="line"> </span><br><span class="line"># Shallow Copy</span><br><span class="line">d &#x3D; copy.copy(c)</span><br><span class="line"> </span><br><span class="line">print id(c) &#x3D;&#x3D; id(d)          # False - d is now a new object</span><br><span class="line">print id(c[0]) &#x3D;&#x3D; id(d[0])    # True - d[0] is the same object as c[0]</span><br><span class="line"> </span><br><span class="line"># Deep Copy</span><br><span class="line">d &#x3D; copy.deepcopy(c)</span><br><span class="line"> </span><br><span class="line">print id(c) &#x3D;&#x3D; id(d)          # False - d is now a new object</span><br><span class="line">print id(c[0]) &#x3D;&#x3D; id(d[0])    # False - d[0] is now a new object</span><br></pre></td></tr></table></figure>
<p>shallow copy (copy ()) 操作创建一个新的容器，其包含的引用指向原对象中的对象。</p>
<p>deep copy (deepcopy ()) 创建的对象包含的引用指向复制出来的新对象。</p>
<p>　　复杂的例子：</p>
<p>　　假定我有两个类，名为 Manager 和 Graph，每个 Graph 包含了一个指向其 manager 的引用，而每个 Manager 有一个指向其管理的 Graph 的集合，现在我们有两个任务需要完成：</p>
<p>　　1) 复制一个 graph 实例，使用 deepcopy，但其 manager 指向为原 graph 的 manager。</p>
<p>　　2) 复制一个 manager，完全创建新 manager，但拷贝原有的所有 graph。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import weakref, copy</span><br><span class="line"> </span><br><span class="line">class Graph(object):</span><br><span class="line">    def __init__(self, manager&#x3D;None):</span><br><span class="line">        self.manager &#x3D; None if manager is None else weakref.ref(manager)</span><br><span class="line">    def __deepcopy__(self, memodict):</span><br><span class="line">        manager &#x3D; self.manager()</span><br><span class="line">        return Graph(memodict.get(id(manager), manager))</span><br><span class="line"> </span><br><span class="line">class Manager(object):</span><br><span class="line">    def __init__(self, graphs&#x3D;[]):</span><br><span class="line">        self.graphs &#x3D; graphs</span><br><span class="line">        for g in self.graphs:</span><br><span class="line">            g.manager &#x3D; weakref.ref(self)</span><br><span class="line"> </span><br><span class="line">a &#x3D; Manager([Graph(), Graph()])</span><br><span class="line">b &#x3D; copy.deepcopy(a)</span><br><span class="line"> </span><br><span class="line">if [g.manager() is b for g in b.graphs]:</span><br><span class="line">    print True # True</span><br><span class="line"> </span><br><span class="line">if copy.deepcopy(a.graphs[0]).manager() is a:</span><br><span class="line">    print True # True</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>Pprint()</li>
</ol>
<p>Pprint 模块能够提供比较优雅的数据结构打印方式，如果你需要打印一个结构较为复杂，层次较深的字典或是 JSON 对象时，使用 Pprint 能够提供较好的打印结果。</p>
<p>假定你需要打印一个矩阵，当使用普通的 print 时，你只能打印出普通的列表，不过如果使用 pprint，你就能打出漂亮的矩阵结构</p>
<p>如果</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pprint</span><br><span class="line"> </span><br><span class="line">matrix &#x3D; [ [1,2,3], [4,5,6], [7,8,9] ]</span><br><span class="line">a &#x3D; pprint.PrettyPrinter(width&#x3D;20)</span><br><span class="line">a.pprint(matrix)</span><br><span class="line"> </span><br><span class="line"># [[1, 2, 3],</span><br><span class="line">#  [4, 5, 6],</span><br><span class="line">#  [7, 8, 9]]</span><br></pre></td></tr></table></figure>
<p>额外的知识</p>
<p>一些基本的数据结构</p>
<ol>
<li>单链链表</li>
</ol>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data &#x3D; None</span><br><span class="line">        self.nextNode &#x3D; None</span><br><span class="line"> </span><br><span class="line">    def set_and_return_Next(self):</span><br><span class="line">        self.nextNode &#x3D; Node()</span><br><span class="line">        return self.nextNode</span><br><span class="line"> </span><br><span class="line">    def getNext(self):</span><br><span class="line">        return self.nextNode</span><br><span class="line"> </span><br><span class="line">    def getData(self):</span><br><span class="line">        return self.data</span><br><span class="line"> </span><br><span class="line">    def setData(self, d):</span><br><span class="line">        self.data &#x3D; d</span><br><span class="line"> </span><br><span class="line">class LinkedList:</span><br><span class="line">    def buildList(self, array):</span><br><span class="line">        self.head &#x3D; Node()</span><br><span class="line">        self.head.setData(array[0])</span><br><span class="line">        self.temp &#x3D; self.head</span><br><span class="line">        for i in array[1:]:</span><br><span class="line">            self.temp &#x3D; self.temp.set_and_return_Next()</span><br><span class="line">            self.temp.setData(i)</span><br><span class="line">            self.tail &#x3D; self.temp</span><br><span class="line">        return self.head</span><br><span class="line">    def printList(self):</span><br><span class="line">        tempNode &#x3D; self.head</span><br><span class="line">        while(tempNode!&#x3D;self.tail):</span><br><span class="line">            print(tempNode.getData())</span><br><span class="line">            tempNode &#x3D; tempNode.getNext()</span><br><span class="line">        print(self.tail.getData())</span><br><span class="line">myArray &#x3D; [3, 5, 4, 6, 2, 6, 7, 8, 9, 10, 21]</span><br><span class="line"> </span><br><span class="line">myList &#x3D; LinkedList()</span><br><span class="line">myList.buildList(myArray)</span><br><span class="line">myList.printList()</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用 Python 实现的普林姆算法</li>
</ol>
<p>　　译者注：普林姆算法 (Prims Algorithm) 是图论中，在加权连通图中搜索最小生成树的算法。</p>
<p>复制代码代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">from heapq import heapify, heappop, heappush</span><br><span class="line"> </span><br><span class="line">def prim( nodes, edges ):</span><br><span class="line">    conn &#x3D; defaultdict( list )</span><br><span class="line">    for n1,n2,c in edges:</span><br><span class="line">        conn[ n1 ].append( (c, n1, n2) )</span><br><span class="line">        conn[ n2 ].append( (c, n2, n1) )</span><br><span class="line"> </span><br><span class="line">    mst &#x3D; []</span><br><span class="line">    used &#x3D; set( nodes[ 0 ] )</span><br><span class="line">    usable_edges &#x3D; conn[ nodes[0] ][:]</span><br><span class="line">    heapify( usable_edges )</span><br><span class="line"> </span><br><span class="line">    while usable_edges:</span><br><span class="line">        cost, n1, n2 &#x3D; heappop( usable_edges )</span><br><span class="line">        if n2 not in used:</span><br><span class="line">            used.add( n2 )</span><br><span class="line">            mst.append( ( n1, n2, cost ) )</span><br><span class="line"> </span><br><span class="line">            for e in conn[ n2 ]:</span><br><span class="line">                if e[ 2 ] not in used:</span><br><span class="line">                    heappush( usable_edges, e )</span><br><span class="line">    return mst</span><br><span class="line"> </span><br><span class="line">#test</span><br><span class="line">nodes &#x3D; list(&quot;ABCDEFG&quot;)</span><br><span class="line">edges &#x3D; [ (&quot;A&quot;, &quot;B&quot;, 7), (&quot;A&quot;, &quot;D&quot;, 5),</span><br><span class="line">          (&quot;B&quot;, &quot;C&quot;, 8), (&quot;B&quot;, &quot;D&quot;, 9), (&quot;B&quot;, &quot;E&quot;, 7),</span><br><span class="line">      (&quot;C&quot;, &quot;E&quot;, 5),</span><br><span class="line">      (&quot;D&quot;, &quot;E&quot;, 15), (&quot;D&quot;, &quot;F&quot;, 6),</span><br><span class="line">      (&quot;E&quot;, &quot;F&quot;, 8), (&quot;E&quot;, &quot;G&quot;, 9),</span><br><span class="line">      (&quot;F&quot;, &quot;G&quot;, 11)]</span><br><span class="line"> </span><br><span class="line">print &quot;prim:&quot;, prim( nodes, edges )</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>如何克服紧张情绪</title>
    <url>/2021/01/28/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E7%B4%A7%E5%BC%A0%E6%83%85%E7%BB%AA/</url>
    <content><![CDATA[<p>&emsp;&emsp;紧张情绪总是伴随着我们的成长，并随着成长逐渐增加，我们会发现以前会逃避的东西，现在逃不掉了。所以这个问题急需解决，有一篇不错，搬了过来，准备随时学习用。</p>
<p><a href="http://www.360doc.com/content/10/0731/17/601194_42756242.shtml">转自</a></p>
<p>&emsp;&emsp;《抓住让人瞩目的机会：当众讲话让掌声响起》作者为北京卡耐基学校校长黄久凌先生十年潜心研究语言魅力的成果，是符合中国社会语境的当众讲话艺术结晶。本文系我从该书中节选，通过自己在文字和文章结构上重新修改编排整理而就，使之更具针对性和操作性。标题系自己提的。</p>
<p>&emsp;&emsp;当众讲话总是伴随着一个人的职业发展悄悄地来到人们面前。因为当众讲话是与我们职业发展联系最密切的一种讲话形式。职场中，很多场合都需要当众讲话：求职面试、竞聘职位、工作述职、汇报说明、总结报告、发表意见、主持活动、商务谈判、宣传产品、激励员工、接受采访、会议发言等。当众讲话是一个人在职场上必备的基本技能，也是管理者对人管理的必要工具。英国前首相邱吉尔曾说过一句经典的话：“你能对着多少人当众讲话，你的事业就会有多大！” 可见，当众讲话是一门不可不学的一课。学习当众讲话对表达能力的提高、个性的改善、社交能力的提升都有很大作用。可是，绝大多数人对于当众讲话都感到紧张恐怖。看来，紧张是绝大部分讲话者面对听众时首先遇到的最大障碍。所以，我们一定要突破当众讲话让我们感觉到紧张的心理障碍.</p>
<p>&emsp;&emsp;美国成人教育家戴尔・卡耐基先生毕生都在训练成人有效地说话。他认为，成人学习当众讲话，最大的障碍便是紧张。他说：“我一生几乎都在致力于帮助人们克服登台的恐惧，增强勇气和自信。”。<br>&emsp;&emsp;何谓紧张？紧张首先是人应对恶劣环境的一种本能反应。人的身体向来就会对外在的刺激保持警觉，一旦感到不利于自己的情况发生，就会出现紧张反应，比如肌肉绷紧、心跳加快、手心出汗等，这些反应不用大脑思考，是人的本能，表明人体的紧急预案已经启动，它会让人大脑兴奋、精神集中、创新能力增强，使人的潜能发挥有了可能，所以，许多专家认为紧张、压力是激发潜能的有利因素.  而紧张不见得是件坏事，适度紧张不但无害，还会起到积极的作用。对于当众讲话来说，适度紧张会让我们重视听众，重视我们的表达方式，不会懈怠。只要你在乎听众，想给听众留下好印象，自然就会重视你的讲话，不会完全放松。我们前面提到的很多演讲家终身没有消除演讲的紧张也是这个道理，这样反而会增强表达的效果 。<br>&emsp;&emsp;很多人不了解这个事实，往往以为别人讲话都不紧张，而天底下只有自己讲话紧张，当众讲话也会紧张，远不止我们这些普通人。只有 “紧张” 和 “过度紧张” 才是我们真正要调整和突破的。因此我们没有必要去担心轻微、适度的紧张，只有过分紧张造成了思维停滞言辞不畅，我们才需要把它降低到一定程度，让它成为一种助力而不是阻力。</p>
<p>&emsp;&emsp;下面列出人们在讲话时怀有不同程度的紧张度及其表现：</p>
<table>
<thead>
<tr>
<th align="left">表现紧张程度</th>
<th align="center">心理状态</th>
<th align="center">身体表现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">不紧张</td>
<td align="center">毫不在乎</td>
<td align="center">松懈</td>
</tr>
<tr>
<td align="left">适度紧张</td>
<td align="center">感到压力不够轻松</td>
<td align="center">重视，会经常思考</td>
</tr>
<tr>
<td align="left">紧张</td>
<td align="center">畏惧担心</td>
<td align="center">惴惴不安 过分关注，心神不宁，睡不好觉，上台时心跳加快、脸红、出汗、表情僵硬</td>
</tr>
<tr>
<td align="left">过度紧张</td>
<td align="center">恐惧害怕</td>
<td align="center">做恶梦、头痛、胃不舒服、胸闷、呼吸困难、当场晕倒等</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;从而，我们可以更清楚地看出，只有 “紧张” 和 “过度紧张” 才是我们真正要调整和突破的。因此我们没有必要去担心轻微、适度的紧张，只有过分紧张造成了思维停滞言辞不畅，我们才需要把它降低到一定程度，让它成为一种助力而不是阻力。</p>
<p>&emsp;&emsp;那么，当众讲话紧张的根源在哪里？既然紧张是人的一种反应式行为，那这种紧张到底是对什么做出的反应呢？有很多学者提出了自己的看法，以下是两位专家的观点。</p>
<p>&emsp;&emsp;一位是美国魅力学校校长都兰博士，他认为，产生怯场紧张的原因主要有以下几个方面：</p>
<pre><code>    1.害怕做得没有想得那么好。

    2.准备得不太充分。

    3.害怕人们 (听众) 反应不佳。

    4.早期有失败的经历。

    5.没有充分进入角色 (可能是由于 1，2，3 或 4)。
</code></pre>
<p>&emsp;&emsp;谈到紧张怯场的原因时，都是由于出现了害怕的感觉，让人产生了紧张。无外乎就是害怕 “自我形象不好”，“怕出丑”、“怕丢脸”、“怕没面子”。有了这种害怕心理，才会导致紧张出现。人类害怕的原理，明确地讲，我把它归结为 6 个字 “有需求，没把握”。很多人经历过高考，高考的时候一般都会特别紧张害怕，为什么呢？首先看这个人有没有需求。有啊，想考上大学，有的人还想考上好大学。但有把握吗？一般来讲都不会有十足的把握，万一发挥失常，万一考试那天发烧拉肚子，万一题目超出了自己复习的范围…… 很多偶然情况可能出现。这样，人就没有把握了。人一旦感觉到对事情没有把握，不安全感就会产生，所以大部分人高考会紧张。但也有人高考不紧张，什么人呢？一类是学习特别好的，保送都不去，一定要自己考，非清华、北大这样的学校不上。这样的学生有需求，但他们把握性很大，因此考试不会紧张。还有一类人是学习特别差的，知道自己怎么也考不上，“是妈妈让我考的”，不得不参加。这是连需求都没有的人，还紧张什么呢？  所以心理学上有一句话 “压力总是伴随着需要而产生”。无欲则刚啊，没有需求了，人还有什么担心和害怕的？<br>我们再看看当众讲话紧张是不是也因为 “有需求，没把握”?</p>
<p>&emsp;&emsp;我们私下讲话的时候很放松，可一旦站起来对一群人讲话，就不一样了，心理发生了变化，产生了展示自己的需要。私下讲话的时候，这种需求不能说没有，但非常小。而一站起来，给别人看的心理就产生了，想要表现得好，想要说得好，想让大家特别是领导认可，谁都会有这样的心理，很正常。但你有没有把握表现好呢？有些人讲话机会多，成功的经验多，把握比较大，但好多人在当众讲话方面缺乏锻炼，没有经验，没有充分的把握好好表现，出现紧张自然就不奇怪了。</p>
<p>&emsp;&emsp;所以，我说当众讲话的紧张就是源于 “有需求，没把握” 而产生的害怕心理。因此，克服当众讲话的紧张就要从这两个方面来解决。</p>
<p>&emsp;&emsp;事情有那么重大吗？　首先我们谈一谈需求，看看能不能把人的需求给降下来。需求没了，人就不紧张了，需求低了，紧张程度就小了。有人说不可能，谁站起来不想展示自己啊，这种需求是正常的，不可能降低。但我说可以，这个需求还是可以降低的。我通过 6 个方法来帮大家试着把需求降下来。</p>
<p>&emsp;&emsp;第 1 个方法：看轻结果。美国有一个著名的高空走钢索表演者叫瓦伦达，他走钢索以距离长、离地面高而出名，是美国观众公认的一流杂技表演艺术家。他走钢索非常有经验，一生做过很多次出色表演，但在最后一次重要演出中，他意外地从 70 米高空坠落身亡。事故发生后记者去采访瓦伦达妻子，没想到瓦伦达的妻子说：“我就觉得他这次要出事，因为他在表演前不停地对我说：‘这次表演实在太重要了，一定不能有一丁点儿失误，更不可以失败。’而这之前的任何一次表演，他根本不紧张，只是一心想着走钢丝的每一个技术细节，从不在意结果。” 后来，心理学家把不专注于事情本身，而是一再考虑做这件事情可能会带来的后果、患得患失的心态，叫做 “瓦伦达心态”。</p>
<p>&emsp;&emsp;在一次重要的国际田径比赛中，一名国内跳高运动员面临着冲击金牌的最后一跳。教练对她说：“好好跳，只要跳过这两厘米，你的房子就到手了。” 结果她硬是没跳过那 “两厘米”，“房子” 也泡了汤。在洛杉矶奥运会上，受了伤的跳水王子洛加尼斯也面临着争夺金牌的最后一跳，但他的教练只轻松地对他说：：“你妈妈在家里等着你呢，跳完这一轮，你就可以回家吃她做的小甜饼了。” 洛加尼斯微微一笑，从容跳入水中。他以自己优美的姿态征服了所有裁判及在场的观众，赢得了久久的掌声。他最终获得了金牌，既回家和妈妈一道品尝了小甜饼，也得到了政府奖励。中外两个教练，同样是用语言去激励运动员，因为 “说法” 不同而导致截然不同的结局。</p>
<p>&emsp;&emsp;让人考虑后果、患得患失的 “瓦伦达心态” 只会让人紧张加剧。我们目前的文化非常在乎事情结果，总是以结果论成败，以成败论英雄。其后果是越想得到就越不容易得到，越怕失败就越容易失败。结果需要我们去关注，但关注过度了，就会把结果看得太重，做事就会受到影响。</p>
<p>&emsp;&emsp;一次我给中关村一家知名企业做产品发布指导。该公司召开产品发布会，由市场部杨经理来介绍产品。她紧张得不得了：“我们研发部门花了半年的心血研究的产品，要是我给介绍砸了就全完了，怎么对得起他们呀。” 我说，我先了解一下你们是怎么发布新产品的吧。</p>
<p>&emsp;&emsp;我了解后知道了他们的新产品是制作电视节目用的非线性编辑系统，是用电脑编辑节目的一套工具，产品发布就是现场演示用这套系统编辑好的一组节目，杨经理在中间要穿插做一些补充介绍。我知道了这些情况之后，对杨经理说：“杨经理，你知道你在产品发布中充当什么角色吗？你充当的角色不是主讲人，而是解说员。解说是什么性质呢？就像赵忠祥老师主持《动物世界》，他是在屏幕后面的人，根本不需要出现，《动物世界》里有哪一集赵老师会露脸？他的工作只是大家在看不懂的时候说上一两句，让大家看得懂，大家能看懂的时候，赵老师还不能说话，否则会影响观众看节目。你所做的事性质和赵老师做的一样，发布会上应该是产品当主角，充分表现，当客户看不明白的时候，才需要你说上几句，而客户能看明白时，你就不用说话。所以，有产品自身的演示作为保证，你不用把你讲话的作用看得太重了。反倒是你表现得过分了，客户都看你而不看产品，才是你介绍的失败呢。其实你们的产品到底符合不符合客户的要求，到底能不能对客户的工作发挥作用，这才是能否成功的根本，不会因为你说了几句动听的话客户就抢着买。所以，你的讲话跟发布会的效果有关系，但不是百分之百，也就只占 5%~10% 吧”。杨经理听我这么一说，松了一口气：“黄老师，那我就轻松多了。</p>
<p>&emsp;&emsp;我们经常听到一句话叫 “这件事具有重大的现实意义和深远的历史意义”，形容我们做的事有很重要的意义。我国的 “嫦娥” 卫星发回第一张月球照片时，我看电视报道时就听到了这句话，评论嫦娥工程意义重大而深远。这件事确实意义重大，但我们的发言、讲话有那么大意义吗？  往往很多情况只是走个过场和有个形式。所以，下次你觉得你讲话的意义非常重大时，和 “嫦娥” 工程比一比，想想你的讲话有那么大的现实意义和深远的历史意义吗？因此，第一点，要客观评价你讲话的作用与意义，把结果看轻而不是盲目放大。</p>
<p>&emsp;&emsp;第 2 个方法：放下自我。　中国有一位音乐家叫陈其钢，他说自己是个内向的人，不太习惯在公众面前讲话。2002 年北京第 5 届国际音乐节上他要展现音乐作品《蝶恋花》，这次展现的方式与以往不同，采用 “音乐会现场解说” 的特殊表现形式，由他自己亲自登台讲解。演奏是他的长项，但对着观众讲话陈其钢心里就打鼓了，感觉很紧张。但他意外想到了一个方法立刻调整了紧张的心情，是什么方法呢？</p>
<p>他说：“有时候我想，音乐会台上有一百多位音乐家在拉琴，好像是一百多只猴子在那里搞表演，台下有一千多名观众，也就是一千多只猴子在看表演，这些猴子在看的时候还会鼓掌。这次更特别的是，还有两只猴子在说话。猴子们在一起玩，所以没必要那么认真。” 咦，你看，大家都不是人了，还有必要那么一本正经吗？<br>&emsp;&emsp;王朔被称为最有风格的作家之一，他有一句名言：“我是流氓我怕谁？” 我称陈其钢、王朔这种调整心态的方法就是不把自己当人的方法。当然，我们普通人谁也不能像陈其钢那样把自己当猴子，像王朔那样把自己比喻成流氓，但很多时候，我们做人确实太过认真了。我们现在的教育只有一种不变的方式，即只教大家做人要认真。其实，要知道任何事物没有变化就是死的东西，没有变化的做人方式也迟早会出问题。我们很多的紧张是由于 “太认真” 才出现的，人在很多时候会孔雀开屏 —— 自作多情，太把自己当回事了。其实，做人应持有 “既认真， 又不认真” 的心态，是最重要的。在这里，我们先需要了解的是放下自我，不要太把自己当回事。</p>
<p>&emsp;&emsp;第 3 个方法：允许犯错。要允许自己犯错误，因为，我们不是学校里专职的老师，更不是职业演讲家，又不是天天以讲话为职业，话讲不好是正常的。讲话中遇到讲错话，不要觉得沮丧。因为我们每个人都要允许自己有一个成长的过程，要学会随时随地给自己一个恰当的定位，任何事物的发展都是从小到大、由弱变强的，要允许自己在缺少经验和技能生疏的情况下讲不好，允许自己犯错误，这是再正常不过的事情了。</p>
<p>&emsp;&emsp;第 4 个方法：允许失败，这又是非常重要的一点。“一定要成功，绝不能失败”，我们经常听到这句振奋人心的话。但大家想一想，这句话现实吗？成功和失败是一对孪生子，任何事情的结果可能成功也可能失败，概率差不多，基本上是各占一半，这是天地运行的自然法则决定的。就像地球不管怎么转，我们这一半现在是白天，地球另一半就绝对是黑夜。既然知道事物有两面性，为什么一到事情的成败上，我们就要求只能成功，不能失败？运动员是不是也要懂得这一点？</p>
<p>&emsp;&emsp;刘翔连续创造了 4 年的辉煌，对于对抗激烈、新人层出不穷的世界短跑赛场，有这样的骄人战绩真让人惊叹不已。我发现，刘翔的成功首先是做人的成功，印证了 “做事先做人” 的道理。他取得的惊人成绩与他拥有良好的心态、极高的心理素质是有关系的。请看：</p>
<p>&emsp;&emsp;在 2007 年 8 月第 11 届世界田径锦标赛上，刘翔凭实力是有机会夺得金牌的，而且他的世界级金牌就差世锦赛这一块，得到了就享有 “大满贯” 的称号。他很想得到这个冠军，全国人民也很希望他得到，压力来了。但刘翔在赛前新闻发布会上却说：“我尽力去跑，但跑出什么成绩现在还不好说，要看当时的状态，拿不到冠军，能拿到第二名、第三名也是不错的。” 我看出他不是嘴上说说而已，是发自真心这么说，是从心里对结果有一个现实的期待，也让全国人民对结果有了一个现实的期待。在这样的心态下，人才会真的放下负担，才会把更多的精力用在做事上。最后的结果刘翔不是第二名、第三名，他拿到了冠军，实现了大满贯的愿望。中国人民的自豪感又被狠狠地激发了一次。而在 2008 年北京奥运会上，刘翔又被全国人民寄予了很大的希望要卫冕奥运会冠军。但刘翔经过努力之后最终因伤退赛。我觉得这又表现了他良好的心理素质。一件事经过尝试之后要允许自己勇于放弃，要允许自己失败，说起来，这不仅不是失败，而是一个人智慧的表现，不把这样的事看成失败，人就不会失落沮丧。</p>
<p>&emsp;&emsp;第 5 个方法：允许丢脸。 大家熟知的香港凤凰卫视的节目主持人窦文涛，有 “名嘴”、“铁嘴” 之雅号，嘴巴着实厉害。但是窦文涛小时候嘴巴并不灵巧，虽然爱说话，但是说不好，结结巴巴，有点口吃。上初中的时候有一次老师跟他说：“窦文涛，学校组织演讲比赛，我看你挺爱说的，你来参加吧。”“哟，演讲怎么讲？”“就像写作文一样，你写篇稿子，上台背出来就行了。”“那好吧。” 窦文涛犹犹豫豫地答应了。回去开始写演讲稿，接着就开始背。背的时候自己还发明了一套方法，把每个自然段的第一个字作为关键字记住，一想到这个字这一段就倒背如流地背下来了，效率很高。他让妈妈考他，妈妈只要任意提其中一个关键字，他就可以把这段背下来。演讲会那天，窦文涛一上台，哎，怎么感觉跟家里不一样？家里没人，但这里台下一千多人黑压压的一大片。他当时有点慌，赶紧背第一段吧。第一段背完之后就想第二段的第一个字，想起来了，第二段也背下来了，还挺顺利。这时就想第三段的第一个字，麻烦了，这第三段的第一个字是什么呢？想不出来了，也没有妈妈在旁边提字。一紧张，整个脑袋空白，什么都没有了。再一看，台下开始交头接耳，开始议论上了。窦文涛站在台上足足半分钟，一句话也没有说，他越来越害怕，最后突然感觉裤子湿了：“坏了，尿裤子了。” 结果全校师生看着窦文涛尿湿了裤子跑下台。第二天窦文涛来上学，也觉得挺难为情，好像全校女生都在看他。老师来找他：“窦文涛，你昨天虽然没朗诵完，但是前面两段朗诵得还是不错的，能背下来一定能拿个名次。你知道吗？这一次我们学校的演讲比赛是为区里的演讲比赛做选拔的，根据你昨天的表现，我们决定让你到区里参加演讲比赛。” 窦文涛还会答应吗？没想到他竟答应得很痛快。为什么呢？在窦文涛的回忆里，他说：“我昨天当众尿了裤子，丢人已经丢到家了，还能有比这个更丢脸的事情吗？自己觉得无所谓了，所以答应得很痛快：“去！” 这一去还真拿了个名次回来” 他说：“从此之后我就有点变化了，反正已经不要脸了，还有什么所谓呢？  卸下这个包袱之后，我觉得自己还行，也能经常在这种场合露露脸。 中国人传统上都比较内向，大家一起听你说话的机会很难得，要珍惜每一次当众说话、当众表演的机会，就让自己积累挫折、积累出丑的经验，这样才能放下自我。这次出丑了吧，你们笑话我吧，我就不要脸了一分；下次又出丑了。我就不要脸了二分；等我全不要脸了，我就进入自由王国、无我的状态。所谓的‘自我’就是脸面、自尊心、虚荣心等诸如此类的东西构成的，当这些东西全被摧毁的时候，你突然发现你获得了一切。”  面子是怎么挣来的？面子是通过丢面子挣来的。你能说窦文涛今天成名不要感谢那次当众尿裤子吗？窦文涛从尿裤子慢慢地练成了主持人，现在他说起小时候尿裤子的事情不仅不觉得没有面子，还觉得是件有面子的事。小时候多笨啊，而现在他是名嘴、铁嘴，主持的节目谁都爱看，多有面子啊。所以丢面子本来就是一件正常的事，是走向成功必须付出的代价，是挣面子的开始啊。所以，要发自内心地接受自己也会有没面子的时候。</p>
<p>&emsp;&emsp;第 6 个方法：允许紧张。要接受紧张而不是控制紧张。紧张的表现本来就是正常的，是应该的，要正确对待它。可是我们很多人认为紧张不正常，为了不想让人看出自己紧张，就拼命掩饰，刻意控制，故作镇定，结果不仅紧张控制不住，反而因为掩饰紧张加重了心理负担，变得更加紧张了。不要跟紧张对抗，它就是身体对外在环境的一种应急反应，说明你的身体正常。如果上台紧张了，不妨在讲话前跟听众坦然承认：“今天看到这么多专家、领导在座，我真的感觉有点紧张。” 这样说，放弃了掩饰的心理，接下来你的表现反倒自然了。一旦我们允许紧张出现，最大的好处就是人会变得真实。因为人人都会紧张，你紧张了大家认为你很真实，但要是刻意控制，听众就会感觉你好像故意在隐藏着什么而让人不踏实，不安全。听众觉得不安全了就会防备你，而展示了最真实的自我，听众就容易接受你，而刻意掩饰就会做作虚假。所以，不要想着去控制紧张，紧张就随它去吧。以上是我谈的如何克服紧张。哦，现在似乎不能叫 “克服” 了，而应该叫 “调适”。调适紧张的第一个方面就是降低需求，有 6 个方法，我们一起总结一下：</p>
<p>　　1.看轻结果</p>
<p>　　2.放下自我</p>
<p>　　3.允许犯错</p>
<p>　　4.允许失败</p>
<p>　　5.允许丢脸</p>
<p>　　6.允许紧张</p>
<p>&emsp;&emsp;附注：我推荐此文，缘于一位名叫 chsdyt 的馆友对此文的评论，它使我很感动，也使我很钦佩这位馆友能学以致用。但愿更多人能受惠。下面是这位馆友的评论：</p>
<p>&emsp;&emsp;“非常感谢此篇文章的分享者！通过阅读到它，让我跨出克服当众发言紧张的第一步。真的如它所说，心中有了那 6 个方法，顿感心理轻松不少。就是，何必呢？何必把事情、把自己看的那么重？- 看轻结果、放下自我。犯点错怕啥呢？不是不会吗？就是会的人也难免犯错。紧张那是必然的。紧张就紧张吧。失败就失败吧。一开始就成功它也不可能啊。是不是？丢点脸怕啥，就怕连丢脸的勇气都没有。所以呢，允许自己犯错、允许自己失败、允许自己丢脸、允许自己紧张。当对自己宽容些了以后呢？发现自己的心里竟是前所未有的轻松。敢去做（当众发言）这件事情了！<br>&emsp;&emsp;终于跨出这一步了！<br>&emsp;&emsp;现在的我当众发言已经不紧张、不害怕了。从容不迫！连自己也没想到呢。呵呵。真好！”</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>如何看待父亲发文怒斥网游</title>
    <url>/2021/02/16/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E7%88%B6%E4%BA%B2%E5%8F%91%E6%96%87%E6%80%92%E6%96%A5%E7%BD%91%E6%B8%B8/</url>
    <content><![CDATA[<p>[转载知乎网文，写得太好了，感谢]</p>
<p>最近，浙江一家长发表在《新华每日电讯》的文章《被网游毁掉的孩子》引热议。他说，儿子沉迷网游，荒废了学业，高考失利。其努力10年才帮儿子从网游中走出。文章全文如下图：</p>
<a id="more"></a>

<p>这孩子天生是个军迷，如果他的成长过程中，从没接触过更高级的爱好，一直玩《穿越火线》这种低门槛、强瘾性的十八线射击游戏，他能沉迷多少年我都不奇怪。</p>
<p>所以，建议这位父亲除了打骂，禁足，送去当兵之外，不如试试我这招：</p>
<p>《使命召唤》和《战地》让他玩玩看？《欧陆风云》和《全面战争》让他玩玩看？我保证他马上忘掉《穿越火线》这玩意。</p>
<p>兴趣需要引导到高处，而不是扼杀在摇篮。</p>
<p>下一步，想买《使命召唤：二战》吗？想换一台 PS4 pro 吗？全战又出 DLC了吗？好好学习去吧，完成了学习目标，爹给你买。</p>
<p>死都不想学习吗？也行，那就跟爹出去玩实弹射击，去军事博物馆，去野外生存，去欧洲旅游，看看当年盟军打突出部之役的地方。</p>
<p>总之就是，用游戏作为奖励，根据孩子的兴趣，让他接触游戏以外的爱好。</p>
<p>其实很多中国孩子之所以沉迷游戏，是因为他们不像西方世界的孩子们一样，有那么多选择。</p>
<p>妞也不能泡，乐队也不让组，不能出去 gapyear，也不能在车库里鼓捣机械。最后最后，连游戏也不让我玩了！？那老子肯定跟你死磕到底喽。</p>
<p>洪水宜疏不宜堵。老祖宗传了几千年的道理，现在都被忘得差不多了。</p>
<p>退一万步讲，就算这位父亲的一篇文章，真的带来权威媒体的批判和游戏发行商的保护，这就真的可以让小孩子们不玩游戏了吗？</p>
<p>前段时间的人民网素质三连，加上大陆游戏用了十几年的所谓什么“防沉迷系统”，这些有让玩《王者荣耀》的小孩子变少吗？并没有。</p>
<p>相反，越来越多的小孩子开始玩游戏了。因为这是社会潮流、科技潮流、也是文化潮流，没人能阻止。</p>
<p>游戏就跟 A片一样，是人类的天性。粗暴一刀切，一点意义都没有。别把孩子们当傻子，只要他们有欲望，你再怎么压制也只会适得其反。</p>
<p>不信的话，不妨去搜搜 “王者荣耀 + 防沉迷”，结果绝对发人深省……</p>
<p>“哪里有压迫，哪里就有反抗”，这句话咱们中国人当成信仰说了一百年，真的到了教育自己后代的时候，却变成了“哪里有反抗，哪里就有压迫”。</p>
<p>这几年来，跟题主截图类似的诸如“优等生沉迷网游成绩一落千丈”、“父亲不让玩游戏导致孩子跳楼”、“母亲怒摔两部手机，以防女儿玩《王者荣耀》”，这样的报道，少吗？</p>
<p>至于孩子 “沉迷” 游戏的解决办法，网络上的信息和评论更是让我笑掉大牙。不妨再去搜搜 “孩子沉迷游戏怎么办”，结果肯定吓得你赶紧去预约一个脑部 CT：</p>
<p>掌握中国话语权的媒体尚且如此，更何况普通父母？</p>
<p>在中国，游戏这顶 “鸦片” 的帽子实在是戴得太久了，太冤了。</p>
<p>心情复杂，有感而发。威廉今天就要说一说这个被 “专家教授”们呕心沥血研究了十几年的问题：</p>
<p>我们到底为什么 “沉迷” 打游戏？游戏真的能害孩子吗？</p>
<p>请不要摔手机、砸电脑、关禁闭、抽嘴巴，让我们理性地来探讨这个问题。</p>
<p>正所谓以史鉴今，要说解释人类的行为，威廉觉得历史就是最好的参考书。</p>
<p>自人类诞生以来，任何一种形式的艺术作品——绘画、雕刻、建筑、音乐、文学、舞蹈、戏剧、电影，它们的终极诉求其实大同小异。艺术家们通过作品来刺激观众的感官，以此来向观众表达自我、建立沟通、继而引发共鸣。</p>
<p>艺术家们表达这种诉求的方式日新月异——从洞穴里的史前壁画到今天的 VR头盔，艺术形式的进步永远跟随着科技的进步。</p>
<p>一如文字催生文学、胶片催生电影，上世纪末，随着人类的科技发展，一种融合了视觉、听觉、触觉的新艺术形式出现了。</p>
<p>电子游戏之所以被称为 “第九艺术”，也正是因为如此。</p>
<p>这个新生儿注定将比电影更加受欢迎，因为观众不再是坐在座椅上冷眼旁观，而是通过触觉设备加入到电影之中，成为电影的主角。</p>
<p>对于那些像我一样大的 80、90后来说，我们的成长就见证了电子游戏产业的从无到有、发展壮大，我们见证了这种艺术形式真正地在普罗大众之间流传开来。我们是真正玩着游戏长大的一群人。</p>
<p>如果雷神杨永信教授读到这里，估计要摩拳擦掌、蓄力大招，准备电一下我这个执迷不悟、大放厥词的网瘾老少年了。</p>
<p>可就算要被杨教授一套带走，威廉也依然坚持自己的观点——其实我们玩游戏的原因很简单：</p>
<p>我们就像是第一次看到裸体雕塑的希腊人、第一次走进漆黑的电影院的美国人一样——我们是“电子游戏” 这种最新艺术形式的第一批观众。</p>
<p>而裸体的石头人、伸手不见五指的放映厅、光怪陆离的液晶屏幕，都会让第一次见到的人害怕。所以，任何一种艺术形式，它们都需要一个媒介，来帮助它们慢慢从少数走向多数。</p>
<p>雕塑的媒介是神庙，电影的媒介是电影院。而对于游戏来讲，这个媒介是家庭游戏主机。</p>
<p>但是，2000年光明日报一篇《电子海洛因》的文章，带来了文化部的一纸游戏机禁令。所以在中国，这个媒介的普及，我们比西方晚了十几年。</p>
<p>而晚了十几年的代价，就是当中国人突然面对以电脑和网络为依托，野蛮生长的电子游戏的时候，就像日本武士面对工业革命带来的现代枪炮——上一代缺乏认知，下一代疯狂滥用。</p>
<p>在世纪之交的中国，那时大哥大还不能打王者荣耀，小霸王还是学习机，而家用电脑普及率极低。所以电子游戏的启蒙仪式，大多数中国人是在烟雾缭绕的网吧中完成的。</p>
<p>启蒙过后，由于跟琴棋书画相比，诞生于时代尖端的电子游戏有着异常真实的画面和极为刺激的交互，所以它开始随着互联网和网吧在中国迅速传播——也让中国的小孩子迅速沉迷。</p>
<p>这些中国的孩子们大部分没见过 XBOX、PS2、NGC，对游戏的认知还停留在 FC 时代的《超级玛丽》和《魂斗罗》。有一天，他们突然就在网吧玩到了《梦幻西游》和《魔兽世界》，那情景就好像一个吃糠咽菜好几年的人，突然发现了一家豪华自助餐，2块钱随便吃，他要是能愿意出来就有鬼了。</p>
<p>这些游戏对小孩子致命的吸引力，将涉世未深的他们吸引到鱼龙混杂又无人监管的网吧，导致学校和家庭对他们再无吸引力可言。所以，家长老师们就觉得：是游戏传播了网吧，而不是网吧传播了游戏。只要没有游戏，天下太平。</p>
<p>于是他们对 “游戏”二字畏之如虎，一味封锁打压、明令禁止，导致孩子们想玩到游戏的方式就只有继续偷偷跑去网吧。</p>
<p>如此一来二去的恶性循环，其实直到今天依然在上演，只是角色不同罢了——《梦幻西游》、《魔兽世界》换成了《穿越火线》、《王者荣耀》，网吧、游戏房换成了手机、iPad。</p>
<p>十几年来，电子游戏变成了利欲熏心的商人、教子无方的父母、疏于职守的老师们最完美的替罪羊——电子游戏是海洛因，我也没办法啊。</p>
<p>沉迷游戏四个字，变成了无药可救的近义词。这个千古奇冤的骂名，直到两亿中国人都在玩着王者荣耀的今天，竟仍然被人不断提起。</p>
<p>难道现在的家长们真的不能感同身受，其实这样的 “沉迷” 无可厚非吗？就像 70 后沉迷武侠小说、80后沉迷日本漫画一样，每一个小孩子——尤其是男孩子——心中都有一个降妖伏魔、惩奸除恶的英雄梦。</p>
<p>而在游戏世界里，你不必再去崇拜、向往那些盖世的英雄。因为你就是英雄，你可以亲手击败那些让你恨得咬牙切齿的坏蛋。</p>
<p>对于 90后来讲，他们也许是代表圣光的骑士、是永不为奴的兽人，起身反抗邪恶的天灾，击败荼毒世间的巫妖王。</p>
<p>而对于那些玩着《王者荣耀》的 00后孩子们来讲，他们就是一骑当千的赵云、就是百步穿杨的黄忠。手指轻轻滑动，就可以破阵杀敌、天下无双。</p>
<p>你能怪他们沉迷吗？《王者荣耀》也好，《穿越火线》也好，这些快餐游戏的设计初衷就是瞄准那些不懂游戏的人，孩子能比企鹅的游戏设计师还聪明吗？</p>
<p>一味的抗拒、声讨、咒骂是没用的。我请全中国的家长们尝试把游戏看作爱好，把《穿越火线》和《王者荣耀》当成敲门砖，把你们的孩子引向更具艺术性、知识性、创造性的好游戏。</p>
<p>你们会发现，游戏是一个多么棒的启蒙工具。</p>
<p>写到这里，我不得不感谢我开明而睿智的父母。在我还是小孩子的时候，他们给了我一个加设密码的家用电脑，让我可以在干净卫生的环境里玩游戏的同时又得到了必要的限制和监督。同时他们也鼓励我接触游戏以外的兴趣爱好，并积极参与。</p>
<p>他们的谆谆教导让威廉今天可以用自己做成反例，来说明一个 “沉迷游戏”的少年非但没有被游戏摧毁，反而被游戏升华：</p>
<p>大概是 10岁的时候，我爸托人在家中电脑里装了一个当时如日中天的游戏《金庸群侠传》——于是我只用了一秒钟就“沉迷” 了。</p>
<p>游戏里自由奔放的叙事手法和极为形象的武功招式激起了我对武侠小说的巨大兴趣。于是我一边玩游戏，一边开始如饥似渴地拜读金庸老师的全部著作。</p>
<p>我妈很支持我，经常陪我阅读，给我解释那些我不认识的词。</p>
<p>之后我一发而不可收拾，“金古梁温黄”一部部读过去之后，我发现，我开始 “沉迷”读小说。中文的武侠小说读完之后，时值我 “沉迷” 于龙与地下城规则的美式 RPG 游戏《冰风谷》和《博德之门》。</p>
<p>于是我便开始去读西方人的“武侠”——同龄人还在看《还珠格格》和《情深深雨濛濛》的时候，我开始“沉迷”《魔戒》、《冰与火之歌》。那一年还没有最强美剧《权力的游戏》，《冰与火之歌》的中文译本很难买，但我老爸还是想办法帮我买到了。</p>
<p>再之后，我又开始读历史题材、侦探题材、科幻题材、悬疑题材的小说。直到 17、8岁的某一个午后，我发现，我想当一个作家。</p>
<p>而我有了这个想法后，第一部尝试写的小说，改编自我玩了无数遍、严重 “沉迷”的汉堂经典 RPG 系列《天地劫》。</p>
<p>我的第一个读者，就是我妈。</p>
<p>还有，我小时候不喜欢运动，但因为《实况足球》而 “沉迷”看球踢球，时至今日仍是阿森纳的忠实厂工；</p>
<p>我的英语启蒙读物是一款叫《弥赛亚》的英文游戏，之后的人生中，我的英文积累有一半来自我“沉迷” 的那些英文游戏，因为不懂那些英文我就没有办法破关；我因为《文明》系列游戏而 “沉迷”历史和地理，历史课是我唯一一门考过全校第一的科目。</p>
<p>同样的例子在威廉的生命里俯拾皆是，不胜枚举。可以说，正是游戏造就了今天的我，一个更好的我，我就是活生生的“游戏鸦片论” 反例。</p>
<p>这虽然是一个关于我的故事，但这个故事的主角其实不是我，而是我的父母。</p>
<p>因为长大之后我才知道，在那个盗版还未猖獗的年代，一台电脑和那些动辄 7、80元的正版游戏光盘，对于并不富有的我爸我妈来说，意味着什么。</p>
<p>因为长大之后我才知道，为什么班里那么多同学都冒着挨揍的风险也要撒谎、逃课，跑去网吧玩《热血传奇》，而我虽然也去过几次，却提不起多大兴趣——因为我在家里写完作业就能玩，而且我玩的游戏可比《热血传奇》高级多了。</p>
<p>所以，如果没有我爸妈对我 “沉迷游戏”的理解、支持，我可能今天就不会在这里写字。是他们的引导，左右了我所接触到的一切；是他们的鼓励，让我的天赋不仅仅停留在兴趣。</p>
<p>在威廉看来，无论是中国的 “限制” 规则，还是西方的 “分级”制度，都不是给孩子们设定的，而是给孩子们的家长设定的。</p>
<p>威廉身边有两个身为人父的朋友，我们称他们为 G 和 C 好了。</p>
<p>G也是一个资深玩家，从孩子还未懂事的时候他就给孩子的设备加了家长锁。他的儿子从小就只能玩到他精挑细选的游戏。《王者荣耀》推出后，他儿子全班同学都在玩，但他的儿子的手机卡并没有上网流量，所以他的儿子并不能在学校里发微信或打游戏。</p>
<p>但他会每晚亲自带着老婆儿子玩王者荣耀，排位上分，并不失时机地给儿子讲解游戏里面每一个历史人物的故事。每每看到他朋友圈分享那些寓教于乐的游戏故事，威廉总觉得为人父、为人夫，莫过于此。</p>
<p>而我的另外一个朋友C，倒是乐得将自己的账号和设备都丢给孩子，随便他玩。因为这样小孩子就会一整天都变得安静听话，大人也落得逍遥自在。</p>
<p>简简单单的两个父亲的故事，恶魔全都藏在细节里。</p>
<p>我猜，过度溺爱孩子要什么给什么的、发现孩子打游戏就把孩子胖揍一顿的，这样的父母，在中国也不是少数。所以，才有了“母亲怒摔两部手机，以防女儿玩王者荣耀”“网游害了一个年代的孩子”这样的文章，见诸报端。</p>
<p>无知是愤怒的源头，而愤怒不能解决问题，只会招致更多问题。</p>
<p>小小的游戏不能决定你孩子的未来，父母才能。错不在电脑，不在手机，不在网络，不在游戏，而在父母的教育方式。</p>
<p>我们为什么玩游戏？因为天生好奇的我们人类，这辈子注定要 “沉迷” 一些事物。</p>
<p>这种沉迷能让一个人攀上巅峰，也能让一个人跌下深渊。而决定我们走向哪条路的明灯，有两个名字：一个叫爸爸，一个叫妈妈。</p>
<p>孩子们不需要《成长守护平台》，也不需要《健康游戏公告》。他们需要的东西再简单不过：陪伴，理解，沟通。</p>
<p>2.9更新：感谢大家的肯定和支持，一直觉得这个话题在当今中国算是一大社会难题，身边的很多父母都缺乏对待游戏的正确态度和开放观念，也不懂如何积极地把游戏作为一个强化物引导孩子的成长。希望我码了这么多字，可以给看到的父母们做一个参考。</p>
<p>同时作为一个玩家，我也希望中国的玩家群体终有一天不会被人放在边缘地带冷眼看待，游戏也是艺术，也是文化，值得被公正地审视和对待。</p>
<p>可这样的待遇，光靠对那些不理解游戏的老一辈人们冷嘲热讽、挖苦臆测，是得不来的。就像父母对待孩子一样，那些苦于父母反对的孩子们，也请多多努力，去陪伴、去理解、去沟通吧。</p>
<p>但愿我们的儿子，都能在爸爸的陪伴下一起打游戏。</p>
<p>2.17更新：除了一部分不懂游戏的脑残和杠精之外，我非常高兴绝大部分知乎用户都跟威廉抱持着一样的想法和态度，同时也积极地给予我支持和转发。我也会像大家一样，利用自己手上的资源把我这篇回答转出知乎，让更多的家长看到。</p>
<p>这几天忙着过年，抱歉实在没时间一一回复网友的评论，今天最后一更，回复一些主流评论的同时，就当是对我这篇啰啰嗦嗦的长文做个总结，没时间细看的朋友可以直接看这里了：</p>
<ol>
<li><p>所有的艺术都分三六九等，这是事实，游戏也不例外。不信就先去看看《泰坦尼克号》，再去看看《纯洁心灵：逐梦演艺圈》，然后再告诉我艺术到底有没有高低。在我的眼中，免费网游处处都是利用心理学和行为学设计的沉迷陷阱，没有任何具有启发性的内容，只是一遍遍地重复毫无意义的感官刺激；而优质的付费游戏就像是一本好书、一部好电影，是非常好的用于学习、思考、激发兴趣的工具。所以，对于孩子们来说，《穿越火线》就是低级的，《文明6》就是高级的，我坚信不疑。</p>
</li>
<li><p>说我何不食肉糜的朋友，我想说我不是从小养尊处优的晋惠帝，我的家庭和其他普通家庭的孩子没有两样，只不过我的爸妈并不认为“电脑就是个游戏机，为什么要买？”。至于那些在讨论钱的朋友，要知道 STEAM上一个游戏才几十块，去一趟比利时也就几千块，如果连这个钱都没有的话，那这就是一个生育决策问题了。我的个人意见是，对大部分中国父母来说，这件事问题还是出在观念上，不是物质上。</p>
</li>
<li><p>这篇文章并不是在讨论 “从沉迷一个游戏到沉迷一堆游戏”，而是“从沉迷一个爱好到沉迷一堆爱好”。就像我说的，堵不如疏，一个精神生活无比丰富的人，不论是大人还是孩子，是不太会一直沉迷同一件事情无法自拔的。如果孩子真的就是除了游戏之外没有任何其他爱好，我觉得哪怕能让他喜欢上许许多多不同类型、不同节奏的游戏，也远比被一个劣质网游牢牢捆住强得多。</p>
</li>
<li><p>至于到底该怎么疏引、怎么管理、怎么激发孩子的兴趣，威廉只能说我不是一个教育家，才学有限，没办法根据极度有限的信息给到你们每一个人因材施教的规划。诚惶诚恐，希望我这一篇关于游戏母题的文章能稍微帮到你们：<a href="https://zhuanlan.zhihu.com/p/33439754">如何确定自己喜欢的游戏类型？</a></p>
</li>
<li><p>我在评论区看到了很多朋友，不幸拥有跟问题中所引用的父亲一样无知无能的父母；但我更多看到的是一些玩着游戏长大的，愿意去陪伴、理解、沟通的父母，和一些将来注定成为优秀父母的年轻人。如果你问我，我从我爸妈的身上学到了什么？我的答案就是——代沟是永远存在的，所以一颗懂得开放和包容的心，还有一颗保持思考和学习的头脑，才是成为一对优秀父母的关键。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>真正决定你人生高度的，是深度学习能力</title>
    <url>/2021/02/16/%E7%9C%9F%E6%AD%A3%E5%86%B3%E5%AE%9A%E4%BD%A0%E4%BA%BA%E7%94%9F%E9%AB%98%E5%BA%A6%E7%9A%84%E6%98%AF%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[<h3 id="主动学习和被动学习的差异"><a href="#主动学习和被动学习的差异" class="headerlink" title="主动学习和被动学习的差异"></a>主动学习和被动学习的差异</h3><p>作者 | 周岭</p>
<p>来源 | 清脑</p>
<p>胡适的英语老师、民国时期自学成才的出版家王云五先生在年轻的时候是这样自学英语写作的：</p>
<p>找到一篇英文的名家佳作，熟读几次以后，把它翻译成中文，等过了一星期之后，再依据中文反过来翻译成英文，这个期间绝不查阅英语原文。</p>
<p>翻译后再与原文比对，找出自己翻译的错误、失误和不够精良之处。</p>
<a id="more"></a>

<p>如此反复练习，王云五先生练就了扎实的英文功底，为日后的英语教学和出版事业打下了坚实的基础。</p>
<p>在那个科技、信息远不如今天发达的年代，有限的学习条件迫使人们静下心来转向这种深度学习。</p>
<p>时间拨到百年之后，我们的社会发生了巨变，人类进入了前所未有的物质和信息丰富时代，新奇有趣、轻简浓缩的知识随处可见。</p>
<p><strong>人们担忧的不再是无知识可学，而是学不完的知识。</strong></p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/b4e134f319d7acc658af8eb1cd3702f9.jpeg" alt="b4e134f319d7acc658af8eb1cd3702f9"></p>
</div>

<p>时至今日，恐怕很少有人能像王云五先生这样主动静下心来深度学习了，甚至很多人认为，现今时代的学习已经不必如此「费尽艰辛」。</p>
<p>人们有太多的方式可以让自己轻松地获取知识，比如每天听一本书、参加牛人的线上课、订阅名家专栏或参加某某学习群……<br>轻松高效，干货满满，只要自已持之以恒，就定能有所成就。</p>
<p>可惜的是，这种认知注定是一个错觉，因为科技和信息虽然在我们这一代发生了巨变，但人类的学习机能并未随之快速变化，我们的大脑运作模式几乎和百年前一模一样。</p>
<p>更坏的消息是，<strong>「丰富的信息和多元的方式」在带来便捷的同时，也深深地损耗着人们「深度学习」的能力，并且这种倾向越来越明显。</strong></p>
<p>三个月前，罗振宇在 2017 跨年演讲中提到这样一个事实：</p>
<p>用钞票和用微信 / 支付宝支付，有什么区别？</p>
<p>表面是更快更方便；实质上，用钞票支付，是在理性决策；用手机支付，是在冲动消费。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/9fa7915cc746cd153e36b9552b367458.jpeg" alt="9fa7915cc746cd153e36b9552b367458"></p>
</div>

<p>购物，越来越不是理性的决策行为，用户用本能花钱，追求的是快感。</p>
<p>种种迹象表明，快速、简便、轻松的方式使得人们低层次的「原始脑」功能得到进一步强化，高层次的「现代脑」功能则进一步弱化，而深度学习能力几乎全部依赖高层次的「现代脑」（大脑皮层）。</p>
<p>商家已经看清了这一点，于是想方设法推出各种代读、领读、听读的产品，让人们瞬间体验到轻松获取知识的快感，并且产生勤奋的感觉。</p>
<p>而现实的情况是：<strong>人们越学越焦虑、越学越浮躁，懂得很多道理，却依旧过不好现在（别说是一生了）。</strong></p>
<p>我隐隐约约看到这个世界正朝着两极发展：</p>
<p>一小部分知识精英依旧直面核心困难，努力地深度钻研，生产内容；绝大部分信息受众享受轻度学习，消费内容。</p>
<p>知识阶层在逐渐固化。如果长期陷于错误的认知或习惯于轻度学习，一旦丧失深度学习能力，将很难打破知识阶层的限制，被困在认知低层。</p>
<p>深度学习的能力已经变得越来越稀缺。</p>
<p>如果我们真的希望在时代潮流中占据一席之地，那就应该尽早抛弃轻松学习的幻想，锤炼深度学习能力，逆流而上，成为稀缺，否则人生之道路势必会越来越窄。</p>
<p>01</p>
<p><strong>什么是深度学习？</strong></p>
<p>1946 年，美国学者埃德加. 戴尔（Edgar Dale）提出了「学习金字塔」（Cone of<br>Learning）的理论，之后美国缅因州国家训练实验室也做了相同的实验，并发布了「学习金字塔」报告。</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/18bd6131eb8a4888e1c294e69338697f.jpeg" alt="18bd6131eb8a4888e1c294e69338697f"></p>
</div>

<p>报告称：人的学习分为「被动学习」和「主动学习」两个层次。</p>
<p>被动学习：如听讲、阅读、试听、演示，学习内容的平均留存率为 5%、10%、20%、30%。</p>
<p>主动学习：如通过讨论、实践、教授给他人，能将原来被动学习的内容留存率，从<br>5%，提升到 50%、75% 和 90%。</p>
<p>这个模型很好地展示了不同学习深度和层次之间的对比。</p>
<p>反观自身的学习，我们同样可以清晰地划分出不同的层次。</p>
<p>以阅读为例，从浅到深依次为：</p>
<p>听书</p>
<p>自己读书</p>
<p>自己读书 + 摘抄金句</p>
<p>自己读书 + 思维导图 / 读书笔记</p>
<p>自己读书 + 践行操练</p>
<p>自己读书 + 践行操练 + 输出教授</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/9fb0480ad30916a18ecfac90a73eb6bf.jpeg" alt="9fb0480ad30916a18ecfac90a73eb6bf"></p>
</div>

<p>当前有很多听书产品，读书达人用十几分钟解读一本书，一天听一本，一年下来就三百多本，这种便捷新颖、浓缩干货的学习看似轻松高效，实则处于被动学习的最浅层。</p>
<p>好一点的情况是自己读原书，但读完之后却不回顾或少有提炼总结，只满足于输入的过程，这类学习的知识留存率很低。卿不见几天之后就想不起来自己读了什么了吗？</p>
<p>更糟的是，这种努力会导致盲目追求阅读的速度和数量，让人产生勤奋的感觉，实际上这是低水平的勤奋，投入越多，损失越大。</p>
<p>初级阅读者不可避免会踩入这两个坑，而另一类浅层次学习的人数也不少，这类人能够自己阅读，也做读书笔记或思维导图，但遗憾的是，读书笔记的内容往往是把书中的内容梳理罗列了一番，看起来更像是一个大纲。</p>
<p>很多人醉心于此，似乎自己对全书的知识了若于胸，殊不知自己只是「农夫山泉」而已——「我们不生产知识，我们只是知识的搬运工！」</p>
<p>虽然这种做法一定程度上属于主动学习，但它仅仅是简单「知识陈述」，与高级别的「知识转换」有很大的不同。</p>
<p>更深一层的是，读书之后能去实践书中的道理，哪怕有那么一两点让生活发生改变，也是很了不起的，因为从这一刻开始，知识得到了转化。</p>
<p>从知道到做到是一个巨大的进步，然而自己知道或做到是一回事，让别人知道或做到又是另外一回事。</p>
<p>不信试着将自己知道的东西向别人清晰地讲出来，你会发现这并不容易，心里想得挺明白，讲的时候就开始语无伦次了，如果再让你把知道的东西写下来呢？你可能根本无从下笔。</p>
<p>请注意，这种困难才是真正深度学习的开始。</p>
<p>因为这必须动用原先所有的已有知识去解释新知识，当你能够把新学的知识解释清楚时，就意味着把它纳入了自己的知识体系，同时达到了教授他人的水平，并可能创造出新的知识。</p>
<p>罗振宇在 60 秒语音中曾提到他是这样学习的：</p>
<p>我每天要求自己写够五篇阅读心得，不用长篇大论，短短几个词就行。</p>
<p>因为真正的学习就像是缝扣子，把新知识缝接到原有的知识结构中，每天写五篇阅读心得就是逼迫自己原来的知识结构对新知识做出反应，然后把这个反应用文字固化下来，缝接的过程就完成了。</p>
<p>「缝合」是深度学习的关键，而大多数人只完成了「获取知识」，却忽略了「缝合知识」这一步，学习过程是不完整的。</p>
<p>另一些人有了一定的缝合，但缝合得不够深入，没有高质量的产出，也使得学习深度大打折扣。</p>
<p>浅层学习满足输入，深度学习注重输出。</p>
<p>从想法到语言再到文字，即网状的思维变成树状的结构再变成线性的文字，相当于把思想从气态变成液态再变成固态——那些固态的东西才真正属于自己。</p>
<p>毕竟任何知识都不可避免地会损耗，并且这种损耗一直存在，如果不想办法让自己学到的东西固化下来，时间一长就会烟消云散，留不下多少痕迹。</p>
<p>有了自己的东西，便一定要「教授」出去，「教授」和「缝合」会相互形成巩固和循环。</p>
<p>《暗时间》的作者刘未鹏说：「教」是最好的「学」，如果一件事情你不能讲清楚，十有八九你还没有完全理解。当然，「教」的最高境界是能用最简洁的话让一个外行人也能明白你讲的东西。</p>
<p>可见，逼迫自己通过「获取高质量知识」+「深度缝合新知识」，再用自己的语言或文字去教授他人，是为深度学习之道。</p>
<p>这是我目前能够觉知到最高层次的深度学习了，也许还有更高级的，但对绝大多数人来讲，能做到并做好这一点已经足够了。</p>
<p>02</p>
<p><strong>如何深度学习？</strong></p>
<p>如上，深度学习有三个要素：</p>
<p>1、获取高质量知识；</p>
<p>2、深度缝合新知识；</p>
<p>3、输出成果去教授。</p>
<p>这样的学习必然要放弃「快学」、「多学」的安全感，同时要耗费更多的时间，面临更难的处境，甚至还会「备受煎熬」。</p>
<p>但请一定相信：正确的行动往往是反直觉的，一开始舒服和容易的事往往得不到好结果，而一开始难受和困难的事才能让人真正产生收获。</p>
<p>所以，我们需要逐步改进。</p>
<p><strong>一. 尽可能地获取并亲自啃读一手知识</strong></p>
<p>从读书角度讲，就是读经典、读原著，甚至是学术论文。经典的一手知识已经经过时间的沉淀，价值深度已被证明，值得精耕细读。</p>
<p>把精力集中到符合自己需求的一手知识上，放弃那些「几分钟读完……」「每天一本……」「十堂……<br>课」的干货幻念，虽然那些也能带来一些启示，但终究是支离破碎、被人咀嚼过的。</p>
<p>亲自啃读虽然更艰辛，但唯有亲历过才能感受到深度理解或认知产生的真正快感，比吸收二手知识不知道要爽多少倍。</p>
<p>读书这事最好不要请人代替，从长远看，终归是要自己获得挖矿的能力的，这样才能走得更远。</p>
<p><strong>二. 尽可量用自己的话把所学知识写出来</strong></p>
<p>每读一本有价值的好书，就用写作的方式把作者的思想用自己的语言重构出来，尽力结合自身的经历、学识、角度去解释、延伸，而不是简单地把书本的要点进行罗列。</p>
<p>简单的「知识陈述」无法达到深度缝合的效果，只有做到「知识转换」才能用旧知识体系对新知识进行深度缝合，所以在重构时只取最需要的观点就好了，其它无关的观点可以放弃，即使它们很有理。</p>
<p>真正深度的好文往往与原书没有太大的关系，只是原书触发了思考，引用了案例，最后看来，读书笔记往往是一篇全新的文章，甚至创造了新的知识。</p>
<p>这个过程是渐近的，虽然刚开始说的好像都是别人的观点，但逐渐地就会衍生出自己的观点，虽然起初会有些吃力，但只要持续练习，能关联的经历、观点、案例就会越来越多，对一个主题的思考也会越来越深入。</p>
<p>所以无需求快、求多。如有必要，可以花足够长的时间去打磨一个主题或观点。当一个趋近你当前最好水平的作品打动了别人，所产生的影响力和收获远比每天写但缺乏深度的思考要强得多。</p>
<p>我鼓励大家写作，是因为一旦能写清楚了，就必定能讲清楚，而且文章具有复利效应，可以随时被他人读到，这样也间接地达到了讨论交流和教授他人的目的。</p>
<p><strong>三. 反思生活</strong></p>
<p>学习不止读书，生活经历同样可以被深度学习。</p>
<p>生活中每天发生的事情如水流一样经过我们，不会停留，如不留心，很难留下痕迹，就像最浅层的被动学习，留存率很低，缺少反思的生活难以产生深度。</p>
<p>《好好学习》的作者成甲就非常注重反思，他每天早上大约要花两个小时左右的时间进行复盘反思，而且要求自己的员工也这样做。</p>
<p>他在书中花了大量笔墨阐述了反思的方法和好处，他说：人与人之间的差距不是来自年龄，甚至不是来自经验，而是来自经验总结、反思和升华的能力。</p>
<p>受这个理念的影响，我从去年 2<br>月份开始，持续每天反思总结，有时几句话，有时上千字。</p>
<p>通过反思，我发现很多没想明白的事情在反思的时候想清楚了，很多模糊的概念在反思的时候变清晰了，很多看似并不关联的事情居然找到了底层的联通……</p>
<p>持续反思让我对生活细节的感知能力变得越来越强，生活给我留下来的东西也越来越多，或许这篇文章的立意与构思有很多要素也来自平日的反思。</p>
<p>如果让我推荐一个不可或缺的习惯，我必推反思。</p>
<p>03</p>
<p><strong>深度学习的好处</strong></p>
<p>深度学习除了能让我们放弃浮躁，磨练理智，还能带来诸多好处，比如跨界能力。</p>
<p>古典在《你的生命有什么可能》一书中说到，人的能力分为「知识、技能和才干」三个层次：</p>
<p>知识是最没有迁移能力的，你读到医科博士，也照样不会做麻婆豆腐；</p>
<p>技能通常由 70% 的通用技能和 30% 的专业技能组成，迁移性要好一些；</p>
<p>而到了才干层面，职业之间的界限就完全被打破了。</p>
<p>这就解释了为什么那些牛人能够轻易地在不同领域之间进行跨界，因为他们已经通过深度学习达到了某一领域的才干层面；</p>
<p>而这些才干在其它领域同样适用，所以只需要花少量的时间熟悉知识与技能就能玩得转。</p>
<p>但反过来，如果你在一个领域从未达到过才干层面，当换到其它行业时，只能从底层的知识和技能重新开始，这就非常吃力了。</p>
<p>深度学习能够帮助人们跨界，这毋庸置疑，同时它还能帮人产生灵感。</p>
<p>我们都知道爱因斯坦是在去专利局上班的路上，看到伯尼尔钟楼时，脑中突然冒出了一个假设：「如果公交车以光速移动，那么从车上看钟楼的指针会不会是静止的呢？」</p>
<p>这个假设使得 20 世界最伟大的发现——狭义相对论从此走入人们的视野。</p>
<p>而另一个德国化学家凯库勒，是在非常疲劳的情况下做了个白日梦，梦到一条首尾相咬的蛇，这条蛇成了他发现了苯分子结构的线索。</p>
<p>人们都惊叹科学家们的直觉和灵感，但假设爱因斯坦是一名理发师，凯库勒是一名管道工，他们就不会获得这些直觉和灵感。</p>
<p>因为只有他们在自己的领域探索得足够深入时，灵感才可能在潜意识的帮助下显现出来，这些原理在现代脑科学研究中都得到了应证。</p>
<p>虽然我们不是科学家，但深度学习依然能让人更大概率地收获意外的惊喜。</p>
<p>与此同时，深度学习能让我们在高处俯视，看到一般事物的更多关联，产生洞见，并且积累得越多，反应速度越快。</p>
<p>比如当我深度解读《超越感觉》，知晓正确思考的核心是让自己的主观认知尽量与客观世界保持一致后，我突然对「解放思想、实事求是」这八个字就有了全新的认识。</p>
<p>再看看祖国近年的发展，如此大的事实证明了这个真理是极其正确并重要的——而换作之前的我，肯定是看不到这个关联的。</p>
<p>不仅如此，如果自己在一些领域的认知深度积累得足够多，那么即便是面对影视节目、娱乐八卦、新闻热点这些「腐蚀」人们注意力的事物时，也同样能调动高级认知，把它们与有益的思考关联起来，产生比众人更深刻更独特的见解。</p>
<p>比如前两天我带女儿去看电影《西游记之女儿国》，剧中女儿国国王与唐僧经历生死之后对他说：「我做了一个梦，多年以后，你蓄满长发，和我一起慢慢变老，但是，你并不开心！」</p>
<p>我立即感慨到，这就是「未来视角」啊，国王用未来视角俯视现在，然后做出了理智的决定，克制了自己的感情放唐僧西行。</p>
<p>换作以前，我肯定是对此无感的，而在女儿眼里，能看到的只是国王好漂亮，猴子好搞笑……</p>
<p>据我所知，很多严肃的成长者同样喜欢娱乐消遣，比如李笑来喜欢看电影，师北宸喜欢看综艺……<br>我敢说，他们身处娱乐时，依旧是「现代脑」在主导，不断地在关联认知，而非单纯地满足「原始脑」的直接需求。</p>
<p>再延伸了说，热点娱乐并非没有价值，浮浅知识也同样具有意义，但前提是：你需要先有足够的认知深度——深度之下的广度才是有效的。</p>
<p>04</p>
<p>专注深度学习</p>
<p><strong>同时对浅学习保持开放</strong></p>
<p>说了这么多深度学习，那像罗辑思维推出的那些专栏、精品课、听书等产品应该如何对待呢？彻底拒绝或远离吗？</p>
<p>我觉得并不需要，因为深度学习与浅学习其实并不冲突，浅学习也有其价值。</p>
<p>重要的是不要搞反权重关系，我们可以把它作为了解新信息的入口，但不能把成长的过程全部寄托于此。</p>
<p>更合理的态度是：专注深度学习，同时对浅学习保持开放。</p>
<p>选择一些值得关注的人，通过这些平台和他们保持连接。</p>
<p>他们释放的一些有价值的信息会引领我们走向更广阔的世界，但无论如何，最终要自己去读、自己去想、自己去做。</p>
<p>就像这篇文章，如果触动了你，也仅仅是为你开启了一个新的视角，<strong>最终能否获取深度学习能力只能靠你自己去行动，没有人能够替代。</strong></p>
<p>学会深度学习，你的人生才会有更多可能。</p>
]]></content>
      <categories>
        <category>文章阅读</category>
      </categories>
      <tags>
        <tag>文章阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>视频有关概念及文件大小计算方法</title>
    <url>/2021/02/15/%E8%A7%86%E9%A2%91%E6%9C%89%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>编码率 / 比特率直接与文件体积有关。且编码率与编码格式配合是否合适，直接关系到视频文件是否清晰。 </p>
<p>在视频编码领域，比特率常翻译为编码率，单位是 Kbps，例如 800Kbps </p>
<p>其中， 1K=1024 1M=1024K </p>
<p>b 为 比特（bit） 这个就是电脑文件大小的计量单位，1KB=8Kb，区分大小写，B 代表字节 (Byte) s 为 秒（second） p 为 每（per） </p>
<a id="more"></a>

<p>以 800kbps 来编码表示经过编码后的数据每秒钟需要用 800K 比特来表示。 </p>
<p>1MB=8Mb=1024KB=8192Kb </p>
<p>Windows 系统文件大小经常用 B (字节) 为单位表示，但网络运营商则用 b (比特)，也就是为什么 2Mb 速度宽带在电脑上显示速度最快只有约 256KB 的原因，网络运营商宣传网速的时候省略了计量单位。  </p>
<p>视频文件体积：(音频码率 + 视频码率) x 时长 / 8</p>
<p>or</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210215115042.png" alt="20210215115042"></p>
</div>

<p>例：有一个 1.5 小时（5400 秒）的影片，希望转换后文件大小刚好为 700M </p>
<p>计算方法如下： </p>
<blockquote>
<p>700×8÷5400×1024≈1061Kbps </p>
</blockquote>
<p>当然不经过压缩文件的计算公式又不同：</p>
<p>声音为，数据量（位 / 秒）= (采样频率（Hz）* 采样位数（bit）* 声道数)</p>
<p>其中，单声道的声道数为 1，立体声的声道数为 2。</p>
<p>数据量 * 时间 / 8＝文件总字节</p>
<p>例如:  </p>
<p>CD 即为未经压缩的音频文件，采样 44.1k,16 位，双声道。</p>
<p>数据量＝44.1<em>16</em>2=1411kb/1024=1.38Mb, 一般的 MP3 压缩后为 128kbps</p>
<p>如果以一张 CD 放一个小时计算的话，CD 总量＝1.38*3600/8=621MB, 当然 CD 大约放 1 小时多点，顶多也就 700MB。</p>
<p>图象应该是，数据量（位 / 秒）= (画面尺寸 * 彩色位数（bit）* 帧数)</p>
<blockquote>
<p>数据量 * 时间 / 8＝文件总字节 </p>
</blockquote>
<p>例如 :<br>2 分钟，25 帧 / 秒，640×480 分辨率，24 位真彩色数字视频的不压缩的数据量约为，数据量<br>＝640x480x24*25=184320Kb=180Mb, 而 VCD、MKV 标准编码率 (加上音频) 分别为 1152Kbps 和 30Mbps (1080p 高清)</p>
<p>2 分钟文件字节＝180Mbx120/8=2700000KB=2636.71875MB＝2.57GB，而压缩后一部 90 分钟高质量 DVD 电影可以达到 9GB。 </p>
<h2 id="像素及显示问题"><a href="#像素及显示问题" class="headerlink" title="像素及显示问题"></a>像素及显示问题</h2><p>大概主要牵扯到 3 个概念：像素、分辨率、密度。</p>
<h4 id="一、像素"><a href="#一、像素" class="headerlink" title="一、像素"></a>一、像素</h4><p>我们常说的像素，一般就是指图像含有多少个像素点。我们就以 720P、1080P 为例：</p>
<p>1080P 的实际像素是 1920*1280, 相乘结果是 2073600，即有 2073600 个像素点， 也就是常说的 1080P 为 200 万像素</p>
<p>720P 实际像素是 1280×720， 相乘结果 921600，即有 921600 个像素点，也就是常说的 720P 为 100 万像素</p>
<p>图像占用空间大小计算公式：</p>
<p>图像像素 * 图像位深 / 8 = 占用字节</p>
<p>如果一张图片像素为 1024*1024， 位深 32 位，则图片占用空间大小为：</p>
<blockquote>
<p>1024<em>1024</em>32/8 = 4194304 byte = 4096KB.</p>
</blockquote>
<h4 id="二、分辨率"><a href="#二、分辨率" class="headerlink" title="二、分辨率"></a>二、分辨率</h4><p>分辨率常指的是设备输出分辨率或叫屏幕分辨率，即屏幕上横竖有多少个容器点，每个容器点用于容纳一个像素。</p>
<p>例如 iPhone 5s, 它的分辨率为 1136<em>640，用它看 1080P, 其实只能看到 1136</em>640 多个像素点，不能发挥 1080P 的优势，</p>
<p>很多细节被忽略。</p>
<h4 id="三-密度"><a href="#三-密度" class="headerlink" title="三  密度"></a>三  密度</h4><p>每英寸包括多少个像素点，单位 PPI (Pixels Per Inch)。屏幕 PPI 计算方式：</p>
<div align=center>

<p><img src="https://cdn.jsdelivr.net/gh/getcoden/picgo@master/blogs/pictures/20210215120502.png" alt="20210215120502"></p>
</div>
比如 iPhone 5s 屏幕分辨率为: 1136*640,  尺寸为 4 英寸，则 PPI 为 (1136*1136+640*640)/4, 开根号，大概就是 325。

<p>PPI 超过 300 就可以算是视网模屏了，肉眼已经分辨不出像素点来。</p>
<p>假设我有 A、B 两部手机，两者屏幕的宽度分辨率都是 320*640，但 A 的尺寸为 3.5 英寸，B 的宽度为 7 英寸，那么显然是 A 手机的密度大，</p>
<p>所有 A 的图像看起来更清晰，而 B 的看起来要模糊些，图像也要大些。</p>
<h2 id="码率（Bitrate）、帧率（FPS）、分辨率和清晰度的联系与区别"><a href="#码率（Bitrate）、帧率（FPS）、分辨率和清晰度的联系与区别" class="headerlink" title="码率（Bitrate）、帧率（FPS）、分辨率和清晰度的联系与区别"></a>码率（Bitrate）、帧率（FPS）、分辨率和清晰度的联系与区别</h2><p><a href="https://blog.csdn.net/pc9319/article/details/79621352?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">转自</a></p>
<h4 id="视频码率、帧率和分辨率到底哪一个影响电影的清晰度"><a href="#视频码率、帧率和分辨率到底哪一个影响电影的清晰度" class="headerlink" title="视频码率、帧率和分辨率到底哪一个影响电影的清晰度"></a>视频码率、帧率和分辨率到底哪一个影响电影的清晰度</h4><p>码率：影响体积，与体积成正比：码率越大，体积越大；码率越小，体积越小。</p>
<p>码率就是数据传输时单位时间传送的数据位数 , 一般我们用的单位是 kbps 即千位每秒。也就是取样率（并不等同与采样率，采样率的单位是 Hz，表示每秒采样的次数），单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真，围绕这个核心衍生出来 cbr（固定码率）与 vbr（可变码率）， “码率” 就是失真度，码率越高越清晰，反之则画面粗糙而多马赛克。</p>
<p>下面是通过一个 wav 文件的采样率来计算码率和文件大小，通过 MediaInfo 工具显示的文件信息如下：</p>
<p>概要</p>
<p>完整名称                            :audio\wav\adele-rolling_in_the_deep.wav</p>
<p>文件格式                            : Wave</p>
<p>文件大小                            : 38.3 MiB</p>
<p>长度                                   : 3 分 47 秒</p>
<p>平均混合码率                    : 1 411 Kbps</p>
<p>音频</p>
<p>ID                                        : 0</p>
<p>文件格式                            : PCM</p>
<p>格式设置 ,Endianness      : Little</p>
<p>编码设置 ID                         : 1</p>
<p>编码设置 ID/ 提示信息        : Microsoft</p>
<p>长度                                     : 3 分 47 秒</p>
<p>码率                                     : 1 411.2 Kbps</p>
<p>声道                                    : 2 声道</p>
<p>采样率                                : 44.1 KHz</p>
<p>位深度                                : 16 位</p>
<p>大小                                    : 38.3 MiB (100%)</p>
<h5 id="1-码率计算公式："><a href="#1-码率计算公式：" class="headerlink" title="1. 码率计算公式："></a>1. 码率计算公式：</h5><p>码率 = 采样率 x 位深度 x 声道</p>
<p>所以，上面文件的码率 = 44.1Khz x 16 位 x 2 声道 = 1411.2 Kbps</p>
<h5 id="2-文件大小-码率-x-时长-1411-2-Kbps-x-3-x-60-47-s-1411-2Kbps-x-227s-38102-4Kb"><a href="#2-文件大小-码率-x-时长-1411-2-Kbps-x-3-x-60-47-s-1411-2Kbps-x-227s-38102-4Kb" class="headerlink" title="2. 文件大小 = 码率 x 时长 = 1411.2 Kbps x (3 x 60 + 47 )s = 1411.2Kbps x 227s =38102.4Kb"></a>2. 文件大小 = 码率 x 时长 = 1411.2 Kbps x (3 x 60 + 47 )s = 1411.2Kbps x 227s =38102.4Kb</h5><p>38102.4 Kb /1024 Kb/M = 37.2M</p>
<p>近似等于 mediainfo 工具显示的文件大小 38.3M。</p>
<p>注：此计算公式对未压缩的 wav 格式文件有效，不适用于 mp3 等被压缩的文件。</p>
<p>通常来说，一个视频文件包括了画面及声音，例如一个 RMVB 的视频文件，里面包含了视频信息和音频信息，音频及视频都有各自不同的采样方式和比特率，也就是说，同一个视频文件音频和视频的比特率并不是一样的。而我们所说的一个视频文件码流率大小，一般是指视频文件中音频及视频信息码流率的总和。</p>
<p>以国内最流行，大家最熟悉的 RMVB 视频文件为例，RMVB 中的 VB，指的是 VBR，即 Variable BitRate 的缩写，中文含义是可变比特率，它表示 RMVB 采用的是动态编码的方式，把较高的采样率用于复杂的动态画面 (歌舞、飞车、战争、动作等)，而把较低的采样率用于静态画面，合理利用资源，达到画质与体积可兼得的效果。</p>
<p>帧率（FPS） ：影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。如果码率为变量，则帧率也会影响体积，帧率越高，每秒钟经过的画面越多，需要的码率也越高，体积也越大。<br>帧率就是在 1 秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。每秒显示的图片数影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。由于人类眼睛的特殊生理结构，如果所看画面之帧率高于 16 的时候，就会认为是连贯的，此现象称之为视觉暂留。并且当帧速达到一定数值后，再增长的话，人眼也不容易察觉到有明显的流畅度提升了。</p>
<p>分辨率：影响图像大小，与图像大小成正比：分辨率越高，图像越大；分辨率越低，图像越小。</p>
<h4 id="带宽、帧率（FPS）"><a href="#带宽、帧率（FPS）" class="headerlink" title="带宽、帧率（FPS）"></a>带宽、帧率（FPS）</h4><p>例如在 ADSL 线路上传输图像，上行带宽只有 512Kbps，但要传输 4 路 CIF 分辨率的图像。按照常规，CIF 分辨率建议码率是 512Kbps，那么照此计算就只能传一路，降低码率势必会影响图像质量。那么为了确保图像质量，就必须降低帧率，这样一来，即便降低码率也不会影响图像质量，但在图像的连贯性上会有影响。</p>
<h4 id="GOP（Group-of-picture）"><a href="#GOP（Group-of-picture）" class="headerlink" title="GOP（Group of picture）"></a>GOP（Group of picture）</h4><p>关键帧的周期，也就是两个 IDR 帧之间的距离，一个帧组的最大帧数，一般而言，每一秒视频至少需要使用 1 个关键帧。增加关键帧个数可改善质量，但是同时增加带宽和网络负载。</p>
<p>需要说明的是，通过提高 GOP 值来提高图像质量是有限度的，在遇到场景切换的情况时，H.264 编码器会自动强制插入一个 I 帧，此时实际的 GOP 值被缩短了。另一方面，在一个 GOP 中，P、B 帧是由 I 帧预测得到的，当 I 帧的图像质量比较差时，会影响到一个 GOP 中后续 P、B 帧的图像质量，直到下一个 GOP 开始才有可能得以恢复，所以 GOP 值也不宜设置过大。</p>
<p>同时，由于 P、B 帧的复杂度大于 I 帧，所以过多的 P、B 帧会影响编码效率，使编码效率降低。另外，过长的 GOP 还会影响 Seek 操作的响应速度，由于 P、B 帧是由前面的 I 或 P 帧预测得到的，所以 Seek 操作需要直接定位，解码某一个 P 或 B 帧时，需要先解码得到本 GOP 内的 I 帧及之前的 N 个预测帧才可以，GOP 值越长，需要解码的预测帧就越多，seek 响应的时间也越长。</p>
<h4 id="常见编码模式："><a href="#常见编码模式：" class="headerlink" title="常见编码模式："></a>常见编码模式：</h4><p>VBR（Variable Bitrate）动态比特率也就是没有固定的比特率，压缩软件在压缩时根据音频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式，推荐编码模式；</p>
<p>ABR（Average Bitrate）平均比特率是 VBR 的一种插值参数。LAME 针对 CBR 不佳的文件体积比和 VBR 生成文件大小不定的特点独创了这种编码模式。ABR 在指定的文件大小内，以每 50 帧（30 帧约 1 秒）为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量，可以做为 VBR 和 CBR 的一种折衷选择。</p>
<p>CBR（Constant Bitrate）常数比特率指文件从头到尾都是一种位速率。相对于 VBR 和 ABR 来讲，它压缩出来的文件体积很大，而且音质相对于 VBR 和 ABR 不会有明显的提高。</p>
<h4 id="高清视频"><a href="#高清视频" class="headerlink" title="高清视频"></a>高清视频</h4><p>目前的 720P 以及 1080P 采用了很多种编码，例如主流的 MPEG2，VC-1 以及 H.264，还有 Divx 以及 Xvid，至于封装格式更多到令人发指，ts、mkv、wmv 以及蓝光专用等等。</p>
<p>720 和 1080 代表视频流的分辨率，前者 1280<em>720，后者 1920</em>1080，不同的编码需要不同的系统资源，大概可以认为是 H.264&gt;VC-1&gt;MPEG2。</p>
<p>VC-1 是最后被认可的高清编码格式，不过因为有微软的后台，所以这种编码格式不能小窥。相对于 MPEG2，VC-1 的压缩比更高，但相对于 H.264 而言，编码解码的计算则要稍小一些，目前来看，VC-1 可能是一个比较好的平衡，辅以微软的支持，应该是一只不可忽视的力量。一般来说，VC-1 多为 “.wmv” 后缀，但这都不是绝对的，具体的编码格式还是要通过软件来查询。</p>
<p>总的来说，从压缩比上来看，H.264 的压缩比率更高一些，也就是同样的视频，通过 H.264 编码算法压出来的视频容量要比 VC-1 的更小，但是 VC-1 格式的视频在解码计算方面则更小一些，一般通过高性能的 CPU 就可以很流畅的观看高清视频。相信这也是目前 NVIDIA Geforce 8 系列显卡不能完全解码 VC-1 视频的主要原因。</p>
<p>PS&amp;TS 是两种视频或影片封装格式，常用于高清片。扩展名分别为 VOB/EVO 和 TS 等；其文件编码一般用 MPEG2/VC-1/H.264</p>
<p>高清，英文为 “High Definition”，即指 “高分辨率”。高清电视 (HDTV)，是由美国电影电视工程师协会确定的高清晰度电视标准格式。现在的大屏幕液晶电视机，一般都支持 1080i 和 720P，而一些俗称的 “全高清”(Full HD)，则是指支持 1080P 输出的电视机。</p>
<p>目前的高清视频编码格式主要有 H.264、VC-1、MPEG-2、MPEG-4、DivX、XviD、WMA-HD 以及 X264。事实上，现在网络上流传的高清视频主要以两类文件的方式存在：一类是经过 MPEG-2 标准压缩，以 tp 和 ts 为后缀的视频流文件 ; 一类是经过 WMV-HD(WindowsMedia Video HighDefinition) 标准压缩过的 wmv 文件，还有少数文件后缀为 avi 或 mpg，其性质与 wmv 是一样的。真正效果好的高清视频更多地以 H.264 与 VC-1 这两种主流的编码格式流传。</p>
<p>一般来说，H.264 格式以 “.avi”、“.mkv” 以及 “.ts” 封装比较常见。</p>
<h4 id="清晰度"><a href="#清晰度" class="headerlink" title="清晰度"></a>清晰度</h4><p>在码率一定的情况下，分辨率与清晰度成反比关系：分辨率越高，图像越不清晰，分辨率越低，图像越清晰。</p>
<p>在分辨率一定的情况下，码率与清晰度成正比关系，码率越高，图像越清晰；码率越低，图像越不清晰。</p>
<p>在码率一定的情况下，分辨率在一定范围内取值都将是清晰的；同样地，在分辨率一定的情况下，码率在一定范围内取值都将是清晰的。</p>
<p>在视频压缩的过程中， I 帧是帧内图像数据压缩，是独立帧。而 P 帧则是参考 I 帧进行帧间图像数据压缩，不是独立帧。在压缩后的视频中绝大多数都是 P 帧，故视频质量主要由 P 帧表现出来。由于 P 帧不是独立帧，而只是保存了与邻近的 I 帧的差值，故实际上并不存在分辨率的概念，应该看成一个二进制差值序列。而该二进制序列在使用熵编码压缩技术时会使用量化参数进行有损压缩，视频的质量直接由量化参数决定，而量化参数会直接影响到压缩比和码率。</p>
<p>视频质量可以通过主观和客观方式来表现，主观方式就是通常人们提到的视频清晰度，而客观参数则是量化参数或者压缩比或者码率。在视频源一样，压缩算法也一样的前提下比较，量化参数，压缩比和码率之间是有直接的比例关系的。</p>
<p>分辨率的变化又称为重新采样。由高分辨率变成低分辨率称为下采样，由于采样前数据充足，只需要尽量保留更多的信息量，一般可以获得相对较好的结果。而由低分辨率变成高分辨率称为上采样，由于需要插值等方法来补充（猜测）缺少的像素点，故必然会带有失真，这就是一种视频质量（清晰度）的损失。</p>
<h4 id="关于一个视频流的数据量："><a href="#关于一个视频流的数据量：" class="headerlink" title="关于一个视频流的数据量："></a>关于一个视频流的数据量：</h4><p>码率如果为 10Mb/s，代表 1 秒钟有 10M bit 的视频数据，对于 YUV422 格式的 1080P 视频而言，一帧图像是 1920x1080x2x8/1024/1024 = 31.64Mbit，1 秒钟 30 帧图像的话，则有 949.2Mb/s，可见其数据量之大，不压缩根本无法网上传播，所以一定要经过视频压缩处理，不要以为 1080P 的视频就一定是高清的，清晰度还跟视频码率密切相关，对于 1080P 的视频而言，蓝光视频的码率是 20Mb/s，一般下载的视频码率大都是 10Mb/s，一些 IPCamera/ 无人机的码率是 2～8Mb/s，而很多视频网站的码率甚至低于 5M/s，其实有时还不如高码率的 720P 清晰。</p>
<h3 id="好的画质是分辨率、帧率和码率三者之间的平衡："><a href="#好的画质是分辨率、帧率和码率三者之间的平衡：" class="headerlink" title="好的画质是分辨率、帧率和码率三者之间的平衡："></a>好的画质是分辨率、帧率和码率三者之间的平衡：</h3><p>码率不是越大越好</p>
<p>如果不做码率大小上的限制，那么分辨率越高，画质越细腻；帧率越高，视频也越流畅，但相应的码率也会很大，因为每秒钟需要用更多的数据来承载较高的清晰度和流畅度。这对云服务厂商而言这是好事（收入跟流量呈正比），但对您可能意味着更多的费用开支。</p>
<p>帧率不要超过 24</p>
<p>如果限定一个码率，比如 800kbps，那么帧率越高，编码器就必须加大对单帧画面的压缩比，也就是通过降低画质来承载足够多的帧数。如果视频源来自摄像头，24FPS 已经是肉眼极限，所以一般 20 帧的 FPS 就已经可以达到很好的用户体验了。</p>
<p>有些玩过 3D 游戏的朋友可能会说，游戏的帧率越高越流畅。这里要注意一定不要混淆场景：游戏追求高帧率的目的是为了尽可能让 3D 模型渲染出来的运动效果更加接近真实运动轨迹，所以帧率越高越好。但对摄像头而言，它要采集的目标是真实世界的物体，真实世界本来就没有刷新率的说法，所以这个理论不适用。</p>
<p>分辨率不盲目攀高</p>
<p>如果限定一个码率，比如 800kbps，那么分辨率越高就会让编码器越 “为难 “ ，可以想象，它必须拆东墙补西墙，通过减少色彩信息或者引入马赛克这种 “鱼目混珠” 的手段来承载足够多的像素点。所以，同样的是 2G 的一个电影文件，1080p 画质的版本可能不如 720p 画质的版本看起来更清晰。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>帧率：FPS（每秒钟要多少帧画面）；   以及 Gop（表示多少秒一个 I 帧）</p>
<p> 码率：编码器每秒编出的数据大小，单位是 kbps，比如 800kbps 代表编码器每秒产生 800kb（或 100KB）的数据。</p>
<p> 分辨率：单位英寸中所包含的像素点数； VGA：Video Graphics Array（视频图像分辨率）</p>
<p> 三者的对应直播质量的影响因素：</p>
<p> 帧率：影响</p>
<p> 画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。如果码率为变量，则帧率也会影响体积，帧率越高，每秒钟经过的画面越多，需要的码率也越高，体积也越大。帧率就是在 1 秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。</p>
<p> 分辨率：影响图像大小，与图像大小成正比：分辨率越高，图像越大；分辨率越低，图像越小。</p>
<p> 清晰度</p>
<p> 在码率一定的情况下，分辨率与清晰度成反比关系：分辨率越高，图像越不清晰，分辨率越低，图像越清晰。</p>
<p> 在分辨率一定的情况下，码率与清晰度成正比关系，码率越高，图像越清晰；码率越低，图像越不清晰。</p>
]]></content>
      <categories>
        <category>视频工具使用</category>
      </categories>
      <tags>
        <tag>视频工具使用</tag>
      </tags>
  </entry>
</search>
